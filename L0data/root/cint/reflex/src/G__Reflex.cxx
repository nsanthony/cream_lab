//
// File generated by core/utils/src/rootcint_tmp at Mon Apr 13 13:38:49 2015

// Do NOT change. Changes will be lost next time file is generated
//

#include "RConfig.h" //rootcint 4834
#if !defined(R__ACCESS_IN_SYMBOL)
//Break the privacy of classes -- Disabled for the moment
#define private public
#define protected public
#endif

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;
#include "G__Reflex.h"

#include "TClass.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"

// START OF SHADOWS

namespace ROOT {
   namespace Shadow {
   } // of namespace Shadow
} // of namespace ROOT
// END OF SHADOWS

namespace Reflex {
   namespace ROOT {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static void Reflex_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("Reflex", 0 /*version*/, "./cint/reflex/inc/Reflex/Builder/VariableBuilder.h", 20,
                     ::ROOT::DefineBehavior((void*)0,(void*)0),
                     &Reflex_Dictionary, 0);
         return &instance;
      }
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_(Init));

      // Dictionary for non-ClassDef classes
      static void Reflex_Dictionary() {
         GenerateInitInstance()->GetClass();
      }

   }
}

namespace ROOT {
   void ReflexcLcLAny_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLAny_Dictionary();
   static void *new_ReflexcLcLAny(void *p = 0);
   static void delete_ReflexcLcLAny(void *p);
   static void deleteArray_ReflexcLcLAny(void *p);
   static void destruct_ReflexcLcLAny(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::Any*)
   {
      ::Reflex::Any *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::Any),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::Any", "./cint/reflex/inc/Reflex/Any.h", 34,
                  typeid(::Reflex::Any), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLAny_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::Any) );
      instance.SetNew(&new_ReflexcLcLAny);
      instance.SetDelete(&delete_ReflexcLcLAny);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLAny);
      instance.SetDestructor(&destruct_ReflexcLcLAny);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::Any*)
   {
      return GenerateInitInstanceLocal((::Reflex::Any*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::Any*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLAny_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::Any*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLType_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLType_Dictionary();
   static void *new_ReflexcLcLType(void *p = 0);
   static void *newArray_ReflexcLcLType(Long_t size, void *p);
   static void delete_ReflexcLcLType(void *p);
   static void deleteArray_ReflexcLcLType(void *p);
   static void destruct_ReflexcLcLType(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::Type*)
   {
      ::Reflex::Type *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::Type),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::Type", "cint/reflex/inc/Reflex/Type.h", 42,
                  typeid(::Reflex::Type), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLType_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::Type) );
      instance.SetNew(&new_ReflexcLcLType);
      instance.SetNewArray(&newArray_ReflexcLcLType);
      instance.SetDelete(&delete_ReflexcLcLType);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLType);
      instance.SetDestructor(&destruct_ReflexcLcLType);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::Type*)
   {
      return GenerateInitInstanceLocal((::Reflex::Type*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::Type*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLType_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::Type*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLBase_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLBase_Dictionary();
   static void *new_ReflexcLcLBase(void *p = 0);
   static void *newArray_ReflexcLcLBase(Long_t size, void *p);
   static void delete_ReflexcLcLBase(void *p);
   static void deleteArray_ReflexcLcLBase(void *p);
   static void destruct_ReflexcLcLBase(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::Base*)
   {
      ::Reflex::Base *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::Base),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::Base", "./cint/reflex/inc/Reflex/Base.h", 28,
                  typeid(::Reflex::Base), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLBase_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::Base) );
      instance.SetNew(&new_ReflexcLcLBase);
      instance.SetNewArray(&newArray_ReflexcLcLBase);
      instance.SetDelete(&delete_ReflexcLcLBase);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLBase);
      instance.SetDestructor(&destruct_ReflexcLcLBase);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::Base*)
   {
      return GenerateInitInstanceLocal((::Reflex::Base*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::Base*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLBase_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::Base*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLScope_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLScope_Dictionary();
   static void *new_ReflexcLcLScope(void *p = 0);
   static void *newArray_ReflexcLcLScope(Long_t size, void *p);
   static void delete_ReflexcLcLScope(void *p);
   static void deleteArray_ReflexcLcLScope(void *p);
   static void destruct_ReflexcLcLScope(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::Scope*)
   {
      ::Reflex::Scope *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::Scope),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::Scope", "cint/reflex/inc/Reflex/Scope.h", 39,
                  typeid(::Reflex::Scope), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLScope_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::Scope) );
      instance.SetNew(&new_ReflexcLcLScope);
      instance.SetNewArray(&newArray_ReflexcLcLScope);
      instance.SetDelete(&delete_ReflexcLcLScope);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLScope);
      instance.SetDestructor(&destruct_ReflexcLcLScope);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::Scope*)
   {
      return GenerateInitInstanceLocal((::Reflex::Scope*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::Scope*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLScope_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::Scope*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLObject_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLObject_Dictionary();
   static void *new_ReflexcLcLObject(void *p = 0);
   static void *newArray_ReflexcLcLObject(Long_t size, void *p);
   static void delete_ReflexcLcLObject(void *p);
   static void deleteArray_ReflexcLcLObject(void *p);
   static void destruct_ReflexcLcLObject(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::Object*)
   {
      ::Reflex::Object *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::Object),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::Object", "cint/reflex/inc/Reflex/Object.h", 29,
                  typeid(::Reflex::Object), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLObject_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::Object) );
      instance.SetNew(&new_ReflexcLcLObject);
      instance.SetNewArray(&newArray_ReflexcLcLObject);
      instance.SetDelete(&delete_ReflexcLcLObject);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLObject);
      instance.SetDestructor(&destruct_ReflexcLcLObject);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::Object*)
   {
      return GenerateInitInstanceLocal((::Reflex::Object*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::Object*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLObject_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::Object*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLMember_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLMember_Dictionary();
   static void *new_ReflexcLcLMember(void *p = 0);
   static void *newArray_ReflexcLcLMember(Long_t size, void *p);
   static void delete_ReflexcLcLMember(void *p);
   static void deleteArray_ReflexcLcLMember(void *p);
   static void destruct_ReflexcLcLMember(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::Member*)
   {
      ::Reflex::Member *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::Member),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::Member", "./cint/reflex/inc/Reflex/Member.h", 36,
                  typeid(::Reflex::Member), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLMember_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::Member) );
      instance.SetNew(&new_ReflexcLcLMember);
      instance.SetNewArray(&newArray_ReflexcLcLMember);
      instance.SetDelete(&delete_ReflexcLcLMember);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLMember);
      instance.SetDestructor(&destruct_ReflexcLcLMember);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::Member*)
   {
      return GenerateInitInstanceLocal((::Reflex::Member*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::Member*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLMember_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::Member*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLTypeTemplate_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLTypeTemplate_Dictionary();
   static void *new_ReflexcLcLTypeTemplate(void *p = 0);
   static void *newArray_ReflexcLcLTypeTemplate(Long_t size, void *p);
   static void delete_ReflexcLcLTypeTemplate(void *p);
   static void deleteArray_ReflexcLcLTypeTemplate(void *p);
   static void destruct_ReflexcLcLTypeTemplate(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::TypeTemplate*)
   {
      ::Reflex::TypeTemplate *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::TypeTemplate),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::TypeTemplate", "cint/reflex/inc/Reflex/TypeTemplate.h", 29,
                  typeid(::Reflex::TypeTemplate), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLTypeTemplate_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::TypeTemplate) );
      instance.SetNew(&new_ReflexcLcLTypeTemplate);
      instance.SetNewArray(&newArray_ReflexcLcLTypeTemplate);
      instance.SetDelete(&delete_ReflexcLcLTypeTemplate);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLTypeTemplate);
      instance.SetDestructor(&destruct_ReflexcLcLTypeTemplate);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::TypeTemplate*)
   {
      return GenerateInitInstanceLocal((::Reflex::TypeTemplate*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::TypeTemplate*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLTypeTemplate_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::TypeTemplate*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLMemberTemplate_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLMemberTemplate_Dictionary();
   static void *new_ReflexcLcLMemberTemplate(void *p = 0);
   static void *newArray_ReflexcLcLMemberTemplate(Long_t size, void *p);
   static void delete_ReflexcLcLMemberTemplate(void *p);
   static void deleteArray_ReflexcLcLMemberTemplate(void *p);
   static void destruct_ReflexcLcLMemberTemplate(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::MemberTemplate*)
   {
      ::Reflex::MemberTemplate *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::MemberTemplate),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::MemberTemplate", "cint/reflex/inc/Reflex/MemberTemplate.h", 30,
                  typeid(::Reflex::MemberTemplate), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLMemberTemplate_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::MemberTemplate) );
      instance.SetNew(&new_ReflexcLcLMemberTemplate);
      instance.SetNewArray(&newArray_ReflexcLcLMemberTemplate);
      instance.SetDelete(&delete_ReflexcLcLMemberTemplate);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLMemberTemplate);
      instance.SetDestructor(&destruct_ReflexcLcLMemberTemplate);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::MemberTemplate*)
   {
      return GenerateInitInstanceLocal((::Reflex::MemberTemplate*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::MemberTemplate*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLMemberTemplate_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::MemberTemplate*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace Reflex {
namespace Dummy {
   namespace ROOT {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static void ReflexcLcLDummy_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("Reflex::Dummy", 0 /*version*/, "cint/reflex/inc/Reflex/Kernel.h", 187,
                     ::ROOT::DefineBehavior((void*)0,(void*)0),
                     &ReflexcLcLDummy_Dictionary, 0);
         return &instance;
      }
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_(Init));

      // Dictionary for non-ClassDef classes
      static void ReflexcLcLDummy_Dictionary() {
         GenerateInitInstance()->GetClass();
      }

   }
}
}

namespace ROOT {
   void ReflexcLcLInstance_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLInstance_Dictionary();
   static void *new_ReflexcLcLInstance(void *p = 0);
   static void *newArray_ReflexcLcLInstance(Long_t size, void *p);
   static void delete_ReflexcLcLInstance(void *p);
   static void deleteArray_ReflexcLcLInstance(void *p);
   static void destruct_ReflexcLcLInstance(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::Instance*)
   {
      ::Reflex::Instance *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::Instance),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::Instance", "cint/reflex/inc/Reflex/Kernel.h", 217,
                  typeid(::Reflex::Instance), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLInstance_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::Instance) );
      instance.SetNew(&new_ReflexcLcLInstance);
      instance.SetNewArray(&newArray_ReflexcLcLInstance);
      instance.SetDelete(&delete_ReflexcLcLInstance);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLInstance);
      instance.SetDestructor(&destruct_ReflexcLcLInstance);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::Instance*)
   {
      return GenerateInitInstanceLocal((::Reflex::Instance*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::Instance*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLInstance_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::Instance*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLNullType_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLNullType_Dictionary();
   static void *new_ReflexcLcLNullType(void *p = 0);
   static void *newArray_ReflexcLcLNullType(Long_t size, void *p);
   static void delete_ReflexcLcLNullType(void *p);
   static void deleteArray_ReflexcLcLNullType(void *p);
   static void destruct_ReflexcLcLNullType(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::NullType*)
   {
      ::Reflex::NullType *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::NullType),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::NullType", "cint/reflex/inc/Reflex/Kernel.h", 379,
                  typeid(::Reflex::NullType), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLNullType_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::NullType) );
      instance.SetNew(&new_ReflexcLcLNullType);
      instance.SetNewArray(&newArray_ReflexcLcLNullType);
      instance.SetDelete(&delete_ReflexcLcLNullType);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLNullType);
      instance.SetDestructor(&destruct_ReflexcLcLNullType);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::NullType*)
   {
      return GenerateInitInstanceLocal((::Reflex::NullType*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::NullType*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLNullType_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::NullType*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLUnknownType_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLUnknownType_Dictionary();
   static void *new_ReflexcLcLUnknownType(void *p = 0);
   static void *newArray_ReflexcLcLUnknownType(Long_t size, void *p);
   static void delete_ReflexcLcLUnknownType(void *p);
   static void deleteArray_ReflexcLcLUnknownType(void *p);
   static void destruct_ReflexcLcLUnknownType(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::UnknownType*)
   {
      ::Reflex::UnknownType *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::UnknownType),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::UnknownType", "cint/reflex/inc/Reflex/Kernel.h", 380,
                  typeid(::Reflex::UnknownType), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLUnknownType_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::UnknownType) );
      instance.SetNew(&new_ReflexcLcLUnknownType);
      instance.SetNewArray(&newArray_ReflexcLcLUnknownType);
      instance.SetDelete(&delete_ReflexcLcLUnknownType);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLUnknownType);
      instance.SetDestructor(&destruct_ReflexcLcLUnknownType);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::UnknownType*)
   {
      return GenerateInitInstanceLocal((::Reflex::UnknownType*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::UnknownType*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLUnknownType_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::UnknownType*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLProtectedClass_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLProtectedClass_Dictionary();
   static void *new_ReflexcLcLProtectedClass(void *p = 0);
   static void *newArray_ReflexcLcLProtectedClass(Long_t size, void *p);
   static void delete_ReflexcLcLProtectedClass(void *p);
   static void deleteArray_ReflexcLcLProtectedClass(void *p);
   static void destruct_ReflexcLcLProtectedClass(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::ProtectedClass*)
   {
      ::Reflex::ProtectedClass *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::ProtectedClass),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::ProtectedClass", "cint/reflex/inc/Reflex/Kernel.h", 382,
                  typeid(::Reflex::ProtectedClass), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLProtectedClass_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::ProtectedClass) );
      instance.SetNew(&new_ReflexcLcLProtectedClass);
      instance.SetNewArray(&newArray_ReflexcLcLProtectedClass);
      instance.SetDelete(&delete_ReflexcLcLProtectedClass);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLProtectedClass);
      instance.SetDestructor(&destruct_ReflexcLcLProtectedClass);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::ProtectedClass*)
   {
      return GenerateInitInstanceLocal((::Reflex::ProtectedClass*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::ProtectedClass*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLProtectedClass_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::ProtectedClass*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLProtectedEnum_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLProtectedEnum_Dictionary();
   static void *new_ReflexcLcLProtectedEnum(void *p = 0);
   static void *newArray_ReflexcLcLProtectedEnum(Long_t size, void *p);
   static void delete_ReflexcLcLProtectedEnum(void *p);
   static void deleteArray_ReflexcLcLProtectedEnum(void *p);
   static void destruct_ReflexcLcLProtectedEnum(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::ProtectedEnum*)
   {
      ::Reflex::ProtectedEnum *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::ProtectedEnum),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::ProtectedEnum", "cint/reflex/inc/Reflex/Kernel.h", 383,
                  typeid(::Reflex::ProtectedEnum), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLProtectedEnum_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::ProtectedEnum) );
      instance.SetNew(&new_ReflexcLcLProtectedEnum);
      instance.SetNewArray(&newArray_ReflexcLcLProtectedEnum);
      instance.SetDelete(&delete_ReflexcLcLProtectedEnum);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLProtectedEnum);
      instance.SetDestructor(&destruct_ReflexcLcLProtectedEnum);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::ProtectedEnum*)
   {
      return GenerateInitInstanceLocal((::Reflex::ProtectedEnum*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::ProtectedEnum*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLProtectedEnum_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::ProtectedEnum*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLProtectedStruct_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLProtectedStruct_Dictionary();
   static void *new_ReflexcLcLProtectedStruct(void *p = 0);
   static void *newArray_ReflexcLcLProtectedStruct(Long_t size, void *p);
   static void delete_ReflexcLcLProtectedStruct(void *p);
   static void deleteArray_ReflexcLcLProtectedStruct(void *p);
   static void destruct_ReflexcLcLProtectedStruct(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::ProtectedStruct*)
   {
      ::Reflex::ProtectedStruct *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::ProtectedStruct),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::ProtectedStruct", "cint/reflex/inc/Reflex/Kernel.h", 384,
                  typeid(::Reflex::ProtectedStruct), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLProtectedStruct_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::ProtectedStruct) );
      instance.SetNew(&new_ReflexcLcLProtectedStruct);
      instance.SetNewArray(&newArray_ReflexcLcLProtectedStruct);
      instance.SetDelete(&delete_ReflexcLcLProtectedStruct);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLProtectedStruct);
      instance.SetDestructor(&destruct_ReflexcLcLProtectedStruct);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::ProtectedStruct*)
   {
      return GenerateInitInstanceLocal((::Reflex::ProtectedStruct*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::ProtectedStruct*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLProtectedStruct_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::ProtectedStruct*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLProtectedUnion_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLProtectedUnion_Dictionary();
   static void *new_ReflexcLcLProtectedUnion(void *p = 0);
   static void *newArray_ReflexcLcLProtectedUnion(Long_t size, void *p);
   static void delete_ReflexcLcLProtectedUnion(void *p);
   static void deleteArray_ReflexcLcLProtectedUnion(void *p);
   static void destruct_ReflexcLcLProtectedUnion(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::ProtectedUnion*)
   {
      ::Reflex::ProtectedUnion *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::ProtectedUnion),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::ProtectedUnion", "cint/reflex/inc/Reflex/Kernel.h", 385,
                  typeid(::Reflex::ProtectedUnion), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLProtectedUnion_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::ProtectedUnion) );
      instance.SetNew(&new_ReflexcLcLProtectedUnion);
      instance.SetNewArray(&newArray_ReflexcLcLProtectedUnion);
      instance.SetDelete(&delete_ReflexcLcLProtectedUnion);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLProtectedUnion);
      instance.SetDestructor(&destruct_ReflexcLcLProtectedUnion);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::ProtectedUnion*)
   {
      return GenerateInitInstanceLocal((::Reflex::ProtectedUnion*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::ProtectedUnion*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLProtectedUnion_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::ProtectedUnion*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLPrivateClass_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLPrivateClass_Dictionary();
   static void *new_ReflexcLcLPrivateClass(void *p = 0);
   static void *newArray_ReflexcLcLPrivateClass(Long_t size, void *p);
   static void delete_ReflexcLcLPrivateClass(void *p);
   static void deleteArray_ReflexcLcLPrivateClass(void *p);
   static void destruct_ReflexcLcLPrivateClass(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::PrivateClass*)
   {
      ::Reflex::PrivateClass *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::PrivateClass),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::PrivateClass", "cint/reflex/inc/Reflex/Kernel.h", 387,
                  typeid(::Reflex::PrivateClass), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLPrivateClass_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::PrivateClass) );
      instance.SetNew(&new_ReflexcLcLPrivateClass);
      instance.SetNewArray(&newArray_ReflexcLcLPrivateClass);
      instance.SetDelete(&delete_ReflexcLcLPrivateClass);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLPrivateClass);
      instance.SetDestructor(&destruct_ReflexcLcLPrivateClass);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::PrivateClass*)
   {
      return GenerateInitInstanceLocal((::Reflex::PrivateClass*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::PrivateClass*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLPrivateClass_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::PrivateClass*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLPrivateEnum_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLPrivateEnum_Dictionary();
   static void *new_ReflexcLcLPrivateEnum(void *p = 0);
   static void *newArray_ReflexcLcLPrivateEnum(Long_t size, void *p);
   static void delete_ReflexcLcLPrivateEnum(void *p);
   static void deleteArray_ReflexcLcLPrivateEnum(void *p);
   static void destruct_ReflexcLcLPrivateEnum(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::PrivateEnum*)
   {
      ::Reflex::PrivateEnum *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::PrivateEnum),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::PrivateEnum", "cint/reflex/inc/Reflex/Kernel.h", 388,
                  typeid(::Reflex::PrivateEnum), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLPrivateEnum_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::PrivateEnum) );
      instance.SetNew(&new_ReflexcLcLPrivateEnum);
      instance.SetNewArray(&newArray_ReflexcLcLPrivateEnum);
      instance.SetDelete(&delete_ReflexcLcLPrivateEnum);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLPrivateEnum);
      instance.SetDestructor(&destruct_ReflexcLcLPrivateEnum);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::PrivateEnum*)
   {
      return GenerateInitInstanceLocal((::Reflex::PrivateEnum*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::PrivateEnum*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLPrivateEnum_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::PrivateEnum*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLPrivateStruct_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLPrivateStruct_Dictionary();
   static void *new_ReflexcLcLPrivateStruct(void *p = 0);
   static void *newArray_ReflexcLcLPrivateStruct(Long_t size, void *p);
   static void delete_ReflexcLcLPrivateStruct(void *p);
   static void deleteArray_ReflexcLcLPrivateStruct(void *p);
   static void destruct_ReflexcLcLPrivateStruct(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::PrivateStruct*)
   {
      ::Reflex::PrivateStruct *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::PrivateStruct),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::PrivateStruct", "cint/reflex/inc/Reflex/Kernel.h", 389,
                  typeid(::Reflex::PrivateStruct), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLPrivateStruct_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::PrivateStruct) );
      instance.SetNew(&new_ReflexcLcLPrivateStruct);
      instance.SetNewArray(&newArray_ReflexcLcLPrivateStruct);
      instance.SetDelete(&delete_ReflexcLcLPrivateStruct);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLPrivateStruct);
      instance.SetDestructor(&destruct_ReflexcLcLPrivateStruct);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::PrivateStruct*)
   {
      return GenerateInitInstanceLocal((::Reflex::PrivateStruct*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::PrivateStruct*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLPrivateStruct_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::PrivateStruct*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLPrivateUnion_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLPrivateUnion_Dictionary();
   static void *new_ReflexcLcLPrivateUnion(void *p = 0);
   static void *newArray_ReflexcLcLPrivateUnion(Long_t size, void *p);
   static void delete_ReflexcLcLPrivateUnion(void *p);
   static void deleteArray_ReflexcLcLPrivateUnion(void *p);
   static void destruct_ReflexcLcLPrivateUnion(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::PrivateUnion*)
   {
      ::Reflex::PrivateUnion *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::PrivateUnion),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::PrivateUnion", "cint/reflex/inc/Reflex/Kernel.h", 390,
                  typeid(::Reflex::PrivateUnion), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLPrivateUnion_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::PrivateUnion) );
      instance.SetNew(&new_ReflexcLcLPrivateUnion);
      instance.SetNewArray(&newArray_ReflexcLcLPrivateUnion);
      instance.SetDelete(&delete_ReflexcLcLPrivateUnion);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLPrivateUnion);
      instance.SetDestructor(&destruct_ReflexcLcLPrivateUnion);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::PrivateUnion*)
   {
      return GenerateInitInstanceLocal((::Reflex::PrivateUnion*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::PrivateUnion*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLPrivateUnion_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::PrivateUnion*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLUnnamedClass_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLUnnamedClass_Dictionary();
   static void *new_ReflexcLcLUnnamedClass(void *p = 0);
   static void *newArray_ReflexcLcLUnnamedClass(Long_t size, void *p);
   static void delete_ReflexcLcLUnnamedClass(void *p);
   static void deleteArray_ReflexcLcLUnnamedClass(void *p);
   static void destruct_ReflexcLcLUnnamedClass(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::UnnamedClass*)
   {
      ::Reflex::UnnamedClass *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::UnnamedClass),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::UnnamedClass", "cint/reflex/inc/Reflex/Kernel.h", 392,
                  typeid(::Reflex::UnnamedClass), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLUnnamedClass_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::UnnamedClass) );
      instance.SetNew(&new_ReflexcLcLUnnamedClass);
      instance.SetNewArray(&newArray_ReflexcLcLUnnamedClass);
      instance.SetDelete(&delete_ReflexcLcLUnnamedClass);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLUnnamedClass);
      instance.SetDestructor(&destruct_ReflexcLcLUnnamedClass);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::UnnamedClass*)
   {
      return GenerateInitInstanceLocal((::Reflex::UnnamedClass*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::UnnamedClass*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLUnnamedClass_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::UnnamedClass*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLUnnamedEnum_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLUnnamedEnum_Dictionary();
   static void *new_ReflexcLcLUnnamedEnum(void *p = 0);
   static void *newArray_ReflexcLcLUnnamedEnum(Long_t size, void *p);
   static void delete_ReflexcLcLUnnamedEnum(void *p);
   static void deleteArray_ReflexcLcLUnnamedEnum(void *p);
   static void destruct_ReflexcLcLUnnamedEnum(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::UnnamedEnum*)
   {
      ::Reflex::UnnamedEnum *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::UnnamedEnum),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::UnnamedEnum", "cint/reflex/inc/Reflex/Kernel.h", 393,
                  typeid(::Reflex::UnnamedEnum), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLUnnamedEnum_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::UnnamedEnum) );
      instance.SetNew(&new_ReflexcLcLUnnamedEnum);
      instance.SetNewArray(&newArray_ReflexcLcLUnnamedEnum);
      instance.SetDelete(&delete_ReflexcLcLUnnamedEnum);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLUnnamedEnum);
      instance.SetDestructor(&destruct_ReflexcLcLUnnamedEnum);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::UnnamedEnum*)
   {
      return GenerateInitInstanceLocal((::Reflex::UnnamedEnum*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::UnnamedEnum*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLUnnamedEnum_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::UnnamedEnum*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLUnnamedNamespace_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLUnnamedNamespace_Dictionary();
   static void *new_ReflexcLcLUnnamedNamespace(void *p = 0);
   static void *newArray_ReflexcLcLUnnamedNamespace(Long_t size, void *p);
   static void delete_ReflexcLcLUnnamedNamespace(void *p);
   static void deleteArray_ReflexcLcLUnnamedNamespace(void *p);
   static void destruct_ReflexcLcLUnnamedNamespace(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::UnnamedNamespace*)
   {
      ::Reflex::UnnamedNamespace *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::UnnamedNamespace),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::UnnamedNamespace", "cint/reflex/inc/Reflex/Kernel.h", 394,
                  typeid(::Reflex::UnnamedNamespace), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLUnnamedNamespace_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::UnnamedNamespace) );
      instance.SetNew(&new_ReflexcLcLUnnamedNamespace);
      instance.SetNewArray(&newArray_ReflexcLcLUnnamedNamespace);
      instance.SetDelete(&delete_ReflexcLcLUnnamedNamespace);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLUnnamedNamespace);
      instance.SetDestructor(&destruct_ReflexcLcLUnnamedNamespace);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::UnnamedNamespace*)
   {
      return GenerateInitInstanceLocal((::Reflex::UnnamedNamespace*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::UnnamedNamespace*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLUnnamedNamespace_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::UnnamedNamespace*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLUnnamedStruct_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLUnnamedStruct_Dictionary();
   static void *new_ReflexcLcLUnnamedStruct(void *p = 0);
   static void *newArray_ReflexcLcLUnnamedStruct(Long_t size, void *p);
   static void delete_ReflexcLcLUnnamedStruct(void *p);
   static void deleteArray_ReflexcLcLUnnamedStruct(void *p);
   static void destruct_ReflexcLcLUnnamedStruct(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::UnnamedStruct*)
   {
      ::Reflex::UnnamedStruct *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::UnnamedStruct),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::UnnamedStruct", "cint/reflex/inc/Reflex/Kernel.h", 395,
                  typeid(::Reflex::UnnamedStruct), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLUnnamedStruct_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::UnnamedStruct) );
      instance.SetNew(&new_ReflexcLcLUnnamedStruct);
      instance.SetNewArray(&newArray_ReflexcLcLUnnamedStruct);
      instance.SetDelete(&delete_ReflexcLcLUnnamedStruct);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLUnnamedStruct);
      instance.SetDestructor(&destruct_ReflexcLcLUnnamedStruct);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::UnnamedStruct*)
   {
      return GenerateInitInstanceLocal((::Reflex::UnnamedStruct*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::UnnamedStruct*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLUnnamedStruct_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::UnnamedStruct*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLUnnamedUnion_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLUnnamedUnion_Dictionary();
   static void *new_ReflexcLcLUnnamedUnion(void *p = 0);
   static void *newArray_ReflexcLcLUnnamedUnion(Long_t size, void *p);
   static void delete_ReflexcLcLUnnamedUnion(void *p);
   static void deleteArray_ReflexcLcLUnnamedUnion(void *p);
   static void destruct_ReflexcLcLUnnamedUnion(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::UnnamedUnion*)
   {
      ::Reflex::UnnamedUnion *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::UnnamedUnion),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::UnnamedUnion", "cint/reflex/inc/Reflex/Kernel.h", 396,
                  typeid(::Reflex::UnnamedUnion), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLUnnamedUnion_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::UnnamedUnion) );
      instance.SetNew(&new_ReflexcLcLUnnamedUnion);
      instance.SetNewArray(&newArray_ReflexcLcLUnnamedUnion);
      instance.SetDelete(&delete_ReflexcLcLUnnamedUnion);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLUnnamedUnion);
      instance.SetDestructor(&destruct_ReflexcLcLUnnamedUnion);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::UnnamedUnion*)
   {
      return GenerateInitInstanceLocal((::Reflex::UnnamedUnion*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::UnnamedUnion*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLUnnamedUnion_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::UnnamedUnion*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLRuntimeError_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLRuntimeError_Dictionary();
   static void delete_ReflexcLcLRuntimeError(void *p);
   static void deleteArray_ReflexcLcLRuntimeError(void *p);
   static void destruct_ReflexcLcLRuntimeError(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::RuntimeError*)
   {
      ::Reflex::RuntimeError *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::RuntimeError),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::RuntimeError", "cint/reflex/inc/Reflex/Kernel.h", 399,
                  typeid(::Reflex::RuntimeError), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLRuntimeError_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::RuntimeError) );
      instance.SetDelete(&delete_ReflexcLcLRuntimeError);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLRuntimeError);
      instance.SetDestructor(&destruct_ReflexcLcLRuntimeError);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::RuntimeError*)
   {
      return GenerateInitInstanceLocal((::Reflex::RuntimeError*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::RuntimeError*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLRuntimeError_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::RuntimeError*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLICallback_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLICallback_Dictionary();
   static void delete_ReflexcLcLICallback(void *p);
   static void deleteArray_ReflexcLcLICallback(void *p);
   static void destruct_ReflexcLcLICallback(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::ICallback*)
   {
      ::Reflex::ICallback *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::ICallback),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::ICallback", "./cint/reflex/inc/Reflex/Callback.h", 30,
                  typeid(::Reflex::ICallback), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLICallback_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::ICallback) );
      instance.SetDelete(&delete_ReflexcLcLICallback);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLICallback);
      instance.SetDestructor(&destruct_ReflexcLcLICallback);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::ICallback*)
   {
      return GenerateInitInstanceLocal((::Reflex::ICallback*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::ICallback*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLICallback_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::ICallback*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace Reflex {
namespace Tools {
   namespace ROOT {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static void ReflexcLcLTools_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("Reflex::Tools", 0 /*version*/, "cint/reflex/inc/Reflex/Tools.h", 47,
                     ::ROOT::DefineBehavior((void*)0,(void*)0),
                     &ReflexcLcLTools_Dictionary, 0);
         return &instance;
      }
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_(Init));

      // Dictionary for non-ClassDef classes
      static void ReflexcLcLTools_Dictionary() {
         GenerateInitInstance()->GetClass();
      }

   }
}
}

namespace ROOT {
   void ReflexcLcLNamespaceBuilder_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLNamespaceBuilder_Dictionary();
   static void delete_ReflexcLcLNamespaceBuilder(void *p);
   static void deleteArray_ReflexcLcLNamespaceBuilder(void *p);
   static void destruct_ReflexcLcLNamespaceBuilder(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::NamespaceBuilder*)
   {
      ::Reflex::NamespaceBuilder *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::NamespaceBuilder),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::NamespaceBuilder", "cint/reflex/inc/Reflex/Builder/NamespaceBuilder.h", 26,
                  typeid(::Reflex::NamespaceBuilder), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLNamespaceBuilder_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::NamespaceBuilder) );
      instance.SetDelete(&delete_ReflexcLcLNamespaceBuilder);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLNamespaceBuilder);
      instance.SetDestructor(&destruct_ReflexcLcLNamespaceBuilder);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::NamespaceBuilder*)
   {
      return GenerateInitInstanceLocal((::Reflex::NamespaceBuilder*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::NamespaceBuilder*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLNamespaceBuilder_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::NamespaceBuilder*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLFunctionBuilder_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLFunctionBuilder_Dictionary();
   static void delete_ReflexcLcLFunctionBuilder(void *p);
   static void deleteArray_ReflexcLcLFunctionBuilder(void *p);
   static void destruct_ReflexcLcLFunctionBuilder(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::FunctionBuilder*)
   {
      ::Reflex::FunctionBuilder *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::FunctionBuilder),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::FunctionBuilder", "cint/reflex/inc/Reflex/Builder/FunctionBuilder.h", 29,
                  typeid(::Reflex::FunctionBuilder), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLFunctionBuilder_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::FunctionBuilder) );
      instance.SetDelete(&delete_ReflexcLcLFunctionBuilder);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLFunctionBuilder);
      instance.SetDestructor(&destruct_ReflexcLcLFunctionBuilder);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::FunctionBuilder*)
   {
      return GenerateInitInstanceLocal((::Reflex::FunctionBuilder*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::FunctionBuilder*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLFunctionBuilder_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::FunctionBuilder*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLFunctionBuilderImpl_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLFunctionBuilderImpl_Dictionary();
   static void delete_ReflexcLcLFunctionBuilderImpl(void *p);
   static void deleteArray_ReflexcLcLFunctionBuilderImpl(void *p);
   static void destruct_ReflexcLcLFunctionBuilderImpl(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::FunctionBuilderImpl*)
   {
      ::Reflex::FunctionBuilderImpl *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::FunctionBuilderImpl),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::FunctionBuilderImpl", "cint/reflex/inc/Reflex/Builder/FunctionBuilder.h", 74,
                  typeid(::Reflex::FunctionBuilderImpl), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLFunctionBuilderImpl_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::FunctionBuilderImpl) );
      instance.SetDelete(&delete_ReflexcLcLFunctionBuilderImpl);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLFunctionBuilderImpl);
      instance.SetDestructor(&destruct_ReflexcLcLFunctionBuilderImpl);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::FunctionBuilderImpl*)
   {
      return GenerateInitInstanceLocal((::Reflex::FunctionBuilderImpl*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::FunctionBuilderImpl*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLFunctionBuilderImpl_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::FunctionBuilderImpl*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLClassBuilder_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLClassBuilder_Dictionary();
   static void delete_ReflexcLcLClassBuilder(void *p);
   static void deleteArray_ReflexcLcLClassBuilder(void *p);
   static void destruct_ReflexcLcLClassBuilder(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::ClassBuilder*)
   {
      ::Reflex::ClassBuilder *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::ClassBuilder),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::ClassBuilder", "./cint/reflex/inc/Reflex/Builder/ClassBuilder.h", 167,
                  typeid(::Reflex::ClassBuilder), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLClassBuilder_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::ClassBuilder) );
      instance.SetDelete(&delete_ReflexcLcLClassBuilder);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLClassBuilder);
      instance.SetDestructor(&destruct_ReflexcLcLClassBuilder);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::ClassBuilder*)
   {
      return GenerateInitInstanceLocal((::Reflex::ClassBuilder*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::ClassBuilder*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLClassBuilder_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::ClassBuilder*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLClassBuilderImpl_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLClassBuilderImpl_Dictionary();
   static void delete_ReflexcLcLClassBuilderImpl(void *p);
   static void deleteArray_ReflexcLcLClassBuilderImpl(void *p);
   static void destruct_ReflexcLcLClassBuilderImpl(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::ClassBuilderImpl*)
   {
      ::Reflex::ClassBuilderImpl *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::ClassBuilderImpl),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::ClassBuilderImpl", "./cint/reflex/inc/Reflex/Builder/ClassBuilder.h", 39,
                  typeid(::Reflex::ClassBuilderImpl), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLClassBuilderImpl_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::ClassBuilderImpl) );
      instance.SetDelete(&delete_ReflexcLcLClassBuilderImpl);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLClassBuilderImpl);
      instance.SetDestructor(&destruct_ReflexcLcLClassBuilderImpl);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::ClassBuilderImpl*)
   {
      return GenerateInitInstanceLocal((::Reflex::ClassBuilderImpl*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::ClassBuilderImpl*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLClassBuilderImpl_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::ClassBuilderImpl*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLCollFuncTable_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLCollFuncTable_Dictionary();
   static void *new_ReflexcLcLCollFuncTable(void *p = 0);
   static void *newArray_ReflexcLcLCollFuncTable(Long_t size, void *p);
   static void delete_ReflexcLcLCollFuncTable(void *p);
   static void deleteArray_ReflexcLcLCollFuncTable(void *p);
   static void destruct_ReflexcLcLCollFuncTable(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::CollFuncTable*)
   {
      ::Reflex::CollFuncTable *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::CollFuncTable),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::CollFuncTable", "./cint/reflex/inc/Reflex/Builder/CollectionProxy.h", 368,
                  typeid(::Reflex::CollFuncTable), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLCollFuncTable_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::CollFuncTable) );
      instance.SetNew(&new_ReflexcLcLCollFuncTable);
      instance.SetNewArray(&newArray_ReflexcLcLCollFuncTable);
      instance.SetDelete(&delete_ReflexcLcLCollFuncTable);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLCollFuncTable);
      instance.SetDestructor(&destruct_ReflexcLcLCollFuncTable);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::CollFuncTable*)
   {
      return GenerateInitInstanceLocal((::Reflex::CollFuncTable*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::CollFuncTable*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLCollFuncTable_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::CollFuncTable*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT_Dictionary();
   static void *new_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT(void *p = 0);
   static void *newArray_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT(Long_t size, void *p);
   static void delete_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT(void *p);
   static void deleteArray_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT(void *p);
   static void destruct_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::Selection::NO_SELF_AUTOSELECT*)
   {
      ::Reflex::Selection::NO_SELF_AUTOSELECT *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::Selection::NO_SELF_AUTOSELECT),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::Selection::NO_SELF_AUTOSELECT", "./cint/reflex/inc/Reflex/Builder/DictSelection.h", 230,
                  typeid(::Reflex::Selection::NO_SELF_AUTOSELECT), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::Selection::NO_SELF_AUTOSELECT) );
      instance.SetNew(&new_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT);
      instance.SetNewArray(&newArray_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT);
      instance.SetDelete(&delete_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT);
      instance.SetDestructor(&destruct_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::Selection::NO_SELF_AUTOSELECT*)
   {
      return GenerateInitInstanceLocal((::Reflex::Selection::NO_SELF_AUTOSELECT*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::Selection::NO_SELF_AUTOSELECT*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::Selection::NO_SELF_AUTOSELECT*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLSelectioncLcLTRANSIENT_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLSelectioncLcLTRANSIENT_Dictionary();
   static void *new_ReflexcLcLSelectioncLcLTRANSIENT(void *p = 0);
   static void *newArray_ReflexcLcLSelectioncLcLTRANSIENT(Long_t size, void *p);
   static void delete_ReflexcLcLSelectioncLcLTRANSIENT(void *p);
   static void deleteArray_ReflexcLcLSelectioncLcLTRANSIENT(void *p);
   static void destruct_ReflexcLcLSelectioncLcLTRANSIENT(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::Selection::TRANSIENT*)
   {
      ::Reflex::Selection::TRANSIENT *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::Selection::TRANSIENT),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::Selection::TRANSIENT", "./cint/reflex/inc/Reflex/Builder/DictSelection.h", 239,
                  typeid(::Reflex::Selection::TRANSIENT), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLSelectioncLcLTRANSIENT_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::Selection::TRANSIENT) );
      instance.SetNew(&new_ReflexcLcLSelectioncLcLTRANSIENT);
      instance.SetNewArray(&newArray_ReflexcLcLSelectioncLcLTRANSIENT);
      instance.SetDelete(&delete_ReflexcLcLSelectioncLcLTRANSIENT);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLSelectioncLcLTRANSIENT);
      instance.SetDestructor(&destruct_ReflexcLcLSelectioncLcLTRANSIENT);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::Selection::TRANSIENT*)
   {
      return GenerateInitInstanceLocal((::Reflex::Selection::TRANSIENT*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::Selection::TRANSIENT*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLSelectioncLcLTRANSIENT_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::Selection::TRANSIENT*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLSelectioncLcLAUTOSELECT_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLSelectioncLcLAUTOSELECT_Dictionary();
   static void *new_ReflexcLcLSelectioncLcLAUTOSELECT(void *p = 0);
   static void *newArray_ReflexcLcLSelectioncLcLAUTOSELECT(Long_t size, void *p);
   static void delete_ReflexcLcLSelectioncLcLAUTOSELECT(void *p);
   static void deleteArray_ReflexcLcLSelectioncLcLAUTOSELECT(void *p);
   static void destruct_ReflexcLcLSelectioncLcLAUTOSELECT(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::Selection::AUTOSELECT*)
   {
      ::Reflex::Selection::AUTOSELECT *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::Selection::AUTOSELECT),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::Selection::AUTOSELECT", "./cint/reflex/inc/Reflex/Builder/DictSelection.h", 250,
                  typeid(::Reflex::Selection::AUTOSELECT), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLSelectioncLcLAUTOSELECT_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::Selection::AUTOSELECT) );
      instance.SetNew(&new_ReflexcLcLSelectioncLcLAUTOSELECT);
      instance.SetNewArray(&newArray_ReflexcLcLSelectioncLcLAUTOSELECT);
      instance.SetDelete(&delete_ReflexcLcLSelectioncLcLAUTOSELECT);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLSelectioncLcLAUTOSELECT);
      instance.SetDestructor(&destruct_ReflexcLcLSelectioncLcLAUTOSELECT);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::Selection::AUTOSELECT*)
   {
      return GenerateInitInstanceLocal((::Reflex::Selection::AUTOSELECT*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::Selection::AUTOSELECT*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLSelectioncLcLAUTOSELECT_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::Selection::AUTOSELECT*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLSelectioncLcLNODEFAULT_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLSelectioncLcLNODEFAULT_Dictionary();
   static void *new_ReflexcLcLSelectioncLcLNODEFAULT(void *p = 0);
   static void *newArray_ReflexcLcLSelectioncLcLNODEFAULT(Long_t size, void *p);
   static void delete_ReflexcLcLSelectioncLcLNODEFAULT(void *p);
   static void deleteArray_ReflexcLcLSelectioncLcLNODEFAULT(void *p);
   static void destruct_ReflexcLcLSelectioncLcLNODEFAULT(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::Selection::NODEFAULT*)
   {
      ::Reflex::Selection::NODEFAULT *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::Selection::NODEFAULT),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::Selection::NODEFAULT", "./cint/reflex/inc/Reflex/Builder/DictSelection.h", 259,
                  typeid(::Reflex::Selection::NODEFAULT), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLSelectioncLcLNODEFAULT_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::Selection::NODEFAULT) );
      instance.SetNew(&new_ReflexcLcLSelectioncLcLNODEFAULT);
      instance.SetNewArray(&newArray_ReflexcLcLSelectioncLcLNODEFAULT);
      instance.SetDelete(&delete_ReflexcLcLSelectioncLcLNODEFAULT);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLSelectioncLcLNODEFAULT);
      instance.SetDestructor(&destruct_ReflexcLcLSelectioncLcLNODEFAULT);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::Selection::NODEFAULT*)
   {
      return GenerateInitInstanceLocal((::Reflex::Selection::NODEFAULT*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::Selection::NODEFAULT*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLSelectioncLcLNODEFAULT_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::Selection::NODEFAULT*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLEnumBuilder_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLEnumBuilder_Dictionary();
   static void delete_ReflexcLcLEnumBuilder(void *p);
   static void deleteArray_ReflexcLcLEnumBuilder(void *p);
   static void destruct_ReflexcLcLEnumBuilder(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::EnumBuilder*)
   {
      ::Reflex::EnumBuilder *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::EnumBuilder),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::EnumBuilder", "./cint/reflex/inc/Reflex/Builder/EnumBuilder.h", 29,
                  typeid(::Reflex::EnumBuilder), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLEnumBuilder_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::EnumBuilder) );
      instance.SetDelete(&delete_ReflexcLcLEnumBuilder);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLEnumBuilder);
      instance.SetDestructor(&destruct_ReflexcLcLEnumBuilder);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::EnumBuilder*)
   {
      return GenerateInitInstanceLocal((::Reflex::EnumBuilder*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::EnumBuilder*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLEnumBuilder_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::EnumBuilder*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLNewDelFunctions_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLNewDelFunctions_Dictionary();
   static void *new_ReflexcLcLNewDelFunctions(void *p = 0);
   static void *newArray_ReflexcLcLNewDelFunctions(Long_t size, void *p);
   static void delete_ReflexcLcLNewDelFunctions(void *p);
   static void deleteArray_ReflexcLcLNewDelFunctions(void *p);
   static void destruct_ReflexcLcLNewDelFunctions(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::NewDelFunctions*)
   {
      ::Reflex::NewDelFunctions *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::NewDelFunctions),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::NewDelFunctions", "./cint/reflex/inc/Reflex/Builder/NewDelFunctions.h", 18,
                  typeid(::Reflex::NewDelFunctions), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLNewDelFunctions_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::NewDelFunctions) );
      instance.SetNew(&new_ReflexcLcLNewDelFunctions);
      instance.SetNewArray(&newArray_ReflexcLcLNewDelFunctions);
      instance.SetDelete(&delete_ReflexcLcLNewDelFunctions);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLNewDelFunctions);
      instance.SetDestructor(&destruct_ReflexcLcLNewDelFunctions);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::NewDelFunctions*)
   {
      return GenerateInitInstanceLocal((::Reflex::NewDelFunctions*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::NewDelFunctions*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLNewDelFunctions_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::NewDelFunctions*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLTypedefBuilderImpl_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLTypedefBuilderImpl_Dictionary();
   static void delete_ReflexcLcLTypedefBuilderImpl(void *p);
   static void deleteArray_ReflexcLcLTypedefBuilderImpl(void *p);
   static void destruct_ReflexcLcLTypedefBuilderImpl(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::TypedefBuilderImpl*)
   {
      ::Reflex::TypedefBuilderImpl *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::TypedefBuilderImpl),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::TypedefBuilderImpl", "./cint/reflex/inc/Reflex/Builder/TypedefBuilder.h", 28,
                  typeid(::Reflex::TypedefBuilderImpl), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLTypedefBuilderImpl_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::TypedefBuilderImpl) );
      instance.SetDelete(&delete_ReflexcLcLTypedefBuilderImpl);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLTypedefBuilderImpl);
      instance.SetDestructor(&destruct_ReflexcLcLTypedefBuilderImpl);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::TypedefBuilderImpl*)
   {
      return GenerateInitInstanceLocal((::Reflex::TypedefBuilderImpl*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::TypedefBuilderImpl*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLTypedefBuilderImpl_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::TypedefBuilderImpl*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLUnionBuilderImpl_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLUnionBuilderImpl_Dictionary();
   static void delete_ReflexcLcLUnionBuilderImpl(void *p);
   static void deleteArray_ReflexcLcLUnionBuilderImpl(void *p);
   static void destruct_ReflexcLcLUnionBuilderImpl(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::UnionBuilderImpl*)
   {
      ::Reflex::UnionBuilderImpl *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::UnionBuilderImpl),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::UnionBuilderImpl", "./cint/reflex/inc/Reflex/Builder/UnionBuilder.h", 30,
                  typeid(::Reflex::UnionBuilderImpl), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLUnionBuilderImpl_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::UnionBuilderImpl) );
      instance.SetDelete(&delete_ReflexcLcLUnionBuilderImpl);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLUnionBuilderImpl);
      instance.SetDestructor(&destruct_ReflexcLcLUnionBuilderImpl);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::UnionBuilderImpl*)
   {
      return GenerateInitInstanceLocal((::Reflex::UnionBuilderImpl*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::UnionBuilderImpl*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLUnionBuilderImpl_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::UnionBuilderImpl*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLVariableBuilder_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLVariableBuilder_Dictionary();
   static void delete_ReflexcLcLVariableBuilder(void *p);
   static void deleteArray_ReflexcLcLVariableBuilder(void *p);
   static void destruct_ReflexcLcLVariableBuilder(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::VariableBuilder*)
   {
      ::Reflex::VariableBuilder *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::VariableBuilder),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::VariableBuilder", "./cint/reflex/inc/Reflex/Builder/VariableBuilder.h", 28,
                  typeid(::Reflex::VariableBuilder), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLVariableBuilder_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::VariableBuilder) );
      instance.SetDelete(&delete_ReflexcLcLVariableBuilder);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLVariableBuilder);
      instance.SetDestructor(&destruct_ReflexcLcLVariableBuilder);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::VariableBuilder*)
   {
      return GenerateInitInstanceLocal((::Reflex::VariableBuilder*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::VariableBuilder*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLVariableBuilder_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::VariableBuilder*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ReflexcLcLVariableBuilderImpl_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ReflexcLcLVariableBuilderImpl_Dictionary();
   static void delete_ReflexcLcLVariableBuilderImpl(void *p);
   static void deleteArray_ReflexcLcLVariableBuilderImpl(void *p);
   static void destruct_ReflexcLcLVariableBuilderImpl(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Reflex::VariableBuilderImpl*)
   {
      ::Reflex::VariableBuilderImpl *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Reflex::VariableBuilderImpl),0);
      static ::ROOT::TGenericClassInfo 
         instance("Reflex::VariableBuilderImpl", "./cint/reflex/inc/Reflex/Builder/VariableBuilder.h", 72,
                  typeid(::Reflex::VariableBuilderImpl), DefineBehavior(ptr, ptr),
                  0, &ReflexcLcLVariableBuilderImpl_Dictionary, isa_proxy, 0,
                  sizeof(::Reflex::VariableBuilderImpl) );
      instance.SetDelete(&delete_ReflexcLcLVariableBuilderImpl);
      instance.SetDeleteArray(&deleteArray_ReflexcLcLVariableBuilderImpl);
      instance.SetDestructor(&destruct_ReflexcLcLVariableBuilderImpl);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Reflex::VariableBuilderImpl*)
   {
      return GenerateInitInstanceLocal((::Reflex::VariableBuilderImpl*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Reflex::VariableBuilderImpl*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ReflexcLcLVariableBuilderImpl_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Reflex::VariableBuilderImpl*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLAny(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::Any( (TRootIOCtor*)0 ) : new ::Reflex::Any( (TRootIOCtor*)0 );
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLAny(void *p) {
      delete ((::Reflex::Any*)p);
   }
   static void deleteArray_ReflexcLcLAny(void *p) {
      delete [] ((::Reflex::Any*)p);
   }
   static void destruct_ReflexcLcLAny(void *p) {
      typedef ::Reflex::Any current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::Any

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLBase(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::Base : new ::Reflex::Base;
   }
   static void *newArray_ReflexcLcLBase(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::Base[nElements] : new ::Reflex::Base[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLBase(void *p) {
      delete ((::Reflex::Base*)p);
   }
   static void deleteArray_ReflexcLcLBase(void *p) {
      delete [] ((::Reflex::Base*)p);
   }
   static void destruct_ReflexcLcLBase(void *p) {
      typedef ::Reflex::Base current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::Base

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ReflexcLcLICallback(void *p) {
      delete ((::Reflex::ICallback*)p);
   }
   static void deleteArray_ReflexcLcLICallback(void *p) {
      delete [] ((::Reflex::ICallback*)p);
   }
   static void destruct_ReflexcLcLICallback(void *p) {
      typedef ::Reflex::ICallback current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::ICallback

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLInstance(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::Instance : new ::Reflex::Instance;
   }
   static void *newArray_ReflexcLcLInstance(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::Instance[nElements] : new ::Reflex::Instance[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLInstance(void *p) {
      delete ((::Reflex::Instance*)p);
   }
   static void deleteArray_ReflexcLcLInstance(void *p) {
      delete [] ((::Reflex::Instance*)p);
   }
   static void destruct_ReflexcLcLInstance(void *p) {
      typedef ::Reflex::Instance current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::Instance

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLMember(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::Member : new ::Reflex::Member;
   }
   static void *newArray_ReflexcLcLMember(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::Member[nElements] : new ::Reflex::Member[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLMember(void *p) {
      delete ((::Reflex::Member*)p);
   }
   static void deleteArray_ReflexcLcLMember(void *p) {
      delete [] ((::Reflex::Member*)p);
   }
   static void destruct_ReflexcLcLMember(void *p) {
      typedef ::Reflex::Member current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::Member

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLMemberTemplate(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::MemberTemplate : new ::Reflex::MemberTemplate;
   }
   static void *newArray_ReflexcLcLMemberTemplate(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::MemberTemplate[nElements] : new ::Reflex::MemberTemplate[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLMemberTemplate(void *p) {
      delete ((::Reflex::MemberTemplate*)p);
   }
   static void deleteArray_ReflexcLcLMemberTemplate(void *p) {
      delete [] ((::Reflex::MemberTemplate*)p);
   }
   static void destruct_ReflexcLcLMemberTemplate(void *p) {
      typedef ::Reflex::MemberTemplate current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::MemberTemplate

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLObject(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::Object : new ::Reflex::Object;
   }
   static void *newArray_ReflexcLcLObject(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::Object[nElements] : new ::Reflex::Object[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLObject(void *p) {
      delete ((::Reflex::Object*)p);
   }
   static void deleteArray_ReflexcLcLObject(void *p) {
      delete [] ((::Reflex::Object*)p);
   }
   static void destruct_ReflexcLcLObject(void *p) {
      typedef ::Reflex::Object current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::Object

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLScope(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::Scope : new ::Reflex::Scope;
   }
   static void *newArray_ReflexcLcLScope(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::Scope[nElements] : new ::Reflex::Scope[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLScope(void *p) {
      delete ((::Reflex::Scope*)p);
   }
   static void deleteArray_ReflexcLcLScope(void *p) {
      delete [] ((::Reflex::Scope*)p);
   }
   static void destruct_ReflexcLcLScope(void *p) {
      typedef ::Reflex::Scope current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::Scope

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLType(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::Type : new ::Reflex::Type;
   }
   static void *newArray_ReflexcLcLType(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::Type[nElements] : new ::Reflex::Type[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLType(void *p) {
      delete ((::Reflex::Type*)p);
   }
   static void deleteArray_ReflexcLcLType(void *p) {
      delete [] ((::Reflex::Type*)p);
   }
   static void destruct_ReflexcLcLType(void *p) {
      typedef ::Reflex::Type current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::Type

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLTypeTemplate(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::TypeTemplate : new ::Reflex::TypeTemplate;
   }
   static void *newArray_ReflexcLcLTypeTemplate(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::TypeTemplate[nElements] : new ::Reflex::TypeTemplate[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLTypeTemplate(void *p) {
      delete ((::Reflex::TypeTemplate*)p);
   }
   static void deleteArray_ReflexcLcLTypeTemplate(void *p) {
      delete [] ((::Reflex::TypeTemplate*)p);
   }
   static void destruct_ReflexcLcLTypeTemplate(void *p) {
      typedef ::Reflex::TypeTemplate current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::TypeTemplate

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLNullType(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::NullType : new ::Reflex::NullType;
   }
   static void *newArray_ReflexcLcLNullType(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::NullType[nElements] : new ::Reflex::NullType[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLNullType(void *p) {
      delete ((::Reflex::NullType*)p);
   }
   static void deleteArray_ReflexcLcLNullType(void *p) {
      delete [] ((::Reflex::NullType*)p);
   }
   static void destruct_ReflexcLcLNullType(void *p) {
      typedef ::Reflex::NullType current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::NullType

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLUnknownType(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::UnknownType : new ::Reflex::UnknownType;
   }
   static void *newArray_ReflexcLcLUnknownType(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::UnknownType[nElements] : new ::Reflex::UnknownType[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLUnknownType(void *p) {
      delete ((::Reflex::UnknownType*)p);
   }
   static void deleteArray_ReflexcLcLUnknownType(void *p) {
      delete [] ((::Reflex::UnknownType*)p);
   }
   static void destruct_ReflexcLcLUnknownType(void *p) {
      typedef ::Reflex::UnknownType current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::UnknownType

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLProtectedClass(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::ProtectedClass : new ::Reflex::ProtectedClass;
   }
   static void *newArray_ReflexcLcLProtectedClass(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::ProtectedClass[nElements] : new ::Reflex::ProtectedClass[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLProtectedClass(void *p) {
      delete ((::Reflex::ProtectedClass*)p);
   }
   static void deleteArray_ReflexcLcLProtectedClass(void *p) {
      delete [] ((::Reflex::ProtectedClass*)p);
   }
   static void destruct_ReflexcLcLProtectedClass(void *p) {
      typedef ::Reflex::ProtectedClass current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::ProtectedClass

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLProtectedEnum(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::ProtectedEnum : new ::Reflex::ProtectedEnum;
   }
   static void *newArray_ReflexcLcLProtectedEnum(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::ProtectedEnum[nElements] : new ::Reflex::ProtectedEnum[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLProtectedEnum(void *p) {
      delete ((::Reflex::ProtectedEnum*)p);
   }
   static void deleteArray_ReflexcLcLProtectedEnum(void *p) {
      delete [] ((::Reflex::ProtectedEnum*)p);
   }
   static void destruct_ReflexcLcLProtectedEnum(void *p) {
      typedef ::Reflex::ProtectedEnum current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::ProtectedEnum

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLProtectedStruct(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::ProtectedStruct : new ::Reflex::ProtectedStruct;
   }
   static void *newArray_ReflexcLcLProtectedStruct(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::ProtectedStruct[nElements] : new ::Reflex::ProtectedStruct[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLProtectedStruct(void *p) {
      delete ((::Reflex::ProtectedStruct*)p);
   }
   static void deleteArray_ReflexcLcLProtectedStruct(void *p) {
      delete [] ((::Reflex::ProtectedStruct*)p);
   }
   static void destruct_ReflexcLcLProtectedStruct(void *p) {
      typedef ::Reflex::ProtectedStruct current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::ProtectedStruct

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLProtectedUnion(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::ProtectedUnion : new ::Reflex::ProtectedUnion;
   }
   static void *newArray_ReflexcLcLProtectedUnion(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::ProtectedUnion[nElements] : new ::Reflex::ProtectedUnion[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLProtectedUnion(void *p) {
      delete ((::Reflex::ProtectedUnion*)p);
   }
   static void deleteArray_ReflexcLcLProtectedUnion(void *p) {
      delete [] ((::Reflex::ProtectedUnion*)p);
   }
   static void destruct_ReflexcLcLProtectedUnion(void *p) {
      typedef ::Reflex::ProtectedUnion current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::ProtectedUnion

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLPrivateClass(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::PrivateClass : new ::Reflex::PrivateClass;
   }
   static void *newArray_ReflexcLcLPrivateClass(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::PrivateClass[nElements] : new ::Reflex::PrivateClass[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLPrivateClass(void *p) {
      delete ((::Reflex::PrivateClass*)p);
   }
   static void deleteArray_ReflexcLcLPrivateClass(void *p) {
      delete [] ((::Reflex::PrivateClass*)p);
   }
   static void destruct_ReflexcLcLPrivateClass(void *p) {
      typedef ::Reflex::PrivateClass current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::PrivateClass

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLPrivateEnum(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::PrivateEnum : new ::Reflex::PrivateEnum;
   }
   static void *newArray_ReflexcLcLPrivateEnum(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::PrivateEnum[nElements] : new ::Reflex::PrivateEnum[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLPrivateEnum(void *p) {
      delete ((::Reflex::PrivateEnum*)p);
   }
   static void deleteArray_ReflexcLcLPrivateEnum(void *p) {
      delete [] ((::Reflex::PrivateEnum*)p);
   }
   static void destruct_ReflexcLcLPrivateEnum(void *p) {
      typedef ::Reflex::PrivateEnum current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::PrivateEnum

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLPrivateStruct(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::PrivateStruct : new ::Reflex::PrivateStruct;
   }
   static void *newArray_ReflexcLcLPrivateStruct(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::PrivateStruct[nElements] : new ::Reflex::PrivateStruct[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLPrivateStruct(void *p) {
      delete ((::Reflex::PrivateStruct*)p);
   }
   static void deleteArray_ReflexcLcLPrivateStruct(void *p) {
      delete [] ((::Reflex::PrivateStruct*)p);
   }
   static void destruct_ReflexcLcLPrivateStruct(void *p) {
      typedef ::Reflex::PrivateStruct current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::PrivateStruct

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLPrivateUnion(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::PrivateUnion : new ::Reflex::PrivateUnion;
   }
   static void *newArray_ReflexcLcLPrivateUnion(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::PrivateUnion[nElements] : new ::Reflex::PrivateUnion[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLPrivateUnion(void *p) {
      delete ((::Reflex::PrivateUnion*)p);
   }
   static void deleteArray_ReflexcLcLPrivateUnion(void *p) {
      delete [] ((::Reflex::PrivateUnion*)p);
   }
   static void destruct_ReflexcLcLPrivateUnion(void *p) {
      typedef ::Reflex::PrivateUnion current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::PrivateUnion

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLUnnamedClass(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::UnnamedClass : new ::Reflex::UnnamedClass;
   }
   static void *newArray_ReflexcLcLUnnamedClass(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::UnnamedClass[nElements] : new ::Reflex::UnnamedClass[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLUnnamedClass(void *p) {
      delete ((::Reflex::UnnamedClass*)p);
   }
   static void deleteArray_ReflexcLcLUnnamedClass(void *p) {
      delete [] ((::Reflex::UnnamedClass*)p);
   }
   static void destruct_ReflexcLcLUnnamedClass(void *p) {
      typedef ::Reflex::UnnamedClass current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::UnnamedClass

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLUnnamedEnum(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::UnnamedEnum : new ::Reflex::UnnamedEnum;
   }
   static void *newArray_ReflexcLcLUnnamedEnum(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::UnnamedEnum[nElements] : new ::Reflex::UnnamedEnum[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLUnnamedEnum(void *p) {
      delete ((::Reflex::UnnamedEnum*)p);
   }
   static void deleteArray_ReflexcLcLUnnamedEnum(void *p) {
      delete [] ((::Reflex::UnnamedEnum*)p);
   }
   static void destruct_ReflexcLcLUnnamedEnum(void *p) {
      typedef ::Reflex::UnnamedEnum current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::UnnamedEnum

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLUnnamedNamespace(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::UnnamedNamespace : new ::Reflex::UnnamedNamespace;
   }
   static void *newArray_ReflexcLcLUnnamedNamespace(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::UnnamedNamespace[nElements] : new ::Reflex::UnnamedNamespace[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLUnnamedNamespace(void *p) {
      delete ((::Reflex::UnnamedNamespace*)p);
   }
   static void deleteArray_ReflexcLcLUnnamedNamespace(void *p) {
      delete [] ((::Reflex::UnnamedNamespace*)p);
   }
   static void destruct_ReflexcLcLUnnamedNamespace(void *p) {
      typedef ::Reflex::UnnamedNamespace current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::UnnamedNamespace

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLUnnamedStruct(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::UnnamedStruct : new ::Reflex::UnnamedStruct;
   }
   static void *newArray_ReflexcLcLUnnamedStruct(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::UnnamedStruct[nElements] : new ::Reflex::UnnamedStruct[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLUnnamedStruct(void *p) {
      delete ((::Reflex::UnnamedStruct*)p);
   }
   static void deleteArray_ReflexcLcLUnnamedStruct(void *p) {
      delete [] ((::Reflex::UnnamedStruct*)p);
   }
   static void destruct_ReflexcLcLUnnamedStruct(void *p) {
      typedef ::Reflex::UnnamedStruct current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::UnnamedStruct

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLUnnamedUnion(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::UnnamedUnion : new ::Reflex::UnnamedUnion;
   }
   static void *newArray_ReflexcLcLUnnamedUnion(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::UnnamedUnion[nElements] : new ::Reflex::UnnamedUnion[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLUnnamedUnion(void *p) {
      delete ((::Reflex::UnnamedUnion*)p);
   }
   static void deleteArray_ReflexcLcLUnnamedUnion(void *p) {
      delete [] ((::Reflex::UnnamedUnion*)p);
   }
   static void destruct_ReflexcLcLUnnamedUnion(void *p) {
      typedef ::Reflex::UnnamedUnion current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::UnnamedUnion

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ReflexcLcLClassBuilder(void *p) {
      delete ((::Reflex::ClassBuilder*)p);
   }
   static void deleteArray_ReflexcLcLClassBuilder(void *p) {
      delete [] ((::Reflex::ClassBuilder*)p);
   }
   static void destruct_ReflexcLcLClassBuilder(void *p) {
      typedef ::Reflex::ClassBuilder current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::ClassBuilder

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ReflexcLcLClassBuilderImpl(void *p) {
      delete ((::Reflex::ClassBuilderImpl*)p);
   }
   static void deleteArray_ReflexcLcLClassBuilderImpl(void *p) {
      delete [] ((::Reflex::ClassBuilderImpl*)p);
   }
   static void destruct_ReflexcLcLClassBuilderImpl(void *p) {
      typedef ::Reflex::ClassBuilderImpl current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::ClassBuilderImpl

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ReflexcLcLEnumBuilder(void *p) {
      delete ((::Reflex::EnumBuilder*)p);
   }
   static void deleteArray_ReflexcLcLEnumBuilder(void *p) {
      delete [] ((::Reflex::EnumBuilder*)p);
   }
   static void destruct_ReflexcLcLEnumBuilder(void *p) {
      typedef ::Reflex::EnumBuilder current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::EnumBuilder

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ReflexcLcLFunctionBuilder(void *p) {
      delete ((::Reflex::FunctionBuilder*)p);
   }
   static void deleteArray_ReflexcLcLFunctionBuilder(void *p) {
      delete [] ((::Reflex::FunctionBuilder*)p);
   }
   static void destruct_ReflexcLcLFunctionBuilder(void *p) {
      typedef ::Reflex::FunctionBuilder current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::FunctionBuilder

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ReflexcLcLFunctionBuilderImpl(void *p) {
      delete ((::Reflex::FunctionBuilderImpl*)p);
   }
   static void deleteArray_ReflexcLcLFunctionBuilderImpl(void *p) {
      delete [] ((::Reflex::FunctionBuilderImpl*)p);
   }
   static void destruct_ReflexcLcLFunctionBuilderImpl(void *p) {
      typedef ::Reflex::FunctionBuilderImpl current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::FunctionBuilderImpl

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ReflexcLcLNamespaceBuilder(void *p) {
      delete ((::Reflex::NamespaceBuilder*)p);
   }
   static void deleteArray_ReflexcLcLNamespaceBuilder(void *p) {
      delete [] ((::Reflex::NamespaceBuilder*)p);
   }
   static void destruct_ReflexcLcLNamespaceBuilder(void *p) {
      typedef ::Reflex::NamespaceBuilder current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::NamespaceBuilder

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ReflexcLcLTypedefBuilderImpl(void *p) {
      delete ((::Reflex::TypedefBuilderImpl*)p);
   }
   static void deleteArray_ReflexcLcLTypedefBuilderImpl(void *p) {
      delete [] ((::Reflex::TypedefBuilderImpl*)p);
   }
   static void destruct_ReflexcLcLTypedefBuilderImpl(void *p) {
      typedef ::Reflex::TypedefBuilderImpl current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::TypedefBuilderImpl

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ReflexcLcLUnionBuilderImpl(void *p) {
      delete ((::Reflex::UnionBuilderImpl*)p);
   }
   static void deleteArray_ReflexcLcLUnionBuilderImpl(void *p) {
      delete [] ((::Reflex::UnionBuilderImpl*)p);
   }
   static void destruct_ReflexcLcLUnionBuilderImpl(void *p) {
      typedef ::Reflex::UnionBuilderImpl current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::UnionBuilderImpl

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ReflexcLcLVariableBuilder(void *p) {
      delete ((::Reflex::VariableBuilder*)p);
   }
   static void deleteArray_ReflexcLcLVariableBuilder(void *p) {
      delete [] ((::Reflex::VariableBuilder*)p);
   }
   static void destruct_ReflexcLcLVariableBuilder(void *p) {
      typedef ::Reflex::VariableBuilder current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::VariableBuilder

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ReflexcLcLVariableBuilderImpl(void *p) {
      delete ((::Reflex::VariableBuilderImpl*)p);
   }
   static void deleteArray_ReflexcLcLVariableBuilderImpl(void *p) {
      delete [] ((::Reflex::VariableBuilderImpl*)p);
   }
   static void destruct_ReflexcLcLVariableBuilderImpl(void *p) {
      typedef ::Reflex::VariableBuilderImpl current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::VariableBuilderImpl

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::Selection::NO_SELF_AUTOSELECT : new ::Reflex::Selection::NO_SELF_AUTOSELECT;
   }
   static void *newArray_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::Selection::NO_SELF_AUTOSELECT[nElements] : new ::Reflex::Selection::NO_SELF_AUTOSELECT[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT(void *p) {
      delete ((::Reflex::Selection::NO_SELF_AUTOSELECT*)p);
   }
   static void deleteArray_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT(void *p) {
      delete [] ((::Reflex::Selection::NO_SELF_AUTOSELECT*)p);
   }
   static void destruct_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT(void *p) {
      typedef ::Reflex::Selection::NO_SELF_AUTOSELECT current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::Selection::NO_SELF_AUTOSELECT

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLSelectioncLcLTRANSIENT(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::Selection::TRANSIENT : new ::Reflex::Selection::TRANSIENT;
   }
   static void *newArray_ReflexcLcLSelectioncLcLTRANSIENT(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::Selection::TRANSIENT[nElements] : new ::Reflex::Selection::TRANSIENT[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLSelectioncLcLTRANSIENT(void *p) {
      delete ((::Reflex::Selection::TRANSIENT*)p);
   }
   static void deleteArray_ReflexcLcLSelectioncLcLTRANSIENT(void *p) {
      delete [] ((::Reflex::Selection::TRANSIENT*)p);
   }
   static void destruct_ReflexcLcLSelectioncLcLTRANSIENT(void *p) {
      typedef ::Reflex::Selection::TRANSIENT current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::Selection::TRANSIENT

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLSelectioncLcLAUTOSELECT(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::Selection::AUTOSELECT : new ::Reflex::Selection::AUTOSELECT;
   }
   static void *newArray_ReflexcLcLSelectioncLcLAUTOSELECT(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::Selection::AUTOSELECT[nElements] : new ::Reflex::Selection::AUTOSELECT[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLSelectioncLcLAUTOSELECT(void *p) {
      delete ((::Reflex::Selection::AUTOSELECT*)p);
   }
   static void deleteArray_ReflexcLcLSelectioncLcLAUTOSELECT(void *p) {
      delete [] ((::Reflex::Selection::AUTOSELECT*)p);
   }
   static void destruct_ReflexcLcLSelectioncLcLAUTOSELECT(void *p) {
      typedef ::Reflex::Selection::AUTOSELECT current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::Selection::AUTOSELECT

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLSelectioncLcLNODEFAULT(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::Selection::NODEFAULT : new ::Reflex::Selection::NODEFAULT;
   }
   static void *newArray_ReflexcLcLSelectioncLcLNODEFAULT(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::Selection::NODEFAULT[nElements] : new ::Reflex::Selection::NODEFAULT[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLSelectioncLcLNODEFAULT(void *p) {
      delete ((::Reflex::Selection::NODEFAULT*)p);
   }
   static void deleteArray_ReflexcLcLSelectioncLcLNODEFAULT(void *p) {
      delete [] ((::Reflex::Selection::NODEFAULT*)p);
   }
   static void destruct_ReflexcLcLSelectioncLcLNODEFAULT(void *p) {
      typedef ::Reflex::Selection::NODEFAULT current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::Selection::NODEFAULT

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ReflexcLcLRuntimeError(void *p) {
      delete ((::Reflex::RuntimeError*)p);
   }
   static void deleteArray_ReflexcLcLRuntimeError(void *p) {
      delete [] ((::Reflex::RuntimeError*)p);
   }
   static void destruct_ReflexcLcLRuntimeError(void *p) {
      typedef ::Reflex::RuntimeError current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::RuntimeError

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLCollFuncTable(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::CollFuncTable : new ::Reflex::CollFuncTable;
   }
   static void *newArray_ReflexcLcLCollFuncTable(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::CollFuncTable[nElements] : new ::Reflex::CollFuncTable[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLCollFuncTable(void *p) {
      delete ((::Reflex::CollFuncTable*)p);
   }
   static void deleteArray_ReflexcLcLCollFuncTable(void *p) {
      delete [] ((::Reflex::CollFuncTable*)p);
   }
   static void destruct_ReflexcLcLCollFuncTable(void *p) {
      typedef ::Reflex::CollFuncTable current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::CollFuncTable

namespace ROOT {
   // Wrappers around operator new
   static void *new_ReflexcLcLNewDelFunctions(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::NewDelFunctions : new ::Reflex::NewDelFunctions;
   }
   static void *newArray_ReflexcLcLNewDelFunctions(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Reflex::NewDelFunctions[nElements] : new ::Reflex::NewDelFunctions[nElements];
   }
   // Wrapper around operator delete
   static void delete_ReflexcLcLNewDelFunctions(void *p) {
      delete ((::Reflex::NewDelFunctions*)p);
   }
   static void deleteArray_ReflexcLcLNewDelFunctions(void *p) {
      delete [] ((::Reflex::NewDelFunctions*)p);
   }
   static void destruct_ReflexcLcLNewDelFunctions(void *p) {
      typedef ::Reflex::NewDelFunctions current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Reflex::NewDelFunctions

/********************************************************
* cint/reflex/src/G__Reflex.cxx
* CAUTION: DON'T CHANGE THIS FILE. THIS FILE IS AUTOMATICALLY GENERATED
*          FROM HEADER FILES LISTED IN G__setup_cpp_environmentXXX().
*          CHANGE THOSE HEADER FILES AND REGENERATE THIS FILE.
********************************************************/

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

#if defined(__GNUC__) && __GNUC__ >= 4 && ((__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ >= 1) || (__GNUC_MINOR__ >= 3))
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif

extern "C" void G__cpp_reset_tagtableG__Reflex();

extern "C" void G__set_cpp_environmentG__Reflex() {
  G__add_compiledheader("TObject.h");
  G__add_compiledheader("TMemberInspector.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/Any.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/Base.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/Callback.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/Kernel.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/Member.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/MemberTemplate.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/Object.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/PluginService.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/PropertyList.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/Scope.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/Tools.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/Type.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/TypeTemplate.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/ValueObject.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/Builder/ClassBuilder.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/Builder/CollectionProxy.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/Builder/DictSelection.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/Builder/EnumBuilder.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/Builder/FunctionBuilder.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/Builder/GenreflexMemberBuilder.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/Builder/NamespaceBuilder.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/Builder/NewDelFunctions.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/Builder/OnDemandBuilderForScope.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/Builder/OnDemandBuilder.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/Builder/TypeBuilder.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/Builder/TypedefBuilder.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/Builder/UnionBuilder.h");
  G__add_compiledheader("cint/reflex/inc/Reflex/Builder/VariableBuilder.h");
  G__cpp_reset_tagtableG__Reflex();
}
#include <new>
extern "C" int G__cpp_dllrevG__Reflex() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* Reflex */
static int G__G__Reflex_102_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string& obj = Reflex::Argv0();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) Reflex::NPos());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ostream& obj = Reflex::operator<<(*(ostream*) libp->para[0].ref, *(Reflex::Any*) libp->para[1].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) Reflex::operator<(*(Reflex::Scope*) libp->para[0].ref, *(Reflex::Scope*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) Reflex::operator==(*(Reflex::Scope*) libp->para[0].ref, *(Reflex::Scope*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ostream& obj = Reflex::operator<<(*(ostream*) libp->para[0].ref, *(Reflex::PropertyList*) libp->para[1].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ostream& obj = Reflex::operator<<(*(ostream*) libp->para[0].ref, *(Reflex::PropertyListImpl*) libp->para[1].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      Reflex::InstallClassCallback((Reflex::ICallback*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      Reflex::UninstallClassCallback((Reflex::ICallback*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      Reflex::FireClassCallback(*(Reflex::Type*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      Reflex::FireFunctionCallback(*(Reflex::Member*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::TypeBuilder((const char*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1]));
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 1:
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::TypeBuilder((const char*) G__int(libp->para[0]));
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::ConstBuilder(*(Reflex::Type*) libp->para[0].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::VolatileBuilder(*(Reflex::Type*) libp->para[0].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::PointerBuilder(*(Reflex::Type*) libp->para[0].ref, *(type_info*) libp->para[1].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 1:
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::PointerBuilder(*(Reflex::Type*) libp->para[0].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::PointerToMemberBuilder(*(Reflex::Type*) libp->para[0].ref, *(Reflex::Scope*) libp->para[1].ref
, *(type_info*) libp->para[2].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 2:
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::PointerToMemberBuilder(*(Reflex::Type*) libp->para[0].ref, *(Reflex::Scope*) libp->para[1].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::ReferenceBuilder(*(Reflex::Type*) libp->para[0].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::ArrayBuilder(*(Reflex::Type*) libp->para[0].ref, (size_t) G__int(libp->para[1])
, *(type_info*) libp->para[2].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 2:
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::ArrayBuilder(*(Reflex::Type*) libp->para[0].ref, (size_t) G__int(libp->para[1]));
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::EnumTypeBuilder((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, *(type_info*) libp->para[2].ref, (unsigned int) G__int(libp->para[3]));
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 3:
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::EnumTypeBuilder((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, *(type_info*) libp->para[2].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 2:
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::EnumTypeBuilder((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 1:
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::EnumTypeBuilder((const char*) G__int(libp->para[0]));
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::TypedefTypeBuilder((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (Reflex::REPRESTYPE) G__int(libp->para[2]));
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 2:
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::TypedefTypeBuilder((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(*(Reflex::Type*) libp->para[0].ref, *(vector<Reflex::Type>*) libp->para[1].ref
, *(type_info*) libp->para[2].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 2:
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(*(Reflex::Type*) libp->para[0].ref, *(vector<Reflex::Type>*) libp->para[1].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(*(Reflex::Type*) libp->para[0].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref, *(Reflex::Type*) libp->para[9].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref, *(Reflex::Type*) libp->para[9].ref
, *(Reflex::Type*) libp->para[10].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref, *(Reflex::Type*) libp->para[9].ref
, *(Reflex::Type*) libp->para[10].ref, *(Reflex::Type*) libp->para[11].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref, *(Reflex::Type*) libp->para[9].ref
, *(Reflex::Type*) libp->para[10].ref, *(Reflex::Type*) libp->para[11].ref
, *(Reflex::Type*) libp->para[12].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref, *(Reflex::Type*) libp->para[9].ref
, *(Reflex::Type*) libp->para[10].ref, *(Reflex::Type*) libp->para[11].ref
, *(Reflex::Type*) libp->para[12].ref, *(Reflex::Type*) libp->para[13].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref, *(Reflex::Type*) libp->para[9].ref
, *(Reflex::Type*) libp->para[10].ref, *(Reflex::Type*) libp->para[11].ref
, *(Reflex::Type*) libp->para[12].ref, *(Reflex::Type*) libp->para[13].ref
, *(Reflex::Type*) libp->para[14].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref, *(Reflex::Type*) libp->para[9].ref
, *(Reflex::Type*) libp->para[10].ref, *(Reflex::Type*) libp->para[11].ref
, *(Reflex::Type*) libp->para[12].ref, *(Reflex::Type*) libp->para[13].ref
, *(Reflex::Type*) libp->para[14].ref, *(Reflex::Type*) libp->para[15].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref, *(Reflex::Type*) libp->para[9].ref
, *(Reflex::Type*) libp->para[10].ref, *(Reflex::Type*) libp->para[11].ref
, *(Reflex::Type*) libp->para[12].ref, *(Reflex::Type*) libp->para[13].ref
, *(Reflex::Type*) libp->para[14].ref, *(Reflex::Type*) libp->para[15].ref
, *(Reflex::Type*) libp->para[16].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref, *(Reflex::Type*) libp->para[9].ref
, *(Reflex::Type*) libp->para[10].ref, *(Reflex::Type*) libp->para[11].ref
, *(Reflex::Type*) libp->para[12].ref, *(Reflex::Type*) libp->para[13].ref
, *(Reflex::Type*) libp->para[14].ref, *(Reflex::Type*) libp->para[15].ref
, *(Reflex::Type*) libp->para[16].ref, *(Reflex::Type*) libp->para[17].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref, *(Reflex::Type*) libp->para[9].ref
, *(Reflex::Type*) libp->para[10].ref, *(Reflex::Type*) libp->para[11].ref
, *(Reflex::Type*) libp->para[12].ref, *(Reflex::Type*) libp->para[13].ref
, *(Reflex::Type*) libp->para[14].ref, *(Reflex::Type*) libp->para[15].ref
, *(Reflex::Type*) libp->para[16].ref, *(Reflex::Type*) libp->para[17].ref
, *(Reflex::Type*) libp->para[18].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref, *(Reflex::Type*) libp->para[9].ref
, *(Reflex::Type*) libp->para[10].ref, *(Reflex::Type*) libp->para[11].ref
, *(Reflex::Type*) libp->para[12].ref, *(Reflex::Type*) libp->para[13].ref
, *(Reflex::Type*) libp->para[14].ref, *(Reflex::Type*) libp->para[15].ref
, *(Reflex::Type*) libp->para[16].ref, *(Reflex::Type*) libp->para[17].ref
, *(Reflex::Type*) libp->para[18].ref, *(Reflex::Type*) libp->para[19].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_42(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref, *(Reflex::Type*) libp->para[9].ref
, *(Reflex::Type*) libp->para[10].ref, *(Reflex::Type*) libp->para[11].ref
, *(Reflex::Type*) libp->para[12].ref, *(Reflex::Type*) libp->para[13].ref
, *(Reflex::Type*) libp->para[14].ref, *(Reflex::Type*) libp->para[15].ref
, *(Reflex::Type*) libp->para[16].ref, *(Reflex::Type*) libp->para[17].ref
, *(Reflex::Type*) libp->para[18].ref, *(Reflex::Type*) libp->para[19].ref
, *(Reflex::Type*) libp->para[20].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_43(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref, *(Reflex::Type*) libp->para[9].ref
, *(Reflex::Type*) libp->para[10].ref, *(Reflex::Type*) libp->para[11].ref
, *(Reflex::Type*) libp->para[12].ref, *(Reflex::Type*) libp->para[13].ref
, *(Reflex::Type*) libp->para[14].ref, *(Reflex::Type*) libp->para[15].ref
, *(Reflex::Type*) libp->para[16].ref, *(Reflex::Type*) libp->para[17].ref
, *(Reflex::Type*) libp->para[18].ref, *(Reflex::Type*) libp->para[19].ref
, *(Reflex::Type*) libp->para[20].ref, *(Reflex::Type*) libp->para[21].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_44(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref, *(Reflex::Type*) libp->para[9].ref
, *(Reflex::Type*) libp->para[10].ref, *(Reflex::Type*) libp->para[11].ref
, *(Reflex::Type*) libp->para[12].ref, *(Reflex::Type*) libp->para[13].ref
, *(Reflex::Type*) libp->para[14].ref, *(Reflex::Type*) libp->para[15].ref
, *(Reflex::Type*) libp->para[16].ref, *(Reflex::Type*) libp->para[17].ref
, *(Reflex::Type*) libp->para[18].ref, *(Reflex::Type*) libp->para[19].ref
, *(Reflex::Type*) libp->para[20].ref, *(Reflex::Type*) libp->para[21].ref
, *(Reflex::Type*) libp->para[22].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_45(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref, *(Reflex::Type*) libp->para[9].ref
, *(Reflex::Type*) libp->para[10].ref, *(Reflex::Type*) libp->para[11].ref
, *(Reflex::Type*) libp->para[12].ref, *(Reflex::Type*) libp->para[13].ref
, *(Reflex::Type*) libp->para[14].ref, *(Reflex::Type*) libp->para[15].ref
, *(Reflex::Type*) libp->para[16].ref, *(Reflex::Type*) libp->para[17].ref
, *(Reflex::Type*) libp->para[18].ref, *(Reflex::Type*) libp->para[19].ref
, *(Reflex::Type*) libp->para[20].ref, *(Reflex::Type*) libp->para[21].ref
, *(Reflex::Type*) libp->para[22].ref, *(Reflex::Type*) libp->para[23].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_46(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref, *(Reflex::Type*) libp->para[9].ref
, *(Reflex::Type*) libp->para[10].ref, *(Reflex::Type*) libp->para[11].ref
, *(Reflex::Type*) libp->para[12].ref, *(Reflex::Type*) libp->para[13].ref
, *(Reflex::Type*) libp->para[14].ref, *(Reflex::Type*) libp->para[15].ref
, *(Reflex::Type*) libp->para[16].ref, *(Reflex::Type*) libp->para[17].ref
, *(Reflex::Type*) libp->para[18].ref, *(Reflex::Type*) libp->para[19].ref
, *(Reflex::Type*) libp->para[20].ref, *(Reflex::Type*) libp->para[21].ref
, *(Reflex::Type*) libp->para[22].ref, *(Reflex::Type*) libp->para[23].ref
, *(Reflex::Type*) libp->para[24].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_47(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref, *(Reflex::Type*) libp->para[9].ref
, *(Reflex::Type*) libp->para[10].ref, *(Reflex::Type*) libp->para[11].ref
, *(Reflex::Type*) libp->para[12].ref, *(Reflex::Type*) libp->para[13].ref
, *(Reflex::Type*) libp->para[14].ref, *(Reflex::Type*) libp->para[15].ref
, *(Reflex::Type*) libp->para[16].ref, *(Reflex::Type*) libp->para[17].ref
, *(Reflex::Type*) libp->para[18].ref, *(Reflex::Type*) libp->para[19].ref
, *(Reflex::Type*) libp->para[20].ref, *(Reflex::Type*) libp->para[21].ref
, *(Reflex::Type*) libp->para[22].ref, *(Reflex::Type*) libp->para[23].ref
, *(Reflex::Type*) libp->para[24].ref, *(Reflex::Type*) libp->para[25].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_48(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref, *(Reflex::Type*) libp->para[9].ref
, *(Reflex::Type*) libp->para[10].ref, *(Reflex::Type*) libp->para[11].ref
, *(Reflex::Type*) libp->para[12].ref, *(Reflex::Type*) libp->para[13].ref
, *(Reflex::Type*) libp->para[14].ref, *(Reflex::Type*) libp->para[15].ref
, *(Reflex::Type*) libp->para[16].ref, *(Reflex::Type*) libp->para[17].ref
, *(Reflex::Type*) libp->para[18].ref, *(Reflex::Type*) libp->para[19].ref
, *(Reflex::Type*) libp->para[20].ref, *(Reflex::Type*) libp->para[21].ref
, *(Reflex::Type*) libp->para[22].ref, *(Reflex::Type*) libp->para[23].ref
, *(Reflex::Type*) libp->para[24].ref, *(Reflex::Type*) libp->para[25].ref
, *(Reflex::Type*) libp->para[26].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_49(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref, *(Reflex::Type*) libp->para[9].ref
, *(Reflex::Type*) libp->para[10].ref, *(Reflex::Type*) libp->para[11].ref
, *(Reflex::Type*) libp->para[12].ref, *(Reflex::Type*) libp->para[13].ref
, *(Reflex::Type*) libp->para[14].ref, *(Reflex::Type*) libp->para[15].ref
, *(Reflex::Type*) libp->para[16].ref, *(Reflex::Type*) libp->para[17].ref
, *(Reflex::Type*) libp->para[18].ref, *(Reflex::Type*) libp->para[19].ref
, *(Reflex::Type*) libp->para[20].ref, *(Reflex::Type*) libp->para[21].ref
, *(Reflex::Type*) libp->para[22].ref, *(Reflex::Type*) libp->para[23].ref
, *(Reflex::Type*) libp->para[24].ref, *(Reflex::Type*) libp->para[25].ref
, *(Reflex::Type*) libp->para[26].ref, *(Reflex::Type*) libp->para[27].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_50(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref, *(Reflex::Type*) libp->para[9].ref
, *(Reflex::Type*) libp->para[10].ref, *(Reflex::Type*) libp->para[11].ref
, *(Reflex::Type*) libp->para[12].ref, *(Reflex::Type*) libp->para[13].ref
, *(Reflex::Type*) libp->para[14].ref, *(Reflex::Type*) libp->para[15].ref
, *(Reflex::Type*) libp->para[16].ref, *(Reflex::Type*) libp->para[17].ref
, *(Reflex::Type*) libp->para[18].ref, *(Reflex::Type*) libp->para[19].ref
, *(Reflex::Type*) libp->para[20].ref, *(Reflex::Type*) libp->para[21].ref
, *(Reflex::Type*) libp->para[22].ref, *(Reflex::Type*) libp->para[23].ref
, *(Reflex::Type*) libp->para[24].ref, *(Reflex::Type*) libp->para[25].ref
, *(Reflex::Type*) libp->para[26].ref, *(Reflex::Type*) libp->para[27].ref
, *(Reflex::Type*) libp->para[28].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_51(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref, *(Reflex::Type*) libp->para[9].ref
, *(Reflex::Type*) libp->para[10].ref, *(Reflex::Type*) libp->para[11].ref
, *(Reflex::Type*) libp->para[12].ref, *(Reflex::Type*) libp->para[13].ref
, *(Reflex::Type*) libp->para[14].ref, *(Reflex::Type*) libp->para[15].ref
, *(Reflex::Type*) libp->para[16].ref, *(Reflex::Type*) libp->para[17].ref
, *(Reflex::Type*) libp->para[18].ref, *(Reflex::Type*) libp->para[19].ref
, *(Reflex::Type*) libp->para[20].ref, *(Reflex::Type*) libp->para[21].ref
, *(Reflex::Type*) libp->para[22].ref, *(Reflex::Type*) libp->para[23].ref
, *(Reflex::Type*) libp->para[24].ref, *(Reflex::Type*) libp->para[25].ref
, *(Reflex::Type*) libp->para[26].ref, *(Reflex::Type*) libp->para[27].ref
, *(Reflex::Type*) libp->para[28].ref, *(Reflex::Type*) libp->para[29].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_52(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref, *(Reflex::Type*) libp->para[9].ref
, *(Reflex::Type*) libp->para[10].ref, *(Reflex::Type*) libp->para[11].ref
, *(Reflex::Type*) libp->para[12].ref, *(Reflex::Type*) libp->para[13].ref
, *(Reflex::Type*) libp->para[14].ref, *(Reflex::Type*) libp->para[15].ref
, *(Reflex::Type*) libp->para[16].ref, *(Reflex::Type*) libp->para[17].ref
, *(Reflex::Type*) libp->para[18].ref, *(Reflex::Type*) libp->para[19].ref
, *(Reflex::Type*) libp->para[20].ref, *(Reflex::Type*) libp->para[21].ref
, *(Reflex::Type*) libp->para[22].ref, *(Reflex::Type*) libp->para[23].ref
, *(Reflex::Type*) libp->para[24].ref, *(Reflex::Type*) libp->para[25].ref
, *(Reflex::Type*) libp->para[26].ref, *(Reflex::Type*) libp->para[27].ref
, *(Reflex::Type*) libp->para[28].ref, *(Reflex::Type*) libp->para[29].ref
, *(Reflex::Type*) libp->para[30].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_53(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref, *(Reflex::Type*) libp->para[9].ref
, *(Reflex::Type*) libp->para[10].ref, *(Reflex::Type*) libp->para[11].ref
, *(Reflex::Type*) libp->para[12].ref, *(Reflex::Type*) libp->para[13].ref
, *(Reflex::Type*) libp->para[14].ref, *(Reflex::Type*) libp->para[15].ref
, *(Reflex::Type*) libp->para[16].ref, *(Reflex::Type*) libp->para[17].ref
, *(Reflex::Type*) libp->para[18].ref, *(Reflex::Type*) libp->para[19].ref
, *(Reflex::Type*) libp->para[20].ref, *(Reflex::Type*) libp->para[21].ref
, *(Reflex::Type*) libp->para[22].ref, *(Reflex::Type*) libp->para[23].ref
, *(Reflex::Type*) libp->para[24].ref, *(Reflex::Type*) libp->para[25].ref
, *(Reflex::Type*) libp->para[26].ref, *(Reflex::Type*) libp->para[27].ref
, *(Reflex::Type*) libp->para[28].ref, *(Reflex::Type*) libp->para[29].ref
, *(Reflex::Type*) libp->para[30].ref, *(Reflex::Type*) libp->para[31].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_102_0_54(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::FunctionTypeBuilder(
*(Reflex::Type*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, *(Reflex::Type*) libp->para[2].ref, *(Reflex::Type*) libp->para[3].ref
, *(Reflex::Type*) libp->para[4].ref, *(Reflex::Type*) libp->para[5].ref
, *(Reflex::Type*) libp->para[6].ref, *(Reflex::Type*) libp->para[7].ref
, *(Reflex::Type*) libp->para[8].ref, *(Reflex::Type*) libp->para[9].ref
, *(Reflex::Type*) libp->para[10].ref, *(Reflex::Type*) libp->para[11].ref
, *(Reflex::Type*) libp->para[12].ref, *(Reflex::Type*) libp->para[13].ref
, *(Reflex::Type*) libp->para[14].ref, *(Reflex::Type*) libp->para[15].ref
, *(Reflex::Type*) libp->para[16].ref, *(Reflex::Type*) libp->para[17].ref
, *(Reflex::Type*) libp->para[18].ref, *(Reflex::Type*) libp->para[19].ref
, *(Reflex::Type*) libp->para[20].ref, *(Reflex::Type*) libp->para[21].ref
, *(Reflex::Type*) libp->para[22].ref, *(Reflex::Type*) libp->para[23].ref
, *(Reflex::Type*) libp->para[24].ref, *(Reflex::Type*) libp->para[25].ref
, *(Reflex::Type*) libp->para[26].ref, *(Reflex::Type*) libp->para[27].ref
, *(Reflex::Type*) libp->para[28].ref, *(Reflex::Type*) libp->para[29].ref
, *(Reflex::Type*) libp->para[30].ref, *(Reflex::Type*) libp->para[31].ref
, *(Reflex::Type*) libp->para[32].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::Any */
static int G__G__Reflex_103_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::Any* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::Any[n];
     } else {
       p = new((void*) gvp) Reflex::Any[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::Any;
     } else {
       p = new((void*) gvp) Reflex::Any;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLAny));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_103_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::Any* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Reflex::Any(*(Reflex::Any*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) Reflex::Any(*(Reflex::Any*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLAny));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_103_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Reflex::Any*) G__getstructoffset())->Clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_103_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((Reflex::Any*) G__getstructoffset())->operator bool());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_103_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Any& obj = ((Reflex::Any*) G__getstructoffset())->Swap(*(Reflex::Any*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_103_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Any& obj = ((Reflex::Any*) G__getstructoffset())->operator=(*(Reflex::Any*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_103_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Any*) G__getstructoffset())->Empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_103_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = ((const Reflex::Any*) G__getstructoffset())->TypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_103_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 89, (long) ((const Reflex::Any*) G__getstructoffset())->Address());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::Any G__TReflexcLcLAny;
static int G__G__Reflex_103_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::Any*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::Any*) (soff+(sizeof(Reflex::Any)*i)))->~G__TReflexcLcLAny();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::Any*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::Any*) (soff))->~G__TReflexcLcLAny();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::Type */
static int G__G__Reflex_104_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::Type* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::Type((const Reflex::TypeName*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) Reflex::Type((const Reflex::TypeName*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::Type((const Reflex::TypeName*) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) Reflex::Type((const Reflex::TypeName*) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Reflex::Type[n];
       } else {
         p = new((void*) gvp) Reflex::Type[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Reflex::Type;
       } else {
         p = new((void*) gvp) Reflex::Type;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::Type* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Reflex::Type(*(Reflex::Type*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) Reflex::Type(*(Reflex::Type*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::Type* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::Type(
*(Reflex::Type*) libp->para[0].ref, (unsigned int) G__int(libp->para[1])
, (Reflex::Type::TYPE_MODIFICATION) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) Reflex::Type(
*(Reflex::Type*) libp->para[0].ref, (unsigned int) G__int(libp->para[1])
, (Reflex::Type::TYPE_MODIFICATION) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::Type(*(Reflex::Type*) libp->para[0].ref, (unsigned int) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) Reflex::Type(*(Reflex::Type*) libp->para[0].ref, (unsigned int) G__int(libp->para[1]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type& obj = ((Reflex::Type*) G__getstructoffset())->operator=(*(Reflex::Type*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->operator==(*(Reflex::Type*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->operator!=(*(Reflex::Type*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->operator<(*(Reflex::Type*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Scope* pobj;
         const Reflex::Scope xobj = ((const Reflex::Type*) G__getstructoffset())->operator ::Reflex::Scope();
         pobj = new Reflex::Scope(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->operator bool());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 89, (long) ((const Reflex::Type*) G__getstructoffset())->Allocate());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Reflex::Type*) G__getstructoffset())->ArrayLength());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Base* pobj;
         const Reflex::Base xobj = ((const Reflex::Type*) G__getstructoffset())->BaseAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::Base(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Reflex::Type*) G__getstructoffset())->BaseSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Base_Iterator* pobj;
         const Reflex::Base_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->Base_Begin();
         pobj = new Reflex::Base_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Base_Iterator* pobj;
         const Reflex::Base_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->Base_End();
         pobj = new Reflex::Base_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Base_Iterator* pobj;
         const Reflex::Reverse_Base_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->Base_RBegin();
         pobj = new Reflex::Reverse_Base_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Base_Iterator* pobj;
         const Reflex::Reverse_Base_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->Base_REnd();
         pobj = new Reflex::Reverse_Base_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::Type::ByName(*(string*) libp->para[0].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::Type::ByTypeInfo(*(type_info*) libp->para[0].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Object* pobj;
         const Reflex::Object xobj = ((const Reflex::Type*) G__getstructoffset())->CastObject(*(Reflex::Type*) libp->para[0].ref, *(Reflex::Object*) libp->para[1].ref);
         pobj = new Reflex::Object(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      {
         const Reflex::Object* pobj;
         const Reflex::Object xobj = ((const Reflex::Type*) G__getstructoffset())->Construct(*(Reflex::Type*) libp->para[0].ref, *(vector<void*>*) libp->para[1].ref
, (void*) G__int(libp->para[2]));
         pobj = new Reflex::Object(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 2:
      {
         const Reflex::Object* pobj;
         const Reflex::Object xobj = ((const Reflex::Type*) G__getstructoffset())->Construct(*(Reflex::Type*) libp->para[0].ref, *(vector<void*>*) libp->para[1].ref);
         pobj = new Reflex::Object(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 1:
      {
         const Reflex::Object* pobj;
         const Reflex::Object xobj = ((const Reflex::Type*) G__getstructoffset())->Construct(*(Reflex::Type*) libp->para[0].ref);
         pobj = new Reflex::Object(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Object* pobj;
         const Reflex::Object xobj = ((const Reflex::Type*) G__getstructoffset())->Construct();
         pobj = new Reflex::Object(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Type*) G__getstructoffset())->DataMemberAt((size_t) G__int(libp->para[0]), (Reflex::EMEMBERQUERY) G__int(libp->para[1]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 1:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Type*) G__getstructoffset())->DataMemberAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Type*) G__getstructoffset())->DataMemberByName(*(string*) libp->para[0].ref, (Reflex::EMEMBERQUERY) G__int(libp->para[1]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 1:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Type*) G__getstructoffset())->DataMemberByName(*(string*) libp->para[0].ref);
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 104, (long) ((const Reflex::Type*) G__getstructoffset())->DataMemberSize((Reflex::EMEMBERQUERY) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 104, (long) ((const Reflex::Type*) G__getstructoffset())->DataMemberSize());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->DataMember_Begin((Reflex::EMEMBERQUERY) G__int(libp->para[0]));
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->DataMember_Begin();
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->DataMember_End((Reflex::EMEMBERQUERY) G__int(libp->para[0]));
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->DataMember_End();
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->DataMember_RBegin((Reflex::EMEMBERQUERY) G__int(libp->para[0]));
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->DataMember_RBegin();
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->DataMember_REnd((Reflex::EMEMBERQUERY) G__int(libp->para[0]));
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->DataMember_REnd();
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Type*) G__getstructoffset())->Deallocate((void*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Scope* pobj;
         const Reflex::Scope xobj = ((const Reflex::Type*) G__getstructoffset())->DeclaringScope();
         pobj = new Reflex::Scope(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((const Reflex::Type*) G__getstructoffset())->Destruct((void*) G__int(libp->para[0]), (bool) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((const Reflex::Type*) G__getstructoffset())->Destruct((void*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type* pobj;
         const Reflex::Type xobj = ((const Reflex::Type*) G__getstructoffset())->DynamicType(*(Reflex::Object*) libp->para[0].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type* pobj;
         const Reflex::Type xobj = ((const Reflex::Type*) G__getstructoffset())->FinalType();
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Type*) G__getstructoffset())->FunctionMemberAt((size_t) G__int(libp->para[0]), (Reflex::EMEMBERQUERY) G__int(libp->para[1]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 1:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Type*) G__getstructoffset())->FunctionMemberAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Type*) G__getstructoffset())->FunctionMemberByName(*(string*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, (unsigned int) G__int(libp->para[2]), (Reflex::EMEMBERQUERY) G__int(libp->para[3])
, (Reflex::EDELAYEDLOADSETTING) G__int(libp->para[4]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 4:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Type*) G__getstructoffset())->FunctionMemberByName(*(string*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, (unsigned int) G__int(libp->para[2]), (Reflex::EMEMBERQUERY) G__int(libp->para[3]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 3:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Type*) G__getstructoffset())->FunctionMemberByName(*(string*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, (unsigned int) G__int(libp->para[2]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 2:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Type*) G__getstructoffset())->FunctionMemberByName(*(string*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref);
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 1:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Type*) G__getstructoffset())->FunctionMemberByName(*(string*) libp->para[0].ref);
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 104, (long) ((const Reflex::Type*) G__getstructoffset())->FunctionMemberSize((Reflex::EMEMBERQUERY) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 104, (long) ((const Reflex::Type*) G__getstructoffset())->FunctionMemberSize());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->FunctionMember_Begin((Reflex::EMEMBERQUERY) G__int(libp->para[0]));
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->FunctionMember_Begin();
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->FunctionMember_End((Reflex::EMEMBERQUERY) G__int(libp->para[0]));
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->FunctionMember_End();
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->FunctionMember_RBegin((Reflex::EMEMBERQUERY) G__int(libp->para[0]));
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->FunctionMember_RBegin();
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->FunctionMember_REnd((Reflex::EMEMBERQUERY) G__int(libp->para[0]));
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->FunctionMember_REnd();
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type* pobj;
         const Reflex::Type xobj = ((const Reflex::Type*) G__getstructoffset())->FunctionParameterAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_42(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Reflex::Type*) G__getstructoffset())->FunctionParameterSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_43(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type_Iterator* pobj;
         const Reflex::Type_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->FunctionParameter_Begin();
         pobj = new Reflex::Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_44(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type_Iterator* pobj;
         const Reflex::Type_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->FunctionParameter_End();
         pobj = new Reflex::Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_45(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Type_Iterator* pobj;
         const Reflex::Reverse_Type_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->FunctionParameter_RBegin();
         pobj = new Reflex::Reverse_Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_46(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Type_Iterator* pobj;
         const Reflex::Reverse_Type_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->FunctionParameter_REnd();
         pobj = new Reflex::Reverse_Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_47(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Type*) G__getstructoffset())->GenerateDict(*(Reflex::DictionaryGenerator*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_48(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->HasBase(*(Reflex::Type*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_49(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 89, (long) ((const Reflex::Type*) G__getstructoffset())->Id());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_50(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsAbstract());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_51(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsArray());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_52(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsClass());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_53(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsComplete());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_54(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsConst());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_55(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsConstVolatile());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_56(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsEnum());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_57(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsEquivalentTo(*(Reflex::Type*) libp->para[0].ref, (unsigned int) G__int(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsEquivalentTo(*(Reflex::Type*) libp->para[0].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_58(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsSignatureEquivalentTo(*(Reflex::Type*) libp->para[0].ref, (unsigned int) G__int(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsSignatureEquivalentTo(*(Reflex::Type*) libp->para[0].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_59(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsFunction());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_60(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsFundamental());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_61(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsPrivate());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_62(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsProtected());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_63(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsPublic());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_64(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsPointer());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_65(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsPointerToMember());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_66(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsReference());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_67(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsStruct());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_68(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsTemplateInstance());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_69(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsTypedef());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_70(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsUnion());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_71(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsUnqualified());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_72(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsVirtual());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_73(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Type*) G__getstructoffset())->IsVolatile());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_74(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Type*) G__getstructoffset())->MemberAt((size_t) G__int(libp->para[0]), (Reflex::EMEMBERQUERY) G__int(libp->para[1]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 1:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Type*) G__getstructoffset())->MemberAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_75(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Type*) G__getstructoffset())->MemberByName(*(string*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, (Reflex::EMEMBERQUERY) G__int(libp->para[2]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 2:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Type*) G__getstructoffset())->MemberByName(*(string*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref);
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 1:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Type*) G__getstructoffset())->MemberByName(*(string*) libp->para[0].ref);
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_76(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 104, (long) ((const Reflex::Type*) G__getstructoffset())->MemberSize((Reflex::EMEMBERQUERY) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 104, (long) ((const Reflex::Type*) G__getstructoffset())->MemberSize());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_77(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->Member_Begin((Reflex::EMEMBERQUERY) G__int(libp->para[0]));
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->Member_Begin();
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_78(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->Member_End((Reflex::EMEMBERQUERY) G__int(libp->para[0]));
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->Member_End();
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_79(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->Member_RBegin((Reflex::EMEMBERQUERY) G__int(libp->para[0]));
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->Member_RBegin();
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_80(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->Member_REnd((Reflex::EMEMBERQUERY) G__int(libp->para[0]));
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->Member_REnd();
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_81(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::MemberTemplate* pobj;
         const Reflex::MemberTemplate xobj = ((const Reflex::Type*) G__getstructoffset())->MemberTemplateAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::MemberTemplate(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_82(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Reflex::Type*) G__getstructoffset())->MemberTemplateSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_83(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::MemberTemplate_Iterator* pobj;
         const Reflex::MemberTemplate_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->MemberTemplate_Begin();
         pobj = new Reflex::MemberTemplate_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_84(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::MemberTemplate_Iterator* pobj;
         const Reflex::MemberTemplate_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->MemberTemplate_End();
         pobj = new Reflex::MemberTemplate_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_85(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_MemberTemplate_Iterator* pobj;
         const Reflex::Reverse_MemberTemplate_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->MemberTemplate_RBegin();
         pobj = new Reflex::Reverse_MemberTemplate_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_86(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_MemberTemplate_Iterator* pobj;
         const Reflex::Reverse_MemberTemplate_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->MemberTemplate_REnd();
         pobj = new Reflex::Reverse_MemberTemplate_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_87(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const string* pobj;
         const string xobj = ((const Reflex::Type*) G__getstructoffset())->Name((unsigned int) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const string* pobj;
         const string xobj = ((const Reflex::Type*) G__getstructoffset())->Name();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_88(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const Reflex::Type*) G__getstructoffset())->Name_c_str());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_89(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Scope* pobj;
         const Reflex::Scope xobj = ((const Reflex::Type*) G__getstructoffset())->PointerToMemberScope();
         pobj = new Reflex::Scope(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_90(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::PropertyList* pobj;
         const Reflex::PropertyList xobj = ((const Reflex::Type*) G__getstructoffset())->Properties();
         pobj = new Reflex::PropertyList(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_91(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type* pobj;
         const Reflex::Type xobj = ((const Reflex::Type*) G__getstructoffset())->RawType();
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_92(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type* pobj;
         const Reflex::Type xobj = ((const Reflex::Type*) G__getstructoffset())->ReturnType();
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_93(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Reflex::Type*) G__getstructoffset())->SizeOf());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_94(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Scope* pobj;
         const Reflex::Scope xobj = ((const Reflex::Type*) G__getstructoffset())->SubScopeAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::Scope(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_95(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Reflex::Type*) G__getstructoffset())->SubScopeSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_96(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Scope_Iterator* pobj;
         const Reflex::Scope_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->SubScope_Begin();
         pobj = new Reflex::Scope_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_97(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Scope_Iterator* pobj;
         const Reflex::Scope_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->SubScope_End();
         pobj = new Reflex::Scope_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_98(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Scope_Iterator* pobj;
         const Reflex::Reverse_Scope_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->SubScope_RBegin();
         pobj = new Reflex::Reverse_Scope_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_99(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Scope_Iterator* pobj;
         const Reflex::Reverse_Scope_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->SubScope_REnd();
         pobj = new Reflex::Reverse_Scope_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_100(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type* pobj;
         const Reflex::Type xobj = ((const Reflex::Type*) G__getstructoffset())->SubTypeAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_101(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Reflex::Type*) G__getstructoffset())->SubTypeSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_102(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type_Iterator* pobj;
         const Reflex::Type_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->SubType_Begin();
         pobj = new Reflex::Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_103(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type_Iterator* pobj;
         const Reflex::Type_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->SubType_End();
         pobj = new Reflex::Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_104(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Type_Iterator* pobj;
         const Reflex::Reverse_Type_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->SubType_RBegin();
         pobj = new Reflex::Reverse_Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_105(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Type_Iterator* pobj;
         const Reflex::Reverse_Type_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->SubType_REnd();
         pobj = new Reflex::Reverse_Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_106(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::TypeTemplate* pobj;
         const Reflex::TypeTemplate xobj = ((const Reflex::Type*) G__getstructoffset())->SubTypeTemplateAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::TypeTemplate(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_107(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Reflex::Type*) G__getstructoffset())->SubTypeTemplateSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_108(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::TypeTemplate_Iterator* pobj;
         const Reflex::TypeTemplate_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->SubTypeTemplate_Begin();
         pobj = new Reflex::TypeTemplate_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_109(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::TypeTemplate_Iterator* pobj;
         const Reflex::TypeTemplate_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->SubTypeTemplate_End();
         pobj = new Reflex::TypeTemplate_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_110(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_TypeTemplate_Iterator* pobj;
         const Reflex::Reverse_TypeTemplate_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->SubTypeTemplate_RBegin();
         pobj = new Reflex::Reverse_TypeTemplate_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_111(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_TypeTemplate_Iterator* pobj;
         const Reflex::Reverse_TypeTemplate_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->SubTypeTemplate_REnd();
         pobj = new Reflex::Reverse_TypeTemplate_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_112(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type* pobj;
         const Reflex::Type xobj = ((const Reflex::Type*) G__getstructoffset())->TemplateArgumentAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_113(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Reflex::Type*) G__getstructoffset())->TemplateArgumentSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_114(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type_Iterator* pobj;
         const Reflex::Type_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->TemplateArgument_Begin();
         pobj = new Reflex::Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_115(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type_Iterator* pobj;
         const Reflex::Type_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->TemplateArgument_End();
         pobj = new Reflex::Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_116(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Type_Iterator* pobj;
         const Reflex::Reverse_Type_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->TemplateArgument_RBegin();
         pobj = new Reflex::Reverse_Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_117(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Type_Iterator* pobj;
         const Reflex::Reverse_Type_Iterator xobj = ((const Reflex::Type*) G__getstructoffset())->TemplateArgument_REnd();
         pobj = new Reflex::Reverse_Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_118(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::TypeTemplate* pobj;
         const Reflex::TypeTemplate xobj = ((const Reflex::Type*) G__getstructoffset())->TemplateFamily();
         pobj = new Reflex::TypeTemplate(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_119(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type* pobj;
         const Reflex::Type xobj = ((const Reflex::Type*) G__getstructoffset())->ToType();
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_120(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = Reflex::Type::TypeAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_121(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) Reflex::Type::TypeSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_122(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type_Iterator* pobj;
         Reflex::Type_Iterator xobj = Reflex::Type::Type_Begin();
         pobj = new Reflex::Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_123(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type_Iterator* pobj;
         Reflex::Type_Iterator xobj = Reflex::Type::Type_End();
         pobj = new Reflex::Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_124(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Reverse_Type_Iterator* pobj;
         Reflex::Reverse_Type_Iterator xobj = Reflex::Type::Type_RBegin();
         pobj = new Reflex::Reverse_Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_125(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Reverse_Type_Iterator* pobj;
         Reflex::Reverse_Type_Iterator xobj = Reflex::Type::Type_REnd();
         pobj = new Reflex::Reverse_Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_126(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = ((const Reflex::Type*) G__getstructoffset())->TypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_127(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const Reflex::Type*) G__getstructoffset())->TypeType());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_128(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const Reflex::Type*) G__getstructoffset())->TypeTypeAsString();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_129(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Type*) G__getstructoffset())->Unload();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_130(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Type*) G__getstructoffset())->UpdateMembers();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_131(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      ((const Reflex::Type*) G__getstructoffset())->AddBase(*(Reflex::Type*) libp->para[0].ref, (Reflex::OffsetFunction) G__int(libp->para[1])
, (unsigned int) G__int(libp->para[2]));
      G__setnull(result7);
      break;
   case 2:
      ((const Reflex::Type*) G__getstructoffset())->AddBase(*(Reflex::Type*) libp->para[0].ref, (Reflex::OffsetFunction) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_132(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Type*) G__getstructoffset())->AddBase(*(Reflex::Base*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_133(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Type*) G__getstructoffset())->AddDataMember(*(Reflex::Member*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_134(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Type*) G__getstructoffset())->AddDataMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (size_t) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3])
, (char*) G__int(libp->para[4]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 4:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Type*) G__getstructoffset())->AddDataMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (size_t) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 3:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Type*) G__getstructoffset())->AddDataMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (size_t) G__int(libp->para[2]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_135(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Type*) G__getstructoffset())->AddFunctionMember(*(Reflex::Member*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_136(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 6:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Type*) G__getstructoffset())->AddFunctionMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (Reflex::StubFunction) G__int(libp->para[2]), (void*) G__int(libp->para[3])
, (const char*) G__int(libp->para[4]), (unsigned int) G__int(libp->para[5]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 5:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Type*) G__getstructoffset())->AddFunctionMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (Reflex::StubFunction) G__int(libp->para[2]), (void*) G__int(libp->para[3])
, (const char*) G__int(libp->para[4]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 4:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Type*) G__getstructoffset())->AddFunctionMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (Reflex::StubFunction) G__int(libp->para[2]), (void*) G__int(libp->para[3]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 3:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Type*) G__getstructoffset())->AddFunctionMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (Reflex::StubFunction) G__int(libp->para[2]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_137(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Type*) G__getstructoffset())->AddSubScope(*(Reflex::Scope*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_138(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((const Reflex::Type*) G__getstructoffset())->AddSubScope((const char*) G__int(libp->para[0]), (Reflex::TYPE) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((const Reflex::Type*) G__getstructoffset())->AddSubScope((const char*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_139(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Type*) G__getstructoffset())->AddSubType(*(Reflex::Type*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_140(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      ((const Reflex::Type*) G__getstructoffset())->AddSubType((const char*) G__int(libp->para[0]), (size_t) G__int(libp->para[1])
, (Reflex::TYPE) G__int(libp->para[2]), *(type_info*) libp->para[3].ref
, (unsigned int) G__int(libp->para[4]));
      G__setnull(result7);
      break;
   case 4:
      ((const Reflex::Type*) G__getstructoffset())->AddSubType((const char*) G__int(libp->para[0]), (size_t) G__int(libp->para[1])
, (Reflex::TYPE) G__int(libp->para[2]), *(type_info*) libp->para[3].ref);
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_141(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Type*) G__getstructoffset())->RemoveDataMember(*(Reflex::Member*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_142(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Type*) G__getstructoffset())->RemoveFunctionMember(*(Reflex::Member*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_143(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Type*) G__getstructoffset())->RemoveSubScope(*(Reflex::Scope*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_144(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Type*) G__getstructoffset())->RemoveSubType(*(Reflex::Type*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_145(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Type*) G__getstructoffset())->SetSize((size_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_146(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Type*) G__getstructoffset())->SetTypeInfo(*(type_info*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_147(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const Reflex::Type*) G__getstructoffset())->ToTypeBase());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_104_0_148(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const Reflex::Type*) G__getstructoffset())->RepresType());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::Type G__TReflexcLcLType;
static int G__G__Reflex_104_0_149(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::Type*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::Type*) (soff+(sizeof(Reflex::Type)*i)))->~G__TReflexcLcLType();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::Type*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::Type*) (soff))->~G__TReflexcLcLType();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::Base */
static int G__G__Reflex_105_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::Base* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::Base[n];
     } else {
       p = new((void*) gvp) Reflex::Base[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::Base;
     } else {
       p = new((void*) gvp) Reflex::Base;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLBase));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_105_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::Base* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::Base(
*(Reflex::Type*) libp->para[0].ref, (Reflex::OffsetFunction) G__int(libp->para[1])
, (unsigned int) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) Reflex::Base(
*(Reflex::Type*) libp->para[0].ref, (Reflex::OffsetFunction) G__int(libp->para[1])
, (unsigned int) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::Base(*(Reflex::Type*) libp->para[0].ref, (Reflex::OffsetFunction) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) Reflex::Base(*(Reflex::Type*) libp->para[0].ref, (Reflex::OffsetFunction) G__int(libp->para[1]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLBase));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_105_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Base*) G__getstructoffset())->operator bool());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_105_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const string* pobj;
         const string xobj = ((const Reflex::Base*) G__getstructoffset())->Name((unsigned int) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const string* pobj;
         const string xobj = ((const Reflex::Base*) G__getstructoffset())->Name();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_105_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Base*) G__getstructoffset())->IsPrivate());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_105_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Base*) G__getstructoffset())->IsProtected());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_105_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Base*) G__getstructoffset())->IsPublic());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_105_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Base*) G__getstructoffset())->IsVirtual());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_105_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 104, (long) ((const Reflex::Base*) G__getstructoffset())->Offset((void*) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 104, (long) ((const Reflex::Base*) G__getstructoffset())->Offset());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_105_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 89, (long) ((const Reflex::Base*) G__getstructoffset())->OffsetFP());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_105_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type* pobj;
         const Reflex::Type xobj = ((const Reflex::Base*) G__getstructoffset())->ToType();
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_105_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Scope* pobj;
         const Reflex::Scope xobj = ((const Reflex::Base*) G__getstructoffset())->ToScope();
         pobj = new Reflex::Scope(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_105_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::Base* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::Base(*(Reflex::Base*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLBase));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::Base G__TReflexcLcLBase;
static int G__G__Reflex_105_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::Base*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::Base*) (soff+(sizeof(Reflex::Base)*i)))->~G__TReflexcLcLBase();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::Base*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::Base*) (soff))->~G__TReflexcLcLBase();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::Scope */
static int G__G__Reflex_106_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::Scope* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::Scope((const Reflex::ScopeName*) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) Reflex::Scope((const Reflex::ScopeName*) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Reflex::Scope[n];
       } else {
         p = new((void*) gvp) Reflex::Scope[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Reflex::Scope;
       } else {
         p = new((void*) gvp) Reflex::Scope;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::Scope* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Reflex::Scope(*(Reflex::Scope*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) Reflex::Scope(*(Reflex::Scope*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Scope*) G__getstructoffset())->operator!=(*(Reflex::Scope*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Scope*) G__getstructoffset())->operator bool());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type* pobj;
         const Reflex::Type xobj = ((const Reflex::Scope*) G__getstructoffset())->operator ::Reflex::Type();
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Base* pobj;
         const Reflex::Base xobj = ((const Reflex::Scope*) G__getstructoffset())->BaseAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::Base(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Reflex::Scope*) G__getstructoffset())->BaseSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Base_Iterator* pobj;
         const Reflex::Base_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->Base_Begin();
         pobj = new Reflex::Base_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Base_Iterator* pobj;
         const Reflex::Base_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->Base_End();
         pobj = new Reflex::Base_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Base_Iterator* pobj;
         const Reflex::Reverse_Base_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->Base_RBegin();
         pobj = new Reflex::Reverse_Base_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Base_Iterator* pobj;
         const Reflex::Reverse_Base_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->Base_REnd();
         pobj = new Reflex::Reverse_Base_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Scope* pobj;
         Reflex::Scope xobj = Reflex::Scope::ByName(*(string*) libp->para[0].ref);
         pobj = new Reflex::Scope(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->DataMemberAt((size_t) G__int(libp->para[0]), (Reflex::EMEMBERQUERY) G__int(libp->para[1]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 1:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->DataMemberAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->DataMemberByName(*(string*) libp->para[0].ref, (Reflex::EMEMBERQUERY) G__int(libp->para[1]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 1:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->DataMemberByName(*(string*) libp->para[0].ref);
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 104, (long) ((const Reflex::Scope*) G__getstructoffset())->DataMemberSize((Reflex::EMEMBERQUERY) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 104, (long) ((const Reflex::Scope*) G__getstructoffset())->DataMemberSize());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->DataMember_Begin((Reflex::EMEMBERQUERY) G__int(libp->para[0]));
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->DataMember_Begin();
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->DataMember_End((Reflex::EMEMBERQUERY) G__int(libp->para[0]));
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->DataMember_End();
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->DataMember_RBegin((Reflex::EMEMBERQUERY) G__int(libp->para[0]));
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->DataMember_RBegin();
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->DataMember_REnd((Reflex::EMEMBERQUERY) G__int(libp->para[0]));
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->DataMember_REnd();
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Scope* pobj;
         const Reflex::Scope xobj = ((const Reflex::Scope*) G__getstructoffset())->DeclaringScope();
         pobj = new Reflex::Scope(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->FunctionMemberAt((size_t) G__int(libp->para[0]), (Reflex::EMEMBERQUERY) G__int(libp->para[1]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 1:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->FunctionMemberAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->FunctionMemberByName(*(string*) libp->para[0].ref, (Reflex::EMEMBERQUERY) G__int(libp->para[1])
, (Reflex::EDELAYEDLOADSETTING) G__int(libp->para[2]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 2:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->FunctionMemberByName(*(string*) libp->para[0].ref, (Reflex::EMEMBERQUERY) G__int(libp->para[1]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 1:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->FunctionMemberByName(*(string*) libp->para[0].ref);
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->FunctionMemberByName(*(string*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, (unsigned int) G__int(libp->para[2]), (Reflex::EMEMBERQUERY) G__int(libp->para[3])
, (Reflex::EDELAYEDLOADSETTING) G__int(libp->para[4]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 4:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->FunctionMemberByName(*(string*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, (unsigned int) G__int(libp->para[2]), (Reflex::EMEMBERQUERY) G__int(libp->para[3]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 3:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->FunctionMemberByName(*(string*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, (unsigned int) G__int(libp->para[2]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 2:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->FunctionMemberByName(*(string*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref);
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->FunctionMemberByNameAndSignature(*(string*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, (unsigned int) G__int(libp->para[2]), (Reflex::EMEMBERQUERY) G__int(libp->para[3])
, (Reflex::EDELAYEDLOADSETTING) G__int(libp->para[4]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 4:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->FunctionMemberByNameAndSignature(*(string*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, (unsigned int) G__int(libp->para[2]), (Reflex::EMEMBERQUERY) G__int(libp->para[3]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 3:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->FunctionMemberByNameAndSignature(*(string*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, (unsigned int) G__int(libp->para[2]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 2:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->FunctionMemberByNameAndSignature(*(string*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref);
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 104, (long) ((const Reflex::Scope*) G__getstructoffset())->FunctionMemberSize((Reflex::EMEMBERQUERY) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 104, (long) ((const Reflex::Scope*) G__getstructoffset())->FunctionMemberSize());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->FunctionMember_Begin((Reflex::EMEMBERQUERY) G__int(libp->para[0]));
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->FunctionMember_Begin();
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->FunctionMember_End((Reflex::EMEMBERQUERY) G__int(libp->para[0]));
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->FunctionMember_End();
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->FunctionMember_RBegin((Reflex::EMEMBERQUERY) G__int(libp->para[0]));
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->FunctionMember_RBegin();
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->FunctionMember_REnd((Reflex::EMEMBERQUERY) G__int(libp->para[0]));
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->FunctionMember_REnd();
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Scope*) G__getstructoffset())->GenerateDict(*(Reflex::DictionaryGenerator*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Scope* pobj;
         Reflex::Scope xobj = Reflex::Scope::GlobalScope();
         pobj = new Reflex::Scope(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Scope*) G__getstructoffset())->HasBase(*(Reflex::Type*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 89, (long) ((const Reflex::Scope*) G__getstructoffset())->Id());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Scope*) G__getstructoffset())->IsClass());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Scope*) G__getstructoffset())->IsEnum());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Scope*) G__getstructoffset())->IsNamespace());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Scope*) G__getstructoffset())->IsPrivate());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Scope*) G__getstructoffset())->IsProtected());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Scope*) G__getstructoffset())->IsPublic());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Scope*) G__getstructoffset())->IsTemplateInstance());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Scope*) G__getstructoffset())->IsTopScope());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_42(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Scope*) G__getstructoffset())->IsUnion());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_43(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->LookupMember(*(string*) libp->para[0].ref);
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_44(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type* pobj;
         const Reflex::Type xobj = ((const Reflex::Scope*) G__getstructoffset())->LookupType(*(string*) libp->para[0].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_45(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Scope* pobj;
         const Reflex::Scope xobj = ((const Reflex::Scope*) G__getstructoffset())->LookupScope(*(string*) libp->para[0].ref);
         pobj = new Reflex::Scope(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_46(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->MemberAt((size_t) G__int(libp->para[0]), (Reflex::EMEMBERQUERY) G__int(libp->para[1]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 1:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->MemberAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_47(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->MemberByName(*(string*) libp->para[0].ref, (Reflex::EMEMBERQUERY) G__int(libp->para[1]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 1:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->MemberByName(*(string*) libp->para[0].ref);
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_48(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->MemberByName(*(string*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, (Reflex::EMEMBERQUERY) G__int(libp->para[2]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 2:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->MemberByName(*(string*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref);
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_49(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 104, (long) ((const Reflex::Scope*) G__getstructoffset())->MemberSize((Reflex::EMEMBERQUERY) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 104, (long) ((const Reflex::Scope*) G__getstructoffset())->MemberSize());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_50(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->Member_Begin((Reflex::EMEMBERQUERY) G__int(libp->para[0]));
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->Member_Begin();
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_51(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->Member_End((Reflex::EMEMBERQUERY) G__int(libp->para[0]));
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->Member_End();
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_52(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->Member_RBegin((Reflex::EMEMBERQUERY) G__int(libp->para[0]));
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->Member_RBegin();
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_53(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->Member_REnd((Reflex::EMEMBERQUERY) G__int(libp->para[0]));
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->Member_REnd();
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_54(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::MemberTemplate* pobj;
         const Reflex::MemberTemplate xobj = ((const Reflex::Scope*) G__getstructoffset())->MemberTemplateAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::MemberTemplate(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_55(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Reflex::Scope*) G__getstructoffset())->MemberTemplateSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_56(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::MemberTemplate* pobj;
         const Reflex::MemberTemplate xobj = ((const Reflex::Scope*) G__getstructoffset())->MemberTemplateByName(*(string*) libp->para[0].ref);
         pobj = new Reflex::MemberTemplate(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_57(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::MemberTemplate_Iterator* pobj;
         const Reflex::MemberTemplate_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->MemberTemplate_Begin();
         pobj = new Reflex::MemberTemplate_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_58(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::MemberTemplate_Iterator* pobj;
         const Reflex::MemberTemplate_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->MemberTemplate_End();
         pobj = new Reflex::MemberTemplate_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_59(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_MemberTemplate_Iterator* pobj;
         const Reflex::Reverse_MemberTemplate_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->MemberTemplate_RBegin();
         pobj = new Reflex::Reverse_MemberTemplate_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_60(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_MemberTemplate_Iterator* pobj;
         const Reflex::Reverse_MemberTemplate_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->MemberTemplate_REnd();
         pobj = new Reflex::Reverse_MemberTemplate_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_61(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const string* pobj;
         const string xobj = ((const Reflex::Scope*) G__getstructoffset())->Name((unsigned int) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const string* pobj;
         const string xobj = ((const Reflex::Scope*) G__getstructoffset())->Name();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_62(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const Reflex::Scope*) G__getstructoffset())->Name_c_str());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_63(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::PropertyList* pobj;
         const Reflex::PropertyList xobj = ((const Reflex::Scope*) G__getstructoffset())->Properties();
         pobj = new Reflex::PropertyList(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_64(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Scope* pobj;
         Reflex::Scope xobj = Reflex::Scope::ScopeAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::Scope(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_65(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) Reflex::Scope::ScopeSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_66(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Scope_Iterator* pobj;
         Reflex::Scope_Iterator xobj = Reflex::Scope::Scope_Begin();
         pobj = new Reflex::Scope_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_67(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Scope_Iterator* pobj;
         Reflex::Scope_Iterator xobj = Reflex::Scope::Scope_End();
         pobj = new Reflex::Scope_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_68(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Reverse_Scope_Iterator* pobj;
         Reflex::Reverse_Scope_Iterator xobj = Reflex::Scope::Scope_RBegin();
         pobj = new Reflex::Reverse_Scope_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_69(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Reverse_Scope_Iterator* pobj;
         Reflex::Reverse_Scope_Iterator xobj = Reflex::Scope::Scope_REnd();
         pobj = new Reflex::Reverse_Scope_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_70(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const Reflex::Scope*) G__getstructoffset())->ScopeType());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_71(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const Reflex::Scope*) G__getstructoffset())->ScopeTypeAsString();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_72(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Scope* pobj;
         const Reflex::Scope xobj = ((const Reflex::Scope*) G__getstructoffset())->SubScopeAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::Scope(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_73(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Reflex::Scope*) G__getstructoffset())->SubScopeLevel());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_74(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Reflex::Scope*) G__getstructoffset())->SubScopeSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_75(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Scope* pobj;
         const Reflex::Scope xobj = ((const Reflex::Scope*) G__getstructoffset())->SubScopeByName(*(string*) libp->para[0].ref);
         pobj = new Reflex::Scope(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_76(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Scope_Iterator* pobj;
         const Reflex::Scope_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->SubScope_Begin();
         pobj = new Reflex::Scope_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_77(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Scope_Iterator* pobj;
         const Reflex::Scope_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->SubScope_End();
         pobj = new Reflex::Scope_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_78(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Scope_Iterator* pobj;
         const Reflex::Reverse_Scope_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->SubScope_RBegin();
         pobj = new Reflex::Reverse_Scope_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_79(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Scope_Iterator* pobj;
         const Reflex::Reverse_Scope_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->SubScope_REnd();
         pobj = new Reflex::Reverse_Scope_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_80(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type* pobj;
         const Reflex::Type xobj = ((const Reflex::Scope*) G__getstructoffset())->SubTypeAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_81(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Reflex::Scope*) G__getstructoffset())->SubTypeSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_82(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type* pobj;
         const Reflex::Type xobj = ((const Reflex::Scope*) G__getstructoffset())->SubTypeByName(*(string*) libp->para[0].ref);
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_83(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type_Iterator* pobj;
         const Reflex::Type_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->SubType_Begin();
         pobj = new Reflex::Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_84(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type_Iterator* pobj;
         const Reflex::Type_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->SubType_End();
         pobj = new Reflex::Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_85(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Type_Iterator* pobj;
         const Reflex::Reverse_Type_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->SubType_RBegin();
         pobj = new Reflex::Reverse_Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_86(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Type_Iterator* pobj;
         const Reflex::Reverse_Type_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->SubType_REnd();
         pobj = new Reflex::Reverse_Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_87(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::TypeTemplate* pobj;
         const Reflex::TypeTemplate xobj = ((const Reflex::Scope*) G__getstructoffset())->SubTypeTemplateAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::TypeTemplate(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_88(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Reflex::Scope*) G__getstructoffset())->SubTypeTemplateSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_89(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::TypeTemplate* pobj;
         const Reflex::TypeTemplate xobj = ((const Reflex::Scope*) G__getstructoffset())->SubTypeTemplateByName(*(string*) libp->para[0].ref);
         pobj = new Reflex::TypeTemplate(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_90(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::TypeTemplate_Iterator* pobj;
         const Reflex::TypeTemplate_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->SubTypeTemplate_Begin();
         pobj = new Reflex::TypeTemplate_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_91(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::TypeTemplate_Iterator* pobj;
         const Reflex::TypeTemplate_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->SubTypeTemplate_End();
         pobj = new Reflex::TypeTemplate_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_92(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_TypeTemplate_Iterator* pobj;
         const Reflex::Reverse_TypeTemplate_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->SubTypeTemplate_RBegin();
         pobj = new Reflex::Reverse_TypeTemplate_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_93(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_TypeTemplate_Iterator* pobj;
         const Reflex::Reverse_TypeTemplate_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->SubTypeTemplate_REnd();
         pobj = new Reflex::Reverse_TypeTemplate_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_94(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type* pobj;
         const Reflex::Type xobj = ((const Reflex::Scope*) G__getstructoffset())->TemplateArgumentAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_95(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Reflex::Scope*) G__getstructoffset())->TemplateArgumentSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_96(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type_Iterator* pobj;
         const Reflex::Type_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->TemplateArgument_Begin();
         pobj = new Reflex::Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_97(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type_Iterator* pobj;
         const Reflex::Type_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->TemplateArgument_End();
         pobj = new Reflex::Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_98(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Type_Iterator* pobj;
         const Reflex::Reverse_Type_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->TemplateArgument_RBegin();
         pobj = new Reflex::Reverse_Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_99(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Type_Iterator* pobj;
         const Reflex::Reverse_Type_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->TemplateArgument_REnd();
         pobj = new Reflex::Reverse_Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_100(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::TypeTemplate* pobj;
         const Reflex::TypeTemplate xobj = ((const Reflex::Scope*) G__getstructoffset())->TemplateFamily();
         pobj = new Reflex::TypeTemplate(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_101(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Scope*) G__getstructoffset())->Unload();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_102(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Scope*) G__getstructoffset())->UpdateMembers();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_103(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Scope* pobj;
         const Reflex::Scope xobj = ((const Reflex::Scope*) G__getstructoffset())->UsingDirectiveAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::Scope(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_104(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Reflex::Scope*) G__getstructoffset())->UsingDirectiveSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_105(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Scope_Iterator* pobj;
         const Reflex::Scope_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->UsingDirective_Begin();
         pobj = new Reflex::Scope_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_106(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Scope_Iterator* pobj;
         const Reflex::Scope_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->UsingDirective_End();
         pobj = new Reflex::Scope_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_107(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Scope_Iterator* pobj;
         const Reflex::Reverse_Scope_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->UsingDirective_RBegin();
         pobj = new Reflex::Reverse_Scope_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_108(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Scope_Iterator* pobj;
         const Reflex::Reverse_Scope_Iterator xobj = ((const Reflex::Scope*) G__getstructoffset())->UsingDirective_REnd();
         pobj = new Reflex::Reverse_Scope_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_109(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      ((const Reflex::Scope*) G__getstructoffset())->AddBase(*(Reflex::Type*) libp->para[0].ref, (Reflex::OffsetFunction) G__int(libp->para[1])
, (unsigned int) G__int(libp->para[2]));
      G__setnull(result7);
      break;
   case 2:
      ((const Reflex::Scope*) G__getstructoffset())->AddBase(*(Reflex::Type*) libp->para[0].ref, (Reflex::OffsetFunction) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_110(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Scope*) G__getstructoffset())->AddBase(*(Reflex::Base*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_111(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Scope*) G__getstructoffset())->AddDataMember(*(Reflex::Member*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_112(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->AddDataMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (size_t) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3])
, (char*) G__int(libp->para[4]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 4:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->AddDataMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (size_t) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 3:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->AddDataMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (size_t) G__int(libp->para[2]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_113(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Scope*) G__getstructoffset())->AddFunctionMember(*(Reflex::Member*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_114(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 6:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->AddFunctionMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (Reflex::StubFunction) G__int(libp->para[2]), (void*) G__int(libp->para[3])
, (const char*) G__int(libp->para[4]), (unsigned int) G__int(libp->para[5]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 5:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->AddFunctionMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (Reflex::StubFunction) G__int(libp->para[2]), (void*) G__int(libp->para[3])
, (const char*) G__int(libp->para[4]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 4:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->AddFunctionMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (Reflex::StubFunction) G__int(libp->para[2]), (void*) G__int(libp->para[3]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 3:
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::Scope*) G__getstructoffset())->AddFunctionMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (Reflex::StubFunction) G__int(libp->para[2]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_115(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Scope*) G__getstructoffset())->AddMemberTemplate(*(Reflex::MemberTemplate*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_116(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Scope*) G__getstructoffset())->AddSubScope(*(Reflex::Scope*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_117(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((const Reflex::Scope*) G__getstructoffset())->AddSubScope((const char*) G__int(libp->para[0]), (Reflex::TYPE) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((const Reflex::Scope*) G__getstructoffset())->AddSubScope((const char*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_118(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Scope*) G__getstructoffset())->AddSubType(*(Reflex::Type*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_119(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      ((const Reflex::Scope*) G__getstructoffset())->AddSubType((const char*) G__int(libp->para[0]), (size_t) G__int(libp->para[1])
, (Reflex::TYPE) G__int(libp->para[2]), *(type_info*) libp->para[3].ref
, (unsigned int) G__int(libp->para[4]));
      G__setnull(result7);
      break;
   case 4:
      ((const Reflex::Scope*) G__getstructoffset())->AddSubType((const char*) G__int(libp->para[0]), (size_t) G__int(libp->para[1])
, (Reflex::TYPE) G__int(libp->para[2]), *(type_info*) libp->para[3].ref);
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_120(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Scope*) G__getstructoffset())->AddSubTypeTemplate(*(Reflex::TypeTemplate*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_121(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Scope*) G__getstructoffset())->AddUsingDirective(*(Reflex::Scope*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_122(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Scope*) G__getstructoffset())->RemoveDataMember(*(Reflex::Member*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_123(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Scope*) G__getstructoffset())->RemoveFunctionMember(*(Reflex::Member*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_124(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Scope*) G__getstructoffset())->RemoveMemberTemplate(*(Reflex::MemberTemplate*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_125(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Scope*) G__getstructoffset())->RemoveSubScope(*(Reflex::Scope*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_126(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Scope*) G__getstructoffset())->RemoveSubType(*(Reflex::Type*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_127(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Scope*) G__getstructoffset())->RemoveSubTypeTemplate(*(Reflex::TypeTemplate*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_128(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Scope*) G__getstructoffset())->RemoveUsingDirective(*(Reflex::Scope*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_129(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const Reflex::Scope*) G__getstructoffset())->ToScopeBase());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_106_0_130(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Scope& obj = Reflex::Scope::__NIRVANA__();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::Scope G__TReflexcLcLScope;
static int G__G__Reflex_106_0_131(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::Scope*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::Scope*) (soff+(sizeof(Reflex::Scope)*i)))->~G__TReflexcLcLScope();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::Scope*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::Scope*) (soff))->~G__TReflexcLcLScope();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::Object */
static int G__G__Reflex_107_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::Object* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::Object(*(Reflex::Type*) libp->para[0].ref, (void*) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) Reflex::Object(*(Reflex::Type*) libp->para[0].ref, (void*) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::Object(*(Reflex::Type*) libp->para[0].ref);
     } else {
       p = new((void*) gvp) Reflex::Object(*(Reflex::Type*) libp->para[0].ref);
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Reflex::Object[n];
       } else {
         p = new((void*) gvp) Reflex::Object[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Reflex::Object;
       } else {
         p = new((void*) gvp) Reflex::Object;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLObject));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_107_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::Object* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Reflex::Object(*(Reflex::Object*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) Reflex::Object(*(Reflex::Object*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLObject));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_107_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Object* pobj;
         Reflex::Object xobj = ((Reflex::Object*) G__getstructoffset())->operator=(*(Reflex::Object*) libp->para[0].ref);
         pobj = new Reflex::Object(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_107_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((Reflex::Object*) G__getstructoffset())->operator==(*(Reflex::Object*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_107_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((Reflex::Object*) G__getstructoffset())->operator!=(*(Reflex::Object*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_107_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Object*) G__getstructoffset())->operator bool());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_107_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 89, (long) ((const Reflex::Object*) G__getstructoffset())->Address());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_107_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Object* pobj;
         const Reflex::Object xobj = ((const Reflex::Object*) G__getstructoffset())->CastObject(*(Reflex::Type*) libp->para[0].ref);
         pobj = new Reflex::Object(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_107_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Object*) G__getstructoffset())->Destruct();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_107_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type* pobj;
         const Reflex::Type xobj = ((const Reflex::Object*) G__getstructoffset())->DynamicType();
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_107_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Object* pobj;
         const Reflex::Object xobj = ((const Reflex::Object*) G__getstructoffset())->Get(*(string*) libp->para[0].ref);
         pobj = new Reflex::Object(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_107_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      ((const Reflex::Object*) G__getstructoffset())->Invoke(*(string*) libp->para[0].ref, (Reflex::Object*) G__int(libp->para[1])
, *(vector<void*>*) libp->para[2].ref);
      G__setnull(result7);
      break;
   case 2:
      ((const Reflex::Object*) G__getstructoffset())->Invoke(*(string*) libp->para[0].ref, (Reflex::Object*) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((const Reflex::Object*) G__getstructoffset())->Invoke(*(string*) libp->para[0].ref);
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_107_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      ((const Reflex::Object*) G__getstructoffset())->Invoke(*(string*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, (Reflex::Object*) G__int(libp->para[2]), *(vector<void*>*) libp->para[3].ref);
      G__setnull(result7);
      break;
   case 3:
      ((const Reflex::Object*) G__getstructoffset())->Invoke(*(string*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref
, (Reflex::Object*) G__int(libp->para[2]));
      G__setnull(result7);
      break;
   case 2:
      ((const Reflex::Object*) G__getstructoffset())->Invoke(*(string*) libp->para[0].ref, *(Reflex::Type*) libp->para[1].ref);
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_107_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Object*) G__getstructoffset())->Set(*(string*) libp->para[0].ref, (const void*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_107_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type* pobj;
         const Reflex::Type xobj = ((const Reflex::Object*) G__getstructoffset())->TypeOf();
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::Object G__TReflexcLcLObject;
static int G__G__Reflex_107_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::Object*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::Object*) (soff+(sizeof(Reflex::Object)*i)))->~G__TReflexcLcLObject();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::Object*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::Object*) (soff))->~G__TReflexcLcLObject();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::Member */
static int G__G__Reflex_108_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::Member* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::Member((const Reflex::MemberBase*) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) Reflex::Member((const Reflex::MemberBase*) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Reflex::Member[n];
       } else {
         p = new((void*) gvp) Reflex::Member[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Reflex::Member;
       } else {
         p = new((void*) gvp) Reflex::Member;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::Member* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Reflex::Member(*(Reflex::Member*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) Reflex::Member(*(Reflex::Member*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->operator<(*(Reflex::Member*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->operator==(*(Reflex::Member*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->operator!=(*(Reflex::Member*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Member& obj = ((Reflex::Member*) G__getstructoffset())->operator=(*(Reflex::Member*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->operator bool());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Scope* pobj;
         const Reflex::Scope xobj = ((const Reflex::Member*) G__getstructoffset())->DeclaringScope();
         pobj = new Reflex::Scope(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type* pobj;
         const Reflex::Type xobj = ((const Reflex::Member*) G__getstructoffset())->DeclaringType();
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Member*) G__getstructoffset())->GenerateDict(*(Reflex::DictionaryGenerator*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Object* pobj;
         const Reflex::Object xobj = ((const Reflex::Member*) G__getstructoffset())->Get();
         pobj = new Reflex::Object(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Object* pobj;
         const Reflex::Object xobj = ((const Reflex::Member*) G__getstructoffset())->Get(*(Reflex::Object*) libp->para[0].ref);
         pobj = new Reflex::Object(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 89, (long) ((const Reflex::Member*) G__getstructoffset())->Id());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      ((const Reflex::Member*) G__getstructoffset())->Invoke(*(Reflex::Object*) libp->para[0].ref, (Reflex::Object*) G__int(libp->para[1])
, *(vector<void*>*) libp->para[2].ref);
      G__setnull(result7);
      break;
   case 2:
      ((const Reflex::Member*) G__getstructoffset())->Invoke(*(Reflex::Object*) libp->para[0].ref, (Reflex::Object*) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((const Reflex::Member*) G__getstructoffset())->Invoke((Reflex::Object*) G__int(libp->para[0]), *(vector<void*>*) libp->para[1].ref);
      G__setnull(result7);
      break;
   case 1:
      ((const Reflex::Member*) G__getstructoffset())->Invoke((Reflex::Object*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsAbstract());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsArtificial());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsAuto());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsConstructor());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsConst());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsConverter());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsCopyConstructor());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsDataMember());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsDestructor());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsExplicit());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsExtern());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsFunctionMember());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsInline());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsMutable());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsOperator());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsPrivate());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsProtected());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsPublic());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsPureVirtual());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsRegister());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsStatic());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsTemplateInstance());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsTransient());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsVirtual());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::Member*) G__getstructoffset())->IsVolatile());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const Reflex::Member*) G__getstructoffset())->MemberType());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_42(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const Reflex::Member*) G__getstructoffset())->MemberTypeAsString();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_43(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const string* pobj;
         const string xobj = ((const Reflex::Member*) G__getstructoffset())->Name((unsigned int) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const string* pobj;
         const string xobj = ((const Reflex::Member*) G__getstructoffset())->Name();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_44(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const Reflex::Member*) G__getstructoffset())->Name_c_str());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_45(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Reflex::Member*) G__getstructoffset())->Offset());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_46(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Reflex::Member*) G__getstructoffset())->InterpreterOffset((char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_47(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         char* const& obj = ((const Reflex::Member*) G__getstructoffset())->InterpreterOffset();
         result7->ref = (long) (&obj);
         G__letint(result7, 'C', (long)obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_48(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 104, (long) ((const Reflex::Member*) G__getstructoffset())->FunctionParameterSize((bool) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 104, (long) ((const Reflex::Member*) G__getstructoffset())->FunctionParameterSize());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_49(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const Reflex::Member*) G__getstructoffset())->FunctionParameterDefaultAt((size_t) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_50(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::StdString_Iterator* pobj;
         const Reflex::StdString_Iterator xobj = ((const Reflex::Member*) G__getstructoffset())->FunctionParameterDefault_Begin();
         pobj = new Reflex::StdString_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_51(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::StdString_Iterator* pobj;
         const Reflex::StdString_Iterator xobj = ((const Reflex::Member*) G__getstructoffset())->FunctionParameterDefault_End();
         pobj = new Reflex::StdString_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_52(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_StdString_Iterator* pobj;
         const Reflex::Reverse_StdString_Iterator xobj = ((const Reflex::Member*) G__getstructoffset())->FunctionParameterDefault_RBegin();
         pobj = new Reflex::Reverse_StdString_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_53(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_StdString_Iterator* pobj;
         const Reflex::Reverse_StdString_Iterator xobj = ((const Reflex::Member*) G__getstructoffset())->FunctionParameterDefault_REnd();
         pobj = new Reflex::Reverse_StdString_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_54(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const Reflex::Member*) G__getstructoffset())->FunctionParameterNameAt((size_t) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_55(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::StdString_Iterator* pobj;
         const Reflex::StdString_Iterator xobj = ((const Reflex::Member*) G__getstructoffset())->FunctionParameterName_Begin();
         pobj = new Reflex::StdString_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_56(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::StdString_Iterator* pobj;
         const Reflex::StdString_Iterator xobj = ((const Reflex::Member*) G__getstructoffset())->FunctionParameterName_End();
         pobj = new Reflex::StdString_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_57(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_StdString_Iterator* pobj;
         const Reflex::Reverse_StdString_Iterator xobj = ((const Reflex::Member*) G__getstructoffset())->FunctionParameterName_RBegin();
         pobj = new Reflex::Reverse_StdString_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_58(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_StdString_Iterator* pobj;
         const Reflex::Reverse_StdString_Iterator xobj = ((const Reflex::Member*) G__getstructoffset())->FunctionParameterName_REnd();
         pobj = new Reflex::Reverse_StdString_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_59(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::PropertyList* pobj;
         const Reflex::PropertyList xobj = ((const Reflex::Member*) G__getstructoffset())->Properties();
         pobj = new Reflex::PropertyList(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_60(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Member*) G__getstructoffset())->Set(*(Reflex::Object*) libp->para[0].ref, (const void*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_61(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::Member*) G__getstructoffset())->SetScope(*(Reflex::Scope*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_62(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 89, (long) ((const Reflex::Member*) G__getstructoffset())->Stubcontext());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_63(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 89, (long) ((const Reflex::Member*) G__getstructoffset())->Stubfunction());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_64(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type* pobj;
         const Reflex::Type xobj = ((const Reflex::Member*) G__getstructoffset())->TemplateArgumentAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_65(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Reflex::Member*) G__getstructoffset())->TemplateArgumentSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_66(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type_Iterator* pobj;
         const Reflex::Type_Iterator xobj = ((const Reflex::Member*) G__getstructoffset())->TemplateArgument_Begin();
         pobj = new Reflex::Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_67(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type_Iterator* pobj;
         const Reflex::Type_Iterator xobj = ((const Reflex::Member*) G__getstructoffset())->TemplateArgument_End();
         pobj = new Reflex::Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_68(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Type_Iterator* pobj;
         const Reflex::Reverse_Type_Iterator xobj = ((const Reflex::Member*) G__getstructoffset())->TemplateArgument_RBegin();
         pobj = new Reflex::Reverse_Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_69(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Type_Iterator* pobj;
         const Reflex::Reverse_Type_Iterator xobj = ((const Reflex::Member*) G__getstructoffset())->TemplateArgument_REnd();
         pobj = new Reflex::Reverse_Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_70(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::MemberTemplate* pobj;
         const Reflex::MemberTemplate xobj = ((const Reflex::Member*) G__getstructoffset())->TemplateFamily();
         pobj = new Reflex::MemberTemplate(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_71(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const Reflex::Member*) G__getstructoffset())->ToMemberBase());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_72(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type* pobj;
         const Reflex::Type xobj = ((const Reflex::Member*) G__getstructoffset())->TypeOf();
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_108_0_73(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Reflex::Member*) G__getstructoffset())->UpdateFunctionParameterNames((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::Member G__TReflexcLcLMember;
static int G__G__Reflex_108_0_75(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::Member*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::Member*) (soff+(sizeof(Reflex::Member)*i)))->~G__TReflexcLcLMember();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::Member*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::Member*) (soff))->~G__TReflexcLcLMember();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::TypeTemplate */
static int G__G__Reflex_110_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::TypeTemplate* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::TypeTemplate((const Reflex::TypeTemplateName*) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) Reflex::TypeTemplate((const Reflex::TypeTemplateName*) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Reflex::TypeTemplate[n];
       } else {
         p = new((void*) gvp) Reflex::TypeTemplate[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Reflex::TypeTemplate;
       } else {
         p = new((void*) gvp) Reflex::TypeTemplate;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypeTemplate));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::TypeTemplate* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Reflex::TypeTemplate(*(Reflex::TypeTemplate*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) Reflex::TypeTemplate(*(Reflex::TypeTemplate*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypeTemplate));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::TypeTemplate*) G__getstructoffset())->operator bool());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::TypeTemplate*) G__getstructoffset())->operator==(*(Reflex::TypeTemplate*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      {
         Reflex::TypeTemplate* pobj;
         Reflex::TypeTemplate xobj = Reflex::TypeTemplate::ByName(*(string*) libp->para[0].ref, (size_t) G__int(libp->para[1]));
         pobj = new Reflex::TypeTemplate(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 1:
      {
         Reflex::TypeTemplate* pobj;
         Reflex::TypeTemplate xobj = Reflex::TypeTemplate::ByName(*(string*) libp->para[0].ref);
         pobj = new Reflex::TypeTemplate(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 89, (long) ((const Reflex::TypeTemplate*) G__getstructoffset())->Id());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const string* pobj;
         const string xobj = ((const Reflex::TypeTemplate*) G__getstructoffset())->Name((unsigned int) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const string* pobj;
         const string xobj = ((const Reflex::TypeTemplate*) G__getstructoffset())->Name();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type_Iterator* pobj;
         const Reflex::Type_Iterator xobj = ((const Reflex::TypeTemplate*) G__getstructoffset())->TemplateInstance_Begin();
         pobj = new Reflex::Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type_Iterator* pobj;
         const Reflex::Type_Iterator xobj = ((const Reflex::TypeTemplate*) G__getstructoffset())->TemplateInstance_End();
         pobj = new Reflex::Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Type_Iterator* pobj;
         const Reflex::Reverse_Type_Iterator xobj = ((const Reflex::TypeTemplate*) G__getstructoffset())->TemplateInstance_RBegin();
         pobj = new Reflex::Reverse_Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Type_Iterator* pobj;
         const Reflex::Reverse_Type_Iterator xobj = ((const Reflex::TypeTemplate*) G__getstructoffset())->TemplateInstance_REnd();
         pobj = new Reflex::Reverse_Type_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type* pobj;
         const Reflex::Type xobj = ((const Reflex::TypeTemplate*) G__getstructoffset())->TemplateInstanceAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Reflex::TypeTemplate*) G__getstructoffset())->TemplateInstanceSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const Reflex::TypeTemplate*) G__getstructoffset())->TemplateParameterDefaultAt((size_t) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::StdString_Iterator* pobj;
         const Reflex::StdString_Iterator xobj = ((const Reflex::TypeTemplate*) G__getstructoffset())->TemplateParameterDefault_Begin();
         pobj = new Reflex::StdString_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::StdString_Iterator* pobj;
         const Reflex::StdString_Iterator xobj = ((const Reflex::TypeTemplate*) G__getstructoffset())->TemplateParameterDefault_End();
         pobj = new Reflex::StdString_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_StdString_Iterator* pobj;
         const Reflex::Reverse_StdString_Iterator xobj = ((const Reflex::TypeTemplate*) G__getstructoffset())->TemplateParameterDefault_RBegin();
         pobj = new Reflex::Reverse_StdString_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_StdString_Iterator* pobj;
         const Reflex::Reverse_StdString_Iterator xobj = ((const Reflex::TypeTemplate*) G__getstructoffset())->TemplateParameterDefault_REnd();
         pobj = new Reflex::Reverse_StdString_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const Reflex::TypeTemplate*) G__getstructoffset())->TemplateParameterNameAt((size_t) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::StdString_Iterator* pobj;
         const Reflex::StdString_Iterator xobj = ((const Reflex::TypeTemplate*) G__getstructoffset())->TemplateParameterName_Begin();
         pobj = new Reflex::StdString_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::StdString_Iterator* pobj;
         const Reflex::StdString_Iterator xobj = ((const Reflex::TypeTemplate*) G__getstructoffset())->TemplateParameterName_End();
         pobj = new Reflex::StdString_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_StdString_Iterator* pobj;
         const Reflex::Reverse_StdString_Iterator xobj = ((const Reflex::TypeTemplate*) G__getstructoffset())->TemplateParameterName_RBegin();
         pobj = new Reflex::Reverse_StdString_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_StdString_Iterator* pobj;
         const Reflex::Reverse_StdString_Iterator xobj = ((const Reflex::TypeTemplate*) G__getstructoffset())->TemplateParameterName_REnd();
         pobj = new Reflex::Reverse_StdString_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Reflex::TypeTemplate*) G__getstructoffset())->TemplateParameterSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::TypeTemplate* pobj;
         Reflex::TypeTemplate xobj = Reflex::TypeTemplate::TypeTemplateAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::TypeTemplate(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) Reflex::TypeTemplate::TypeTemplateSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::TypeTemplate_Iterator* pobj;
         Reflex::TypeTemplate_Iterator xobj = Reflex::TypeTemplate::TypeTemplate_Begin();
         pobj = new Reflex::TypeTemplate_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::TypeTemplate_Iterator* pobj;
         Reflex::TypeTemplate_Iterator xobj = Reflex::TypeTemplate::TypeTemplate_End();
         pobj = new Reflex::TypeTemplate_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Reverse_TypeTemplate_Iterator* pobj;
         Reflex::Reverse_TypeTemplate_Iterator xobj = Reflex::TypeTemplate::TypeTemplate_RBegin();
         pobj = new Reflex::Reverse_TypeTemplate_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Reverse_TypeTemplate_Iterator* pobj;
         Reflex::Reverse_TypeTemplate_Iterator xobj = Reflex::TypeTemplate::TypeTemplate_REnd();
         pobj = new Reflex::Reverse_TypeTemplate_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::TypeTemplate*) G__getstructoffset())->Unload();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_110_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::TypeTemplate*) G__getstructoffset())->AddTemplateInstance(*(Reflex::Type*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::TypeTemplate G__TReflexcLcLTypeTemplate;
static int G__G__Reflex_110_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::TypeTemplate*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::TypeTemplate*) (soff+(sizeof(Reflex::TypeTemplate)*i)))->~G__TReflexcLcLTypeTemplate();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::TypeTemplate*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::TypeTemplate*) (soff))->~G__TReflexcLcLTypeTemplate();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::MemberTemplate */
static int G__G__Reflex_111_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::MemberTemplate* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::MemberTemplate((const Reflex::MemberTemplateName*) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) Reflex::MemberTemplate((const Reflex::MemberTemplateName*) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Reflex::MemberTemplate[n];
       } else {
         p = new((void*) gvp) Reflex::MemberTemplate[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new Reflex::MemberTemplate;
       } else {
         p = new((void*) gvp) Reflex::MemberTemplate;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMemberTemplate));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::MemberTemplate* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Reflex::MemberTemplate(*(Reflex::MemberTemplate*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) Reflex::MemberTemplate(*(Reflex::MemberTemplate*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMemberTemplate));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::MemberTemplate*) G__getstructoffset())->operator bool());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const Reflex::MemberTemplate*) G__getstructoffset())->operator==(*(Reflex::MemberTemplate*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      {
         Reflex::MemberTemplate* pobj;
         Reflex::MemberTemplate xobj = Reflex::MemberTemplate::ByName(*(string*) libp->para[0].ref, (size_t) G__int(libp->para[1]));
         pobj = new Reflex::MemberTemplate(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 1:
      {
         Reflex::MemberTemplate* pobj;
         Reflex::MemberTemplate xobj = Reflex::MemberTemplate::ByName(*(string*) libp->para[0].ref);
         pobj = new Reflex::MemberTemplate(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 89, (long) ((const Reflex::MemberTemplate*) G__getstructoffset())->Id());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::MemberTemplate* pobj;
         Reflex::MemberTemplate xobj = Reflex::MemberTemplate::MemberTemplateAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::MemberTemplate(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) Reflex::MemberTemplate::MemberTemplateSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::MemberTemplate_Iterator* pobj;
         Reflex::MemberTemplate_Iterator xobj = Reflex::MemberTemplate::MemberTemplate_Begin();
         pobj = new Reflex::MemberTemplate_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::MemberTemplate_Iterator* pobj;
         Reflex::MemberTemplate_Iterator xobj = Reflex::MemberTemplate::MemberTemplate_End();
         pobj = new Reflex::MemberTemplate_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Reverse_MemberTemplate_Iterator* pobj;
         Reflex::Reverse_MemberTemplate_Iterator xobj = Reflex::MemberTemplate::MemberTemplate_RBegin();
         pobj = new Reflex::Reverse_MemberTemplate_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Reverse_MemberTemplate_Iterator* pobj;
         Reflex::Reverse_MemberTemplate_Iterator xobj = Reflex::MemberTemplate::MemberTemplate_REnd();
         pobj = new Reflex::Reverse_MemberTemplate_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      {
         const string* pobj;
         const string xobj = ((const Reflex::MemberTemplate*) G__getstructoffset())->Name((unsigned int) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 0:
      {
         const string* pobj;
         const string xobj = ((const Reflex::MemberTemplate*) G__getstructoffset())->Name();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::MemberTemplate*) G__getstructoffset())->TemplateInstance_Begin();
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Member_Iterator* pobj;
         const Reflex::Member_Iterator xobj = ((const Reflex::MemberTemplate*) G__getstructoffset())->TemplateInstance_End();
         pobj = new Reflex::Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::MemberTemplate*) G__getstructoffset())->TemplateInstance_RBegin();
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_Member_Iterator* pobj;
         const Reflex::Reverse_Member_Iterator xobj = ((const Reflex::MemberTemplate*) G__getstructoffset())->TemplateInstance_REnd();
         pobj = new Reflex::Reverse_Member_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Member* pobj;
         const Reflex::Member xobj = ((const Reflex::MemberTemplate*) G__getstructoffset())->TemplateInstanceAt((size_t) G__int(libp->para[0]));
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Reflex::MemberTemplate*) G__getstructoffset())->TemplateInstanceSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const Reflex::MemberTemplate*) G__getstructoffset())->TemplateParameterDefaultAt((size_t) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::StdString_Iterator* pobj;
         const Reflex::StdString_Iterator xobj = ((const Reflex::MemberTemplate*) G__getstructoffset())->TemplateParameterDefault_Begin();
         pobj = new Reflex::StdString_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::StdString_Iterator* pobj;
         const Reflex::StdString_Iterator xobj = ((const Reflex::MemberTemplate*) G__getstructoffset())->TemplateParameterDefault_End();
         pobj = new Reflex::StdString_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_StdString_Iterator* pobj;
         const Reflex::Reverse_StdString_Iterator xobj = ((const Reflex::MemberTemplate*) G__getstructoffset())->TemplateParameterDefault_RBegin();
         pobj = new Reflex::Reverse_StdString_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_StdString_Iterator* pobj;
         const Reflex::Reverse_StdString_Iterator xobj = ((const Reflex::MemberTemplate*) G__getstructoffset())->TemplateParameterDefault_REnd();
         pobj = new Reflex::Reverse_StdString_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const Reflex::MemberTemplate*) G__getstructoffset())->TemplateParameterNameAt((size_t) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::StdString_Iterator* pobj;
         const Reflex::StdString_Iterator xobj = ((const Reflex::MemberTemplate*) G__getstructoffset())->TemplateParameterName_Begin();
         pobj = new Reflex::StdString_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::StdString_Iterator* pobj;
         const Reflex::StdString_Iterator xobj = ((const Reflex::MemberTemplate*) G__getstructoffset())->TemplateParameterName_End();
         pobj = new Reflex::StdString_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_StdString_Iterator* pobj;
         const Reflex::Reverse_StdString_Iterator xobj = ((const Reflex::MemberTemplate*) G__getstructoffset())->TemplateParameterName_RBegin();
         pobj = new Reflex::Reverse_StdString_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Reverse_StdString_Iterator* pobj;
         const Reflex::Reverse_StdString_Iterator xobj = ((const Reflex::MemberTemplate*) G__getstructoffset())->TemplateParameterName_REnd();
         pobj = new Reflex::Reverse_StdString_Iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const Reflex::MemberTemplate*) G__getstructoffset())->TemplateParameterSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_111_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const Reflex::MemberTemplate*) G__getstructoffset())->AddTemplateInstance(*(Reflex::Member*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::MemberTemplate G__TReflexcLcLMemberTemplate;
static int G__G__Reflex_111_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::MemberTemplate*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::MemberTemplate*) (soff+(sizeof(Reflex::MemberTemplate)*i)))->~G__TReflexcLcLMemberTemplate();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::MemberTemplate*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::MemberTemplate*) (soff))->~G__TReflexcLcLMemberTemplate();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::Dummy */
static int G__G__Reflex_144_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::StdString_Cont_Type_t& obj = Reflex::Dummy::StdStringCont();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_144_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type_Cont_Type_t& obj = Reflex::Dummy::TypeCont();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_144_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Base_Cont_Type_t& obj = Reflex::Dummy::BaseCont();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_144_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Scope_Cont_Type_t& obj = Reflex::Dummy::ScopeCont();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_144_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Object_Cont_Type_t& obj = Reflex::Dummy::ObjectCont();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_144_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Member_Cont_Type_t& obj = Reflex::Dummy::MemberCont();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_144_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::TypeTemplate_Cont_Type_t& obj = Reflex::Dummy::TypeTemplateCont();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_144_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::MemberTemplate_Cont_Type_t& obj = Reflex::Dummy::MemberTemplateCont();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_144_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Any& obj = Reflex::Dummy::Any();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_144_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Object& obj = Reflex::Dummy::Object();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_144_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Type& obj = Reflex::Dummy::Type();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_144_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::TypeTemplate& obj = Reflex::Dummy::TypeTemplate();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_144_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Base& obj = Reflex::Dummy::Base();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_144_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::PropertyList& obj = Reflex::Dummy::PropertyList();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_144_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Member& obj = Reflex::Dummy::Member();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_144_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::MemberTemplate& obj = Reflex::Dummy::MemberTemplate();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_144_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::Scope& obj = Reflex::Dummy::Scope();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::Instance */
static int G__G__Reflex_145_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::Instance* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::Instance[n];
     } else {
       p = new((void*) gvp) Reflex::Instance[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::Instance;
     } else {
       p = new((void*) gvp) Reflex::Instance;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLInstance));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_145_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) Reflex::Instance::HasShutdown());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_145_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::Instance* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::Instance(*(Reflex::Instance*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLInstance));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::Instance G__TReflexcLcLInstance;
static int G__G__Reflex_145_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::Instance*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::Instance*) (soff+(sizeof(Reflex::Instance)*i)))->~G__TReflexcLcLInstance();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::Instance*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::Instance*) (soff))->~G__TReflexcLcLInstance();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_145_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::Instance* dest = (Reflex::Instance*) G__getstructoffset();
   *dest = *(Reflex::Instance*) libp->para[0].ref;
   const Reflex::Instance& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::NullType */
// automatic default constructor
static int G__G__Reflex_152_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::NullType *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::NullType[n];
     } else {
       p = new((void*) gvp) Reflex::NullType[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::NullType;
     } else {
       p = new((void*) gvp) Reflex::NullType;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNullType));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_152_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::NullType* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::NullType(*(Reflex::NullType*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNullType));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::NullType G__TReflexcLcLNullType;
static int G__G__Reflex_152_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::NullType*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::NullType*) (soff+(sizeof(Reflex::NullType)*i)))->~G__TReflexcLcLNullType();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::NullType*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::NullType*) (soff))->~G__TReflexcLcLNullType();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_152_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::NullType* dest = (Reflex::NullType*) G__getstructoffset();
   const Reflex::NullType& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::UnknownType */
// automatic default constructor
static int G__G__Reflex_153_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::UnknownType *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::UnknownType[n];
     } else {
       p = new((void*) gvp) Reflex::UnknownType[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::UnknownType;
     } else {
       p = new((void*) gvp) Reflex::UnknownType;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnknownType));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_153_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::UnknownType* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::UnknownType(*(Reflex::UnknownType*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnknownType));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::UnknownType G__TReflexcLcLUnknownType;
static int G__G__Reflex_153_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::UnknownType*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::UnknownType*) (soff+(sizeof(Reflex::UnknownType)*i)))->~G__TReflexcLcLUnknownType();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::UnknownType*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::UnknownType*) (soff))->~G__TReflexcLcLUnknownType();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_153_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::UnknownType* dest = (Reflex::UnknownType*) G__getstructoffset();
   const Reflex::UnknownType& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::ProtectedClass */
// automatic default constructor
static int G__G__Reflex_154_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::ProtectedClass *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::ProtectedClass[n];
     } else {
       p = new((void*) gvp) Reflex::ProtectedClass[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::ProtectedClass;
     } else {
       p = new((void*) gvp) Reflex::ProtectedClass;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedClass));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_154_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::ProtectedClass* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::ProtectedClass(*(Reflex::ProtectedClass*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedClass));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::ProtectedClass G__TReflexcLcLProtectedClass;
static int G__G__Reflex_154_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::ProtectedClass*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::ProtectedClass*) (soff+(sizeof(Reflex::ProtectedClass)*i)))->~G__TReflexcLcLProtectedClass();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::ProtectedClass*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::ProtectedClass*) (soff))->~G__TReflexcLcLProtectedClass();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_154_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::ProtectedClass* dest = (Reflex::ProtectedClass*) G__getstructoffset();
   const Reflex::ProtectedClass& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::ProtectedEnum */
// automatic default constructor
static int G__G__Reflex_155_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::ProtectedEnum *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::ProtectedEnum[n];
     } else {
       p = new((void*) gvp) Reflex::ProtectedEnum[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::ProtectedEnum;
     } else {
       p = new((void*) gvp) Reflex::ProtectedEnum;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedEnum));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_155_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::ProtectedEnum* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::ProtectedEnum(*(Reflex::ProtectedEnum*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedEnum));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::ProtectedEnum G__TReflexcLcLProtectedEnum;
static int G__G__Reflex_155_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::ProtectedEnum*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::ProtectedEnum*) (soff+(sizeof(Reflex::ProtectedEnum)*i)))->~G__TReflexcLcLProtectedEnum();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::ProtectedEnum*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::ProtectedEnum*) (soff))->~G__TReflexcLcLProtectedEnum();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_155_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::ProtectedEnum* dest = (Reflex::ProtectedEnum*) G__getstructoffset();
   const Reflex::ProtectedEnum& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::ProtectedStruct */
// automatic default constructor
static int G__G__Reflex_156_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::ProtectedStruct *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::ProtectedStruct[n];
     } else {
       p = new((void*) gvp) Reflex::ProtectedStruct[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::ProtectedStruct;
     } else {
       p = new((void*) gvp) Reflex::ProtectedStruct;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedStruct));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_156_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::ProtectedStruct* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::ProtectedStruct(*(Reflex::ProtectedStruct*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedStruct));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::ProtectedStruct G__TReflexcLcLProtectedStruct;
static int G__G__Reflex_156_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::ProtectedStruct*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::ProtectedStruct*) (soff+(sizeof(Reflex::ProtectedStruct)*i)))->~G__TReflexcLcLProtectedStruct();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::ProtectedStruct*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::ProtectedStruct*) (soff))->~G__TReflexcLcLProtectedStruct();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_156_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::ProtectedStruct* dest = (Reflex::ProtectedStruct*) G__getstructoffset();
   const Reflex::ProtectedStruct& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::ProtectedUnion */
// automatic default constructor
static int G__G__Reflex_157_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::ProtectedUnion *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::ProtectedUnion[n];
     } else {
       p = new((void*) gvp) Reflex::ProtectedUnion[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::ProtectedUnion;
     } else {
       p = new((void*) gvp) Reflex::ProtectedUnion;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedUnion));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_157_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::ProtectedUnion* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::ProtectedUnion(*(Reflex::ProtectedUnion*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedUnion));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::ProtectedUnion G__TReflexcLcLProtectedUnion;
static int G__G__Reflex_157_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::ProtectedUnion*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::ProtectedUnion*) (soff+(sizeof(Reflex::ProtectedUnion)*i)))->~G__TReflexcLcLProtectedUnion();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::ProtectedUnion*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::ProtectedUnion*) (soff))->~G__TReflexcLcLProtectedUnion();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_157_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::ProtectedUnion* dest = (Reflex::ProtectedUnion*) G__getstructoffset();
   const Reflex::ProtectedUnion& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::PrivateClass */
// automatic default constructor
static int G__G__Reflex_158_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::PrivateClass *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::PrivateClass[n];
     } else {
       p = new((void*) gvp) Reflex::PrivateClass[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::PrivateClass;
     } else {
       p = new((void*) gvp) Reflex::PrivateClass;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateClass));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_158_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::PrivateClass* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::PrivateClass(*(Reflex::PrivateClass*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateClass));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::PrivateClass G__TReflexcLcLPrivateClass;
static int G__G__Reflex_158_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::PrivateClass*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::PrivateClass*) (soff+(sizeof(Reflex::PrivateClass)*i)))->~G__TReflexcLcLPrivateClass();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::PrivateClass*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::PrivateClass*) (soff))->~G__TReflexcLcLPrivateClass();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_158_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::PrivateClass* dest = (Reflex::PrivateClass*) G__getstructoffset();
   const Reflex::PrivateClass& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::PrivateEnum */
// automatic default constructor
static int G__G__Reflex_159_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::PrivateEnum *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::PrivateEnum[n];
     } else {
       p = new((void*) gvp) Reflex::PrivateEnum[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::PrivateEnum;
     } else {
       p = new((void*) gvp) Reflex::PrivateEnum;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateEnum));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_159_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::PrivateEnum* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::PrivateEnum(*(Reflex::PrivateEnum*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateEnum));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::PrivateEnum G__TReflexcLcLPrivateEnum;
static int G__G__Reflex_159_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::PrivateEnum*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::PrivateEnum*) (soff+(sizeof(Reflex::PrivateEnum)*i)))->~G__TReflexcLcLPrivateEnum();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::PrivateEnum*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::PrivateEnum*) (soff))->~G__TReflexcLcLPrivateEnum();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_159_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::PrivateEnum* dest = (Reflex::PrivateEnum*) G__getstructoffset();
   const Reflex::PrivateEnum& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::PrivateStruct */
// automatic default constructor
static int G__G__Reflex_160_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::PrivateStruct *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::PrivateStruct[n];
     } else {
       p = new((void*) gvp) Reflex::PrivateStruct[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::PrivateStruct;
     } else {
       p = new((void*) gvp) Reflex::PrivateStruct;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateStruct));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_160_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::PrivateStruct* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::PrivateStruct(*(Reflex::PrivateStruct*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateStruct));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::PrivateStruct G__TReflexcLcLPrivateStruct;
static int G__G__Reflex_160_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::PrivateStruct*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::PrivateStruct*) (soff+(sizeof(Reflex::PrivateStruct)*i)))->~G__TReflexcLcLPrivateStruct();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::PrivateStruct*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::PrivateStruct*) (soff))->~G__TReflexcLcLPrivateStruct();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_160_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::PrivateStruct* dest = (Reflex::PrivateStruct*) G__getstructoffset();
   const Reflex::PrivateStruct& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::PrivateUnion */
// automatic default constructor
static int G__G__Reflex_161_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::PrivateUnion *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::PrivateUnion[n];
     } else {
       p = new((void*) gvp) Reflex::PrivateUnion[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::PrivateUnion;
     } else {
       p = new((void*) gvp) Reflex::PrivateUnion;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateUnion));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_161_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::PrivateUnion* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::PrivateUnion(*(Reflex::PrivateUnion*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateUnion));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::PrivateUnion G__TReflexcLcLPrivateUnion;
static int G__G__Reflex_161_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::PrivateUnion*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::PrivateUnion*) (soff+(sizeof(Reflex::PrivateUnion)*i)))->~G__TReflexcLcLPrivateUnion();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::PrivateUnion*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::PrivateUnion*) (soff))->~G__TReflexcLcLPrivateUnion();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_161_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::PrivateUnion* dest = (Reflex::PrivateUnion*) G__getstructoffset();
   const Reflex::PrivateUnion& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::UnnamedClass */
// automatic default constructor
static int G__G__Reflex_162_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::UnnamedClass *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::UnnamedClass[n];
     } else {
       p = new((void*) gvp) Reflex::UnnamedClass[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::UnnamedClass;
     } else {
       p = new((void*) gvp) Reflex::UnnamedClass;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedClass));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_162_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::UnnamedClass* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::UnnamedClass(*(Reflex::UnnamedClass*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedClass));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::UnnamedClass G__TReflexcLcLUnnamedClass;
static int G__G__Reflex_162_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::UnnamedClass*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::UnnamedClass*) (soff+(sizeof(Reflex::UnnamedClass)*i)))->~G__TReflexcLcLUnnamedClass();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::UnnamedClass*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::UnnamedClass*) (soff))->~G__TReflexcLcLUnnamedClass();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_162_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::UnnamedClass* dest = (Reflex::UnnamedClass*) G__getstructoffset();
   const Reflex::UnnamedClass& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::UnnamedEnum */
// automatic default constructor
static int G__G__Reflex_163_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::UnnamedEnum *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::UnnamedEnum[n];
     } else {
       p = new((void*) gvp) Reflex::UnnamedEnum[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::UnnamedEnum;
     } else {
       p = new((void*) gvp) Reflex::UnnamedEnum;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedEnum));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_163_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::UnnamedEnum* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::UnnamedEnum(*(Reflex::UnnamedEnum*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedEnum));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::UnnamedEnum G__TReflexcLcLUnnamedEnum;
static int G__G__Reflex_163_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::UnnamedEnum*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::UnnamedEnum*) (soff+(sizeof(Reflex::UnnamedEnum)*i)))->~G__TReflexcLcLUnnamedEnum();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::UnnamedEnum*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::UnnamedEnum*) (soff))->~G__TReflexcLcLUnnamedEnum();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_163_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::UnnamedEnum* dest = (Reflex::UnnamedEnum*) G__getstructoffset();
   const Reflex::UnnamedEnum& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::UnnamedNamespace */
// automatic default constructor
static int G__G__Reflex_164_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::UnnamedNamespace *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::UnnamedNamespace[n];
     } else {
       p = new((void*) gvp) Reflex::UnnamedNamespace[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::UnnamedNamespace;
     } else {
       p = new((void*) gvp) Reflex::UnnamedNamespace;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedNamespace));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_164_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::UnnamedNamespace* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::UnnamedNamespace(*(Reflex::UnnamedNamespace*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedNamespace));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::UnnamedNamespace G__TReflexcLcLUnnamedNamespace;
static int G__G__Reflex_164_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::UnnamedNamespace*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::UnnamedNamespace*) (soff+(sizeof(Reflex::UnnamedNamespace)*i)))->~G__TReflexcLcLUnnamedNamespace();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::UnnamedNamespace*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::UnnamedNamespace*) (soff))->~G__TReflexcLcLUnnamedNamespace();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_164_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::UnnamedNamespace* dest = (Reflex::UnnamedNamespace*) G__getstructoffset();
   const Reflex::UnnamedNamespace& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::UnnamedStruct */
// automatic default constructor
static int G__G__Reflex_165_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::UnnamedStruct *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::UnnamedStruct[n];
     } else {
       p = new((void*) gvp) Reflex::UnnamedStruct[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::UnnamedStruct;
     } else {
       p = new((void*) gvp) Reflex::UnnamedStruct;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedStruct));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_165_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::UnnamedStruct* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::UnnamedStruct(*(Reflex::UnnamedStruct*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedStruct));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::UnnamedStruct G__TReflexcLcLUnnamedStruct;
static int G__G__Reflex_165_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::UnnamedStruct*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::UnnamedStruct*) (soff+(sizeof(Reflex::UnnamedStruct)*i)))->~G__TReflexcLcLUnnamedStruct();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::UnnamedStruct*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::UnnamedStruct*) (soff))->~G__TReflexcLcLUnnamedStruct();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_165_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::UnnamedStruct* dest = (Reflex::UnnamedStruct*) G__getstructoffset();
   const Reflex::UnnamedStruct& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::UnnamedUnion */
// automatic default constructor
static int G__G__Reflex_166_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::UnnamedUnion *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::UnnamedUnion[n];
     } else {
       p = new((void*) gvp) Reflex::UnnamedUnion[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::UnnamedUnion;
     } else {
       p = new((void*) gvp) Reflex::UnnamedUnion;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedUnion));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_166_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::UnnamedUnion* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::UnnamedUnion(*(Reflex::UnnamedUnion*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedUnion));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::UnnamedUnion G__TReflexcLcLUnnamedUnion;
static int G__G__Reflex_166_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::UnnamedUnion*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::UnnamedUnion*) (soff+(sizeof(Reflex::UnnamedUnion)*i)))->~G__TReflexcLcLUnnamedUnion();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::UnnamedUnion*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::UnnamedUnion*) (soff))->~G__TReflexcLcLUnnamedUnion();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_166_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::UnnamedUnion* dest = (Reflex::UnnamedUnion*) G__getstructoffset();
   const Reflex::UnnamedUnion& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::RuntimeError */
static int G__G__Reflex_167_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::RuntimeError* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Reflex::RuntimeError(*(string*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) Reflex::RuntimeError(*(string*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLRuntimeError));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_167_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const Reflex::RuntimeError*) G__getstructoffset())->what());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_167_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::RuntimeError* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::RuntimeError(*(Reflex::RuntimeError*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLRuntimeError));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::RuntimeError G__TReflexcLcLRuntimeError;
static int G__G__Reflex_167_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::RuntimeError*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::RuntimeError*) (soff+(sizeof(Reflex::RuntimeError)*i)))->~G__TReflexcLcLRuntimeError();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::RuntimeError*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::RuntimeError*) (soff))->~G__TReflexcLcLRuntimeError();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_167_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::RuntimeError* dest = (Reflex::RuntimeError*) G__getstructoffset();
   *dest = *(Reflex::RuntimeError*) libp->para[0].ref;
   const Reflex::RuntimeError& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::ICallback */
static int G__G__Reflex_206_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Reflex::ICallback*) G__getstructoffset())->operator()(*(Reflex::Type*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_206_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Reflex::ICallback*) G__getstructoffset())->operator()(*(Reflex::Member*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::ICallback G__TReflexcLcLICallback;
static int G__G__Reflex_206_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::ICallback*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::ICallback*) (soff+(sizeof(Reflex::ICallback)*i)))->~G__TReflexcLcLICallback();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::ICallback*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::ICallback*) (soff))->~G__TReflexcLcLICallback();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_206_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::ICallback* dest = (Reflex::ICallback*) G__getstructoffset();
   *dest = *(Reflex::ICallback*) libp->para[0].ref;
   const Reflex::ICallback& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::Tools */
static int G__G__Reflex_211_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) Reflex::Tools::FundamentalType(*(Reflex::Type*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_211_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         string* pobj;
         string xobj = Reflex::Tools::Demangle(*(type_info*) libp->para[0].ref);
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_211_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      Reflex::Tools::StringSplit(*(vector<std::string>*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref);
      G__setnull(result7);
      break;
   case 2:
      Reflex::Tools::StringSplit(*(vector<std::string>*) libp->para[0].ref, *(string*) libp->para[1].ref);
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_211_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      Reflex::Tools::StringSplitPair(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref, *(string*) libp->para[3].ref);
      G__setnull(result7);
      break;
   case 3:
      Reflex::Tools::StringSplitPair(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref);
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_211_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      Reflex::Tools::StringStrip(*(string*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_211_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         string* pobj;
         string xobj = Reflex::Tools::StringVec2String(*(vector<std::string>*) libp->para[0].ref);
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_211_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         string* pobj;
         string xobj = Reflex::Tools::BuildTypeName(*(Reflex::Type*) libp->para[0].ref, (unsigned int) G__int(libp->para[1]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_211_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<std::string>* pobj;
         vector<std::string> xobj = Reflex::Tools::GenTemplateArgVec(*(string*) libp->para[0].ref);
         pobj = new vector<std::string>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_211_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      Reflex::Tools::GetTemplateComponents(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(vector<std::string>*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_211_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) Reflex::Tools::GetBasePosition(*(string*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_211_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) Reflex::Tools::GetFirstScopePosition(*(string*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_211_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      {
         string* pobj;
         string xobj = Reflex::Tools::GetScopeName(*(string*) libp->para[0].ref, (bool) G__int(libp->para[1]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 1:
      {
         string* pobj;
         string xobj = Reflex::Tools::GetScopeName(*(string*) libp->para[0].ref);
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_211_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      {
         string* pobj;
         string xobj = Reflex::Tools::GetBaseName(*(string*) libp->para[0].ref, (bool) G__int(libp->para[1]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   case 1:
      {
         string* pobj;
         string xobj = Reflex::Tools::GetBaseName(*(string*) libp->para[0].ref);
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_211_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) Reflex::Tools::IsTemplated((const char*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_211_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         string* pobj;
         string xobj = Reflex::Tools::GetTemplateArguments((const char*) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_211_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         string* pobj;
         string xobj = Reflex::Tools::GetTemplateName((const char*) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_211_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         string* pobj;
         string xobj = Reflex::Tools::NormalizeName(*(string*) libp->para[0].ref);
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_211_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         string* pobj;
         string xobj = Reflex::Tools::NormalizeName((const char*) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::NamespaceBuilder */
static int G__G__Reflex_215_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::NamespaceBuilder* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Reflex::NamespaceBuilder((const char*) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) Reflex::NamespaceBuilder((const char*) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNamespaceBuilder));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_215_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::NamespaceBuilder& obj = ((Reflex::NamespaceBuilder*) G__getstructoffset())->AddProperty((const char*) G__int(libp->para[0]), *((Reflex::Any*) G__int(libp->para[1])));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_215_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::NamespaceBuilder& obj = ((Reflex::NamespaceBuilder*) G__getstructoffset())->AddProperty((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_215_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Scope* pobj;
         Reflex::Scope xobj = ((Reflex::NamespaceBuilder*) G__getstructoffset())->ToScope();
         pobj = new Reflex::Scope(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_215_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::NamespaceBuilder* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::NamespaceBuilder(*(Reflex::NamespaceBuilder*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNamespaceBuilder));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::NamespaceBuilder G__TReflexcLcLNamespaceBuilder;
static int G__G__Reflex_215_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::NamespaceBuilder*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::NamespaceBuilder*) (soff+(sizeof(Reflex::NamespaceBuilder)*i)))->~G__TReflexcLcLNamespaceBuilder();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::NamespaceBuilder*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::NamespaceBuilder*) (soff))->~G__TReflexcLcLNamespaceBuilder();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::FunctionBuilder */
static int G__G__Reflex_219_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::FunctionBuilder* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 6
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Reflex::FunctionBuilder(
*(Reflex::Type*) libp->para[0].ref, (const char*) G__int(libp->para[1])
, (Reflex::StubFunction) G__int(libp->para[2]), (void*) G__int(libp->para[3])
, (const char*) G__int(libp->para[4]), (unsigned char) G__int(libp->para[5]));
   } else {
     p = new((void*) gvp) Reflex::FunctionBuilder(
*(Reflex::Type*) libp->para[0].ref, (const char*) G__int(libp->para[1])
, (Reflex::StubFunction) G__int(libp->para[2]), (void*) G__int(libp->para[3])
, (const char*) G__int(libp->para[4]), (unsigned char) G__int(libp->para[5]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLFunctionBuilder));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_219_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::FunctionBuilder& obj = ((Reflex::FunctionBuilder*) G__getstructoffset())->AddProperty((const char*) G__int(libp->para[0]), *((Reflex::Any*) G__int(libp->para[1])));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_219_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::FunctionBuilder& obj = ((Reflex::FunctionBuilder*) G__getstructoffset())->AddProperty((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_219_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Member* pobj;
         Reflex::Member xobj = ((Reflex::FunctionBuilder*) G__getstructoffset())->ToMember();
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_219_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::FunctionBuilder* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::FunctionBuilder(*(Reflex::FunctionBuilder*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLFunctionBuilder));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::FunctionBuilder G__TReflexcLcLFunctionBuilder;
static int G__G__Reflex_219_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::FunctionBuilder*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::FunctionBuilder*) (soff+(sizeof(Reflex::FunctionBuilder)*i)))->~G__TReflexcLcLFunctionBuilder();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::FunctionBuilder*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::FunctionBuilder*) (soff))->~G__TReflexcLcLFunctionBuilder();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_219_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::FunctionBuilder* dest = (Reflex::FunctionBuilder*) G__getstructoffset();
   *dest = *(Reflex::FunctionBuilder*) libp->para[0].ref;
   const Reflex::FunctionBuilder& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::FunctionBuilderImpl */
static int G__G__Reflex_220_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::FunctionBuilderImpl* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 6:
     //m: 6
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::FunctionBuilderImpl(
(const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (Reflex::StubFunction) G__int(libp->para[2]), (void*) G__int(libp->para[3])
, (const char*) G__int(libp->para[4]), (unsigned char) G__int(libp->para[5]));
     } else {
       p = new((void*) gvp) Reflex::FunctionBuilderImpl(
(const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (Reflex::StubFunction) G__int(libp->para[2]), (void*) G__int(libp->para[3])
, (const char*) G__int(libp->para[4]), (unsigned char) G__int(libp->para[5]));
     }
     break;
   case 5:
     //m: 5
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::FunctionBuilderImpl(
(const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (Reflex::StubFunction) G__int(libp->para[2]), (void*) G__int(libp->para[3])
, (const char*) G__int(libp->para[4]));
     } else {
       p = new((void*) gvp) Reflex::FunctionBuilderImpl(
(const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (Reflex::StubFunction) G__int(libp->para[2]), (void*) G__int(libp->para[3])
, (const char*) G__int(libp->para[4]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLFunctionBuilderImpl));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_220_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Reflex::FunctionBuilderImpl*) G__getstructoffset())->AddProperty((const char*) G__int(libp->para[0]), *((Reflex::Any*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_220_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Reflex::FunctionBuilderImpl*) G__getstructoffset())->AddProperty((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_220_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Member* pobj;
         Reflex::Member xobj = ((Reflex::FunctionBuilderImpl*) G__getstructoffset())->ToMember();
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_220_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::FunctionBuilderImpl* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::FunctionBuilderImpl(*(Reflex::FunctionBuilderImpl*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLFunctionBuilderImpl));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::FunctionBuilderImpl G__TReflexcLcLFunctionBuilderImpl;
static int G__G__Reflex_220_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::FunctionBuilderImpl*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::FunctionBuilderImpl*) (soff+(sizeof(Reflex::FunctionBuilderImpl)*i)))->~G__TReflexcLcLFunctionBuilderImpl();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::FunctionBuilderImpl*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::FunctionBuilderImpl*) (soff))->~G__TReflexcLcLFunctionBuilderImpl();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_220_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::FunctionBuilderImpl* dest = (Reflex::FunctionBuilderImpl*) G__getstructoffset();
   *dest = *(Reflex::FunctionBuilderImpl*) libp->para[0].ref;
   const Reflex::FunctionBuilderImpl& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::ClassBuilder */
static int G__G__Reflex_229_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::ClassBuilder* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 5:
     //m: 5
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::ClassBuilder(
(const char*) G__int(libp->para[0]), *(type_info*) libp->para[1].ref
, (size_t) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3])
, (Reflex::TYPE) G__int(libp->para[4]));
     } else {
       p = new((void*) gvp) Reflex::ClassBuilder(
(const char*) G__int(libp->para[0]), *(type_info*) libp->para[1].ref
, (size_t) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3])
, (Reflex::TYPE) G__int(libp->para[4]));
     }
     break;
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::ClassBuilder(
(const char*) G__int(libp->para[0]), *(type_info*) libp->para[1].ref
, (size_t) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) Reflex::ClassBuilder(
(const char*) G__int(libp->para[0]), *(type_info*) libp->para[1].ref
, (size_t) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::ClassBuilder(
(const char*) G__int(libp->para[0]), *(type_info*) libp->para[1].ref
, (size_t) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) Reflex::ClassBuilder(
(const char*) G__int(libp->para[0]), *(type_info*) libp->para[1].ref
, (size_t) G__int(libp->para[2]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilder));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_229_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::ClassBuilder* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Reflex::ClassBuilder((Reflex::Class*) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) Reflex::ClassBuilder((Reflex::Class*) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilder));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_229_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      {
         const Reflex::ClassBuilder& obj = ((Reflex::ClassBuilder*) G__getstructoffset())->AddBase(*(Reflex::Type*) libp->para[0].ref, (Reflex::OffsetFunction) G__int(libp->para[1])
, (unsigned int) G__int(libp->para[2]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
      break;
   case 2:
      {
         const Reflex::ClassBuilder& obj = ((Reflex::ClassBuilder*) G__getstructoffset())->AddBase(*(Reflex::Type*) libp->para[0].ref, (Reflex::OffsetFunction) G__int(libp->para[1]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_229_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      {
         const Reflex::ClassBuilder& obj = ((Reflex::ClassBuilder*) G__getstructoffset())->AddDataMember(*(Reflex::Type*) libp->para[0].ref, (const char*) G__int(libp->para[1])
, (size_t) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
      break;
   case 3:
      {
         const Reflex::ClassBuilder& obj = ((Reflex::ClassBuilder*) G__getstructoffset())->AddDataMember(*(Reflex::Type*) libp->para[0].ref, (const char*) G__int(libp->para[1])
, (size_t) G__int(libp->para[2]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_229_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 6:
      {
         const Reflex::ClassBuilder& obj = ((Reflex::ClassBuilder*) G__getstructoffset())->AddFunctionMember(*(Reflex::Type*) libp->para[0].ref, (const char*) G__int(libp->para[1])
, (Reflex::StubFunction) G__int(libp->para[2]), (void*) G__int(libp->para[3])
, (const char*) G__int(libp->para[4]), (unsigned int) G__int(libp->para[5]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
      break;
   case 5:
      {
         const Reflex::ClassBuilder& obj = ((Reflex::ClassBuilder*) G__getstructoffset())->AddFunctionMember(*(Reflex::Type*) libp->para[0].ref, (const char*) G__int(libp->para[1])
, (Reflex::StubFunction) G__int(libp->para[2]), (void*) G__int(libp->para[3])
, (const char*) G__int(libp->para[4]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
      break;
   case 4:
      {
         const Reflex::ClassBuilder& obj = ((Reflex::ClassBuilder*) G__getstructoffset())->AddFunctionMember(*(Reflex::Type*) libp->para[0].ref, (const char*) G__int(libp->para[1])
, (Reflex::StubFunction) G__int(libp->para[2]), (void*) G__int(libp->para[3]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
      break;
   case 3:
      {
         const Reflex::ClassBuilder& obj = ((Reflex::ClassBuilder*) G__getstructoffset())->AddFunctionMember(*(Reflex::Type*) libp->para[0].ref, (const char*) G__int(libp->para[1])
, (Reflex::StubFunction) G__int(libp->para[2]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_229_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::ClassBuilder& obj = ((Reflex::ClassBuilder*) G__getstructoffset())->AddTypedef(*(Reflex::Type*) libp->para[0].ref, (const char*) G__int(libp->para[1]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_229_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::ClassBuilder& obj = ((Reflex::ClassBuilder*) G__getstructoffset())->AddTypedef((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_229_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      {
         const Reflex::ClassBuilder& obj = ((Reflex::ClassBuilder*) G__getstructoffset())->AddEnum((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const type_info*) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
      break;
   case 3:
      {
         const Reflex::ClassBuilder& obj = ((Reflex::ClassBuilder*) G__getstructoffset())->AddEnum((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const type_info*) G__int(libp->para[2]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
      break;
   case 2:
      {
         const Reflex::ClassBuilder& obj = ((Reflex::ClassBuilder*) G__getstructoffset())->AddEnum((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_229_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::ClassBuilder& obj = ((Reflex::ClassBuilder*) G__getstructoffset())->AddOnDemandDataMemberBuilder((Reflex::OnDemandBuilderForScope*) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_229_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::ClassBuilder& obj = ((Reflex::ClassBuilder*) G__getstructoffset())->AddOnDemandFunctionMemberBuilder((Reflex::OnDemandBuilderForScope*) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_229_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::ClassBuilder& obj = ((Reflex::ClassBuilder*) G__getstructoffset())->SetSizeOf((size_t) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_229_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = ((Reflex::ClassBuilder*) G__getstructoffset())->ToType();
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_229_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::ClassBuilder* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::ClassBuilder(*(Reflex::ClassBuilder*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilder));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::ClassBuilder G__TReflexcLcLClassBuilder;
static int G__G__Reflex_229_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::ClassBuilder*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::ClassBuilder*) (soff+(sizeof(Reflex::ClassBuilder)*i)))->~G__TReflexcLcLClassBuilder();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::ClassBuilder*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::ClassBuilder*) (soff))->~G__TReflexcLcLClassBuilder();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_229_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::ClassBuilder* dest = (Reflex::ClassBuilder*) G__getstructoffset();
   *dest = *(Reflex::ClassBuilder*) libp->para[0].ref;
   const Reflex::ClassBuilder& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::ClassBuilderImpl */
static int G__G__Reflex_231_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::ClassBuilderImpl* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 5:
     //m: 5
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::ClassBuilderImpl(
(const char*) G__int(libp->para[0]), *(type_info*) libp->para[1].ref
, (size_t) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3])
, (Reflex::TYPE) G__int(libp->para[4]));
     } else {
       p = new((void*) gvp) Reflex::ClassBuilderImpl(
(const char*) G__int(libp->para[0]), *(type_info*) libp->para[1].ref
, (size_t) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3])
, (Reflex::TYPE) G__int(libp->para[4]));
     }
     break;
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::ClassBuilderImpl(
(const char*) G__int(libp->para[0]), *(type_info*) libp->para[1].ref
, (size_t) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) Reflex::ClassBuilderImpl(
(const char*) G__int(libp->para[0]), *(type_info*) libp->para[1].ref
, (size_t) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::ClassBuilderImpl(
(const char*) G__int(libp->para[0]), *(type_info*) libp->para[1].ref
, (size_t) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) Reflex::ClassBuilderImpl(
(const char*) G__int(libp->para[0]), *(type_info*) libp->para[1].ref
, (size_t) G__int(libp->para[2]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilderImpl));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_231_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::ClassBuilderImpl* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Reflex::ClassBuilderImpl((Reflex::Class*) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) Reflex::ClassBuilderImpl((Reflex::Class*) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilderImpl));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_231_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      ((Reflex::ClassBuilderImpl*) G__getstructoffset())->AddBase(*(Reflex::Type*) libp->para[0].ref, (Reflex::OffsetFunction) G__int(libp->para[1])
, (unsigned int) G__int(libp->para[2]));
      G__setnull(result7);
      break;
   case 2:
      ((Reflex::ClassBuilderImpl*) G__getstructoffset())->AddBase(*(Reflex::Type*) libp->para[0].ref, (Reflex::OffsetFunction) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_231_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      ((Reflex::ClassBuilderImpl*) G__getstructoffset())->AddDataMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (size_t) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3]));
      G__setnull(result7);
      break;
   case 3:
      ((Reflex::ClassBuilderImpl*) G__getstructoffset())->AddDataMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (size_t) G__int(libp->para[2]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_231_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 6:
      ((Reflex::ClassBuilderImpl*) G__getstructoffset())->AddFunctionMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (Reflex::StubFunction) G__int(libp->para[2]), (void*) G__int(libp->para[3])
, (const char*) G__int(libp->para[4]), (unsigned int) G__int(libp->para[5]));
      G__setnull(result7);
      break;
   case 5:
      ((Reflex::ClassBuilderImpl*) G__getstructoffset())->AddFunctionMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (Reflex::StubFunction) G__int(libp->para[2]), (void*) G__int(libp->para[3])
, (const char*) G__int(libp->para[4]));
      G__setnull(result7);
      break;
   case 4:
      ((Reflex::ClassBuilderImpl*) G__getstructoffset())->AddFunctionMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (Reflex::StubFunction) G__int(libp->para[2]), (void*) G__int(libp->para[3]));
      G__setnull(result7);
      break;
   case 3:
      ((Reflex::ClassBuilderImpl*) G__getstructoffset())->AddFunctionMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (Reflex::StubFunction) G__int(libp->para[2]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_231_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Reflex::ClassBuilderImpl*) G__getstructoffset())->AddTypedef(*(Reflex::Type*) libp->para[0].ref, (const char*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_231_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      ((Reflex::ClassBuilderImpl*) G__getstructoffset())->AddEnum((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const type_info*) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3]));
      G__setnull(result7);
      break;
   case 3:
      ((Reflex::ClassBuilderImpl*) G__getstructoffset())->AddEnum((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const type_info*) G__int(libp->para[2]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_231_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Reflex::ClassBuilderImpl*) G__getstructoffset())->AddProperty((const char*) G__int(libp->para[0]), *((Reflex::Any*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_231_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Reflex::ClassBuilderImpl*) G__getstructoffset())->AddProperty((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_231_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Reflex::ClassBuilderImpl*) G__getstructoffset())->AddOnDemandDataMemberBuilder((Reflex::OnDemandBuilderForScope*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_231_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Reflex::ClassBuilderImpl*) G__getstructoffset())->AddOnDemandFunctionMemberBuilder((Reflex::OnDemandBuilderForScope*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_231_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Reflex::ClassBuilderImpl*) G__getstructoffset())->SetSizeOf((size_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_231_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = ((Reflex::ClassBuilderImpl*) G__getstructoffset())->ToType();
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_231_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::ClassBuilderImpl* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::ClassBuilderImpl(*(Reflex::ClassBuilderImpl*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilderImpl));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::ClassBuilderImpl G__TReflexcLcLClassBuilderImpl;
static int G__G__Reflex_231_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::ClassBuilderImpl*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::ClassBuilderImpl*) (soff+(sizeof(Reflex::ClassBuilderImpl)*i)))->~G__TReflexcLcLClassBuilderImpl();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::ClassBuilderImpl*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::ClassBuilderImpl*) (soff))->~G__TReflexcLcLClassBuilderImpl();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_231_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::ClassBuilderImpl* dest = (Reflex::ClassBuilderImpl*) G__getstructoffset();
   *dest = *(Reflex::ClassBuilderImpl*) libp->para[0].ref;
   const Reflex::ClassBuilderImpl& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::CollFuncTable */
// automatic default constructor
static int G__G__Reflex_233_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::CollFuncTable *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::CollFuncTable[n];
     } else {
       p = new((void*) gvp) Reflex::CollFuncTable[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::CollFuncTable;
     } else {
       p = new((void*) gvp) Reflex::CollFuncTable;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLCollFuncTable));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_233_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::CollFuncTable* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::CollFuncTable(*(Reflex::CollFuncTable*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLCollFuncTable));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::CollFuncTable G__TReflexcLcLCollFuncTable;
static int G__G__Reflex_233_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::CollFuncTable*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::CollFuncTable*) (soff+(sizeof(Reflex::CollFuncTable)*i)))->~G__TReflexcLcLCollFuncTable();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::CollFuncTable*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::CollFuncTable*) (soff))->~G__TReflexcLcLCollFuncTable();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_233_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::CollFuncTable* dest = (Reflex::CollFuncTable*) G__getstructoffset();
   *dest = *(Reflex::CollFuncTable*) libp->para[0].ref;
   const Reflex::CollFuncTable& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::Selection::NO_SELF_AUTOSELECT */
// automatic default constructor
static int G__G__Reflex_236_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::Selection::NO_SELF_AUTOSELECT *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::Selection::NO_SELF_AUTOSELECT[n];
     } else {
       p = new((void*) gvp) Reflex::Selection::NO_SELF_AUTOSELECT[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::Selection::NO_SELF_AUTOSELECT;
     } else {
       p = new((void*) gvp) Reflex::Selection::NO_SELF_AUTOSELECT;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_236_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::Selection::NO_SELF_AUTOSELECT* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::Selection::NO_SELF_AUTOSELECT(*(Reflex::Selection::NO_SELF_AUTOSELECT*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::Selection::NO_SELF_AUTOSELECT G__TReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT;
static int G__G__Reflex_236_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::Selection::NO_SELF_AUTOSELECT*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::Selection::NO_SELF_AUTOSELECT*) (soff+(sizeof(Reflex::Selection::NO_SELF_AUTOSELECT)*i)))->~G__TReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::Selection::NO_SELF_AUTOSELECT*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::Selection::NO_SELF_AUTOSELECT*) (soff))->~G__TReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_236_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::Selection::NO_SELF_AUTOSELECT* dest = (Reflex::Selection::NO_SELF_AUTOSELECT*) G__getstructoffset();
   const Reflex::Selection::NO_SELF_AUTOSELECT& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::Selection::TRANSIENT */
// automatic default constructor
static int G__G__Reflex_237_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::Selection::TRANSIENT *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::Selection::TRANSIENT[n];
     } else {
       p = new((void*) gvp) Reflex::Selection::TRANSIENT[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::Selection::TRANSIENT;
     } else {
       p = new((void*) gvp) Reflex::Selection::TRANSIENT;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLTRANSIENT));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_237_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::Selection::TRANSIENT* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::Selection::TRANSIENT(*(Reflex::Selection::TRANSIENT*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLTRANSIENT));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::Selection::TRANSIENT G__TReflexcLcLSelectioncLcLTRANSIENT;
static int G__G__Reflex_237_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::Selection::TRANSIENT*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::Selection::TRANSIENT*) (soff+(sizeof(Reflex::Selection::TRANSIENT)*i)))->~G__TReflexcLcLSelectioncLcLTRANSIENT();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::Selection::TRANSIENT*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::Selection::TRANSIENT*) (soff))->~G__TReflexcLcLSelectioncLcLTRANSIENT();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_237_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::Selection::TRANSIENT* dest = (Reflex::Selection::TRANSIENT*) G__getstructoffset();
   const Reflex::Selection::TRANSIENT& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::Selection::AUTOSELECT */
// automatic default constructor
static int G__G__Reflex_238_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::Selection::AUTOSELECT *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::Selection::AUTOSELECT[n];
     } else {
       p = new((void*) gvp) Reflex::Selection::AUTOSELECT[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::Selection::AUTOSELECT;
     } else {
       p = new((void*) gvp) Reflex::Selection::AUTOSELECT;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLAUTOSELECT));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_238_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::Selection::AUTOSELECT* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::Selection::AUTOSELECT(*(Reflex::Selection::AUTOSELECT*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLAUTOSELECT));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::Selection::AUTOSELECT G__TReflexcLcLSelectioncLcLAUTOSELECT;
static int G__G__Reflex_238_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::Selection::AUTOSELECT*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::Selection::AUTOSELECT*) (soff+(sizeof(Reflex::Selection::AUTOSELECT)*i)))->~G__TReflexcLcLSelectioncLcLAUTOSELECT();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::Selection::AUTOSELECT*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::Selection::AUTOSELECT*) (soff))->~G__TReflexcLcLSelectioncLcLAUTOSELECT();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_238_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::Selection::AUTOSELECT* dest = (Reflex::Selection::AUTOSELECT*) G__getstructoffset();
   const Reflex::Selection::AUTOSELECT& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::Selection::NODEFAULT */
// automatic default constructor
static int G__G__Reflex_239_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::Selection::NODEFAULT *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::Selection::NODEFAULT[n];
     } else {
       p = new((void*) gvp) Reflex::Selection::NODEFAULT[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::Selection::NODEFAULT;
     } else {
       p = new((void*) gvp) Reflex::Selection::NODEFAULT;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLNODEFAULT));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_239_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::Selection::NODEFAULT* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::Selection::NODEFAULT(*(Reflex::Selection::NODEFAULT*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLNODEFAULT));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::Selection::NODEFAULT G__TReflexcLcLSelectioncLcLNODEFAULT;
static int G__G__Reflex_239_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::Selection::NODEFAULT*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::Selection::NODEFAULT*) (soff+(sizeof(Reflex::Selection::NODEFAULT)*i)))->~G__TReflexcLcLSelectioncLcLNODEFAULT();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::Selection::NODEFAULT*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::Selection::NODEFAULT*) (soff))->~G__TReflexcLcLSelectioncLcLNODEFAULT();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_239_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::Selection::NODEFAULT* dest = (Reflex::Selection::NODEFAULT*) G__getstructoffset();
   const Reflex::Selection::NODEFAULT& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::EnumBuilder */
static int G__G__Reflex_241_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::EnumBuilder* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::EnumBuilder(
(const char*) G__int(libp->para[0]), *(type_info*) libp->para[1].ref
, (unsigned int) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) Reflex::EnumBuilder(
(const char*) G__int(libp->para[0]), *(type_info*) libp->para[1].ref
, (unsigned int) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::EnumBuilder((const char*) G__int(libp->para[0]), *(type_info*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) Reflex::EnumBuilder((const char*) G__int(libp->para[0]), *(type_info*) libp->para[1].ref);
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEnumBuilder));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_241_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::EnumBuilder& obj = ((Reflex::EnumBuilder*) G__getstructoffset())->AddItem((const char*) G__int(libp->para[0]), (long) G__int(libp->para[1]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_241_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::EnumBuilder& obj = ((Reflex::EnumBuilder*) G__getstructoffset())->AddProperty((const char*) G__int(libp->para[0]), *((Reflex::Any*) G__int(libp->para[1])));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_241_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::EnumBuilder& obj = ((Reflex::EnumBuilder*) G__getstructoffset())->AddProperty((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_241_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = ((Reflex::EnumBuilder*) G__getstructoffset())->ToType();
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_241_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::EnumBuilder* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::EnumBuilder(*(Reflex::EnumBuilder*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEnumBuilder));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::EnumBuilder G__TReflexcLcLEnumBuilder;
static int G__G__Reflex_241_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::EnumBuilder*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::EnumBuilder*) (soff+(sizeof(Reflex::EnumBuilder)*i)))->~G__TReflexcLcLEnumBuilder();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::EnumBuilder*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::EnumBuilder*) (soff))->~G__TReflexcLcLEnumBuilder();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_241_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::EnumBuilder* dest = (Reflex::EnumBuilder*) G__getstructoffset();
   *dest = *(Reflex::EnumBuilder*) libp->para[0].ref;
   const Reflex::EnumBuilder& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::NewDelFunctions */
// automatic default constructor
static int G__G__Reflex_243_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::NewDelFunctions *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::NewDelFunctions[n];
     } else {
       p = new((void*) gvp) Reflex::NewDelFunctions[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::NewDelFunctions;
     } else {
       p = new((void*) gvp) Reflex::NewDelFunctions;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNewDelFunctions));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_243_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::NewDelFunctions* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::NewDelFunctions(*(Reflex::NewDelFunctions*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNewDelFunctions));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::NewDelFunctions G__TReflexcLcLNewDelFunctions;
static int G__G__Reflex_243_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::NewDelFunctions*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::NewDelFunctions*) (soff+(sizeof(Reflex::NewDelFunctions)*i)))->~G__TReflexcLcLNewDelFunctions();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::NewDelFunctions*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::NewDelFunctions*) (soff))->~G__TReflexcLcLNewDelFunctions();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_243_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::NewDelFunctions* dest = (Reflex::NewDelFunctions*) G__getstructoffset();
   *dest = *(Reflex::NewDelFunctions*) libp->para[0].ref;
   const Reflex::NewDelFunctions& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::TypedefBuilderImpl */
static int G__G__Reflex_244_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::TypedefBuilderImpl* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Reflex::TypedefBuilderImpl((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref);
   } else {
     p = new((void*) gvp) Reflex::TypedefBuilderImpl((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypedefBuilderImpl));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_244_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Reflex::TypedefBuilderImpl*) G__getstructoffset())->AddProperty((const char*) G__int(libp->para[0]), *((Reflex::Any*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_244_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Reflex::TypedefBuilderImpl*) G__getstructoffset())->AddProperty((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_244_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = ((Reflex::TypedefBuilderImpl*) G__getstructoffset())->ToType();
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_244_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::TypedefBuilderImpl* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::TypedefBuilderImpl(*(Reflex::TypedefBuilderImpl*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypedefBuilderImpl));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::TypedefBuilderImpl G__TReflexcLcLTypedefBuilderImpl;
static int G__G__Reflex_244_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::TypedefBuilderImpl*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::TypedefBuilderImpl*) (soff+(sizeof(Reflex::TypedefBuilderImpl)*i)))->~G__TReflexcLcLTypedefBuilderImpl();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::TypedefBuilderImpl*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::TypedefBuilderImpl*) (soff))->~G__TReflexcLcLTypedefBuilderImpl();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::UnionBuilderImpl */
static int G__G__Reflex_246_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::UnionBuilderImpl* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 5:
     //m: 5
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::UnionBuilderImpl(
(const char*) G__int(libp->para[0]), (size_t) G__int(libp->para[1])
, *(type_info*) libp->para[2].ref, (unsigned int) G__int(libp->para[3])
, (Reflex::TYPE) G__int(libp->para[4]));
     } else {
       p = new((void*) gvp) Reflex::UnionBuilderImpl(
(const char*) G__int(libp->para[0]), (size_t) G__int(libp->para[1])
, *(type_info*) libp->para[2].ref, (unsigned int) G__int(libp->para[3])
, (Reflex::TYPE) G__int(libp->para[4]));
     }
     break;
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::UnionBuilderImpl(
(const char*) G__int(libp->para[0]), (size_t) G__int(libp->para[1])
, *(type_info*) libp->para[2].ref, (unsigned int) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) Reflex::UnionBuilderImpl(
(const char*) G__int(libp->para[0]), (size_t) G__int(libp->para[1])
, *(type_info*) libp->para[2].ref, (unsigned int) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::UnionBuilderImpl(
(const char*) G__int(libp->para[0]), (size_t) G__int(libp->para[1])
, *(type_info*) libp->para[2].ref);
     } else {
       p = new((void*) gvp) Reflex::UnionBuilderImpl(
(const char*) G__int(libp->para[0]), (size_t) G__int(libp->para[1])
, *(type_info*) libp->para[2].ref);
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnionBuilderImpl));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_246_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Reflex::UnionBuilderImpl*) G__getstructoffset())->AddItem((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_246_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      ((Reflex::UnionBuilderImpl*) G__getstructoffset())->AddDataMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (size_t) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3]));
      G__setnull(result7);
      break;
   case 3:
      ((Reflex::UnionBuilderImpl*) G__getstructoffset())->AddDataMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (size_t) G__int(libp->para[2]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_246_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 6:
      ((Reflex::UnionBuilderImpl*) G__getstructoffset())->AddFunctionMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (Reflex::StubFunction) G__int(libp->para[2]), (void*) G__int(libp->para[3])
, (const char*) G__int(libp->para[4]), (unsigned int) G__int(libp->para[5]));
      G__setnull(result7);
      break;
   case 5:
      ((Reflex::UnionBuilderImpl*) G__getstructoffset())->AddFunctionMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (Reflex::StubFunction) G__int(libp->para[2]), (void*) G__int(libp->para[3])
, (const char*) G__int(libp->para[4]));
      G__setnull(result7);
      break;
   case 4:
      ((Reflex::UnionBuilderImpl*) G__getstructoffset())->AddFunctionMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (Reflex::StubFunction) G__int(libp->para[2]), (void*) G__int(libp->para[3]));
      G__setnull(result7);
      break;
   case 3:
      ((Reflex::UnionBuilderImpl*) G__getstructoffset())->AddFunctionMember((const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (Reflex::StubFunction) G__int(libp->para[2]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_246_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Reflex::UnionBuilderImpl*) G__getstructoffset())->AddProperty((const char*) G__int(libp->para[0]), *((Reflex::Any*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_246_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Reflex::UnionBuilderImpl*) G__getstructoffset())->AddProperty((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_246_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Reflex::UnionBuilderImpl*) G__getstructoffset())->SetSizeOf((size_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_246_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Type* pobj;
         Reflex::Type xobj = ((Reflex::UnionBuilderImpl*) G__getstructoffset())->ToType();
         pobj = new Reflex::Type(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_246_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::UnionBuilderImpl* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::UnionBuilderImpl(*(Reflex::UnionBuilderImpl*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnionBuilderImpl));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::UnionBuilderImpl G__TReflexcLcLUnionBuilderImpl;
static int G__G__Reflex_246_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::UnionBuilderImpl*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::UnionBuilderImpl*) (soff+(sizeof(Reflex::UnionBuilderImpl)*i)))->~G__TReflexcLcLUnionBuilderImpl();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::UnionBuilderImpl*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::UnionBuilderImpl*) (soff))->~G__TReflexcLcLUnionBuilderImpl();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_246_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::UnionBuilderImpl* dest = (Reflex::UnionBuilderImpl*) G__getstructoffset();
   *dest = *(Reflex::UnionBuilderImpl*) libp->para[0].ref;
   const Reflex::UnionBuilderImpl& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::VariableBuilder */
static int G__G__Reflex_249_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::VariableBuilder* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::VariableBuilder(
(const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (size_t) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) Reflex::VariableBuilder(
(const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (size_t) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::VariableBuilder(
(const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (size_t) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) Reflex::VariableBuilder(
(const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (size_t) G__int(libp->para[2]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLVariableBuilder));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_249_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::VariableBuilder& obj = ((Reflex::VariableBuilder*) G__getstructoffset())->AddProperty((const char*) G__int(libp->para[0]), *((Reflex::Any*) G__int(libp->para[1])));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_249_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Reflex::VariableBuilder& obj = ((Reflex::VariableBuilder*) G__getstructoffset())->AddProperty((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_249_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Member* pobj;
         Reflex::Member xobj = ((Reflex::VariableBuilder*) G__getstructoffset())->ToMember();
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_249_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::VariableBuilder* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::VariableBuilder(*(Reflex::VariableBuilder*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLVariableBuilder));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::VariableBuilder G__TReflexcLcLVariableBuilder;
static int G__G__Reflex_249_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::VariableBuilder*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::VariableBuilder*) (soff+(sizeof(Reflex::VariableBuilder)*i)))->~G__TReflexcLcLVariableBuilder();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::VariableBuilder*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::VariableBuilder*) (soff))->~G__TReflexcLcLVariableBuilder();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_249_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::VariableBuilder* dest = (Reflex::VariableBuilder*) G__getstructoffset();
   *dest = *(Reflex::VariableBuilder*) libp->para[0].ref;
   const Reflex::VariableBuilder& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Reflex::VariableBuilderImpl */
static int G__G__Reflex_250_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::VariableBuilderImpl* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::VariableBuilderImpl(
(const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (size_t) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) Reflex::VariableBuilderImpl(
(const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (size_t) G__int(libp->para[2]), (unsigned int) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Reflex::VariableBuilderImpl(
(const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (size_t) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) Reflex::VariableBuilderImpl(
(const char*) G__int(libp->para[0]), *(Reflex::Type*) libp->para[1].ref
, (size_t) G__int(libp->para[2]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLVariableBuilderImpl));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_250_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Reflex::VariableBuilderImpl*) G__getstructoffset())->AddProperty((const char*) G__int(libp->para[0]), *((Reflex::Any*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_250_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((Reflex::VariableBuilderImpl*) G__getstructoffset())->AddProperty((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Reflex_250_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Reflex::Member* pobj;
         Reflex::Member xobj = ((Reflex::VariableBuilderImpl*) G__getstructoffset())->ToMember();
         pobj = new Reflex::Member(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Reflex_250_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Reflex::VariableBuilderImpl* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Reflex::VariableBuilderImpl(*(Reflex::VariableBuilderImpl*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLVariableBuilderImpl));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Reflex::VariableBuilderImpl G__TReflexcLcLVariableBuilderImpl;
static int G__G__Reflex_250_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Reflex::VariableBuilderImpl*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Reflex::VariableBuilderImpl*) (soff+(sizeof(Reflex::VariableBuilderImpl)*i)))->~G__TReflexcLcLVariableBuilderImpl();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Reflex::VariableBuilderImpl*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Reflex::VariableBuilderImpl*) (soff))->~G__TReflexcLcLVariableBuilderImpl();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Reflex_250_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Reflex::VariableBuilderImpl* dest = (Reflex::VariableBuilderImpl*) G__getstructoffset();
   *dest = *(Reflex::VariableBuilderImpl*) libp->para[0].ref;
   const Reflex::VariableBuilderImpl& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */

/*********************************************************
* Member function Stub
*********************************************************/

/* Reflex */

/* Reflex::Any */

/* Reflex::Type */

/* Reflex::Base */

/* Reflex::Scope */

/* Reflex::Object */

/* Reflex::Member */

/* Reflex::TypeTemplate */

/* Reflex::MemberTemplate */

/* Reflex::Dummy */

/* Reflex::Instance */

/* Reflex::NullType */

/* Reflex::UnknownType */

/* Reflex::ProtectedClass */

/* Reflex::ProtectedEnum */

/* Reflex::ProtectedStruct */

/* Reflex::ProtectedUnion */

/* Reflex::PrivateClass */

/* Reflex::PrivateEnum */

/* Reflex::PrivateStruct */

/* Reflex::PrivateUnion */

/* Reflex::UnnamedClass */

/* Reflex::UnnamedEnum */

/* Reflex::UnnamedNamespace */

/* Reflex::UnnamedStruct */

/* Reflex::UnnamedUnion */

/* Reflex::RuntimeError */

/* Reflex::ICallback */

/* Reflex::Tools */

/* Reflex::NamespaceBuilder */

/* Reflex::FunctionBuilder */

/* Reflex::FunctionBuilderImpl */

/* Reflex::ClassBuilder */

/* Reflex::ClassBuilderImpl */

/* Reflex::CollFuncTable */

/* Reflex::Selection::NO_SELF_AUTOSELECT */

/* Reflex::Selection::TRANSIENT */

/* Reflex::Selection::AUTOSELECT */

/* Reflex::Selection::NODEFAULT */

/* Reflex::EnumBuilder */

/* Reflex::NewDelFunctions */

/* Reflex::TypedefBuilderImpl */

/* Reflex::UnionBuilderImpl */

/* Reflex::VariableBuilder */

/* Reflex::VariableBuilderImpl */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfuncG__Reflex {
 public:
  G__Sizep2memfuncG__Reflex(): p(&G__Sizep2memfuncG__Reflex::sizep2memfunc) {}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfuncG__Reflex::*p)();
};

size_t G__get_sizep2memfuncG__Reflex()
{
  G__Sizep2memfuncG__Reflex a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */

/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritanceG__Reflex() {

   /* Setting up class inheritance */
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLRuntimeError))) {
     Reflex::RuntimeError *G__Lderived;
     G__Lderived=(Reflex::RuntimeError*)0x1000;
     {
       exception *G__Lpbase=(exception*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLRuntimeError),G__get_linked_tagnum(&G__G__ReflexLN_exception),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetableG__Reflex() {

   /* Setting up typedef entry */
   G__search_typename2("vector<TSchemaHelper>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<std::string>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<string>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("StdString_Cont_Type_t",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgR),0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("StdString_Iterator",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgRcLcLiterator),0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Reverse_StdString_Iterator",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Type>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Reflex::Type>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Type_Cont_Type_t",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgR),0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Type_Iterator",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiterator),0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Reverse_Type_Iterator",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Base>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Reflex::Base>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Base_Cont_Type_t",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgR),0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Base_Iterator",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgRcLcLiterator),0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Reverse_Base_Iterator",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Scope>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Reflex::Scope>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Scope_Cont_Type_t",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgR),0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Scope_Iterator",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiterator),0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Reverse_Scope_Iterator",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Object>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLObjectcOallocatorlEReflexcLcLObjectgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLObjectcOallocatorlEReflexcLcLObjectgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLObjectcOallocatorlEReflexcLcLObjectgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLObjectcOallocatorlEReflexcLcLObjectgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLObjectcOallocatorlEReflexcLcLObjectgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Reflex::Object>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLObjectcOallocatorlEReflexcLcLObjectgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Object_Cont_Type_t",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLObjectcOallocatorlEReflexcLcLObjectgRsPgR),0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Object_Iterator",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLObjectcOallocatorlEReflexcLcLObjectgRsPgRcLcLiterator),0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Reverse_Object_Iterator",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLObjectcOallocatorlEReflexcLcLObjectgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Member>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Reflex::Member>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Member_Cont_Type_t",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgR),0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Member_Iterator",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiterator),0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Reverse_Member_Iterator",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TypeTemplate>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Reflex::TypeTemplate>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TypeTemplate_Cont_Type_t",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgR),0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TypeTemplate_Iterator",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgRcLcLiterator),0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Reverse_TypeTemplate_Iterator",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<MemberTemplate>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Reflex::MemberTemplate>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("MemberTemplate_Cont_Type_t",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgR),0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("MemberTemplate_Iterator",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgRcLcLiterator),0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Reverse_MemberTemplate_Iterator",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("StubFunction",89,-1,0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,"void (*StubFunction)(void*, void*, const std::vector<void*>&, void*);",0);
   G__search_typename2("OffsetFunction",89,-1,0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,"size_t (*OffsetFunction)(void*);",0);
   G__search_typename2("vector<void*>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEvoidmUcOallocatorlEvoidmUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEvoidmUcOallocatorlEvoidmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEvoidmUcOallocatorlEvoidmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEvoidmUcOallocatorlEvoidmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEvoidmUcOallocatorlEvoidmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Any>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLAnycOallocatorlEReflexcLcLAnygRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLAnycOallocatorlEReflexcLcLAnygRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLAnycOallocatorlEReflexcLcLAnygRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLAnycOallocatorlEReflexcLcLAnygRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLAnycOallocatorlEReflexcLcLAnygRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Reflex::Any>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLAnycOallocatorlEReflexcLcLAnygRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<OwnedMember>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLOwnedMembercOallocatorlEReflexcLcLOwnedMembergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLOwnedMembercOallocatorlEReflexcLcLOwnedMembergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLOwnedMembercOallocatorlEReflexcLcLOwnedMembergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLOwnedMembercOallocatorlEReflexcLcLOwnedMembergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLOwnedMembercOallocatorlEReflexcLcLOwnedMembergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Reflex::OwnedMember>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLOwnedMembercOallocatorlEReflexcLcLOwnedMembergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<OwnedMemberTemplate>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLOwnedMemberTemplatecOallocatorlEReflexcLcLOwnedMemberTemplategRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLOwnedMemberTemplatecOallocatorlEReflexcLcLOwnedMemberTemplategRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLOwnedMemberTemplatecOallocatorlEReflexcLcLOwnedMemberTemplategRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLOwnedMemberTemplatecOallocatorlEReflexcLcLOwnedMemberTemplategRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLOwnedMemberTemplatecOallocatorlEReflexcLcLOwnedMemberTemplategRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Reflex::OwnedMemberTemplate>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLOwnedMemberTemplatecOallocatorlEReflexcLcLOwnedMemberTemplategRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ValueObject>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLValueObjectcOallocatorlEReflexcLcLValueObjectgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLValueObjectcOallocatorlEReflexcLcLValueObjectgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLValueObjectcOallocatorlEReflexcLcLValueObjectgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLValueObjectcOallocatorlEReflexcLcLValueObjectgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLValueObjectcOallocatorlEReflexcLcLValueObjectgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Reflex::ValueObject>",117,G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLValueObjectcOallocatorlEReflexcLcLValueObjectgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("NewFunc_t",89,-1,0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,"void* (*NewFunc_t)(void*);",0);
   G__search_typename2("NewArrFunc_t",89,-1,0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,"void* (*NewArrFunc_t)(long size, void* arena);",0);
   G__search_typename2("DelFunc_t",89,-1,0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,"void (*DelFunc_t)(void*);",0);
   G__search_typename2("DelArrFunc_t",89,-1,0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,"void (*DelArrFunc_t)(void*);",0);
   G__search_typename2("DesFunc_t",89,-1,0,G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__setnewtype(-1,"void (*DesFunc_t)(void*);",0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* Reflex */
static void G__setup_memvarReflex(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   {
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"PUBLIC=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"PROTECTED=2",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"PRIVATE=4",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"REGISTER=8",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"STATIC=16",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"CONSTRUCTOR=32",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"DESTRUCTOR=64",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"EXPLICIT=128",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"EXTERN=256",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"COPYCONSTRUCTOR=512",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"OPERATOR=1024",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"INLINE=2048",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"CONVERTER=4096",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"AUTO=8192",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"MUTABLE=16384",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"CONST=32768",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"VOLATILE=65536",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"REFERENCE=131072",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"ABSTRACT=262144",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"VIRTUAL=524288",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"TRANSIENT=1048576",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"ARTIFICIAL=2097152",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"TEMPLATEDEFAULTS1=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"TEMPLATEDEFAULTS2=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"TEMPLATEDEFAULTS3=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"TEMPLATEDEFAULTS4=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"TEMPLATEDEFAULTS5=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"TEMPLATEDEFAULTS6=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"TEMPLATEDEFAULTS7=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"TEMPLATEDEFAULTS8=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"TEMPLATEDEFAULTS9=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"TEMPLATEDEFAULTS10=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"TEMPLATEDEFAULTS11=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"TEMPLATEDEFAULTS12=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"TEMPLATEDEFAULTS13=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"TEMPLATEDEFAULTS14=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),-1,-2,1,"TEMPLATEDEFAULTS15=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_HANDLING),-1,-2,1,"FINAL=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_HANDLING),-1,-2,1,"QUALIFIED=2",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_HANDLING),-1,-2,1,"SCOPED=4",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_HANDLING),-1,-2,1,"F=16",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_HANDLING),-1,-2,1,"Q=32",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_HANDLING),-1,-2,1,"S=64",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTYPE),-1,-2,1,"CLASS=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTYPE),-1,-2,1,"STRUCT=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTYPE),-1,-2,1,"ENUM=2",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTYPE),-1,-2,1,"FUNCTION=3",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTYPE),-1,-2,1,"ARRAY=4",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTYPE),-1,-2,1,"FUNDAMENTAL=5",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTYPE),-1,-2,1,"POINTER=6",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTYPE),-1,-2,1,"POINTERTOMEMBER=7",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTYPE),-1,-2,1,"TYPEDEF=8",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTYPE),-1,-2,1,"UNION=9",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTYPE),-1,-2,1,"TYPETEMPLATEINSTANCE=10",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTYPE),-1,-2,1,"MEMBERTEMPLATEINSTANCE=11",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTYPE),-1,-2,1,"NAMESPACE=12",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTYPE),-1,-2,1,"DATAMEMBER=13",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTYPE),-1,-2,1,"FUNCTIONMEMBER=14",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTYPE),-1,-2,1,"UNRESOLVED=15",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLREPRESTYPE),-1,-2,1,"REPRES_POINTER=32",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLREPRESTYPE),-1,-2,1,"REPRES_CHAR=99",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLREPRESTYPE),-1,-2,1,"REPRES_SIGNED_CHAR=99",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLREPRESTYPE),-1,-2,1,"REPRES_SHORT_INT=115",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLREPRESTYPE),-1,-2,1,"REPRES_INT=105",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLREPRESTYPE),-1,-2,1,"REPRES_LONG_INT=108",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLREPRESTYPE),-1,-2,1,"REPRES_UNSIGNED_CHAR=98",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLREPRESTYPE),-1,-2,1,"REPRES_UNSIGNED_SHORT_INT=114",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLREPRESTYPE),-1,-2,1,"REPRES_UNSIGNED_INT=104",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLREPRESTYPE),-1,-2,1,"REPRES_UNSIGNED_LONG_INT=107",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLREPRESTYPE),-1,-2,1,"REPRES_BOOL=103",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLREPRESTYPE),-1,-2,1,"REPRES_FLOAT=102",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLREPRESTYPE),-1,-2,1,"REPRES_DOUBLE=100",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLREPRESTYPE),-1,-2,1,"REPRES_LONG_DOUBLE=113",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLREPRESTYPE),-1,-2,1,"REPRES_VOID=121",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLREPRESTYPE),-1,-2,1,"REPRES_LONGLONG=110",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLREPRESTYPE),-1,-2,1,"REPRES_ULONGLONG=109",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLREPRESTYPE),-1,-2,1,"REPRES_STRUCT=117",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLREPRESTYPE),-1,-2,1,"REPRES_CLASS=117",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLREPRESTYPE),-1,-2,1,"REPRES_ENUM=105",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLREPRESTYPE),-1,-2,1,"REPRES_NOTYPE=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEMEMBERQUERY),-1,-2,1,"INHERITEDMEMBERS_DEFAULT=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEMEMBERQUERY),-1,-2,1,"INHERITEDMEMBERS_NO=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEMEMBERQUERY),-1,-2,1,"INHERITEDMEMBERS_ALSO=2",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEDELAYEDLOADSETTING),-1,-2,1,"DELAYEDLOAD_OFF=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEDELAYEDLOADSETTING),-1,-2,1,"DELAYEDLOAD_ON=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEFUNDAMENTALTYPE),-1,-2,1,"kCHAR=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEFUNDAMENTALTYPE),-1,-2,1,"kSIGNED_CHAR=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEFUNDAMENTALTYPE),-1,-2,1,"kSHORT_INT=2",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEFUNDAMENTALTYPE),-1,-2,1,"kINT=3",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEFUNDAMENTALTYPE),-1,-2,1,"kLONG_INT=4",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEFUNDAMENTALTYPE),-1,-2,1,"kUNSIGNED_CHAR=5",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEFUNDAMENTALTYPE),-1,-2,1,"kUNSIGNED_SHORT_INT=6",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEFUNDAMENTALTYPE),-1,-2,1,"kUNSIGNED_INT=7",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEFUNDAMENTALTYPE),-1,-2,1,"kUNSIGNED_LONG_INT=8",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEFUNDAMENTALTYPE),-1,-2,1,"kBOOL=9",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEFUNDAMENTALTYPE),-1,-2,1,"kFLOAT=10",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEFUNDAMENTALTYPE),-1,-2,1,"kDOUBLE=11",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEFUNDAMENTALTYPE),-1,-2,1,"kLONG_DOUBLE=12",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEFUNDAMENTALTYPE),-1,-2,1,"kVOID=13",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEFUNDAMENTALTYPE),-1,-2,1,"kLONGLONG=14",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEFUNDAMENTALTYPE),-1,-2,1,"kULONGLONG=15",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEFUNDAMENTALTYPE),-1,-2,1,"kNOTFUNDAMENTAL=16",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Reflex::Any */
static void G__setup_memvarReflexcLcLAny(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLAny));
   { Reflex::Any *p; p=(Reflex::Any*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLAnycLcLPlaceholder),-1,-1,4,"fContent=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Reflex::Type */
static void G__setup_memvarReflexcLcLType(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType));
   { Reflex::Type *p; p=(Reflex::Type*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypecLcLTYPE_MODIFICATION),-1,-2,1,"REPLACE=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypecLcLTYPE_MODIFICATION),-1,-2,1,"APPEND=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypecLcLTYPE_MODIFICATION),-1,-2,1,"MASK=2",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypeName),-1,-1,4,"fTypeName=",0,(char*)NULL);
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fModifiers=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Reflex::Base */
static void G__setup_memvarReflexcLcLBase(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLBase));
   { Reflex::Base *p; p=(Reflex::Base*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,89,0,0,-1,G__defined_typename("OffsetFunction"),-1,4,"fOffsetFP=",0,(char*)NULL);
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fModifiers=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType),-1,-1,4,"fBaseType=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClass),-1,-1,4,"fBaseClass=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Reflex::Scope */
static void G__setup_memvarReflexcLcLScope(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope));
   { Reflex::Scope *p; p=(Reflex::Scope*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScopeName),-1,-1,4,"fScopeName=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Reflex::Object */
static void G__setup_memvarReflexcLcLObject(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLObject));
   { Reflex::Object *p; p=(Reflex::Object*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType),-1,-1,4,"fType=",0,(char*)NULL);
   G__memvar_setup((void*)0,89,0,0,-1,-1,-1,4,"fAddress=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Reflex::Member */
static void G__setup_memvarReflexcLcLMember(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember));
   { Reflex::Member *p; p=(Reflex::Member*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMemberBase),-1,-1,4,"fMemberBase=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Reflex::TypeTemplate */
static void G__setup_memvarReflexcLcLTypeTemplate(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypeTemplate));
   { Reflex::TypeTemplate *p; p=(Reflex::TypeTemplate*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypeTemplateName),-1,-1,4,"fTypeTemplateName=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Reflex::MemberTemplate */
static void G__setup_memvarReflexcLcLMemberTemplate(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMemberTemplate));
   { Reflex::MemberTemplate *p; p=(Reflex::MemberTemplate*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,1,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMemberTemplateName),-1,-1,4,"fMemberTemplateName=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Reflex::Dummy */
static void G__setup_memvarReflexcLcLDummy(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLDummy));
   {
   }
   G__tag_memvar_reset();
}


   /* Reflex::Instance */
static void G__setup_memvarReflexcLcLInstance(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLInstance));
   { Reflex::Instance *p; p=(Reflex::Instance*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLInstance),-1,-2,4,"fgSingleton=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,-1,-2,4,"fgHasShutdown=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Reflex::NullType */
static void G__setup_memvarReflexcLcLNullType(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNullType));
   { Reflex::NullType *p; p=(Reflex::NullType*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Reflex::UnknownType */
static void G__setup_memvarReflexcLcLUnknownType(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnknownType));
   { Reflex::UnknownType *p; p=(Reflex::UnknownType*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Reflex::ProtectedClass */
static void G__setup_memvarReflexcLcLProtectedClass(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedClass));
   { Reflex::ProtectedClass *p; p=(Reflex::ProtectedClass*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Reflex::ProtectedEnum */
static void G__setup_memvarReflexcLcLProtectedEnum(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedEnum));
   { Reflex::ProtectedEnum *p; p=(Reflex::ProtectedEnum*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Reflex::ProtectedStruct */
static void G__setup_memvarReflexcLcLProtectedStruct(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedStruct));
   { Reflex::ProtectedStruct *p; p=(Reflex::ProtectedStruct*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Reflex::ProtectedUnion */
static void G__setup_memvarReflexcLcLProtectedUnion(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedUnion));
   { Reflex::ProtectedUnion *p; p=(Reflex::ProtectedUnion*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Reflex::PrivateClass */
static void G__setup_memvarReflexcLcLPrivateClass(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateClass));
   { Reflex::PrivateClass *p; p=(Reflex::PrivateClass*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Reflex::PrivateEnum */
static void G__setup_memvarReflexcLcLPrivateEnum(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateEnum));
   { Reflex::PrivateEnum *p; p=(Reflex::PrivateEnum*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Reflex::PrivateStruct */
static void G__setup_memvarReflexcLcLPrivateStruct(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateStruct));
   { Reflex::PrivateStruct *p; p=(Reflex::PrivateStruct*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Reflex::PrivateUnion */
static void G__setup_memvarReflexcLcLPrivateUnion(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateUnion));
   { Reflex::PrivateUnion *p; p=(Reflex::PrivateUnion*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Reflex::UnnamedClass */
static void G__setup_memvarReflexcLcLUnnamedClass(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedClass));
   { Reflex::UnnamedClass *p; p=(Reflex::UnnamedClass*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Reflex::UnnamedEnum */
static void G__setup_memvarReflexcLcLUnnamedEnum(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedEnum));
   { Reflex::UnnamedEnum *p; p=(Reflex::UnnamedEnum*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Reflex::UnnamedNamespace */
static void G__setup_memvarReflexcLcLUnnamedNamespace(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedNamespace));
   { Reflex::UnnamedNamespace *p; p=(Reflex::UnnamedNamespace*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Reflex::UnnamedStruct */
static void G__setup_memvarReflexcLcLUnnamedStruct(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedStruct));
   { Reflex::UnnamedStruct *p; p=(Reflex::UnnamedStruct*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Reflex::UnnamedUnion */
static void G__setup_memvarReflexcLcLUnnamedUnion(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedUnion));
   { Reflex::UnnamedUnion *p; p=(Reflex::UnnamedUnion*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Reflex::RuntimeError */
static void G__setup_memvarReflexcLcLRuntimeError(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLRuntimeError));
   { Reflex::RuntimeError *p; p=(Reflex::RuntimeError*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->fMsg)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__G__ReflexLN_string),-1,-1,1,"fMsg=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Reflex::ICallback */
static void G__setup_memvarReflexcLcLICallback(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLICallback));
   { Reflex::ICallback *p; p=(Reflex::ICallback*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Reflex::Tools */
static void G__setup_memvarReflexcLcLTools(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTools));
   {
   }
   G__tag_memvar_reset();
}


   /* Reflex::NamespaceBuilder */
static void G__setup_memvarReflexcLcLNamespaceBuilder(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNamespaceBuilder));
   { Reflex::NamespaceBuilder *p; p=(Reflex::NamespaceBuilder*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope),-1,-1,4,"fNamespace=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Reflex::FunctionBuilder */
static void G__setup_memvarReflexcLcLFunctionBuilder(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLFunctionBuilder));
   { Reflex::FunctionBuilder *p; p=(Reflex::FunctionBuilder*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember),-1,-1,4,"fFunction=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Reflex::FunctionBuilderImpl */
static void G__setup_memvarReflexcLcLFunctionBuilderImpl(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLFunctionBuilderImpl));
   { Reflex::FunctionBuilderImpl *p; p=(Reflex::FunctionBuilderImpl*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember),-1,-1,4,"fFunction=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Reflex::ClassBuilder */
static void G__setup_memvarReflexcLcLClassBuilder(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilder));
   { Reflex::ClassBuilder *p; p=(Reflex::ClassBuilder*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilderImpl),-1,-1,4,"fClassBuilderImpl=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Reflex::ClassBuilderImpl */
static void G__setup_memvarReflexcLcLClassBuilderImpl(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilderImpl));
   { Reflex::ClassBuilderImpl *p; p=(Reflex::ClassBuilderImpl*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClass),-1,-1,4,"fClass=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember),-1,-1,4,"fLastMember=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"fNewClass=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"fCallbackEnabled=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Reflex::CollFuncTable */
static void G__setup_memvarReflexcLcLCollFuncTable(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLCollFuncTable));
   { Reflex::CollFuncTable *p; p=(Reflex::CollFuncTable*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->iter_size)-(long)(p)),104,0,0,-1,G__defined_typename("size_t"),-1,1,"iter_size=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->value_diff)-(long)(p)),104,0,0,-1,G__defined_typename("size_t"),-1,1,"value_diff=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->value_offset)-(long)(p)),105,0,0,-1,-1,-1,1,"value_offset=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->size_func)-(long)(p)),49,0,0,-1,G__defined_typename("void* (*)(void*)"),-1,1,"size_func=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->resize_func)-(long)(p)),49,0,0,-1,G__defined_typename("void* (*)(void*)"),-1,1,"resize_func=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->clear_func)-(long)(p)),49,0,0,-1,G__defined_typename("void* (*)(void*)"),-1,1,"clear_func=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->first_func)-(long)(p)),49,0,0,-1,G__defined_typename("void* (*)(void*)"),-1,1,"first_func=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->next_func)-(long)(p)),49,0,0,-1,G__defined_typename("void* (*)(void*)"),-1,1,"next_func=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->construct_func)-(long)(p)),49,0,0,-1,G__defined_typename("void* (*)(void*)"),-1,1,"construct_func=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->destruct_func)-(long)(p)),49,0,0,-1,G__defined_typename("void* (*)(void*)"),-1,1,"destruct_func=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->feed_func)-(long)(p)),49,0,0,-1,G__defined_typename("void* (*)(void*)"),-1,1,"feed_func=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->collect_func)-(long)(p)),49,0,0,-1,G__defined_typename("void* (*)(void*)"),-1,1,"collect_func=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->create_env)-(long)(p)),49,0,0,-1,G__defined_typename("void* (*)()"),-1,1,"create_env=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Reflex::Selection::NO_SELF_AUTOSELECT */
static void G__setup_memvarReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT));
   { Reflex::Selection::NO_SELF_AUTOSELECT *p; p=(Reflex::Selection::NO_SELF_AUTOSELECT*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Reflex::Selection::TRANSIENT */
static void G__setup_memvarReflexcLcLSelectioncLcLTRANSIENT(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLTRANSIENT));
   { Reflex::Selection::TRANSIENT *p; p=(Reflex::Selection::TRANSIENT*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Reflex::Selection::AUTOSELECT */
static void G__setup_memvarReflexcLcLSelectioncLcLAUTOSELECT(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLAUTOSELECT));
   { Reflex::Selection::AUTOSELECT *p; p=(Reflex::Selection::AUTOSELECT*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Reflex::Selection::NODEFAULT */
static void G__setup_memvarReflexcLcLSelectioncLcLNODEFAULT(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLNODEFAULT));
   { Reflex::Selection::NODEFAULT *p; p=(Reflex::Selection::NODEFAULT*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Reflex::EnumBuilder */
static void G__setup_memvarReflexcLcLEnumBuilder(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEnumBuilder));
   { Reflex::EnumBuilder *p; p=(Reflex::EnumBuilder*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEnum),-1,-1,4,"fEnum=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember),-1,-1,4,"fLastMember=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Reflex::NewDelFunctions */
static void G__setup_memvarReflexcLcLNewDelFunctions(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNewDelFunctions));
   { Reflex::NewDelFunctions *p; p=(Reflex::NewDelFunctions*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->fNew)-(long)(p)),89,0,0,-1,G__defined_typename("NewFunc_t"),-1,1,"fNew=",0,"pointer to a function newing one object.");
   G__memvar_setup((void*)((long)(&p->fNewArray)-(long)(p)),89,0,0,-1,G__defined_typename("NewArrFunc_t"),-1,1,"fNewArray=",0,"pointer to a function newing an array of objects.");
   G__memvar_setup((void*)((long)(&p->fDelete)-(long)(p)),89,0,0,-1,G__defined_typename("DelFunc_t"),-1,1,"fDelete=",0,"pointer to a function deleting one object.");
   G__memvar_setup((void*)((long)(&p->fDeleteArray)-(long)(p)),89,0,0,-1,G__defined_typename("DelArrFunc_t"),-1,1,"fDeleteArray=",0,"pointer to a function deleting an array of objects.");
   G__memvar_setup((void*)((long)(&p->fDestructor)-(long)(p)),89,0,0,-1,G__defined_typename("DesFunc_t"),-1,1,"fDestructor=",0,"pointer to a function call an object's destructor.");
   }
   G__tag_memvar_reset();
}


   /* Reflex::TypedefBuilderImpl */
static void G__setup_memvarReflexcLcLTypedefBuilderImpl(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypedefBuilderImpl));
   { Reflex::TypedefBuilderImpl *p; p=(Reflex::TypedefBuilderImpl*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType),-1,-1,4,"fTypedef=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Reflex::UnionBuilderImpl */
static void G__setup_memvarReflexcLcLUnionBuilderImpl(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnionBuilderImpl));
   { Reflex::UnionBuilderImpl *p; p=(Reflex::UnionBuilderImpl*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnion),-1,-1,4,"fUnion=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember),-1,-1,4,"fLastMember=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"fCallbackEnabled=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Reflex::VariableBuilder */
static void G__setup_memvarReflexcLcLVariableBuilder(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLVariableBuilder));
   { Reflex::VariableBuilder *p; p=(Reflex::VariableBuilder*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember),-1,-1,4,"fDataMember=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Reflex::VariableBuilderImpl */
static void G__setup_memvarReflexcLcLVariableBuilderImpl(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLVariableBuilderImpl));
   { Reflex::VariableBuilderImpl *p; p=(Reflex::VariableBuilderImpl*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember),-1,-1,4,"fDataMember=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvarG__Reflex() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncReflex(void) {
   /* Reflex */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_Reflex));
   G__memfunc_setup("Argv0",448,G__G__Reflex_102_0_1, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 1, 0, 1, 1, 1, "", "returns \"Reflex\";", (void*) G__func2void( (const string& (*)())(&Reflex::Argv0) ), 0);
   G__memfunc_setup("NPos",384,G__G__Reflex_102_0_2, 104, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) G__func2void( (size_t (*)())(&Reflex::NPos) ), 0);
   G__memfunc_setup("operator<<",996,G__G__Reflex_102_0_3, 117, G__get_linked_tagnum(&G__G__ReflexLN_basic_ostreamlEcharcOchar_traitslEchargRsPgR), G__defined_typename("ostream"), 1, 2, 1, 1, 0, 
"u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 - - u 'Reflex::Any' - 11 - -", (char*)NULL, (void*) G__func2void( (ostream& (*)(ostream&, const Reflex::Any&))(&Reflex::operator<<) ), 0);
   G__memfunc_setup("operator<",936,G__G__Reflex_102_0_4, 103, -1, -1, 0, 2, 1, 1, 0, 
"u 'Reflex::Scope' - 11 - lh u 'Reflex::Scope' - 11 - rh", (char*)NULL, (void*) G__func2void( (bool (*)(const Reflex::Scope&, const Reflex::Scope&))(&Reflex::operator<) ), 0);
   G__memfunc_setup("operator==",998,G__G__Reflex_102_0_5, 103, -1, -1, 0, 2, 1, 1, 0, 
"u 'Reflex::Scope' - 11 - lh u 'Reflex::Scope' - 11 - rh", (char*)NULL, (void*) G__func2void( (bool (*)(const Reflex::Scope&, const Reflex::Scope&))(&Reflex::operator==) ), 0);
   G__memfunc_setup("operator<<",996,G__G__Reflex_102_0_6, 117, G__get_linked_tagnum(&G__G__ReflexLN_basic_ostreamlEcharcOchar_traitslEchargRsPgR), G__defined_typename("ostream"), 1, 2, 1, 1, 0, 
"u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 - s u 'Reflex::PropertyList' - 11 - p", (char*)NULL, (void*) G__func2void( (ostream& (*)(ostream&, const Reflex::PropertyList&))(&Reflex::operator<<) ), 0);
   G__memfunc_setup("operator<<",996,G__G__Reflex_102_0_7, 117, G__get_linked_tagnum(&G__G__ReflexLN_basic_ostreamlEcharcOchar_traitslEchargRsPgR), G__defined_typename("ostream"), 1, 2, 1, 1, 0, 
"u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 - s u 'Reflex::PropertyListImpl' - 11 - p", (char*)NULL, (void*) G__func2void( (ostream& (*)(ostream&, const Reflex::PropertyListImpl&))(&Reflex::operator<<) ), 0);
   G__memfunc_setup("InstallClassCallback",2010,G__G__Reflex_102_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "U 'Reflex::ICallback' - 0 - cb", (char*)NULL, (void*) G__func2void( (void (*)(Reflex::ICallback*))(&Reflex::InstallClassCallback) ), 0);
   G__memfunc_setup("UninstallClassCallback",2237,G__G__Reflex_102_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "U 'Reflex::ICallback' - 0 - cb", (char*)NULL, (void*) G__func2void( (void (*)(Reflex::ICallback*))(&Reflex::UninstallClassCallback) ), 0);
   G__memfunc_setup("FireClassCallback",1673,G__G__Reflex_102_0_10, 121, -1, -1, 0, 1, 1, 1, 0, "u 'Reflex::Type' - 11 - -", (char*)NULL, (void*) G__func2void( (void (*)(const Reflex::Type&))(&Reflex::FireClassCallback) ), 0);
   G__memfunc_setup("FireFunctionCallback",2009,G__G__Reflex_102_0_11, 121, -1, -1, 0, 1, 1, 1, 0, "u 'Reflex::Member' - 11 - -", (char*)NULL, (void*) G__func2void( (void (*)(const Reflex::Member&))(&Reflex::FireFunctionCallback) ), 0);
   G__memfunc_setup("TypeBuilder",1129,G__G__Reflex_102_0_12, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 2, 1, 1, 0, 
"C - - 10 - n h - - 0 '0' modifiers", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const char*, unsigned int))(&Reflex::TypeBuilder) ), 0);
   G__memfunc_setup("ConstBuilder",1230,G__G__Reflex_102_0_13, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 1, 1, 1, 0, "u 'Reflex::Type' - 11 - t", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&))(&Reflex::ConstBuilder) ), 0);
   G__memfunc_setup("VolatileBuilder",1543,G__G__Reflex_102_0_14, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 1, 1, 1, 0, "u 'Reflex::Type' - 11 - t", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&))(&Reflex::VolatileBuilder) ), 0);
   G__memfunc_setup("PointerBuilder",1448,G__G__Reflex_102_0_15, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 2, 1, 1, 0, 
"u 'Reflex::Type' - 11 - t u 'type_info' - 11 'typeid(UnknownType)' ti", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const type_info&))(&Reflex::PointerBuilder) ), 0);
   G__memfunc_setup("PointerToMemberBuilder",2243,G__G__Reflex_102_0_16, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 3, 1, 1, 0, 
"u 'Reflex::Type' - 11 - t u 'Reflex::Scope' - 11 - s "
"u 'type_info' - 11 'typeid(UnknownType)' ti", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Scope&, const type_info&))(&Reflex::PointerToMemberBuilder) ), 0);
   G__memfunc_setup("ReferenceBuilder",1622,G__G__Reflex_102_0_17, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 1, 1, 1, 0, "u 'Reflex::Type' - 11 - t", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&))(&Reflex::ReferenceBuilder) ), 0);
   G__memfunc_setup("ArrayBuilder",1222,G__G__Reflex_102_0_18, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 3, 1, 1, 0, 
"u 'Reflex::Type' - 11 - t h - 'size_t' 0 - n "
"u 'type_info' - 11 'typeid(UnknownType)' ti", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, size_t, const type_info&))(&Reflex::ArrayBuilder) ), 0);
   G__memfunc_setup("EnumTypeBuilder",1534,G__G__Reflex_102_0_19, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 4, 1, 1, 0, 
"C - - 10 - - C - - 10 '\"\"' items "
"u 'type_info' - 11 'typeid(UnknownType)' ti h - - 0 '0' modifiers", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const char*, const char*, const type_info&, unsigned int))(&Reflex::EnumTypeBuilder) ), 0);
   G__memfunc_setup("TypedefTypeBuilder",1850,G__G__Reflex_102_0_20, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 3, 1, 1, 0, 
"C - - 10 - Name u 'Reflex::Type' - 11 - t "
"i 'Reflex::REPRESTYPE' - 0 'REPRES_NOTYPE' represType", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const char*, const Reflex::Type&, Reflex::REPRESTYPE))(&Reflex::TypedefTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_21, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 3, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'vector<Reflex::Type,allocator<Reflex::Type> >' 'vector<Reflex::Type>' 11 - p "
"u 'type_info' - 11 'typeid(UnknownType)' ti", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const vector<Reflex::Type>&, const type_info&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_22, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 1, 1, 1, 0, "u 'Reflex::Type' - 11 - r", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_23, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 2, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_24, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 3, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_25, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 4, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_26, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 5, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_27, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 6, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_28, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 7, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_29, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 8, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_30, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 9, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_31, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 10, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7 u 'Reflex::Type' - 11 - t8", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_32, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 11, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7 u 'Reflex::Type' - 11 - t8 "
"u 'Reflex::Type' - 11 - t9", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_33, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 12, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7 u 'Reflex::Type' - 11 - t8 "
"u 'Reflex::Type' - 11 - t9 u 'Reflex::Type' - 11 - t10", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_34, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 13, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7 u 'Reflex::Type' - 11 - t8 "
"u 'Reflex::Type' - 11 - t9 u 'Reflex::Type' - 11 - t10 "
"u 'Reflex::Type' - 11 - t11", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_35, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 14, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7 u 'Reflex::Type' - 11 - t8 "
"u 'Reflex::Type' - 11 - t9 u 'Reflex::Type' - 11 - t10 "
"u 'Reflex::Type' - 11 - t11 u 'Reflex::Type' - 11 - t12", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_36, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 15, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7 u 'Reflex::Type' - 11 - t8 "
"u 'Reflex::Type' - 11 - t9 u 'Reflex::Type' - 11 - t10 "
"u 'Reflex::Type' - 11 - t11 u 'Reflex::Type' - 11 - t12 "
"u 'Reflex::Type' - 11 - t13", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_37, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 16, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7 u 'Reflex::Type' - 11 - t8 "
"u 'Reflex::Type' - 11 - t9 u 'Reflex::Type' - 11 - t10 "
"u 'Reflex::Type' - 11 - t11 u 'Reflex::Type' - 11 - t12 "
"u 'Reflex::Type' - 11 - t13 u 'Reflex::Type' - 11 - t14", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_38, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 17, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7 u 'Reflex::Type' - 11 - t8 "
"u 'Reflex::Type' - 11 - t9 u 'Reflex::Type' - 11 - t10 "
"u 'Reflex::Type' - 11 - t11 u 'Reflex::Type' - 11 - t12 "
"u 'Reflex::Type' - 11 - t13 u 'Reflex::Type' - 11 - t14 "
"u 'Reflex::Type' - 11 - t15", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_39, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 18, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7 u 'Reflex::Type' - 11 - t8 "
"u 'Reflex::Type' - 11 - t9 u 'Reflex::Type' - 11 - t10 "
"u 'Reflex::Type' - 11 - t11 u 'Reflex::Type' - 11 - t12 "
"u 'Reflex::Type' - 11 - t13 u 'Reflex::Type' - 11 - t14 "
"u 'Reflex::Type' - 11 - t15 u 'Reflex::Type' - 11 - t16", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_40, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 19, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7 u 'Reflex::Type' - 11 - t8 "
"u 'Reflex::Type' - 11 - t9 u 'Reflex::Type' - 11 - t10 "
"u 'Reflex::Type' - 11 - t11 u 'Reflex::Type' - 11 - t12 "
"u 'Reflex::Type' - 11 - t13 u 'Reflex::Type' - 11 - t14 "
"u 'Reflex::Type' - 11 - t15 u 'Reflex::Type' - 11 - t16 "
"u 'Reflex::Type' - 11 - t17", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_41, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 20, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7 u 'Reflex::Type' - 11 - t8 "
"u 'Reflex::Type' - 11 - t9 u 'Reflex::Type' - 11 - t10 "
"u 'Reflex::Type' - 11 - t11 u 'Reflex::Type' - 11 - t12 "
"u 'Reflex::Type' - 11 - t13 u 'Reflex::Type' - 11 - t14 "
"u 'Reflex::Type' - 11 - t15 u 'Reflex::Type' - 11 - t16 "
"u 'Reflex::Type' - 11 - t17 u 'Reflex::Type' - 11 - t18", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_42, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 21, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7 u 'Reflex::Type' - 11 - t8 "
"u 'Reflex::Type' - 11 - t9 u 'Reflex::Type' - 11 - t10 "
"u 'Reflex::Type' - 11 - t11 u 'Reflex::Type' - 11 - t12 "
"u 'Reflex::Type' - 11 - t13 u 'Reflex::Type' - 11 - t14 "
"u 'Reflex::Type' - 11 - t15 u 'Reflex::Type' - 11 - t16 "
"u 'Reflex::Type' - 11 - t17 u 'Reflex::Type' - 11 - t18 "
"u 'Reflex::Type' - 11 - t19", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_43, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 22, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7 u 'Reflex::Type' - 11 - t8 "
"u 'Reflex::Type' - 11 - t9 u 'Reflex::Type' - 11 - t10 "
"u 'Reflex::Type' - 11 - t11 u 'Reflex::Type' - 11 - t12 "
"u 'Reflex::Type' - 11 - t13 u 'Reflex::Type' - 11 - t14 "
"u 'Reflex::Type' - 11 - t15 u 'Reflex::Type' - 11 - t16 "
"u 'Reflex::Type' - 11 - t17 u 'Reflex::Type' - 11 - t18 "
"u 'Reflex::Type' - 11 - t19 u 'Reflex::Type' - 11 - t20", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_44, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 23, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7 u 'Reflex::Type' - 11 - t8 "
"u 'Reflex::Type' - 11 - t9 u 'Reflex::Type' - 11 - t10 "
"u 'Reflex::Type' - 11 - t11 u 'Reflex::Type' - 11 - t12 "
"u 'Reflex::Type' - 11 - t13 u 'Reflex::Type' - 11 - t14 "
"u 'Reflex::Type' - 11 - t15 u 'Reflex::Type' - 11 - t16 "
"u 'Reflex::Type' - 11 - t17 u 'Reflex::Type' - 11 - t18 "
"u 'Reflex::Type' - 11 - t19 u 'Reflex::Type' - 11 - t20 "
"u 'Reflex::Type' - 11 - t21", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_45, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 24, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7 u 'Reflex::Type' - 11 - t8 "
"u 'Reflex::Type' - 11 - t9 u 'Reflex::Type' - 11 - t10 "
"u 'Reflex::Type' - 11 - t11 u 'Reflex::Type' - 11 - t12 "
"u 'Reflex::Type' - 11 - t13 u 'Reflex::Type' - 11 - t14 "
"u 'Reflex::Type' - 11 - t15 u 'Reflex::Type' - 11 - t16 "
"u 'Reflex::Type' - 11 - t17 u 'Reflex::Type' - 11 - t18 "
"u 'Reflex::Type' - 11 - t19 u 'Reflex::Type' - 11 - t20 "
"u 'Reflex::Type' - 11 - t21 u 'Reflex::Type' - 11 - t22", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_46, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 25, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7 u 'Reflex::Type' - 11 - t8 "
"u 'Reflex::Type' - 11 - t9 u 'Reflex::Type' - 11 - t10 "
"u 'Reflex::Type' - 11 - t11 u 'Reflex::Type' - 11 - t12 "
"u 'Reflex::Type' - 11 - t13 u 'Reflex::Type' - 11 - t14 "
"u 'Reflex::Type' - 11 - t15 u 'Reflex::Type' - 11 - t16 "
"u 'Reflex::Type' - 11 - t17 u 'Reflex::Type' - 11 - t18 "
"u 'Reflex::Type' - 11 - t19 u 'Reflex::Type' - 11 - t20 "
"u 'Reflex::Type' - 11 - t21 u 'Reflex::Type' - 11 - t22 "
"u 'Reflex::Type' - 11 - t23", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_47, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 26, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7 u 'Reflex::Type' - 11 - t8 "
"u 'Reflex::Type' - 11 - t9 u 'Reflex::Type' - 11 - t10 "
"u 'Reflex::Type' - 11 - t11 u 'Reflex::Type' - 11 - t12 "
"u 'Reflex::Type' - 11 - t13 u 'Reflex::Type' - 11 - t14 "
"u 'Reflex::Type' - 11 - t15 u 'Reflex::Type' - 11 - t16 "
"u 'Reflex::Type' - 11 - t17 u 'Reflex::Type' - 11 - t18 "
"u 'Reflex::Type' - 11 - t19 u 'Reflex::Type' - 11 - t20 "
"u 'Reflex::Type' - 11 - t21 u 'Reflex::Type' - 11 - t22 "
"u 'Reflex::Type' - 11 - t23 u 'Reflex::Type' - 11 - t24", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_48, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 27, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7 u 'Reflex::Type' - 11 - t8 "
"u 'Reflex::Type' - 11 - t9 u 'Reflex::Type' - 11 - t10 "
"u 'Reflex::Type' - 11 - t11 u 'Reflex::Type' - 11 - t12 "
"u 'Reflex::Type' - 11 - t13 u 'Reflex::Type' - 11 - t14 "
"u 'Reflex::Type' - 11 - t15 u 'Reflex::Type' - 11 - t16 "
"u 'Reflex::Type' - 11 - t17 u 'Reflex::Type' - 11 - t18 "
"u 'Reflex::Type' - 11 - t19 u 'Reflex::Type' - 11 - t20 "
"u 'Reflex::Type' - 11 - t21 u 'Reflex::Type' - 11 - t22 "
"u 'Reflex::Type' - 11 - t23 u 'Reflex::Type' - 11 - t24 "
"u 'Reflex::Type' - 11 - t25", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_49, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 28, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7 u 'Reflex::Type' - 11 - t8 "
"u 'Reflex::Type' - 11 - t9 u 'Reflex::Type' - 11 - t10 "
"u 'Reflex::Type' - 11 - t11 u 'Reflex::Type' - 11 - t12 "
"u 'Reflex::Type' - 11 - t13 u 'Reflex::Type' - 11 - t14 "
"u 'Reflex::Type' - 11 - t15 u 'Reflex::Type' - 11 - t16 "
"u 'Reflex::Type' - 11 - t17 u 'Reflex::Type' - 11 - t18 "
"u 'Reflex::Type' - 11 - t19 u 'Reflex::Type' - 11 - t20 "
"u 'Reflex::Type' - 11 - t21 u 'Reflex::Type' - 11 - t22 "
"u 'Reflex::Type' - 11 - t23 u 'Reflex::Type' - 11 - t24 "
"u 'Reflex::Type' - 11 - t25 u 'Reflex::Type' - 11 - t26", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_50, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 29, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7 u 'Reflex::Type' - 11 - t8 "
"u 'Reflex::Type' - 11 - t9 u 'Reflex::Type' - 11 - t10 "
"u 'Reflex::Type' - 11 - t11 u 'Reflex::Type' - 11 - t12 "
"u 'Reflex::Type' - 11 - t13 u 'Reflex::Type' - 11 - t14 "
"u 'Reflex::Type' - 11 - t15 u 'Reflex::Type' - 11 - t16 "
"u 'Reflex::Type' - 11 - t17 u 'Reflex::Type' - 11 - t18 "
"u 'Reflex::Type' - 11 - t19 u 'Reflex::Type' - 11 - t20 "
"u 'Reflex::Type' - 11 - t21 u 'Reflex::Type' - 11 - t22 "
"u 'Reflex::Type' - 11 - t23 u 'Reflex::Type' - 11 - t24 "
"u 'Reflex::Type' - 11 - t25 u 'Reflex::Type' - 11 - t26 "
"u 'Reflex::Type' - 11 - t27", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_51, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 30, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7 u 'Reflex::Type' - 11 - t8 "
"u 'Reflex::Type' - 11 - t9 u 'Reflex::Type' - 11 - t10 "
"u 'Reflex::Type' - 11 - t11 u 'Reflex::Type' - 11 - t12 "
"u 'Reflex::Type' - 11 - t13 u 'Reflex::Type' - 11 - t14 "
"u 'Reflex::Type' - 11 - t15 u 'Reflex::Type' - 11 - t16 "
"u 'Reflex::Type' - 11 - t17 u 'Reflex::Type' - 11 - t18 "
"u 'Reflex::Type' - 11 - t19 u 'Reflex::Type' - 11 - t20 "
"u 'Reflex::Type' - 11 - t21 u 'Reflex::Type' - 11 - t22 "
"u 'Reflex::Type' - 11 - t23 u 'Reflex::Type' - 11 - t24 "
"u 'Reflex::Type' - 11 - t25 u 'Reflex::Type' - 11 - t26 "
"u 'Reflex::Type' - 11 - t27 u 'Reflex::Type' - 11 - t28", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_52, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 31, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7 u 'Reflex::Type' - 11 - t8 "
"u 'Reflex::Type' - 11 - t9 u 'Reflex::Type' - 11 - t10 "
"u 'Reflex::Type' - 11 - t11 u 'Reflex::Type' - 11 - t12 "
"u 'Reflex::Type' - 11 - t13 u 'Reflex::Type' - 11 - t14 "
"u 'Reflex::Type' - 11 - t15 u 'Reflex::Type' - 11 - t16 "
"u 'Reflex::Type' - 11 - t17 u 'Reflex::Type' - 11 - t18 "
"u 'Reflex::Type' - 11 - t19 u 'Reflex::Type' - 11 - t20 "
"u 'Reflex::Type' - 11 - t21 u 'Reflex::Type' - 11 - t22 "
"u 'Reflex::Type' - 11 - t23 u 'Reflex::Type' - 11 - t24 "
"u 'Reflex::Type' - 11 - t25 u 'Reflex::Type' - 11 - t26 "
"u 'Reflex::Type' - 11 - t27 u 'Reflex::Type' - 11 - t28 "
"u 'Reflex::Type' - 11 - t29", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_53, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 32, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7 u 'Reflex::Type' - 11 - t8 "
"u 'Reflex::Type' - 11 - t9 u 'Reflex::Type' - 11 - t10 "
"u 'Reflex::Type' - 11 - t11 u 'Reflex::Type' - 11 - t12 "
"u 'Reflex::Type' - 11 - t13 u 'Reflex::Type' - 11 - t14 "
"u 'Reflex::Type' - 11 - t15 u 'Reflex::Type' - 11 - t16 "
"u 'Reflex::Type' - 11 - t17 u 'Reflex::Type' - 11 - t18 "
"u 'Reflex::Type' - 11 - t19 u 'Reflex::Type' - 11 - t20 "
"u 'Reflex::Type' - 11 - t21 u 'Reflex::Type' - 11 - t22 "
"u 'Reflex::Type' - 11 - t23 u 'Reflex::Type' - 11 - t24 "
"u 'Reflex::Type' - 11 - t25 u 'Reflex::Type' - 11 - t26 "
"u 'Reflex::Type' - 11 - t27 u 'Reflex::Type' - 11 - t28 "
"u 'Reflex::Type' - 11 - t29 u 'Reflex::Type' - 11 - t30", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__memfunc_setup("FunctionTypeBuilder",1967,G__G__Reflex_102_0_54, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 33, 1, 1, 0, 
"u 'Reflex::Type' - 11 - r u 'Reflex::Type' - 11 - t0 "
"u 'Reflex::Type' - 11 - t1 u 'Reflex::Type' - 11 - t2 "
"u 'Reflex::Type' - 11 - t3 u 'Reflex::Type' - 11 - t4 "
"u 'Reflex::Type' - 11 - t5 u 'Reflex::Type' - 11 - t6 "
"u 'Reflex::Type' - 11 - t7 u 'Reflex::Type' - 11 - t8 "
"u 'Reflex::Type' - 11 - t9 u 'Reflex::Type' - 11 - t10 "
"u 'Reflex::Type' - 11 - t11 u 'Reflex::Type' - 11 - t12 "
"u 'Reflex::Type' - 11 - t13 u 'Reflex::Type' - 11 - t14 "
"u 'Reflex::Type' - 11 - t15 u 'Reflex::Type' - 11 - t16 "
"u 'Reflex::Type' - 11 - t17 u 'Reflex::Type' - 11 - t18 "
"u 'Reflex::Type' - 11 - t19 u 'Reflex::Type' - 11 - t20 "
"u 'Reflex::Type' - 11 - t21 u 'Reflex::Type' - 11 - t22 "
"u 'Reflex::Type' - 11 - t23 u 'Reflex::Type' - 11 - t24 "
"u 'Reflex::Type' - 11 - t25 u 'Reflex::Type' - 11 - t26 "
"u 'Reflex::Type' - 11 - t27 u 'Reflex::Type' - 11 - t28 "
"u 'Reflex::Type' - 11 - t29 u 'Reflex::Type' - 11 - t30 "
"u 'Reflex::Type' - 11 - t31", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&, const Reflex::Type&))(&Reflex::FunctionTypeBuilder) ), 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLAny(void) {
   /* Reflex::Any */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLAny));
   G__memfunc_setup("Any",296,G__G__Reflex_103_0_1, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLAny), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Any",296,G__G__Reflex_103_0_2, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLAny), -1, 0, 1, 1, 1, 0, "u 'Reflex::Any' - 11 - other", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clear",487,G__G__Reflex_103_0_3, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator bool",1336,G__G__Reflex_103_0_4, 103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Swap",411,G__G__Reflex_103_0_5, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLAny), -1, 1, 1, 1, 1, 0, "u 'Reflex::Any' - 1 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__Reflex_103_0_6, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLAny), -1, 1, 1, 1, 1, 0, "u 'Reflex::Any' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Empty",527,G__G__Reflex_103_0_7, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TypeInfo",814,G__G__Reflex_103_0_8, 117, G__get_linked_tagnum(&G__G__ReflexLN_type_info), -1, 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Address",710,G__G__Reflex_103_0_9, 89, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Any", 422, G__G__Reflex_103_0_10, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLType(void) {
   /* Reflex::Type */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType));
   G__memfunc_setup("Type",418,G__G__Reflex_104_0_1, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 2, 1, 1, 0, 
"U 'Reflex::TypeName' - 10 '0' typName h - - 0 '0' modifiers", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Type",418,G__G__Reflex_104_0_2, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 1, 1, 1, 0, "u 'Reflex::Type' - 11 - rh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Type",418,G__G__Reflex_104_0_3, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 3, 1, 1, 0, 
"u 'Reflex::Type' - 11 - rh h - - 0 - modifiers "
"i 'Reflex::Type::TYPE_MODIFICATION' - 0 'REPLACE' operation", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__Reflex_104_0_4, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 1, 1, 1, 1, 0, "u 'Reflex::Type' - 11 - rh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator==",998,G__G__Reflex_104_0_5, 103, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Type' - 11 - rh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator!=",970,G__G__Reflex_104_0_6, 103, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Type' - 11 - rh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator<",936,G__G__Reflex_104_0_7, 103, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Type' - 11 - rh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator Reflex::Scope",2144,G__G__Reflex_104_0_8, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator bool",1336,G__G__Reflex_104_0_9, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Allocate",805,G__G__Reflex_104_0_10, 89, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ArrayLength",1121,G__G__Reflex_104_0_11, 104, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("BaseAt",560,G__G__Reflex_104_0_12, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLBase), -1, 0, 1, 1, 1, 8, "h - 'size_t' 0 - nth", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("BaseSize",790,G__G__Reflex_104_0_13, 104, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Base_Begin",959,G__G__Reflex_104_0_14, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgRcLcLiterator), G__defined_typename("Reflex::Base_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Base_End",753,G__G__Reflex_104_0_15, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgRcLcLiterator), G__defined_typename("Reflex::Base_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Base_RBegin",1041,G__G__Reflex_104_0_16, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Base_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Base_REnd",835,G__G__Reflex_104_0_17, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Base_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ByName",572,G__G__Reflex_104_0_18, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 1, 3, 1, 0, "u 'string' - 11 - key", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const string&))(&Reflex::Type::ByName) ), 0);
   G__memfunc_setup("ByTypeInfo",1001,G__G__Reflex_104_0_19, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 1, 3, 1, 0, "u 'type_info' - 11 - tid", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(const type_info&))(&Reflex::Type::ByTypeInfo) ), 0);
   G__memfunc_setup("CastObject",994,G__G__Reflex_104_0_20, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLObject), -1, 0, 2, 1, 1, 8, 
"u 'Reflex::Type' - 11 - to u 'Reflex::Object' - 11 - obj", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Construct",965,G__G__Reflex_104_0_21, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLObject), -1, 0, 3, 1, 1, 8, 
"u 'Reflex::Type' - 11 'Type(0,0)' signature u 'vector<void*,allocator<void*> >' 'vector<void*>' 11 'std::vector<void*>()' values "
"Y - - 0 '0' mem", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DataMemberAt",1159,G__G__Reflex_104_0_22, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 2, 1, 1, 8, 
"h - 'size_t' 0 - nth i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DataMemberByName",1550,G__G__Reflex_104_0_23, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 2, 1, 1, 8, 
"u 'string' - 11 - nam i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DataMemberSize",1389,G__G__Reflex_104_0_24, 104, -1, G__defined_typename("size_t"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DataMember_Begin",1558,G__G__Reflex_104_0_25, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiterator), G__defined_typename("Reflex::Member_Iterator"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DataMember_End",1352,G__G__Reflex_104_0_26, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiterator), G__defined_typename("Reflex::Member_Iterator"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DataMember_RBegin",1640,G__G__Reflex_104_0_27, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Member_Iterator"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DataMember_REnd",1434,G__G__Reflex_104_0_28, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Member_Iterator"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Deallocate",1006,G__G__Reflex_104_0_29, 121, -1, -1, 0, 1, 1, 1, 8, "Y - - 0 - instance", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclaringScope",1411,G__G__Reflex_104_0_30, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Destruct",846,G__G__Reflex_104_0_31, 121, -1, -1, 0, 2, 1, 1, 8, 
"Y - - 0 - instance g - - 0 'true' dealloc", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DynamicType",1127,G__G__Reflex_104_0_32, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 1, 1, 1, 8, "u 'Reflex::Object' - 11 - obj", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FinalType",908,G__G__Reflex_104_0_33, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionMemberAt",1619,G__G__Reflex_104_0_34, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 2, 1, 1, 8, 
"h - 'size_t' 0 - nth i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionMemberByName",2010,G__G__Reflex_104_0_35, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 5, 1, 1, 8, 
"u 'string' - 11 - nam u 'Reflex::Type' - 11 'Type(0,0)' signature "
"h - - 0 '0' modifiers_mask i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh "
"i 'Reflex::EDELAYEDLOADSETTING' - 0 'DELAYEDLOAD_ON' allowDelayedLoad", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionMemberSize",1849,G__G__Reflex_104_0_36, 104, -1, G__defined_typename("size_t"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionMember_Begin",2018,G__G__Reflex_104_0_37, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiterator), G__defined_typename("Reflex::Member_Iterator"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionMember_End",1812,G__G__Reflex_104_0_38, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiterator), G__defined_typename("Reflex::Member_Iterator"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionMember_RBegin",2100,G__G__Reflex_104_0_39, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Member_Iterator"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionMember_REnd",1894,G__G__Reflex_104_0_40, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Member_Iterator"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionParameterAt",1948,G__G__Reflex_104_0_41, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 1, 1, 1, 8, "h - 'size_t' 0 - nth", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionParameterSize",2178,G__G__Reflex_104_0_42, 104, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionParameter_Begin",2347,G__G__Reflex_104_0_43, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiterator), G__defined_typename("Reflex::Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionParameter_End",2141,G__G__Reflex_104_0_44, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiterator), G__defined_typename("Reflex::Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionParameter_RBegin",2429,G__G__Reflex_104_0_45, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionParameter_REnd",2223,G__G__Reflex_104_0_46, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GenerateDict",1199,G__G__Reflex_104_0_47, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::DictionaryGenerator' - 1 - generator", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("HasBase",663,G__G__Reflex_104_0_48, 103, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Type' - 11 - cl", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Id",173,G__G__Reflex_104_0_49, 89, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsAbstract",1008,G__G__Reflex_104_0_50, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsArray",699,G__G__Reflex_104_0_51, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsClass",690,G__G__Reflex_104_0_52, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsComplete",1013,G__G__Reflex_104_0_53, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsConst",707,G__G__Reflex_104_0_54, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsConstVolatile",1539,G__G__Reflex_104_0_55, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsEnum",593,G__G__Reflex_104_0_56, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsEquivalentTo",1437,G__G__Reflex_104_0_57, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'Reflex::Type' - 11 - typ h - - 0 '0' modifiers_mask", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsSignatureEquivalentTo",2383,G__G__Reflex_104_0_58, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'Reflex::Type' - 11 - typ h - - 0 '0' modifiers_mask", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsFunction",1026,G__G__Reflex_104_0_59, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsFundamental",1323,G__G__Reflex_104_0_60, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsPrivate",919,G__G__Reflex_104_0_61, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsProtected",1126,G__G__Reflex_104_0_62, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsPublic",795,G__G__Reflex_104_0_63, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsPointer",925,G__G__Reflex_104_0_64, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsPointerToMember",1720,G__G__Reflex_104_0_65, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsReference",1099,G__G__Reflex_104_0_66, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsStruct",833,G__G__Reflex_104_0_67, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsTemplateInstance",1837,G__G__Reflex_104_0_68, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsTypedef",909,G__G__Reflex_104_0_69, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsUnion",709,G__G__Reflex_104_0_70, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsUnqualified",1331,G__G__Reflex_104_0_71, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsVirtual",931,G__G__Reflex_104_0_72, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsVolatile",1020,G__G__Reflex_104_0_73, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MemberAt",781,G__G__Reflex_104_0_74, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 2, 1, 1, 8, 
"h - 'size_t' 0 - nth i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MemberByName",1172,G__G__Reflex_104_0_75, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 3, 1, 1, 8, 
"u 'string' - 11 - nam u 'Reflex::Type' - 11 'Type(0,0)' signature "
"i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MemberSize",1011,G__G__Reflex_104_0_76, 104, -1, G__defined_typename("size_t"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Member_Begin",1180,G__G__Reflex_104_0_77, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiterator), G__defined_typename("Reflex::Member_Iterator"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Member_End",974,G__G__Reflex_104_0_78, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiterator), G__defined_typename("Reflex::Member_Iterator"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Member_RBegin",1262,G__G__Reflex_104_0_79, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Member_Iterator"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Member_REnd",1056,G__G__Reflex_104_0_80, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Member_Iterator"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MemberTemplateAt",1609,G__G__Reflex_104_0_81, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMemberTemplate), -1, 0, 1, 1, 1, 8, "h - 'size_t' 0 - nth", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MemberTemplateSize",1839,G__G__Reflex_104_0_82, 104, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MemberTemplate_Begin",2008,G__G__Reflex_104_0_83, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgRcLcLiterator), G__defined_typename("Reflex::MemberTemplate_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MemberTemplate_End",1802,G__G__Reflex_104_0_84, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgRcLcLiterator), G__defined_typename("Reflex::MemberTemplate_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MemberTemplate_RBegin",2090,G__G__Reflex_104_0_85, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_MemberTemplate_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MemberTemplate_REnd",1884,G__G__Reflex_104_0_86, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_MemberTemplate_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Name",385,G__G__Reflex_104_0_87, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 0, 1, 1, 1, 8, "h - - 0 '0' mod", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Name_c_str",1019,G__G__Reflex_104_0_88, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PointerToMemberScope",2038,G__G__Reflex_104_0_89, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Properties",1069,G__G__Reflex_104_0_90, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPropertyList), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RawType",716,G__G__Reflex_104_0_91, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ReturnType",1058,G__G__Reflex_104_0_92, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SizeOf",592,G__G__Reflex_104_0_93, 104, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubScopeAt",985,G__G__Reflex_104_0_94, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope), -1, 0, 1, 1, 1, 8, "h - 'size_t' 0 - nth", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubScopeSize",1215,G__G__Reflex_104_0_95, 104, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubScope_Begin",1384,G__G__Reflex_104_0_96, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiterator), G__defined_typename("Reflex::Scope_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubScope_End",1178,G__G__Reflex_104_0_97, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiterator), G__defined_typename("Reflex::Scope_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubScope_RBegin",1466,G__G__Reflex_104_0_98, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Scope_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubScope_REnd",1260,G__G__Reflex_104_0_99, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Scope_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubTypeAt",897,G__G__Reflex_104_0_100, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 1, 1, 1, 8, "h - 'size_t' 0 - nth", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubTypeSize",1127,G__G__Reflex_104_0_101, 104, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubType_Begin",1296,G__G__Reflex_104_0_102, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiterator), G__defined_typename("Reflex::Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubType_End",1090,G__G__Reflex_104_0_103, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiterator), G__defined_typename("Reflex::Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubType_RBegin",1378,G__G__Reflex_104_0_104, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubType_REnd",1172,G__G__Reflex_104_0_105, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubTypeTemplateAt",1725,G__G__Reflex_104_0_106, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypeTemplate), -1, 0, 1, 1, 1, 8, "h - 'size_t' 0 - nth", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubTypeTemplateSize",1955,G__G__Reflex_104_0_107, 104, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubTypeTemplate_Begin",2124,G__G__Reflex_104_0_108, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgRcLcLiterator), G__defined_typename("Reflex::TypeTemplate_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubTypeTemplate_End",1918,G__G__Reflex_104_0_109, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgRcLcLiterator), G__defined_typename("Reflex::TypeTemplate_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubTypeTemplate_RBegin",2206,G__G__Reflex_104_0_110, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_TypeTemplate_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubTypeTemplate_REnd",2000,G__G__Reflex_104_0_111, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_TypeTemplate_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateArgumentAt",1844,G__G__Reflex_104_0_112, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 1, 1, 1, 8, "h - 'size_t' 0 - nth", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateArgumentSize",2074,G__G__Reflex_104_0_113, 104, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateArgument_Begin",2243,G__G__Reflex_104_0_114, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiterator), G__defined_typename("Reflex::Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateArgument_End",2037,G__G__Reflex_104_0_115, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiterator), G__defined_typename("Reflex::Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateArgument_RBegin",2325,G__G__Reflex_104_0_116, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateArgument_REnd",2119,G__G__Reflex_104_0_117, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateFamily",1438,G__G__Reflex_104_0_118, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypeTemplate), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ToType",613,G__G__Reflex_104_0_119, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TypeAt",599,G__G__Reflex_104_0_120, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 1, 3, 1, 0, "h - 'size_t' 0 - nth", (char*)NULL, (void*) G__func2void( (Reflex::Type (*)(size_t))(&Reflex::Type::TypeAt) ), 0);
   G__memfunc_setup("TypeSize",829,G__G__Reflex_104_0_121, 104, -1, G__defined_typename("size_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (size_t (*)())(&Reflex::Type::TypeSize) ), 0);
   G__memfunc_setup("Type_Begin",998,G__G__Reflex_104_0_122, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiterator), G__defined_typename("Reflex::Type_Iterator"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Reflex::Type_Iterator (*)())(&Reflex::Type::Type_Begin) ), 0);
   G__memfunc_setup("Type_End",792,G__G__Reflex_104_0_123, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiterator), G__defined_typename("Reflex::Type_Iterator"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Reflex::Type_Iterator (*)())(&Reflex::Type::Type_End) ), 0);
   G__memfunc_setup("Type_RBegin",1080,G__G__Reflex_104_0_124, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Type_Iterator"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Reflex::Reverse_Type_Iterator (*)())(&Reflex::Type::Type_RBegin) ), 0);
   G__memfunc_setup("Type_REnd",874,G__G__Reflex_104_0_125, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Type_Iterator"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Reflex::Reverse_Type_Iterator (*)())(&Reflex::Type::Type_REnd) ), 0);
   G__memfunc_setup("TypeInfo",814,G__G__Reflex_104_0_126, 117, G__get_linked_tagnum(&G__G__ReflexLN_type_info), -1, 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TypeType",836,G__G__Reflex_104_0_127, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTYPE), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TypeTypeAsString",1647,G__G__Reflex_104_0_128, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Unload",611,G__G__Reflex_104_0_129, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("UpdateMembers",1326,G__G__Reflex_104_0_130, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddBase",644,G__G__Reflex_104_0_131, 121, -1, -1, 0, 3, 1, 1, 8, 
"u 'Reflex::Type' - 11 - bas Y - 'Reflex::OffsetFunction' 0 - offsFP "
"h - - 0 '0' modifiers", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddBase",644,G__G__Reflex_104_0_132, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Base' - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddDataMember",1243,G__G__Reflex_104_0_133, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Member' - 11 - dm", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddDataMember",1243,G__G__Reflex_104_0_134, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 5, 1, 1, 8, 
"C - - 10 - nam u 'Reflex::Type' - 11 - typ "
"h - 'size_t' 0 - offs h - - 0 '0' modifiers "
"C - - 0 '0' interpreterOffset", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddFunctionMember",1703,G__G__Reflex_104_0_135, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Member' - 11 - fm", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddFunctionMember",1703,G__G__Reflex_104_0_136, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 6, 1, 1, 8, 
"C - - 10 - nam u 'Reflex::Type' - 11 - typ "
"Y - 'Reflex::StubFunction' 0 - stubFP Y - - 0 '0' stubCtx "
"C - - 10 '0' params h - - 0 '0' modifiers", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddSubScope",1069,G__G__Reflex_104_0_137, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Scope' - 11 - sc", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddSubScope",1069,G__G__Reflex_104_0_138, 121, -1, -1, 0, 2, 1, 1, 8, 
"C - - 10 - scop i 'Reflex::TYPE' - 0 'NAMESPACE' scopeTyp", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddSubType",981,G__G__Reflex_104_0_139, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Type' - 11 - ty", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddSubType",981,G__G__Reflex_104_0_140, 121, -1, -1, 0, 5, 1, 1, 8, 
"C - - 10 - typ h - 'size_t' 0 - size "
"i 'Reflex::TYPE' - 0 - typeTyp u 'type_info' - 11 - ti "
"h - - 0 '0' modifiers", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RemoveDataMember",1600,G__G__Reflex_104_0_141, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Member' - 11 - dm", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RemoveFunctionMember",2060,G__G__Reflex_104_0_142, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Member' - 11 - fm", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RemoveSubScope",1426,G__G__Reflex_104_0_143, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Scope' - 11 - sc", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RemoveSubType",1338,G__G__Reflex_104_0_144, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Type' - 11 - ty", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetSize",711,G__G__Reflex_104_0_145, 121, -1, -1, 0, 1, 1, 1, 8, "h - 'size_t' 0 - s", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetTypeInfo",1114,G__G__Reflex_104_0_146, 121, -1, -1, 0, 1, 1, 1, 8, "u 'type_info' - 11 - ti", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ToTypeBase",992,G__G__Reflex_104_0_147, 85, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypeBase), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RepresType",1043,G__G__Reflex_104_0_148, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLREPRESTYPE), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Type", 544, G__G__Reflex_104_0_149, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLBase(void) {
   /* Reflex::Base */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLBase));
   G__memfunc_setup("Base",379,G__G__Reflex_105_0_1, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLBase), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Base",379,G__G__Reflex_105_0_2, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLBase), -1, 0, 3, 1, 1, 0, 
"u 'Reflex::Type' - 11 - baseType Y - 'Reflex::OffsetFunction' 0 - offsetFP "
"h - - 0 '0' modifiers", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator bool",1336,G__G__Reflex_105_0_3, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Name",385,G__G__Reflex_105_0_4, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 0, 1, 1, 1, 8, "h - - 0 '0' mod", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsPrivate",919,G__G__Reflex_105_0_5, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsProtected",1126,G__G__Reflex_105_0_6, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsPublic",795,G__G__Reflex_105_0_7, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsVirtual",931,G__G__Reflex_105_0_8, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Offset",615,G__G__Reflex_105_0_9, 104, -1, G__defined_typename("size_t"), 0, 1, 1, 1, 8, "Y - - 0 '0' mem", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("OffsetFP",765,G__G__Reflex_105_0_10, 89, -1, G__defined_typename("Reflex::OffsetFunction"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ToType",613,G__G__Reflex_105_0_11, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ToScope",701,G__G__Reflex_105_0_12, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("BaseClass",881,(G__InterfaceMethod) NULL, 85, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClass), -1, 0, 0, 1, 4, 9, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Base", 379, G__G__Reflex_105_0_14, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLBase), -1, 0, 1, 1, 1, 0, "u 'Reflex::Base' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Base", 505, G__G__Reflex_105_0_15, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLScope(void) {
   /* Reflex::Scope */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope));
   G__memfunc_setup("Scope",506,G__G__Reflex_106_0_1, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope), -1, 0, 1, 1, 1, 0, "U 'Reflex::ScopeName' - 10 '0' scopeName", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Scope",506,G__G__Reflex_106_0_2, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope), -1, 0, 1, 1, 1, 0, "u 'Reflex::Scope' - 11 - rh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator!=",970,G__G__Reflex_106_0_3, 103, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Scope' - 11 - rh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator bool",1336,G__G__Reflex_106_0_4, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator Reflex::Type",2056,G__G__Reflex_106_0_5, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("BaseAt",560,G__G__Reflex_106_0_6, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLBase), -1, 0, 1, 1, 1, 8, "h - 'size_t' 0 - nth", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("BaseSize",790,G__G__Reflex_106_0_7, 104, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Base_Begin",959,G__G__Reflex_106_0_8, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgRcLcLiterator), G__defined_typename("Reflex::Base_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Base_End",753,G__G__Reflex_106_0_9, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgRcLcLiterator), G__defined_typename("Reflex::Base_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Base_RBegin",1041,G__G__Reflex_106_0_10, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Base_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Base_REnd",835,G__G__Reflex_106_0_11, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Base_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ByName",572,G__G__Reflex_106_0_12, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope), -1, 0, 1, 3, 1, 0, "u 'string' - 11 - name", (char*)NULL, (void*) G__func2void( (Reflex::Scope (*)(const string&))(&Reflex::Scope::ByName) ), 0);
   G__memfunc_setup("DataMemberAt",1159,G__G__Reflex_106_0_13, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 2, 1, 1, 8, 
"h - 'size_t' 0 - nth i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DataMemberByName",1550,G__G__Reflex_106_0_14, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 2, 1, 1, 8, 
"u 'string' - 11 - name i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DataMemberSize",1389,G__G__Reflex_106_0_15, 104, -1, G__defined_typename("size_t"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DataMember_Begin",1558,G__G__Reflex_106_0_16, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiterator), G__defined_typename("Reflex::Member_Iterator"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DataMember_End",1352,G__G__Reflex_106_0_17, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiterator), G__defined_typename("Reflex::Member_Iterator"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DataMember_RBegin",1640,G__G__Reflex_106_0_18, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Member_Iterator"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DataMember_REnd",1434,G__G__Reflex_106_0_19, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Member_Iterator"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclaringScope",1411,G__G__Reflex_106_0_20, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionMemberAt",1619,G__G__Reflex_106_0_21, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 2, 1, 1, 8, 
"h - 'size_t' 0 - nth i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionMemberByName",2010,G__G__Reflex_106_0_22, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 3, 1, 1, 8, 
"u 'string' - 11 - name i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh "
"i 'Reflex::EDELAYEDLOADSETTING' - 0 'DELAYEDLOAD_ON' allowDelayedLoad", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionMemberByName",2010,G__G__Reflex_106_0_23, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 5, 1, 1, 8, 
"u 'string' - 11 - name u 'Reflex::Type' - 11 - signature "
"h - - 0 '0' modifers_mask i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh "
"i 'Reflex::EDELAYEDLOADSETTING' - 0 'DELAYEDLOAD_ON' allowDelayedLoad", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionMemberByNameAndSignature",3231,G__G__Reflex_106_0_24, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 5, 1, 1, 8, 
"u 'string' - 11 - name u 'Reflex::Type' - 11 - signature "
"h - - 0 '0' modifers_mask i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh "
"i 'Reflex::EDELAYEDLOADSETTING' - 0 'DELAYEDLOAD_ON' allowDelayedLoad", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionMemberSize",1849,G__G__Reflex_106_0_25, 104, -1, G__defined_typename("size_t"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionMember_Begin",2018,G__G__Reflex_106_0_26, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiterator), G__defined_typename("Reflex::Member_Iterator"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionMember_End",1812,G__G__Reflex_106_0_27, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiterator), G__defined_typename("Reflex::Member_Iterator"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionMember_RBegin",2100,G__G__Reflex_106_0_28, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Member_Iterator"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionMember_REnd",1894,G__G__Reflex_106_0_29, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Member_Iterator"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GenerateDict",1199,G__G__Reflex_106_0_30, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::DictionaryGenerator' - 1 - generator", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GlobalScope",1099,G__G__Reflex_106_0_31, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Reflex::Scope (*)())(&Reflex::Scope::GlobalScope) ), 0);
   G__memfunc_setup("HasBase",663,G__G__Reflex_106_0_32, 103, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Type' - 11 - cl", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Id",173,G__G__Reflex_106_0_33, 89, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsClass",690,G__G__Reflex_106_0_34, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsEnum",593,G__G__Reflex_106_0_35, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsNamespace",1097,G__G__Reflex_106_0_36, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsPrivate",919,G__G__Reflex_106_0_37, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsProtected",1126,G__G__Reflex_106_0_38, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsPublic",795,G__G__Reflex_106_0_39, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsTemplateInstance",1837,G__G__Reflex_106_0_40, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsTopScope",1001,G__G__Reflex_106_0_41, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsUnion",709,G__G__Reflex_106_0_42, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("LookupMember",1234,G__G__Reflex_106_0_43, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 1, 1, 1, 8, "u 'string' - 11 - nam", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("LookupType",1052,G__G__Reflex_106_0_44, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 1, 1, 1, 8, "u 'string' - 11 - nam", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("LookupScope",1140,G__G__Reflex_106_0_45, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope), -1, 0, 1, 1, 1, 8, "u 'string' - 11 - nam", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MemberAt",781,G__G__Reflex_106_0_46, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 2, 1, 1, 8, 
"h - 'size_t' 0 - nth i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MemberByName",1172,G__G__Reflex_106_0_47, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 2, 1, 1, 8, 
"u 'string' - 11 - name i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MemberByName",1172,G__G__Reflex_106_0_48, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 3, 1, 1, 8, 
"u 'string' - 11 - name u 'Reflex::Type' - 11 - signature "
"i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MemberSize",1011,G__G__Reflex_106_0_49, 104, -1, G__defined_typename("size_t"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Member_Begin",1180,G__G__Reflex_106_0_50, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiterator), G__defined_typename("Reflex::Member_Iterator"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Member_End",974,G__G__Reflex_106_0_51, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiterator), G__defined_typename("Reflex::Member_Iterator"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Member_RBegin",1262,G__G__Reflex_106_0_52, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Member_Iterator"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Member_REnd",1056,G__G__Reflex_106_0_53, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Member_Iterator"), 0, 1, 1, 1, 8, "i 'Reflex::EMEMBERQUERY' - 0 'INHERITEDMEMBERS_DEFAULT' inh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MemberTemplateAt",1609,G__G__Reflex_106_0_54, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMemberTemplate), -1, 0, 1, 1, 1, 8, "h - 'size_t' 0 - nth", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MemberTemplateSize",1839,G__G__Reflex_106_0_55, 104, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MemberTemplateByName",2000,G__G__Reflex_106_0_56, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMemberTemplate), -1, 0, 1, 1, 1, 8, "u 'string' - 11 - nam", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MemberTemplate_Begin",2008,G__G__Reflex_106_0_57, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgRcLcLiterator), G__defined_typename("Reflex::MemberTemplate_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MemberTemplate_End",1802,G__G__Reflex_106_0_58, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgRcLcLiterator), G__defined_typename("Reflex::MemberTemplate_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MemberTemplate_RBegin",2090,G__G__Reflex_106_0_59, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_MemberTemplate_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MemberTemplate_REnd",1884,G__G__Reflex_106_0_60, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_MemberTemplate_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Name",385,G__G__Reflex_106_0_61, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 0, 1, 1, 1, 8, "h - - 0 '0' mod", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Name_c_str",1019,G__G__Reflex_106_0_62, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Properties",1069,G__G__Reflex_106_0_63, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPropertyList), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ScopeAt",687,G__G__Reflex_106_0_64, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope), -1, 0, 1, 3, 1, 0, "h - 'size_t' 0 - nth", (char*)NULL, (void*) G__func2void( (Reflex::Scope (*)(size_t))(&Reflex::Scope::ScopeAt) ), 0);
   G__memfunc_setup("ScopeSize",917,G__G__Reflex_106_0_65, 104, -1, G__defined_typename("size_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (size_t (*)())(&Reflex::Scope::ScopeSize) ), 0);
   G__memfunc_setup("Scope_Begin",1086,G__G__Reflex_106_0_66, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiterator), G__defined_typename("Reflex::Scope_Iterator"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Reflex::Scope_Iterator (*)())(&Reflex::Scope::Scope_Begin) ), 0);
   G__memfunc_setup("Scope_End",880,G__G__Reflex_106_0_67, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiterator), G__defined_typename("Reflex::Scope_Iterator"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Reflex::Scope_Iterator (*)())(&Reflex::Scope::Scope_End) ), 0);
   G__memfunc_setup("Scope_RBegin",1168,G__G__Reflex_106_0_68, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Scope_Iterator"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Reflex::Reverse_Scope_Iterator (*)())(&Reflex::Scope::Scope_RBegin) ), 0);
   G__memfunc_setup("Scope_REnd",962,G__G__Reflex_106_0_69, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Scope_Iterator"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Reflex::Reverse_Scope_Iterator (*)())(&Reflex::Scope::Scope_REnd) ), 0);
   G__memfunc_setup("ScopeType",924,G__G__Reflex_106_0_70, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTYPE), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ScopeTypeAsString",1735,G__G__Reflex_106_0_71, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubScopeAt",985,G__G__Reflex_106_0_72, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope), -1, 0, 1, 1, 1, 8, "h - 'size_t' 0 - nth", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubScopeLevel",1308,G__G__Reflex_106_0_73, 104, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubScopeSize",1215,G__G__Reflex_106_0_74, 104, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubScopeByName",1376,G__G__Reflex_106_0_75, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope), -1, 0, 1, 1, 1, 8, "u 'string' - 11 - nam", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubScope_Begin",1384,G__G__Reflex_106_0_76, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiterator), G__defined_typename("Reflex::Scope_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubScope_End",1178,G__G__Reflex_106_0_77, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiterator), G__defined_typename("Reflex::Scope_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubScope_RBegin",1466,G__G__Reflex_106_0_78, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Scope_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubScope_REnd",1260,G__G__Reflex_106_0_79, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Scope_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubTypeAt",897,G__G__Reflex_106_0_80, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 1, 1, 1, 8, "h - 'size_t' 0 - nth", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubTypeSize",1127,G__G__Reflex_106_0_81, 104, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubTypeByName",1288,G__G__Reflex_106_0_82, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 1, 1, 1, 8, "u 'string' - 11 - nam", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubType_Begin",1296,G__G__Reflex_106_0_83, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiterator), G__defined_typename("Reflex::Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubType_End",1090,G__G__Reflex_106_0_84, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiterator), G__defined_typename("Reflex::Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubType_RBegin",1378,G__G__Reflex_106_0_85, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubType_REnd",1172,G__G__Reflex_106_0_86, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubTypeTemplateAt",1725,G__G__Reflex_106_0_87, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypeTemplate), -1, 0, 1, 1, 1, 8, "h - 'size_t' 0 - nth", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubTypeTemplateSize",1955,G__G__Reflex_106_0_88, 104, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubTypeTemplateByName",2116,G__G__Reflex_106_0_89, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypeTemplate), -1, 0, 1, 1, 1, 8, "u 'string' - 11 - nam", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubTypeTemplate_Begin",2124,G__G__Reflex_106_0_90, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgRcLcLiterator), G__defined_typename("Reflex::TypeTemplate_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubTypeTemplate_End",1918,G__G__Reflex_106_0_91, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgRcLcLiterator), G__defined_typename("Reflex::TypeTemplate_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubTypeTemplate_RBegin",2206,G__G__Reflex_106_0_92, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_TypeTemplate_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SubTypeTemplate_REnd",2000,G__G__Reflex_106_0_93, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_TypeTemplate_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateArgumentAt",1844,G__G__Reflex_106_0_94, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 1, 1, 1, 8, "h - 'size_t' 0 - nth", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateArgumentSize",2074,G__G__Reflex_106_0_95, 104, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateArgument_Begin",2243,G__G__Reflex_106_0_96, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiterator), G__defined_typename("Reflex::Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateArgument_End",2037,G__G__Reflex_106_0_97, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiterator), G__defined_typename("Reflex::Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateArgument_RBegin",2325,G__G__Reflex_106_0_98, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateArgument_REnd",2119,G__G__Reflex_106_0_99, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateFamily",1438,G__G__Reflex_106_0_100, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypeTemplate), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Unload",611,G__G__Reflex_106_0_101, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("UpdateMembers",1326,G__G__Reflex_106_0_102, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("UsingDirectiveAt",1626,G__G__Reflex_106_0_103, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope), -1, 0, 1, 1, 1, 8, "h - 'size_t' 0 - nth", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("UsingDirectiveSize",1856,G__G__Reflex_106_0_104, 104, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("UsingDirective_Begin",2025,G__G__Reflex_106_0_105, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiterator), G__defined_typename("Reflex::Scope_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("UsingDirective_End",1819,G__G__Reflex_106_0_106, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiterator), G__defined_typename("Reflex::Scope_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("UsingDirective_RBegin",2107,G__G__Reflex_106_0_107, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Scope_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("UsingDirective_REnd",1901,G__G__Reflex_106_0_108, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Scope_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddBase",644,G__G__Reflex_106_0_109, 121, -1, -1, 0, 3, 1, 1, 8, 
"u 'Reflex::Type' - 11 - bas Y - 'Reflex::OffsetFunction' 0 - offsFP "
"h - - 0 '0' modifiers", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddBase",644,G__G__Reflex_106_0_110, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Base' - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddDataMember",1243,G__G__Reflex_106_0_111, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Member' - 11 - dm", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddDataMember",1243,G__G__Reflex_106_0_112, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 5, 1, 1, 8, 
"C - - 10 - name u 'Reflex::Type' - 11 - type "
"h - 'size_t' 0 - offset h - - 0 '0' modifiers "
"C - - 0 '0' interpreterOffset", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddFunctionMember",1703,G__G__Reflex_106_0_113, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Member' - 11 - fm", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddFunctionMember",1703,G__G__Reflex_106_0_114, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 6, 1, 1, 8, 
"C - - 10 - name u 'Reflex::Type' - 11 - type "
"Y - 'Reflex::StubFunction' 0 - stubFP Y - - 0 '0' stubCtx "
"C - - 10 '0' params h - - 0 '0' modifiers", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddMemberTemplate",1693,G__G__Reflex_106_0_115, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::MemberTemplate' - 11 - mt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddSubScope",1069,G__G__Reflex_106_0_116, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Scope' - 11 - sc", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddSubScope",1069,G__G__Reflex_106_0_117, 121, -1, -1, 0, 2, 1, 1, 8, 
"C - - 10 - scope i 'Reflex::TYPE' - 0 'NAMESPACE' scopeType", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddSubType",981,G__G__Reflex_106_0_118, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Type' - 11 - ty", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddSubType",981,G__G__Reflex_106_0_119, 121, -1, -1, 0, 5, 1, 1, 8, 
"C - - 10 - type h - 'size_t' 0 - size "
"i 'Reflex::TYPE' - 0 - typeType u 'type_info' - 11 - typeInfo "
"h - - 0 '0' modifiers", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddSubTypeTemplate",1809,G__G__Reflex_106_0_120, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::TypeTemplate' - 11 - mt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddUsingDirective",1710,G__G__Reflex_106_0_121, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Scope' - 11 - ud", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RemoveDataMember",1600,G__G__Reflex_106_0_122, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Member' - 11 - dm", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RemoveFunctionMember",2060,G__G__Reflex_106_0_123, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Member' - 11 - fm", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RemoveMemberTemplate",2050,G__G__Reflex_106_0_124, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::MemberTemplate' - 11 - mt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RemoveSubScope",1426,G__G__Reflex_106_0_125, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Scope' - 11 - sc", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RemoveSubType",1338,G__G__Reflex_106_0_126, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Type' - 11 - ty", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RemoveSubTypeTemplate",2166,G__G__Reflex_106_0_127, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::TypeTemplate' - 11 - tt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RemoveUsingDirective",2067,G__G__Reflex_106_0_128, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Scope' - 11 - ud", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ToScopeBase",1080,G__G__Reflex_106_0_129, 85, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScopeBase), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("__NIRVANA__",907,G__G__Reflex_106_0_130, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope), -1, 1, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Reflex::Scope& (*)())(&Reflex::Scope::__NIRVANA__) ), 0);
   // automatic destructor
   G__memfunc_setup("~Scope", 632, G__G__Reflex_106_0_131, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLObject(void) {
   /* Reflex::Object */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLObject));
   G__memfunc_setup("Object",599,G__G__Reflex_107_0_1, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLObject), -1, 0, 2, 1, 1, 0, 
"u 'Reflex::Type' - 11 'Type()' type Y - - 0 '0' mem", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Object",599,G__G__Reflex_107_0_2, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLObject), -1, 0, 1, 1, 1, 0, "u 'Reflex::Object' - 11 - obj", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__Reflex_107_0_3, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLObject), -1, 0, 1, 1, 1, 0, "u 'Reflex::Object' - 11 - obj", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator==",998,G__G__Reflex_107_0_4, 103, -1, -1, 0, 1, 1, 1, 0, "u 'Reflex::Object' - 11 - obj", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator!=",970,G__G__Reflex_107_0_5, 103, -1, -1, 0, 1, 1, 1, 0, "u 'Reflex::Object' - 11 - obj", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator bool",1336,G__G__Reflex_107_0_6, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Address",710,G__G__Reflex_107_0_7, 89, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("CastObject",994,G__G__Reflex_107_0_8, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLObject), -1, 0, 1, 1, 1, 8, "u 'Reflex::Type' - 11 - to", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Destruct",846,G__G__Reflex_107_0_9, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DynamicType",1127,G__G__Reflex_107_0_10, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Get",288,G__G__Reflex_107_0_11, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLObject), -1, 0, 1, 1, 1, 8, "u 'string' - 11 - dm", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Invoke",620,G__G__Reflex_107_0_12, 121, -1, -1, 0, 3, 1, 1, 8, 
"u 'string' - 11 - fm U 'Reflex::Object' - 0 '0' ret "
"u 'vector<void*,allocator<void*> >' 'vector<void*>' 11 'std::vector<void*>()' args", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Invoke",620,G__G__Reflex_107_0_13, 121, -1, -1, 0, 4, 1, 1, 8, 
"u 'string' - 11 - fm u 'Reflex::Type' - 11 - sign "
"U 'Reflex::Object' - 0 '0' ret u 'vector<void*,allocator<void*> >' 'vector<void*>' 11 'std::vector<void*>()' args", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Set",300,G__G__Reflex_107_0_14, 121, -1, -1, 0, 2, 1, 1, 8, 
"u 'string' - 11 - dm Y - - 10 - value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TypeOf",599,G__G__Reflex_107_0_15, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Set2",350,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 2, 1, 4, 8, 
"u 'string' - 11 - dm Y - - 10 - value", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Object", 725, G__G__Reflex_107_0_17, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLMember(void) {
   /* Reflex::Member */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember));
   G__memfunc_setup("Member",600,G__G__Reflex_108_0_1, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 1, 1, 1, 0, "U 'Reflex::MemberBase' - 10 '0' memberBase", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Member",600,G__G__Reflex_108_0_2, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 1, 1, 1, 0, "u 'Reflex::Member' - 11 - rh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator<",936,G__G__Reflex_108_0_3, 103, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Member' - 11 - rh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator==",998,G__G__Reflex_108_0_4, 103, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Member' - 11 - rh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator!=",970,G__G__Reflex_108_0_5, 103, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Member' - 11 - rh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__Reflex_108_0_6, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 1, 1, 1, 1, 0, "u 'Reflex::Member' - 11 - rh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator bool",1336,G__G__Reflex_108_0_7, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclaringScope",1411,G__G__Reflex_108_0_8, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclaringType",1323,G__G__Reflex_108_0_9, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GenerateDict",1199,G__G__Reflex_108_0_10, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::DictionaryGenerator' - 1 - generator", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Get",288,G__G__Reflex_108_0_11, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLObject), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Get",288,G__G__Reflex_108_0_12, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLObject), -1, 0, 1, 1, 1, 8, "u 'Reflex::Object' - 11 - obj", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Id",173,G__G__Reflex_108_0_13, 89, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Invoke",620,G__G__Reflex_108_0_14, 121, -1, -1, 0, 3, 1, 1, 8, 
"u 'Reflex::Object' - 11 - obj U 'Reflex::Object' - 0 - ret "
"u 'vector<void*,allocator<void*> >' 'vector<void*>' 11 'std::vector<void*>()' paramList", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Invoke",620,G__G__Reflex_108_0_15, 121, -1, -1, 0, 2, 1, 1, 8, 
"U 'Reflex::Object' - 0 - ret u 'vector<void*,allocator<void*> >' 'vector<void*>' 11 'std::vector<void*>()' paramList", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsAbstract",1008,G__G__Reflex_108_0_16, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsArtificial",1204,G__G__Reflex_108_0_17, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsAuto",597,G__G__Reflex_108_0_18, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsConstructor",1378,G__G__Reflex_108_0_19, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsConst",707,G__G__Reflex_108_0_20, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsConverter",1140,G__G__Reflex_108_0_21, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsCopyConstructor",1789,G__G__Reflex_108_0_22, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsDataMember",1166,G__G__Reflex_108_0_23, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsDestructor",1259,G__G__Reflex_108_0_24, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsExplicit",1022,G__G__Reflex_108_0_25, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsExtern",818,G__G__Reflex_108_0_26, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsFunctionMember",1626,G__G__Reflex_108_0_27, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsInline",795,G__G__Reflex_108_0_28, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsMutable",902,G__G__Reflex_108_0_29, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsOperator",1032,G__G__Reflex_108_0_30, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsPrivate",919,G__G__Reflex_108_0_31, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsProtected",1126,G__G__Reflex_108_0_32, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsPublic",795,G__G__Reflex_108_0_33, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsPureVirtual",1343,G__G__Reflex_108_0_34, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsRegister",1025,G__G__Reflex_108_0_35, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsStatic",804,G__G__Reflex_108_0_36, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsTemplateInstance",1837,G__G__Reflex_108_0_37, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsTransient",1140,G__G__Reflex_108_0_38, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsVirtual",931,G__G__Reflex_108_0_39, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsVolatile",1020,G__G__Reflex_108_0_40, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MemberType",1018,G__G__Reflex_108_0_41, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTYPE), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MemberTypeAsString",1829,G__G__Reflex_108_0_42, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Name",385,G__G__Reflex_108_0_43, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 0, 1, 1, 1, 8, "h - - 0 '0' mod", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Name_c_str",1019,G__G__Reflex_108_0_44, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Offset",615,G__G__Reflex_108_0_45, 104, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("InterpreterOffset",1787,G__G__Reflex_108_0_46, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 0 - offset", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("InterpreterOffset",1787,G__G__Reflex_108_0_47, 67, -1, -1, 1, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionParameterSize",2178,G__G__Reflex_108_0_48, 104, -1, G__defined_typename("size_t"), 0, 1, 1, 1, 8, "g - - 0 'false' required", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionParameterDefaultAt",2657,G__G__Reflex_108_0_49, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 0, 1, 1, 1, 8, "h - 'size_t' 0 - nth", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionParameterDefault_Begin",3056,G__G__Reflex_108_0_50, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgRcLcLiterator), G__defined_typename("Reflex::StdString_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionParameterDefault_End",2850,G__G__Reflex_108_0_51, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgRcLcLiterator), G__defined_typename("Reflex::StdString_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionParameterDefault_RBegin",3138,G__G__Reflex_108_0_52, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_StdString_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionParameterDefault_REnd",2932,G__G__Reflex_108_0_53, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_StdString_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionParameterNameAt",2333,G__G__Reflex_108_0_54, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 0, 1, 1, 1, 8, "h - 'size_t' 0 - nth", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionParameterName_Begin",2732,G__G__Reflex_108_0_55, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgRcLcLiterator), G__defined_typename("Reflex::StdString_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionParameterName_End",2526,G__G__Reflex_108_0_56, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgRcLcLiterator), G__defined_typename("Reflex::StdString_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionParameterName_RBegin",2814,G__G__Reflex_108_0_57, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_StdString_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FunctionParameterName_REnd",2608,G__G__Reflex_108_0_58, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_StdString_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Properties",1069,G__G__Reflex_108_0_59, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPropertyList), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Set",300,G__G__Reflex_108_0_60, 121, -1, -1, 0, 2, 1, 1, 8, 
"u 'Reflex::Object' - 11 - instance Y - - 10 - value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetScope",806,G__G__Reflex_108_0_61, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Scope' - 11 - sc", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Stubcontext",1187,G__G__Reflex_108_0_62, 89, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Stubfunction",1284,G__G__Reflex_108_0_63, 89, -1, G__defined_typename("Reflex::StubFunction"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateArgumentAt",1844,G__G__Reflex_108_0_64, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 1, 1, 1, 8, "h - 'size_t' 0 - nth", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateArgumentSize",2074,G__G__Reflex_108_0_65, 104, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateArgument_Begin",2243,G__G__Reflex_108_0_66, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiterator), G__defined_typename("Reflex::Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateArgument_End",2037,G__G__Reflex_108_0_67, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiterator), G__defined_typename("Reflex::Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateArgument_RBegin",2325,G__G__Reflex_108_0_68, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateArgument_REnd",2119,G__G__Reflex_108_0_69, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateFamily",1438,G__G__Reflex_108_0_70, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMemberTemplate), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ToMemberBase",1174,G__G__Reflex_108_0_71, 85, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMemberBase), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TypeOf",599,G__G__Reflex_108_0_72, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("UpdateFunctionParameterNames",2878,G__G__Reflex_108_0_73, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - parameters", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Delete",595,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 0, 1, 4, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Member", 726, G__G__Reflex_108_0_75, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLTypeTemplate(void) {
   /* Reflex::TypeTemplate */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypeTemplate));
   G__memfunc_setup("TypeTemplate",1246,G__G__Reflex_110_0_1, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypeTemplate), -1, 0, 1, 1, 1, 0, "U 'Reflex::TypeTemplateName' - 10 '0' typeTemplateName", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TypeTemplate",1246,G__G__Reflex_110_0_2, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypeTemplate), -1, 0, 1, 1, 1, 0, "u 'Reflex::TypeTemplate' - 11 - rh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator bool",1336,G__G__Reflex_110_0_3, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator==",998,G__G__Reflex_110_0_4, 103, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::TypeTemplate' - 11 - rh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ByName",572,G__G__Reflex_110_0_5, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypeTemplate), -1, 0, 2, 3, 1, 0, 
"u 'string' - 11 - name h - 'size_t' 0 '0' nTemplateParams", (char*)NULL, (void*) G__func2void( (Reflex::TypeTemplate (*)(const string&, size_t))(&Reflex::TypeTemplate::ByName) ), 0);
   G__memfunc_setup("Id",173,G__G__Reflex_110_0_6, 89, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Name",385,G__G__Reflex_110_0_7, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 0, 1, 1, 1, 8, "h - - 0 '0' mod", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateInstance_Begin",2229,G__G__Reflex_110_0_8, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiterator), G__defined_typename("Reflex::Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateInstance_End",2023,G__G__Reflex_110_0_9, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiterator), G__defined_typename("Reflex::Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateInstance_RBegin",2311,G__G__Reflex_110_0_10, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateInstance_REnd",2105,G__G__Reflex_110_0_11, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Type_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateInstanceAt",1830,G__G__Reflex_110_0_12, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 1, 1, 1, 8, "h - 'size_t' 0 - nth", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateInstanceSize",2060,G__G__Reflex_110_0_13, 104, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateParameterDefaultAt",2647,G__G__Reflex_110_0_14, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 0, 1, 1, 1, 8, "h - 'size_t' 0 - nth", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateParameterDefault_Begin",3046,G__G__Reflex_110_0_15, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgRcLcLiterator), G__defined_typename("Reflex::StdString_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateParameterDefault_End",2840,G__G__Reflex_110_0_16, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgRcLcLiterator), G__defined_typename("Reflex::StdString_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateParameterDefault_RBegin",3128,G__G__Reflex_110_0_17, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_StdString_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateParameterDefault_REnd",2922,G__G__Reflex_110_0_18, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_StdString_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateParameterNameAt",2323,G__G__Reflex_110_0_19, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 0, 1, 1, 1, 8, "h - 'size_t' 0 - nth", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateParameterName_Begin",2722,G__G__Reflex_110_0_20, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgRcLcLiterator), G__defined_typename("Reflex::StdString_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateParameterName_End",2516,G__G__Reflex_110_0_21, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgRcLcLiterator), G__defined_typename("Reflex::StdString_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateParameterName_RBegin",2804,G__G__Reflex_110_0_22, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_StdString_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateParameterName_REnd",2598,G__G__Reflex_110_0_23, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_StdString_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateParameterSize",2168,G__G__Reflex_110_0_24, 104, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TypeTemplateAt",1427,G__G__Reflex_110_0_25, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypeTemplate), -1, 0, 1, 3, 1, 0, "h - 'size_t' 0 - nth", (char*)NULL, (void*) G__func2void( (Reflex::TypeTemplate (*)(size_t))(&Reflex::TypeTemplate::TypeTemplateAt) ), 0);
   G__memfunc_setup("TypeTemplateSize",1657,G__G__Reflex_110_0_26, 104, -1, G__defined_typename("size_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (size_t (*)())(&Reflex::TypeTemplate::TypeTemplateSize) ), 0);
   G__memfunc_setup("TypeTemplate_Begin",1826,G__G__Reflex_110_0_27, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgRcLcLiterator), G__defined_typename("Reflex::TypeTemplate_Iterator"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Reflex::TypeTemplate_Iterator (*)())(&Reflex::TypeTemplate::TypeTemplate_Begin) ), 0);
   G__memfunc_setup("TypeTemplate_End",1620,G__G__Reflex_110_0_28, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgRcLcLiterator), G__defined_typename("Reflex::TypeTemplate_Iterator"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Reflex::TypeTemplate_Iterator (*)())(&Reflex::TypeTemplate::TypeTemplate_End) ), 0);
   G__memfunc_setup("TypeTemplate_RBegin",1908,G__G__Reflex_110_0_29, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_TypeTemplate_Iterator"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Reflex::Reverse_TypeTemplate_Iterator (*)())(&Reflex::TypeTemplate::TypeTemplate_RBegin) ), 0);
   G__memfunc_setup("TypeTemplate_REnd",1702,G__G__Reflex_110_0_30, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_TypeTemplate_Iterator"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Reflex::Reverse_TypeTemplate_Iterator (*)())(&Reflex::TypeTemplate::TypeTemplate_REnd) ), 0);
   G__memfunc_setup("Unload",611,G__G__Reflex_110_0_31, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddTemplateInstance",1914,G__G__Reflex_110_0_32, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Type' - 11 - templateInstance", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TypeTemplate", 1372, G__G__Reflex_110_0_33, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLMemberTemplate(void) {
   /* Reflex::MemberTemplate */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMemberTemplate));
   G__memfunc_setup("MemberTemplate",1428,G__G__Reflex_111_0_1, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMemberTemplate), -1, 0, 1, 1, 1, 0, "U 'Reflex::MemberTemplateName' - 10 '0' memberTemplateName", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MemberTemplate",1428,G__G__Reflex_111_0_2, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMemberTemplate), -1, 0, 1, 1, 1, 0, "u 'Reflex::MemberTemplate' - 11 - rh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator bool",1336,G__G__Reflex_111_0_3, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator==",998,G__G__Reflex_111_0_4, 103, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::MemberTemplate' - 11 - rh", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ByName",572,G__G__Reflex_111_0_5, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMemberTemplate), -1, 0, 2, 3, 1, 0, 
"u 'string' - 11 - name h - 'size_t' 0 '0' nTemplateParams", (char*)NULL, (void*) G__func2void( (Reflex::MemberTemplate (*)(const string&, size_t))(&Reflex::MemberTemplate::ByName) ), 0);
   G__memfunc_setup("Id",173,G__G__Reflex_111_0_6, 89, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MemberTemplateAt",1609,G__G__Reflex_111_0_7, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMemberTemplate), -1, 0, 1, 3, 1, 0, "h - 'size_t' 0 - nth", (char*)NULL, (void*) G__func2void( (Reflex::MemberTemplate (*)(size_t))(&Reflex::MemberTemplate::MemberTemplateAt) ), 0);
   G__memfunc_setup("MemberTemplateSize",1839,G__G__Reflex_111_0_8, 104, -1, G__defined_typename("size_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (size_t (*)())(&Reflex::MemberTemplate::MemberTemplateSize) ), 0);
   G__memfunc_setup("MemberTemplate_Begin",2008,G__G__Reflex_111_0_9, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgRcLcLiterator), G__defined_typename("Reflex::MemberTemplate_Iterator"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Reflex::MemberTemplate_Iterator (*)())(&Reflex::MemberTemplate::MemberTemplate_Begin) ), 0);
   G__memfunc_setup("MemberTemplate_End",1802,G__G__Reflex_111_0_10, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgRcLcLiterator), G__defined_typename("Reflex::MemberTemplate_Iterator"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Reflex::MemberTemplate_Iterator (*)())(&Reflex::MemberTemplate::MemberTemplate_End) ), 0);
   G__memfunc_setup("MemberTemplate_RBegin",2090,G__G__Reflex_111_0_11, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_MemberTemplate_Iterator"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Reflex::Reverse_MemberTemplate_Iterator (*)())(&Reflex::MemberTemplate::MemberTemplate_RBegin) ), 0);
   G__memfunc_setup("MemberTemplate_REnd",1884,G__G__Reflex_111_0_12, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_MemberTemplate_Iterator"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Reflex::Reverse_MemberTemplate_Iterator (*)())(&Reflex::MemberTemplate::MemberTemplate_REnd) ), 0);
   G__memfunc_setup("Name",385,G__G__Reflex_111_0_13, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 0, 1, 1, 1, 8, "h - - 0 '0' mod", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateInstance_Begin",2229,G__G__Reflex_111_0_14, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiterator), G__defined_typename("Reflex::Member_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateInstance_End",2023,G__G__Reflex_111_0_15, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiterator), G__defined_typename("Reflex::Member_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateInstance_RBegin",2311,G__G__Reflex_111_0_16, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Member_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateInstance_REnd",2105,G__G__Reflex_111_0_17, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_Member_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateInstanceAt",1830,G__G__Reflex_111_0_18, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 1, 1, 1, 8, "h - 'size_t' 0 - nth", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateInstanceSize",2060,G__G__Reflex_111_0_19, 104, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateParameterDefaultAt",2647,G__G__Reflex_111_0_20, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 0, 1, 1, 1, 8, "h - 'size_t' 0 - nth", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateParameterDefault_Begin",3046,G__G__Reflex_111_0_21, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgRcLcLiterator), G__defined_typename("Reflex::StdString_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateParameterDefault_End",2840,G__G__Reflex_111_0_22, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgRcLcLiterator), G__defined_typename("Reflex::StdString_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateParameterDefault_RBegin",3128,G__G__Reflex_111_0_23, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_StdString_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateParameterDefault_REnd",2922,G__G__Reflex_111_0_24, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_StdString_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateParameterNameAt",2323,G__G__Reflex_111_0_25, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 0, 1, 1, 1, 8, "h - 'size_t' 0 - nth", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateParameterName_Begin",2722,G__G__Reflex_111_0_26, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgRcLcLiterator), G__defined_typename("Reflex::StdString_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateParameterName_End",2516,G__G__Reflex_111_0_27, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgRcLcLiterator), G__defined_typename("Reflex::StdString_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateParameterName_RBegin",2804,G__G__Reflex_111_0_28, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_StdString_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateParameterName_REnd",2598,G__G__Reflex_111_0_29, 117, G__get_linked_tagnum(&G__G__ReflexLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR), G__defined_typename("Reflex::Reverse_StdString_Iterator"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TemplateParameterSize",2168,G__G__Reflex_111_0_30, 104, -1, G__defined_typename("size_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddTemplateInstance",1914,G__G__Reflex_111_0_31, 121, -1, -1, 0, 1, 1, 1, 8, "u 'Reflex::Member' - 11 - templateInstance", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~MemberTemplate", 1554, G__G__Reflex_111_0_32, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLDummy(void) {
   /* Reflex::Dummy */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLDummy));
   G__memfunc_setup("StdStringCont",1334,G__G__Reflex_144_0_1, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgR), G__defined_typename("Reflex::StdString_Cont_Type_t"), 1, 0, 1, 1, 1, "", (char*)NULL, (void*) G__func2void( (const Reflex::StdString_Cont_Type_t& (*)())(&Reflex::Dummy::StdStringCont) ), 0);
   G__memfunc_setup("TypeCont",822,G__G__Reflex_144_0_2, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgR), G__defined_typename("Reflex::Type_Cont_Type_t"), 1, 0, 1, 1, 1, "", (char*)NULL, (void*) G__func2void( (const Reflex::Type_Cont_Type_t& (*)())(&Reflex::Dummy::TypeCont) ), 0);
   G__memfunc_setup("BaseCont",783,G__G__Reflex_144_0_3, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgR), G__defined_typename("Reflex::Base_Cont_Type_t"), 1, 0, 1, 1, 1, "", (char*)NULL, (void*) G__func2void( (const Reflex::Base_Cont_Type_t& (*)())(&Reflex::Dummy::BaseCont) ), 0);
   G__memfunc_setup("ScopeCont",910,G__G__Reflex_144_0_4, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgR), G__defined_typename("Reflex::Scope_Cont_Type_t"), 1, 0, 1, 1, 1, "", (char*)NULL, (void*) G__func2void( (const Reflex::Scope_Cont_Type_t& (*)())(&Reflex::Dummy::ScopeCont) ), 0);
   G__memfunc_setup("ObjectCont",1003,G__G__Reflex_144_0_5, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLObjectcOallocatorlEReflexcLcLObjectgRsPgR), G__defined_typename("Reflex::Object_Cont_Type_t"), 1, 0, 1, 1, 1, "", (char*)NULL, (void*) G__func2void( (const Reflex::Object_Cont_Type_t& (*)())(&Reflex::Dummy::ObjectCont) ), 0);
   G__memfunc_setup("MemberCont",1004,G__G__Reflex_144_0_6, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgR), G__defined_typename("Reflex::Member_Cont_Type_t"), 1, 0, 1, 1, 1, "", (char*)NULL, (void*) G__func2void( (const Reflex::Member_Cont_Type_t& (*)())(&Reflex::Dummy::MemberCont) ), 0);
   G__memfunc_setup("TypeTemplateCont",1650,G__G__Reflex_144_0_7, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgR), G__defined_typename("Reflex::TypeTemplate_Cont_Type_t"), 1, 0, 1, 1, 1, "", (char*)NULL, (void*) G__func2void( (const Reflex::TypeTemplate_Cont_Type_t& (*)())(&Reflex::Dummy::TypeTemplateCont) ), 0);
   G__memfunc_setup("MemberTemplateCont",1832,G__G__Reflex_144_0_8, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgR), G__defined_typename("Reflex::MemberTemplate_Cont_Type_t"), 1, 0, 1, 1, 1, "", (char*)NULL, (void*) G__func2void( (const Reflex::MemberTemplate_Cont_Type_t& (*)())(&Reflex::Dummy::MemberTemplateCont) ), 0);
   G__memfunc_setup("Any",296,G__G__Reflex_144_0_9, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLAny), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) G__func2void( (Reflex::Any& (*)())(&Reflex::Dummy::Any) ), 0);
   G__memfunc_setup("Object",599,G__G__Reflex_144_0_10, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLObject), -1, 1, 0, 1, 1, 1, "", (char*)NULL, (void*) G__func2void( (const Reflex::Object& (*)())(&Reflex::Dummy::Object) ), 0);
   G__memfunc_setup("Type",418,G__G__Reflex_144_0_11, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 1, 0, 1, 1, 1, "", (char*)NULL, (void*) G__func2void( (const Reflex::Type& (*)())(&Reflex::Dummy::Type) ), 0);
   G__memfunc_setup("TypeTemplate",1246,G__G__Reflex_144_0_12, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypeTemplate), -1, 1, 0, 1, 1, 1, "", (char*)NULL, (void*) G__func2void( (const Reflex::TypeTemplate& (*)())(&Reflex::Dummy::TypeTemplate) ), 0);
   G__memfunc_setup("Base",379,G__G__Reflex_144_0_13, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLBase), -1, 1, 0, 1, 1, 1, "", (char*)NULL, (void*) G__func2void( (const Reflex::Base& (*)())(&Reflex::Dummy::Base) ), 0);
   G__memfunc_setup("PropertyList",1281,G__G__Reflex_144_0_14, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPropertyList), -1, 1, 0, 1, 1, 1, "", (char*)NULL, (void*) G__func2void( (const Reflex::PropertyList& (*)())(&Reflex::Dummy::PropertyList) ), 0);
   G__memfunc_setup("Member",600,G__G__Reflex_144_0_15, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 1, 0, 1, 1, 1, "", (char*)NULL, (void*) G__func2void( (const Reflex::Member& (*)())(&Reflex::Dummy::Member) ), 0);
   G__memfunc_setup("MemberTemplate",1428,G__G__Reflex_144_0_16, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMemberTemplate), -1, 1, 0, 1, 1, 1, "", (char*)NULL, (void*) G__func2void( (const Reflex::MemberTemplate& (*)())(&Reflex::Dummy::MemberTemplate) ), 0);
   G__memfunc_setup("Scope",506,G__G__Reflex_144_0_17, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope), -1, 1, 0, 1, 1, 1, "", (char*)NULL, (void*) G__func2void( (const Reflex::Scope& (*)())(&Reflex::Dummy::Scope) ), 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLInstance(void) {
   /* Reflex::Instance */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLInstance));
   G__memfunc_setup("Instance",821,G__G__Reflex_145_0_1, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLInstance), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("HasShutdown",1144,G__G__Reflex_145_0_2, 103, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (bool (*)())(&Reflex::Instance::HasShutdown) ), 0);
   G__memfunc_setup("Instance",821,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLInstance), -1, 0, 1, 1, 4, 0, "U 'Reflex::Instance' - 0 - createSingleton", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("CreateReflexInstance",2031,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLInstance), -1, 1, 0, 3, 4, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Shutdown",860,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 0, 1, 4, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Instance", 821, G__G__Reflex_145_0_6, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLInstance), -1, 0, 1, 1, 1, 0, "u 'Reflex::Instance' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Instance", 947, G__G__Reflex_145_0_7, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_145_0_8, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLInstance), -1, 1, 1, 1, 1, 0, "u 'Reflex::Instance' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLNullType(void) {
   /* Reflex::NullType */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNullType));
   // automatic default constructor
   G__memfunc_setup("NullType", 829, G__G__Reflex_152_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNullType), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("NullType", 829, G__G__Reflex_152_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNullType), -1, 0, 1, 1, 1, 0, "u 'Reflex::NullType' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~NullType", 955, G__G__Reflex_152_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_152_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNullType), -1, 1, 1, 1, 1, 0, "u 'Reflex::NullType' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLUnknownType(void) {
   /* Reflex::UnknownType */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnknownType));
   // automatic default constructor
   G__memfunc_setup("UnknownType", 1170, G__G__Reflex_153_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnknownType), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("UnknownType", 1170, G__G__Reflex_153_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnknownType), -1, 0, 1, 1, 1, 0, "u 'Reflex::UnknownType' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~UnknownType", 1296, G__G__Reflex_153_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_153_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnknownType), -1, 1, 1, 1, 1, 0, "u 'Reflex::UnknownType' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLProtectedClass(void) {
   /* Reflex::ProtectedClass */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedClass));
   // automatic default constructor
   G__memfunc_setup("ProtectedClass", 1440, G__G__Reflex_154_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedClass), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ProtectedClass", 1440, G__G__Reflex_154_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedClass), -1, 0, 1, 1, 1, 0, "u 'Reflex::ProtectedClass' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ProtectedClass", 1566, G__G__Reflex_154_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_154_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedClass), -1, 1, 1, 1, 1, 0, "u 'Reflex::ProtectedClass' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLProtectedEnum(void) {
   /* Reflex::ProtectedEnum */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedEnum));
   // automatic default constructor
   G__memfunc_setup("ProtectedEnum", 1343, G__G__Reflex_155_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedEnum), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ProtectedEnum", 1343, G__G__Reflex_155_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedEnum), -1, 0, 1, 1, 1, 0, "u 'Reflex::ProtectedEnum' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ProtectedEnum", 1469, G__G__Reflex_155_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_155_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedEnum), -1, 1, 1, 1, 1, 0, "u 'Reflex::ProtectedEnum' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLProtectedStruct(void) {
   /* Reflex::ProtectedStruct */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedStruct));
   // automatic default constructor
   G__memfunc_setup("ProtectedStruct", 1583, G__G__Reflex_156_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedStruct), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ProtectedStruct", 1583, G__G__Reflex_156_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedStruct), -1, 0, 1, 1, 1, 0, "u 'Reflex::ProtectedStruct' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ProtectedStruct", 1709, G__G__Reflex_156_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_156_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedStruct), -1, 1, 1, 1, 1, 0, "u 'Reflex::ProtectedStruct' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLProtectedUnion(void) {
   /* Reflex::ProtectedUnion */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedUnion));
   // automatic default constructor
   G__memfunc_setup("ProtectedUnion", 1459, G__G__Reflex_157_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedUnion), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ProtectedUnion", 1459, G__G__Reflex_157_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedUnion), -1, 0, 1, 1, 1, 0, "u 'Reflex::ProtectedUnion' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ProtectedUnion", 1585, G__G__Reflex_157_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_157_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedUnion), -1, 1, 1, 1, 1, 0, "u 'Reflex::ProtectedUnion' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLPrivateClass(void) {
   /* Reflex::PrivateClass */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateClass));
   // automatic default constructor
   G__memfunc_setup("PrivateClass", 1233, G__G__Reflex_158_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateClass), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("PrivateClass", 1233, G__G__Reflex_158_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateClass), -1, 0, 1, 1, 1, 0, "u 'Reflex::PrivateClass' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PrivateClass", 1359, G__G__Reflex_158_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_158_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateClass), -1, 1, 1, 1, 1, 0, "u 'Reflex::PrivateClass' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLPrivateEnum(void) {
   /* Reflex::PrivateEnum */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateEnum));
   // automatic default constructor
   G__memfunc_setup("PrivateEnum", 1136, G__G__Reflex_159_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateEnum), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("PrivateEnum", 1136, G__G__Reflex_159_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateEnum), -1, 0, 1, 1, 1, 0, "u 'Reflex::PrivateEnum' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PrivateEnum", 1262, G__G__Reflex_159_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_159_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateEnum), -1, 1, 1, 1, 1, 0, "u 'Reflex::PrivateEnum' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLPrivateStruct(void) {
   /* Reflex::PrivateStruct */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateStruct));
   // automatic default constructor
   G__memfunc_setup("PrivateStruct", 1376, G__G__Reflex_160_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateStruct), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("PrivateStruct", 1376, G__G__Reflex_160_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateStruct), -1, 0, 1, 1, 1, 0, "u 'Reflex::PrivateStruct' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PrivateStruct", 1502, G__G__Reflex_160_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_160_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateStruct), -1, 1, 1, 1, 1, 0, "u 'Reflex::PrivateStruct' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLPrivateUnion(void) {
   /* Reflex::PrivateUnion */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateUnion));
   // automatic default constructor
   G__memfunc_setup("PrivateUnion", 1252, G__G__Reflex_161_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateUnion), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("PrivateUnion", 1252, G__G__Reflex_161_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateUnion), -1, 0, 1, 1, 1, 0, "u 'Reflex::PrivateUnion' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PrivateUnion", 1378, G__G__Reflex_161_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_161_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateUnion), -1, 1, 1, 1, 1, 0, "u 'Reflex::PrivateUnion' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLUnnamedClass(void) {
   /* Reflex::UnnamedClass */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedClass));
   // automatic default constructor
   G__memfunc_setup("UnnamedClass", 1214, G__G__Reflex_162_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedClass), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("UnnamedClass", 1214, G__G__Reflex_162_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedClass), -1, 0, 1, 1, 1, 0, "u 'Reflex::UnnamedClass' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~UnnamedClass", 1340, G__G__Reflex_162_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_162_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedClass), -1, 1, 1, 1, 1, 0, "u 'Reflex::UnnamedClass' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLUnnamedEnum(void) {
   /* Reflex::UnnamedEnum */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedEnum));
   // automatic default constructor
   G__memfunc_setup("UnnamedEnum", 1117, G__G__Reflex_163_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedEnum), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("UnnamedEnum", 1117, G__G__Reflex_163_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedEnum), -1, 0, 1, 1, 1, 0, "u 'Reflex::UnnamedEnum' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~UnnamedEnum", 1243, G__G__Reflex_163_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_163_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedEnum), -1, 1, 1, 1, 1, 0, "u 'Reflex::UnnamedEnum' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLUnnamedNamespace(void) {
   /* Reflex::UnnamedNamespace */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedNamespace));
   // automatic default constructor
   G__memfunc_setup("UnnamedNamespace", 1621, G__G__Reflex_164_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedNamespace), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("UnnamedNamespace", 1621, G__G__Reflex_164_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedNamespace), -1, 0, 1, 1, 1, 0, "u 'Reflex::UnnamedNamespace' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~UnnamedNamespace", 1747, G__G__Reflex_164_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_164_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedNamespace), -1, 1, 1, 1, 1, 0, "u 'Reflex::UnnamedNamespace' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLUnnamedStruct(void) {
   /* Reflex::UnnamedStruct */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedStruct));
   // automatic default constructor
   G__memfunc_setup("UnnamedStruct", 1357, G__G__Reflex_165_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedStruct), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("UnnamedStruct", 1357, G__G__Reflex_165_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedStruct), -1, 0, 1, 1, 1, 0, "u 'Reflex::UnnamedStruct' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~UnnamedStruct", 1483, G__G__Reflex_165_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_165_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedStruct), -1, 1, 1, 1, 1, 0, "u 'Reflex::UnnamedStruct' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLUnnamedUnion(void) {
   /* Reflex::UnnamedUnion */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedUnion));
   // automatic default constructor
   G__memfunc_setup("UnnamedUnion", 1233, G__G__Reflex_166_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedUnion), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("UnnamedUnion", 1233, G__G__Reflex_166_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedUnion), -1, 0, 1, 1, 1, 0, "u 'Reflex::UnnamedUnion' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~UnnamedUnion", 1359, G__G__Reflex_166_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_166_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedUnion), -1, 1, 1, 1, 1, 0, "u 'Reflex::UnnamedUnion' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLRuntimeError(void) {
   /* Reflex::RuntimeError */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLRuntimeError));
   G__memfunc_setup("RuntimeError",1262,G__G__Reflex_167_0_1, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLRuntimeError), -1, 0, 1, 1, 1, 0, "u 'string' - 11 - msg", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("what",436,G__G__Reflex_167_0_2, 67, -1, -1, 0, 0, 1, 1, 41, "", (char*)NULL, (void*) NULL, 1);
   // automatic copy constructor
   G__memfunc_setup("RuntimeError", 1262, G__G__Reflex_167_0_3, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLRuntimeError), -1, 0, 1, 1, 1, 0, "u 'Reflex::RuntimeError' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~RuntimeError", 1388, G__G__Reflex_167_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_167_0_5, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLRuntimeError), -1, 1, 1, 1, 1, 0, "u 'Reflex::RuntimeError' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLICallback(void) {
   /* Reflex::ICallback */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLICallback));
   G__memfunc_setup("operator()",957,G__G__Reflex_206_0_2, 121, -1, -1, 0, 1, 1, 1, 0, "u 'Reflex::Type' - 11 - -", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("operator()",957,G__G__Reflex_206_0_3, 121, -1, -1, 0, 1, 1, 1, 0, "u 'Reflex::Member' - 11 - -", (char*)NULL, (void*) NULL, 3);
   // automatic destructor
   G__memfunc_setup("~ICallback", 980, G__G__Reflex_206_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_206_0_5, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLICallback), -1, 1, 1, 1, 1, 0, "u 'Reflex::ICallback' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLTools(void) {
   /* Reflex::Tools */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTools));
   G__memfunc_setup("FundamentalType",1553,G__G__Reflex_211_0_1, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEFUNDAMENTALTYPE), -1, 0, 1, 1, 1, 0, "u 'Reflex::Type' - 11 - typ", (char*)NULL, (void*) G__func2void( (Reflex::EFUNDAMENTALTYPE (*)(const Reflex::Type&))(&Reflex::Tools::FundamentalType) ), 0);
   G__memfunc_setup("Demangle",797,G__G__Reflex_211_0_2, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 0, 1, 1, 1, 0, "u 'type_info' - 11 - ti", (char*)NULL, (void*) G__func2void( (string (*)(const type_info&))(&Reflex::Tools::Demangle) ), 0);
   G__memfunc_setup("StringSplit",1155,G__G__Reflex_211_0_3, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<string,allocator<string> >' 'vector<std::string>' 1 - splitValues u 'string' - 11 - str "
"u 'string' - 11 '\",\"' delim", (char*)NULL, (void*) G__func2void( (void (*)(vector<std::string>&, const string&, const string&))(&Reflex::Tools::StringSplit) ), 0);
   G__memfunc_setup("StringSplitPair",1551,G__G__Reflex_211_0_4, 121, -1, -1, 0, 4, 1, 1, 0, 
"u 'string' - 1 - val1 u 'string' - 1 - val2 "
"u 'string' - 11 - str u 'string' - 11 '\",\"' delim", (char*)NULL, (void*) G__func2void( (void (*)(string&, string&, const string&, const string&))(&Reflex::Tools::StringSplitPair) ), 0);
   G__memfunc_setup("StringStrip",1161,G__G__Reflex_211_0_5, 121, -1, -1, 0, 1, 1, 1, 0, "u 'string' - 1 - str", (char*)NULL, (void*) G__func2void( (void (*)(string&))(&Reflex::Tools::StringStrip) ), 0);
   G__memfunc_setup("StringVec2String",1598,G__G__Reflex_211_0_6, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 0, 1, 1, 1, 0, "u 'vector<string,allocator<string> >' 'vector<std::string>' 11 - vec", (char*)NULL, (void*) G__func2void( (string (*)(const vector<std::string>&))(&Reflex::Tools::StringVec2String) ), 0);
   G__memfunc_setup("BuildTypeName",1299,G__G__Reflex_211_0_7, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 0, 2, 1, 1, 0, 
"u 'Reflex::Type' - 1 - t h - - 0 - modifiers", (char*)NULL, (void*) G__func2void( (string (*)(Reflex::Type&, unsigned int))(&Reflex::Tools::BuildTypeName) ), 0);
   G__memfunc_setup("GenTemplateArgVec",1678,G__G__Reflex_211_0_8, 117, G__get_linked_tagnum(&G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgR), G__defined_typename("vector<std::string>"), 0, 1, 1, 1, 0, "u 'string' - 11 - name", (char*)NULL, (void*) G__func2void( (vector<std::string> (*)(const string&))(&Reflex::Tools::GenTemplateArgVec) ), 0);
   G__memfunc_setup("GetTemplateComponents",2178,G__G__Reflex_211_0_9, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'string' - 11 - Name u 'string' - 1 - templatename "
"u 'vector<string,allocator<string> >' 'vector<std::string>' 1 - args", (char*)NULL, (void*) G__func2void( (void (*)(const string&, string&, vector<std::string>&))(&Reflex::Tools::GetTemplateComponents) ), 0);
   G__memfunc_setup("GetBasePosition",1520,G__G__Reflex_211_0_10, 104, -1, G__defined_typename("size_t"), 0, 1, 1, 1, 0, "u 'string' - 11 - name", (char*)NULL, (void*) G__func2void( (size_t (*)(const string&))(&Reflex::Tools::GetBasePosition) ), 0);
   G__memfunc_setup("GetFirstScopePosition",2167,G__G__Reflex_211_0_11, 104, -1, G__defined_typename("size_t"), 0, 1, 1, 1, 0, "u 'string' - 11 - name", (char*)NULL, (void*) G__func2void( (size_t (*)(const string&))(&Reflex::Tools::GetFirstScopePosition) ), 0);
   G__memfunc_setup("GetScopeName",1179,G__G__Reflex_211_0_12, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 0, 2, 1, 1, 0, 
"u 'string' - 11 - name g - - 0 'false' startFromLeft", (char*)NULL, (void*) G__func2void( (string (*)(const string&, bool))(&Reflex::Tools::GetScopeName) ), 0);
   G__memfunc_setup("GetBaseName",1052,G__G__Reflex_211_0_13, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 0, 2, 1, 1, 0, 
"u 'string' - 11 - name g - - 0 'false' startFromLeft", (char*)NULL, (void*) G__func2void( (string (*)(const string&, bool))(&Reflex::Tools::GetBaseName) ), 0);
   G__memfunc_setup("IsTemplated",1116,G__G__Reflex_211_0_14, 103, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - name", (char*)NULL, (void*) G__func2void( (bool (*)(const char*))(&Reflex::Tools::IsTemplated) ), 0);
   G__memfunc_setup("GetTemplateArguments",2066,G__G__Reflex_211_0_15, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 0, 1, 1, 1, 0, "C - - 10 - name", (char*)NULL, (void*) G__func2void( (string (*)(const char*))(&Reflex::Tools::GetTemplateArguments) ), 0);
   G__memfunc_setup("GetTemplateName",1501,G__G__Reflex_211_0_16, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 0, 1, 1, 1, 0, "C - - 10 - name", (char*)NULL, (void*) G__func2void( (string (*)(const char*))(&Reflex::Tools::GetTemplateName) ), 0);
   G__memfunc_setup("NormalizeName",1330,G__G__Reflex_211_0_17, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 0, 1, 1, 1, 0, "u 'string' - 11 - name", (char*)NULL, (void*) G__func2void( (string (*)(const string&))(&Reflex::Tools::NormalizeName) ), 0);
   G__memfunc_setup("NormalizeName",1330,G__G__Reflex_211_0_18, 117, G__get_linked_tagnum(&G__G__ReflexLN_string), -1, 0, 1, 1, 1, 0, "C - - 10 - name", (char*)NULL, (void*) G__func2void( (string (*)(const char*))(&Reflex::Tools::NormalizeName) ), 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLNamespaceBuilder(void) {
   /* Reflex::NamespaceBuilder */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNamespaceBuilder));
   G__memfunc_setup("NamespaceBuilder",1620,G__G__Reflex_215_0_1, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNamespaceBuilder), -1, 0, 1, 1, 1, 0, "C - - 10 - nam", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddProperty",1134,G__G__Reflex_215_0_2, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNamespaceBuilder), -1, 1, 2, 1, 1, 0, 
"C - - 10 - key u 'Reflex::Any' - 0 - value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddProperty",1134,G__G__Reflex_215_0_3, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNamespaceBuilder), -1, 1, 2, 1, 1, 0, 
"C - - 10 - key C - - 10 - value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ToScope",701,G__G__Reflex_215_0_4, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("NamespaceBuilder", 1620, G__G__Reflex_215_0_5, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNamespaceBuilder), -1, 0, 1, 1, 1, 0, "u 'Reflex::NamespaceBuilder' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~NamespaceBuilder", 1746, G__G__Reflex_215_0_6, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLFunctionBuilder(void) {
   /* Reflex::FunctionBuilder */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLFunctionBuilder));
   G__memfunc_setup("FunctionBuilder",1549,G__G__Reflex_219_0_1, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLFunctionBuilder), -1, 0, 6, 1, 1, 0, 
"u 'Reflex::Type' - 11 - typ C - - 10 - nam "
"Y - 'Reflex::StubFunction' 0 - stubFP Y - - 0 - stubCtx "
"C - - 10 - params b - - 0 - modifiers", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddProperty",1134,G__G__Reflex_219_0_2, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLFunctionBuilder), -1, 1, 2, 1, 1, 0, 
"C - - 10 - key u 'Reflex::Any' - 0 - value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddProperty",1134,G__G__Reflex_219_0_3, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLFunctionBuilder), -1, 1, 2, 1, 1, 0, 
"C - - 10 - key C - - 10 - value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ToMember",795,G__G__Reflex_219_0_4, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("FunctionBuilder", 1549, G__G__Reflex_219_0_5, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLFunctionBuilder), -1, 0, 1, 1, 1, 0, "u 'Reflex::FunctionBuilder' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~FunctionBuilder", 1675, G__G__Reflex_219_0_6, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_219_0_7, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLFunctionBuilder), -1, 1, 1, 1, 1, 0, "u 'Reflex::FunctionBuilder' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLFunctionBuilderImpl(void) {
   /* Reflex::FunctionBuilderImpl */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLFunctionBuilderImpl));
   G__memfunc_setup("FunctionBuilderImpl",1951,G__G__Reflex_220_0_1, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLFunctionBuilderImpl), -1, 0, 6, 1, 1, 0, 
"C - - 10 - nam u 'Reflex::Type' - 11 - typ "
"Y - 'Reflex::StubFunction' 0 - stubFP Y - - 0 - stubCtx "
"C - - 10 - params b - - 0 '0' modifiers", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddProperty",1134,G__G__Reflex_220_0_2, 121, -1, -1, 0, 2, 1, 1, 0, 
"C - - 10 - key u 'Reflex::Any' - 0 - value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddProperty",1134,G__G__Reflex_220_0_3, 121, -1, -1, 0, 2, 1, 1, 0, 
"C - - 10 - key C - - 10 - value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ToMember",795,G__G__Reflex_220_0_4, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("FunctionBuilderImpl", 1951, G__G__Reflex_220_0_5, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLFunctionBuilderImpl), -1, 0, 1, 1, 1, 0, "u 'Reflex::FunctionBuilderImpl' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~FunctionBuilderImpl", 2077, G__G__Reflex_220_0_6, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_220_0_7, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLFunctionBuilderImpl), -1, 1, 1, 1, 1, 0, "u 'Reflex::FunctionBuilderImpl' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLClassBuilder(void) {
   /* Reflex::ClassBuilder */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilder));
   G__memfunc_setup("ClassBuilder",1213,G__G__Reflex_229_0_1, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilder), -1, 0, 5, 1, 1, 0, 
"C - - 10 - nam u 'type_info' - 11 - ti "
"h - 'size_t' 0 - size h - - 0 '0' modifiers "
"i 'Reflex::TYPE' - 0 'CLASS' typ", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ClassBuilder",1213,G__G__Reflex_229_0_2, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilder), -1, 0, 1, 1, 1, 0, "U 'Reflex::Class' - 0 - cl", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddBase",644,G__G__Reflex_229_0_3, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilder), -1, 1, 3, 1, 1, 0, 
"u 'Reflex::Type' - 11 - bas Y - 'Reflex::OffsetFunction' 0 - offsFP "
"h - - 0 '0' modifiers", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddDataMember",1243,G__G__Reflex_229_0_4, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilder), -1, 1, 4, 1, 1, 0, 
"u 'Reflex::Type' - 11 - typ C - - 10 - nam "
"h - 'size_t' 0 - offs h - - 0 '0' modifiers", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddFunctionMember",1703,G__G__Reflex_229_0_5, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilder), -1, 1, 6, 1, 1, 0, 
"u 'Reflex::Type' - 11 - typ C - - 10 - nam "
"Y - 'Reflex::StubFunction' 0 - stubFP Y - - 0 '0' stubCtx "
"C - - 10 '0' params h - - 0 '0' modifiers", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddTypedef",986,G__G__Reflex_229_0_6, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilder), -1, 1, 2, 1, 1, 0, 
"u 'Reflex::Type' - 11 - typ C - - 10 - def", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddTypedef",986,G__G__Reflex_229_0_7, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilder), -1, 1, 2, 1, 1, 0, 
"C - - 10 - typ C - - 10 - def", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddEnum",670,G__G__Reflex_229_0_8, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilder), -1, 1, 4, 1, 1, 0, 
"C - - 10 - nam C - - 10 - values "
"U 'type_info' - 10 '0' ti h - - 0 '0' modifiers", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddOnDemandDataMemberBuilder",2728,G__G__Reflex_229_0_9, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilder), -1, 1, 1, 1, 1, 0, "U 'Reflex::OnDemandBuilderForScope' - 0 - odb", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddOnDemandFunctionMemberBuilder",3188,G__G__Reflex_229_0_10, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilder), -1, 1, 1, 1, 1, 0, "U 'Reflex::OnDemandBuilderForScope' - 0 - odb", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetSizeOf",892,G__G__Reflex_229_0_11, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilder), -1, 1, 1, 1, 1, 0, "h - 'size_t' 0 - size", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ToType",613,G__G__Reflex_229_0_12, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("EnableCallback",1364,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilder), -1, 1, 1, 1, 2, 0, "g - - 0 'true' enable", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ClassBuilder", 1213, G__G__Reflex_229_0_14, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilder), -1, 0, 1, 1, 1, 0, "u 'Reflex::ClassBuilder' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ClassBuilder", 1339, G__G__Reflex_229_0_15, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_229_0_16, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilder), -1, 1, 1, 1, 1, 0, "u 'Reflex::ClassBuilder' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLClassBuilderImpl(void) {
   /* Reflex::ClassBuilderImpl */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilderImpl));
   G__memfunc_setup("ClassBuilderImpl",1615,G__G__Reflex_231_0_1, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilderImpl), -1, 0, 5, 1, 1, 0, 
"C - - 10 - nam u 'type_info' - 11 - ti "
"h - 'size_t' 0 - size h - - 0 '0' modifiers "
"i 'Reflex::TYPE' - 0 'CLASS' typ", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ClassBuilderImpl",1615,G__G__Reflex_231_0_2, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilderImpl), -1, 0, 1, 1, 1, 0, "U 'Reflex::Class' - 0 - cl", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddBase",644,G__G__Reflex_231_0_3, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'Reflex::Type' - 11 - bas Y - 'Reflex::OffsetFunction' 0 - offsFP "
"h - - 0 '0' modifiers", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddDataMember",1243,G__G__Reflex_231_0_4, 121, -1, -1, 0, 4, 1, 1, 0, 
"C - - 10 - nam u 'Reflex::Type' - 11 - typ "
"h - 'size_t' 0 - offs h - - 0 '0' modifiers", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddFunctionMember",1703,G__G__Reflex_231_0_5, 121, -1, -1, 0, 6, 1, 1, 0, 
"C - - 10 - nam u 'Reflex::Type' - 11 - typ "
"Y - 'Reflex::StubFunction' 0 - stubFP Y - - 0 '0' stubCtx "
"C - - 10 '0' params h - - 0 '0' modifiers", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddTypedef",986,G__G__Reflex_231_0_6, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'Reflex::Type' - 11 - typ C - - 10 - def", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddEnum",670,G__G__Reflex_231_0_7, 121, -1, -1, 0, 4, 1, 1, 0, 
"C - - 10 - nam C - - 10 - values "
"U 'type_info' - 10 - ti h - - 0 '0' modifiers", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddProperty",1134,G__G__Reflex_231_0_8, 121, -1, -1, 0, 2, 1, 1, 0, 
"C - - 10 - key u 'Reflex::Any' - 0 - value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddProperty",1134,G__G__Reflex_231_0_9, 121, -1, -1, 0, 2, 1, 1, 0, 
"C - - 10 - key C - - 10 - value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddOnDemandDataMemberBuilder",2728,G__G__Reflex_231_0_10, 121, -1, -1, 0, 1, 1, 1, 0, "U 'Reflex::OnDemandBuilderForScope' - 0 - odb", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddOnDemandFunctionMemberBuilder",3188,G__G__Reflex_231_0_11, 121, -1, -1, 0, 1, 1, 1, 0, "U 'Reflex::OnDemandBuilderForScope' - 0 - odb", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetSizeOf",892,G__G__Reflex_231_0_12, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'size_t' 0 - size", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ToType",613,G__G__Reflex_231_0_13, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("EnableCallback",1364,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 1, 1, 2, 0, "g - - 0 'true' enable", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ClassBuilderImpl", 1615, G__G__Reflex_231_0_15, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilderImpl), -1, 0, 1, 1, 1, 0, "u 'Reflex::ClassBuilderImpl' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ClassBuilderImpl", 1741, G__G__Reflex_231_0_16, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_231_0_17, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilderImpl), -1, 1, 1, 1, 1, 0, "u 'Reflex::ClassBuilderImpl' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLCollFuncTable(void) {
   /* Reflex::CollFuncTable */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLCollFuncTable));
   // automatic default constructor
   G__memfunc_setup("CollFuncTable", 1278, G__G__Reflex_233_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLCollFuncTable), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("CollFuncTable", 1278, G__G__Reflex_233_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLCollFuncTable), -1, 0, 1, 1, 1, 0, "u 'Reflex::CollFuncTable' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~CollFuncTable", 1404, G__G__Reflex_233_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_233_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLCollFuncTable), -1, 1, 1, 1, 1, 0, "u 'Reflex::CollFuncTable' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT(void) {
   /* Reflex::Selection::NO_SELF_AUTOSELECT */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT));
   // automatic default constructor
   G__memfunc_setup("NO_SELF_AUTOSELECT", 1406, G__G__Reflex_236_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("NO_SELF_AUTOSELECT", 1406, G__G__Reflex_236_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT), -1, 0, 1, 1, 1, 0, "u 'Reflex::Selection::NO_SELF_AUTOSELECT' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~NO_SELF_AUTOSELECT", 1532, G__G__Reflex_236_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_236_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT), -1, 1, 1, 1, 1, 0, "u 'Reflex::Selection::NO_SELF_AUTOSELECT' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLSelectioncLcLTRANSIENT(void) {
   /* Reflex::Selection::TRANSIENT */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLTRANSIENT));
   // automatic default constructor
   G__memfunc_setup("TRANSIENT", 696, G__G__Reflex_237_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLTRANSIENT), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TRANSIENT", 696, G__G__Reflex_237_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLTRANSIENT), -1, 0, 1, 1, 1, 0, "u 'Reflex::Selection::TRANSIENT' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TRANSIENT", 822, G__G__Reflex_237_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_237_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLTRANSIENT), -1, 1, 1, 1, 1, 0, "u 'Reflex::Selection::TRANSIENT' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLSelectioncLcLAUTOSELECT(void) {
   /* Reflex::Selection::AUTOSELECT */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLAUTOSELECT));
   // automatic default constructor
   G__memfunc_setup("AUTOSELECT", 761, G__G__Reflex_238_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLAUTOSELECT), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("AUTOSELECT", 761, G__G__Reflex_238_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLAUTOSELECT), -1, 0, 1, 1, 1, 0, "u 'Reflex::Selection::AUTOSELECT' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AUTOSELECT", 887, G__G__Reflex_238_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_238_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLAUTOSELECT), -1, 1, 1, 1, 1, 0, "u 'Reflex::Selection::AUTOSELECT' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLSelectioncLcLNODEFAULT(void) {
   /* Reflex::Selection::NODEFAULT */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLNODEFAULT));
   // automatic default constructor
   G__memfunc_setup("NODEFAULT", 674, G__G__Reflex_239_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLNODEFAULT), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("NODEFAULT", 674, G__G__Reflex_239_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLNODEFAULT), -1, 0, 1, 1, 1, 0, "u 'Reflex::Selection::NODEFAULT' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~NODEFAULT", 800, G__G__Reflex_239_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_239_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLNODEFAULT), -1, 1, 1, 1, 1, 0, "u 'Reflex::Selection::NODEFAULT' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLEnumBuilder(void) {
   /* Reflex::EnumBuilder */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEnumBuilder));
   G__memfunc_setup("EnumBuilder",1116,G__G__Reflex_241_0_1, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEnumBuilder), -1, 0, 3, 1, 1, 0, 
"C - - 10 - name u 'type_info' - 11 - ti "
"h - - 0 '0' modifiers", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddItem",664,G__G__Reflex_241_0_2, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEnumBuilder), -1, 1, 2, 1, 1, 0, 
"C - - 10 - nam l - - 0 - value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddProperty",1134,G__G__Reflex_241_0_3, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEnumBuilder), -1, 1, 2, 1, 1, 0, 
"C - - 10 - key u 'Reflex::Any' - 0 - value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddProperty",1134,G__G__Reflex_241_0_4, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEnumBuilder), -1, 1, 2, 1, 1, 0, 
"C - - 10 - key C - - 10 - value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ToType",613,G__G__Reflex_241_0_5, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("EnumBuilder", 1116, G__G__Reflex_241_0_6, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEnumBuilder), -1, 0, 1, 1, 1, 0, "u 'Reflex::EnumBuilder' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~EnumBuilder", 1242, G__G__Reflex_241_0_7, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_241_0_8, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEnumBuilder), -1, 1, 1, 1, 1, 0, "u 'Reflex::EnumBuilder' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLNewDelFunctions(void) {
   /* Reflex::NewDelFunctions */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNewDelFunctions));
   // automatic default constructor
   G__memfunc_setup("NewDelFunctions", 1528, G__G__Reflex_243_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNewDelFunctions), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("NewDelFunctions", 1528, G__G__Reflex_243_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNewDelFunctions), -1, 0, 1, 1, 1, 0, "u 'Reflex::NewDelFunctions' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~NewDelFunctions", 1654, G__G__Reflex_243_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_243_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNewDelFunctions), -1, 1, 1, 1, 1, 0, "u 'Reflex::NewDelFunctions' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLTypedefBuilderImpl(void) {
   /* Reflex::TypedefBuilderImpl */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypedefBuilderImpl));
   G__memfunc_setup("TypedefBuilderImpl",1834,G__G__Reflex_244_0_1, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypedefBuilderImpl), -1, 0, 2, 1, 1, 0, 
"C - - 10 - typ u 'Reflex::Type' - 11 - typedefType", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddProperty",1134,G__G__Reflex_244_0_2, 121, -1, -1, 0, 2, 1, 1, 0, 
"C - - 10 - key u 'Reflex::Any' - 0 - value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddProperty",1134,G__G__Reflex_244_0_3, 121, -1, -1, 0, 2, 1, 1, 0, 
"C - - 10 - key C - - 10 - value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ToType",613,G__G__Reflex_244_0_4, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TypedefBuilderImpl", 1834, G__G__Reflex_244_0_5, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypedefBuilderImpl), -1, 0, 1, 1, 1, 0, "u 'Reflex::TypedefBuilderImpl' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TypedefBuilderImpl", 1960, G__G__Reflex_244_0_6, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLUnionBuilderImpl(void) {
   /* Reflex::UnionBuilderImpl */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnionBuilderImpl));
   G__memfunc_setup("UnionBuilderImpl",1634,G__G__Reflex_246_0_1, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnionBuilderImpl), -1, 0, 5, 1, 1, 0, 
"C - - 10 - nam h - 'size_t' 0 - size "
"u 'type_info' - 11 - ti h - - 0 '0' modifiers "
"i 'Reflex::TYPE' - 0 'UNION' typ", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddItem",664,G__G__Reflex_246_0_2, 121, -1, -1, 0, 2, 1, 1, 0, 
"C - - 10 - nam u 'Reflex::Type' - 11 - typ", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddDataMember",1243,G__G__Reflex_246_0_3, 121, -1, -1, 0, 4, 1, 1, 0, 
"C - - 10 - nam u 'Reflex::Type' - 11 - typ "
"h - 'size_t' 0 - offs h - - 0 '0' modifiers", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddFunctionMember",1703,G__G__Reflex_246_0_4, 121, -1, -1, 0, 6, 1, 1, 0, 
"C - - 10 - nam u 'Reflex::Type' - 11 - typ "
"Y - 'Reflex::StubFunction' 0 - stubFP Y - - 0 '0' stubCtx "
"C - - 10 '0' params h - - 0 '0' modifiers", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddProperty",1134,G__G__Reflex_246_0_5, 121, -1, -1, 0, 2, 1, 1, 0, 
"C - - 10 - key u 'Reflex::Any' - 0 - value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddProperty",1134,G__G__Reflex_246_0_6, 121, -1, -1, 0, 2, 1, 1, 0, 
"C - - 10 - key C - - 10 - value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetSizeOf",892,G__G__Reflex_246_0_7, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'size_t' 0 - size", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ToType",613,G__G__Reflex_246_0_8, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("EnableCallback",1364,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 1, 1, 2, 0, "g - - 10 'true' enable", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("UnionBuilderImpl", 1634, G__G__Reflex_246_0_10, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnionBuilderImpl), -1, 0, 1, 1, 1, 0, "u 'Reflex::UnionBuilderImpl' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~UnionBuilderImpl", 1760, G__G__Reflex_246_0_11, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_246_0_12, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnionBuilderImpl), -1, 1, 1, 1, 1, 0, "u 'Reflex::UnionBuilderImpl' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLVariableBuilder(void) {
   /* Reflex::VariableBuilder */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLVariableBuilder));
   G__memfunc_setup("VariableBuilder",1517,G__G__Reflex_249_0_1, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLVariableBuilder), -1, 0, 4, 1, 1, 0, 
"C - - 10 - nam u 'Reflex::Type' - 11 - typ "
"h - 'size_t' 0 - offs h - - 0 '0' modifiers", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddProperty",1134,G__G__Reflex_249_0_2, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLVariableBuilder), -1, 1, 2, 1, 1, 0, 
"C - - 10 - key u 'Reflex::Any' - 0 - value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddProperty",1134,G__G__Reflex_249_0_3, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLVariableBuilder), -1, 1, 2, 1, 1, 0, 
"C - - 10 - key C - - 10 - value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ToMember",795,G__G__Reflex_249_0_4, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("VariableBuilder", 1517, G__G__Reflex_249_0_5, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLVariableBuilder), -1, 0, 1, 1, 1, 0, "u 'Reflex::VariableBuilder' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~VariableBuilder", 1643, G__G__Reflex_249_0_6, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_249_0_7, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLVariableBuilder), -1, 1, 1, 1, 1, 0, "u 'Reflex::VariableBuilder' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncReflexcLcLVariableBuilderImpl(void) {
   /* Reflex::VariableBuilderImpl */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLVariableBuilderImpl));
   G__memfunc_setup("VariableBuilderImpl",1919,G__G__Reflex_250_0_1, 105, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLVariableBuilderImpl), -1, 0, 4, 1, 1, 0, 
"C - - 10 - nam u 'Reflex::Type' - 11 - typ "
"h - 'size_t' 0 - offs h - - 0 '0' modifiers", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddProperty",1134,G__G__Reflex_250_0_2, 121, -1, -1, 0, 2, 1, 1, 0, 
"C - - 10 - key u 'Reflex::Any' - 0 - value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddProperty",1134,G__G__Reflex_250_0_3, 121, -1, -1, 0, 2, 1, 1, 0, 
"C - - 10 - key C - - 10 - value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ToMember",795,G__G__Reflex_250_0_4, 117, G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("VariableBuilderImpl", 1919, G__G__Reflex_250_0_5, (int) ('i'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLVariableBuilderImpl), -1, 0, 1, 1, 1, 0, "u 'Reflex::VariableBuilderImpl' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~VariableBuilderImpl", 2045, G__G__Reflex_250_0_6, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Reflex_250_0_7, (int) ('u'), G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLVariableBuilderImpl), -1, 1, 1, 1, 1, 0, "u 'Reflex::VariableBuilderImpl' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfuncG__Reflex() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

}

static void G__cpp_setup_global1() {

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_globalG__Reflex() {
  G__cpp_setup_global0();
  G__cpp_setup_global1();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();

}

static void G__cpp_setup_func1() {
}

static void G__cpp_setup_func2() {
}

static void G__cpp_setup_func3() {
}

static void G__cpp_setup_func4() {
}

static void G__cpp_setup_func5() {
}

static void G__cpp_setup_func6() {
}

static void G__cpp_setup_func7() {
}

static void G__cpp_setup_func8() {
}

static void G__cpp_setup_func9() {
}

static void G__cpp_setup_func10() {

   G__resetifuncposition();
}

extern "C" void G__cpp_setup_funcG__Reflex() {
  G__cpp_setup_func0();
  G__cpp_setup_func1();
  G__cpp_setup_func2();
  G__cpp_setup_func3();
  G__cpp_setup_func4();
  G__cpp_setup_func5();
  G__cpp_setup_func6();
  G__cpp_setup_func7();
  G__cpp_setup_func8();
  G__cpp_setup_func9();
  G__cpp_setup_func10();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__G__ReflexLN_type_info = { "type_info" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_basic_ostreamlEcharcOchar_traitslEchargRsPgR = { "basic_ostream<char,char_traits<char> >" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_string = { "string" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR = { "vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_exception = { "exception" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_Reflex = { "Reflex" , 110 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLAny = { "Reflex::Any" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLType = { "Reflex::Type" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLBase = { "Reflex::Base" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLScope = { "Reflex::Scope" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLObject = { "Reflex::Object" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLMember = { "Reflex::Member" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLPropertyList = { "Reflex::PropertyList" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLTypeTemplate = { "Reflex::TypeTemplate" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLMemberTemplate = { "Reflex::MemberTemplate" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgR = { "vector<string,allocator<string> >" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgRcLcLiterator = { "vector<string,allocator<string> >::iterator" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<string,allocator<string> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgR = { "vector<Reflex::Type,allocator<Reflex::Type> >" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiterator = { "vector<Reflex::Type,allocator<Reflex::Type> >::iterator" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Reflex::Type,allocator<Reflex::Type> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_vectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgR = { "vector<Reflex::Base,allocator<Reflex::Base> >" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_vectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgRcLcLiterator = { "vector<Reflex::Base,allocator<Reflex::Base> >::iterator" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Reflex::Base,allocator<Reflex::Base> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_vectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgR = { "vector<Reflex::Scope,allocator<Reflex::Scope> >" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_vectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiterator = { "vector<Reflex::Scope,allocator<Reflex::Scope> >::iterator" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Reflex::Scope,allocator<Reflex::Scope> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_vectorlEReflexcLcLObjectcOallocatorlEReflexcLcLObjectgRsPgR = { "vector<Reflex::Object,allocator<Reflex::Object> >" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_vectorlEReflexcLcLObjectcOallocatorlEReflexcLcLObjectgRsPgRcLcLiterator = { "vector<Reflex::Object,allocator<Reflex::Object> >::iterator" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLObjectcOallocatorlEReflexcLcLObjectgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Reflex::Object,allocator<Reflex::Object> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgR = { "vector<Reflex::Member,allocator<Reflex::Member> >" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiterator = { "vector<Reflex::Member,allocator<Reflex::Member> >::iterator" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Reflex::Member,allocator<Reflex::Member> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_vectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgR = { "vector<Reflex::TypeTemplate,allocator<Reflex::TypeTemplate> >" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_vectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgRcLcLiterator = { "vector<Reflex::TypeTemplate,allocator<Reflex::TypeTemplate> >::iterator" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Reflex::TypeTemplate,allocator<Reflex::TypeTemplate> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_vectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgR = { "vector<Reflex::MemberTemplate,allocator<Reflex::MemberTemplate> >" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_vectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgRcLcLiterator = { "vector<Reflex::MemberTemplate,allocator<Reflex::MemberTemplate> >::iterator" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Reflex::MemberTemplate,allocator<Reflex::MemberTemplate> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLDummy = { "Reflex::Dummy" , 110 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLInstance = { "Reflex::Instance" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION = { "Reflex::ENTITY_DESCRIPTION" , 101 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLENTITY_HANDLING = { "Reflex::ENTITY_HANDLING" , 101 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLTYPE = { "Reflex::TYPE" , 101 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLREPRESTYPE = { "Reflex::REPRESTYPE" , 101 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLEMEMBERQUERY = { "Reflex::EMEMBERQUERY" , 101 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLEDELAYEDLOADSETTING = { "Reflex::EDELAYEDLOADSETTING" , 101 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLNullType = { "Reflex::NullType" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLUnknownType = { "Reflex::UnknownType" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLProtectedClass = { "Reflex::ProtectedClass" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLProtectedEnum = { "Reflex::ProtectedEnum" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLProtectedStruct = { "Reflex::ProtectedStruct" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLProtectedUnion = { "Reflex::ProtectedUnion" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLPrivateClass = { "Reflex::PrivateClass" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLPrivateEnum = { "Reflex::PrivateEnum" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLPrivateStruct = { "Reflex::PrivateStruct" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLPrivateUnion = { "Reflex::PrivateUnion" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLUnnamedClass = { "Reflex::UnnamedClass" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLUnnamedEnum = { "Reflex::UnnamedEnum" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLUnnamedNamespace = { "Reflex::UnnamedNamespace" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLUnnamedStruct = { "Reflex::UnnamedStruct" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLUnnamedUnion = { "Reflex::UnnamedUnion" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLRuntimeError = { "Reflex::RuntimeError" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLAnycLcLPlaceholder = { "Reflex::Any::Placeholder" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLTypeBase = { "Reflex::TypeBase" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLTypeName = { "Reflex::TypeName" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLDictionaryGenerator = { "Reflex::DictionaryGenerator" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLTypecLcLTYPE_MODIFICATION = { "Reflex::Type::TYPE_MODIFICATION" , 101 , -1 };
G__linked_taginfo G__G__ReflexLN_vectorlEvoidmUcOallocatorlEvoidmUgRsPgR = { "vector<void*,allocator<void*> >" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_reverse_iteratorlEvectorlEvoidmUcOallocatorlEvoidmUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<void*,allocator<void*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLScopeBase = { "Reflex::ScopeBase" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLScopeName = { "Reflex::ScopeName" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLPropertyListImpl = { "Reflex::PropertyListImpl" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_vectorlEReflexcLcLAnycOallocatorlEReflexcLcLAnygRsPgR = { "vector<Reflex::Any,allocator<Reflex::Any> >" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLAnycOallocatorlEReflexcLcLAnygRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Reflex::Any,allocator<Reflex::Any> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLClass = { "Reflex::Class" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_vectorlEReflexcLcLOwnedMembercOallocatorlEReflexcLcLOwnedMembergRsPgR = { "vector<Reflex::OwnedMember,allocator<Reflex::OwnedMember> >" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLOwnedMembercOallocatorlEReflexcLcLOwnedMembergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Reflex::OwnedMember,allocator<Reflex::OwnedMember> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_vectorlEReflexcLcLOwnedMemberTemplatecOallocatorlEReflexcLcLOwnedMemberTemplategRsPgR = { "vector<Reflex::OwnedMemberTemplate,allocator<Reflex::OwnedMemberTemplate> >" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLOwnedMemberTemplatecOallocatorlEReflexcLcLOwnedMemberTemplategRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Reflex::OwnedMemberTemplate,allocator<Reflex::OwnedMemberTemplate> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLTypeTemplateName = { "Reflex::TypeTemplateName" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLICallback = { "Reflex::ICallback" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLMemberBase = { "Reflex::MemberBase" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLEFUNDAMENTALTYPE = { "Reflex::EFUNDAMENTALTYPE" , 101 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLTools = { "Reflex::Tools" , 110 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLMemberTemplateName = { "Reflex::MemberTemplateName" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLNamespaceBuilder = { "Reflex::NamespaceBuilder" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLFunctionBuilder = { "Reflex::FunctionBuilder" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLFunctionBuilderImpl = { "Reflex::FunctionBuilderImpl" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_vectorlEReflexcLcLValueObjectcOallocatorlEReflexcLcLValueObjectgRsPgR = { "vector<Reflex::ValueObject,allocator<Reflex::ValueObject> >" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLValueObjectcOallocatorlEReflexcLcLValueObjectgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Reflex::ValueObject,allocator<Reflex::ValueObject> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLClassBuilder = { "Reflex::ClassBuilder" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLOnDemandBuilderForScope = { "Reflex::OnDemandBuilderForScope" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLClassBuilderImpl = { "Reflex::ClassBuilderImpl" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLCollFuncTable = { "Reflex::CollFuncTable" , 115 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLSelection = { "Reflex::Selection" , 110 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT = { "Reflex::Selection::NO_SELF_AUTOSELECT" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLSelectioncLcLTRANSIENT = { "Reflex::Selection::TRANSIENT" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLSelectioncLcLAUTOSELECT = { "Reflex::Selection::AUTOSELECT" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLSelectioncLcLNODEFAULT = { "Reflex::Selection::NODEFAULT" , 115 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLEnum = { "Reflex::Enum" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLEnumBuilder = { "Reflex::EnumBuilder" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLNewDelFunctions = { "Reflex::NewDelFunctions" , 115 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLTypedefBuilderImpl = { "Reflex::TypedefBuilderImpl" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLUnion = { "Reflex::Union" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLUnionBuilderImpl = { "Reflex::UnionBuilderImpl" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLVariableBuilder = { "Reflex::VariableBuilder" , 99 , -1 };
G__linked_taginfo G__G__ReflexLN_ReflexcLcLVariableBuilderImpl = { "Reflex::VariableBuilderImpl" , 99 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtableG__Reflex() {
  G__G__ReflexLN_type_info.tagnum = -1 ;
  G__G__ReflexLN_basic_ostreamlEcharcOchar_traitslEchargRsPgR.tagnum = -1 ;
  G__G__ReflexLN_string.tagnum = -1 ;
  G__G__ReflexLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR.tagnum = -1 ;
  G__G__ReflexLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__ReflexLN_exception.tagnum = -1 ;
  G__G__ReflexLN_Reflex.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLAny.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLType.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLBase.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLScope.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLObject.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLMember.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLPropertyList.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLTypeTemplate.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLMemberTemplate.tagnum = -1 ;
  G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgR.tagnum = -1 ;
  G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgRcLcLiterator.tagnum = -1 ;
  G__G__ReflexLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgR.tagnum = -1 ;
  G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiterator.tagnum = -1 ;
  G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__ReflexLN_vectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgR.tagnum = -1 ;
  G__G__ReflexLN_vectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgRcLcLiterator.tagnum = -1 ;
  G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__ReflexLN_vectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgR.tagnum = -1 ;
  G__G__ReflexLN_vectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiterator.tagnum = -1 ;
  G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__ReflexLN_vectorlEReflexcLcLObjectcOallocatorlEReflexcLcLObjectgRsPgR.tagnum = -1 ;
  G__G__ReflexLN_vectorlEReflexcLcLObjectcOallocatorlEReflexcLcLObjectgRsPgRcLcLiterator.tagnum = -1 ;
  G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLObjectcOallocatorlEReflexcLcLObjectgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgR.tagnum = -1 ;
  G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiterator.tagnum = -1 ;
  G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__ReflexLN_vectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgR.tagnum = -1 ;
  G__G__ReflexLN_vectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgRcLcLiterator.tagnum = -1 ;
  G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__ReflexLN_vectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgR.tagnum = -1 ;
  G__G__ReflexLN_vectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgRcLcLiterator.tagnum = -1 ;
  G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLDummy.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLInstance.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLENTITY_HANDLING.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLTYPE.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLREPRESTYPE.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLEMEMBERQUERY.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLEDELAYEDLOADSETTING.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLNullType.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLUnknownType.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLProtectedClass.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLProtectedEnum.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLProtectedStruct.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLProtectedUnion.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLPrivateClass.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLPrivateEnum.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLPrivateStruct.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLPrivateUnion.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLUnnamedClass.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLUnnamedEnum.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLUnnamedNamespace.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLUnnamedStruct.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLUnnamedUnion.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLRuntimeError.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLAnycLcLPlaceholder.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLTypeBase.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLTypeName.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLDictionaryGenerator.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLTypecLcLTYPE_MODIFICATION.tagnum = -1 ;
  G__G__ReflexLN_vectorlEvoidmUcOallocatorlEvoidmUgRsPgR.tagnum = -1 ;
  G__G__ReflexLN_reverse_iteratorlEvectorlEvoidmUcOallocatorlEvoidmUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLScopeBase.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLScopeName.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLPropertyListImpl.tagnum = -1 ;
  G__G__ReflexLN_vectorlEReflexcLcLAnycOallocatorlEReflexcLcLAnygRsPgR.tagnum = -1 ;
  G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLAnycOallocatorlEReflexcLcLAnygRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLClass.tagnum = -1 ;
  G__G__ReflexLN_vectorlEReflexcLcLOwnedMembercOallocatorlEReflexcLcLOwnedMembergRsPgR.tagnum = -1 ;
  G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLOwnedMembercOallocatorlEReflexcLcLOwnedMembergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__ReflexLN_vectorlEReflexcLcLOwnedMemberTemplatecOallocatorlEReflexcLcLOwnedMemberTemplategRsPgR.tagnum = -1 ;
  G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLOwnedMemberTemplatecOallocatorlEReflexcLcLOwnedMemberTemplategRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLTypeTemplateName.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLICallback.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLMemberBase.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLEFUNDAMENTALTYPE.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLTools.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLMemberTemplateName.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLNamespaceBuilder.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLFunctionBuilder.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLFunctionBuilderImpl.tagnum = -1 ;
  G__G__ReflexLN_vectorlEReflexcLcLValueObjectcOallocatorlEReflexcLcLValueObjectgRsPgR.tagnum = -1 ;
  G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLValueObjectcOallocatorlEReflexcLcLValueObjectgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLClassBuilder.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLOnDemandBuilderForScope.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLClassBuilderImpl.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLCollFuncTable.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLSelection.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLSelectioncLcLTRANSIENT.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLSelectioncLcLAUTOSELECT.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLSelectioncLcLNODEFAULT.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLEnum.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLEnumBuilder.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLNewDelFunctions.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLTypedefBuilderImpl.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLUnion.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLUnionBuilderImpl.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLVariableBuilder.tagnum = -1 ;
  G__G__ReflexLN_ReflexcLcLVariableBuilderImpl.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtableG__Reflex() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_type_info);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_basic_ostreamlEcharcOchar_traitslEchargRsPgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_string);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_exception);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_Reflex),0,-1,0,(char*)NULL,G__setup_memvarReflex,G__setup_memfuncReflex);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLAny),sizeof(Reflex::Any),-1,3840,(char*)NULL,G__setup_memvarReflexcLcLAny,G__setup_memfuncReflexcLcLAny);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLType),sizeof(Reflex::Type),-1,36608,(char*)NULL,G__setup_memvarReflexcLcLType,G__setup_memfuncReflexcLcLType);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLBase),sizeof(Reflex::Base),-1,34048,(char*)NULL,G__setup_memvarReflexcLcLBase,G__setup_memfuncReflexcLcLBase);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLScope),sizeof(Reflex::Scope),-1,34560,(char*)NULL,G__setup_memvarReflexcLcLScope,G__setup_memfuncReflexcLcLScope);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLObject),sizeof(Reflex::Object),-1,36608,(char*)NULL,G__setup_memvarReflexcLcLObject,G__setup_memfuncReflexcLcLObject);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMember),sizeof(Reflex::Member),-1,3840,(char*)NULL,G__setup_memvarReflexcLcLMember,G__setup_memfuncReflexcLcLMember);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_ReflexcLcLPropertyList);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypeTemplate),sizeof(Reflex::TypeTemplate),-1,34560,(char*)NULL,G__setup_memvarReflexcLcLTypeTemplate,G__setup_memfuncReflexcLcLTypeTemplate);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLMemberTemplate),sizeof(Reflex::MemberTemplate),-1,34560,(char*)NULL,G__setup_memvarReflexcLcLMemberTemplate,G__setup_memfuncReflexcLcLMemberTemplate);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_vectorlEstringcOallocatorlEstringgRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_vectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypecOallocatorlEReflexcLcLTypegRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_vectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_vectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLBasecOallocatorlEReflexcLcLBasegRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_vectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_vectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLScopecOallocatorlEReflexcLcLScopegRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_vectorlEReflexcLcLObjectcOallocatorlEReflexcLcLObjectgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_vectorlEReflexcLcLObjectcOallocatorlEReflexcLcLObjectgRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLObjectcOallocatorlEReflexcLcLObjectgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_vectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMembercOallocatorlEReflexcLcLMembergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_vectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_vectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLTypeTemplatecOallocatorlEReflexcLcLTypeTemplategRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_vectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_vectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLMemberTemplatecOallocatorlEReflexcLcLMemberTemplategRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLDummy),0,-1,0,(char*)NULL,G__setup_memvarReflexcLcLDummy,G__setup_memfuncReflexcLcLDummy);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLInstance),sizeof(Reflex::Instance),-1,34048,(char*)NULL,G__setup_memvarReflexcLcLInstance,G__setup_memfuncReflexcLcLInstance);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_DESCRIPTION),sizeof(int),-1,0,(char*)NULL,NULL,NULL);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLENTITY_HANDLING),sizeof(int),-1,0,(char*)NULL,NULL,NULL);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTYPE),sizeof(int),-1,0,(char*)NULL,NULL,NULL);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_ReflexcLcLREPRESTYPE);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_ReflexcLcLEMEMBERQUERY);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_ReflexcLcLEDELAYEDLOADSETTING);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNullType),sizeof(Reflex::NullType),-1,0,(char*)NULL,G__setup_memvarReflexcLcLNullType,G__setup_memfuncReflexcLcLNullType);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnknownType),sizeof(Reflex::UnknownType),-1,0,(char*)NULL,G__setup_memvarReflexcLcLUnknownType,G__setup_memfuncReflexcLcLUnknownType);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedClass),sizeof(Reflex::ProtectedClass),-1,0,(char*)NULL,G__setup_memvarReflexcLcLProtectedClass,G__setup_memfuncReflexcLcLProtectedClass);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedEnum),sizeof(Reflex::ProtectedEnum),-1,0,(char*)NULL,G__setup_memvarReflexcLcLProtectedEnum,G__setup_memfuncReflexcLcLProtectedEnum);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedStruct),sizeof(Reflex::ProtectedStruct),-1,0,(char*)NULL,G__setup_memvarReflexcLcLProtectedStruct,G__setup_memfuncReflexcLcLProtectedStruct);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLProtectedUnion),sizeof(Reflex::ProtectedUnion),-1,0,(char*)NULL,G__setup_memvarReflexcLcLProtectedUnion,G__setup_memfuncReflexcLcLProtectedUnion);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateClass),sizeof(Reflex::PrivateClass),-1,0,(char*)NULL,G__setup_memvarReflexcLcLPrivateClass,G__setup_memfuncReflexcLcLPrivateClass);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateEnum),sizeof(Reflex::PrivateEnum),-1,0,(char*)NULL,G__setup_memvarReflexcLcLPrivateEnum,G__setup_memfuncReflexcLcLPrivateEnum);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateStruct),sizeof(Reflex::PrivateStruct),-1,0,(char*)NULL,G__setup_memvarReflexcLcLPrivateStruct,G__setup_memfuncReflexcLcLPrivateStruct);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLPrivateUnion),sizeof(Reflex::PrivateUnion),-1,0,(char*)NULL,G__setup_memvarReflexcLcLPrivateUnion,G__setup_memfuncReflexcLcLPrivateUnion);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedClass),sizeof(Reflex::UnnamedClass),-1,0,(char*)NULL,G__setup_memvarReflexcLcLUnnamedClass,G__setup_memfuncReflexcLcLUnnamedClass);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedEnum),sizeof(Reflex::UnnamedEnum),-1,0,(char*)NULL,G__setup_memvarReflexcLcLUnnamedEnum,G__setup_memfuncReflexcLcLUnnamedEnum);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedNamespace),sizeof(Reflex::UnnamedNamespace),-1,0,(char*)NULL,G__setup_memvarReflexcLcLUnnamedNamespace,G__setup_memfuncReflexcLcLUnnamedNamespace);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedStruct),sizeof(Reflex::UnnamedStruct),-1,0,(char*)NULL,G__setup_memvarReflexcLcLUnnamedStruct,G__setup_memfuncReflexcLcLUnnamedStruct);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnnamedUnion),sizeof(Reflex::UnnamedUnion),-1,0,(char*)NULL,G__setup_memvarReflexcLcLUnnamedUnion,G__setup_memfuncReflexcLcLUnnamedUnion);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLRuntimeError),sizeof(Reflex::RuntimeError),-1,33792,(char*)NULL,G__setup_memvarReflexcLcLRuntimeError,G__setup_memfuncReflexcLcLRuntimeError);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_ReflexcLcLAnycLcLPlaceholder);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_ReflexcLcLTypeBase);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_ReflexcLcLTypeName);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_ReflexcLcLDictionaryGenerator);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_ReflexcLcLTypecLcLTYPE_MODIFICATION);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_vectorlEvoidmUcOallocatorlEvoidmUgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_reverse_iteratorlEvectorlEvoidmUcOallocatorlEvoidmUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_ReflexcLcLScopeBase);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_ReflexcLcLScopeName);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_ReflexcLcLPropertyListImpl);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_vectorlEReflexcLcLAnycOallocatorlEReflexcLcLAnygRsPgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLAnycOallocatorlEReflexcLcLAnygRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_ReflexcLcLClass);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_vectorlEReflexcLcLOwnedMembercOallocatorlEReflexcLcLOwnedMembergRsPgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLOwnedMembercOallocatorlEReflexcLcLOwnedMembergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_vectorlEReflexcLcLOwnedMemberTemplatecOallocatorlEReflexcLcLOwnedMemberTemplategRsPgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLOwnedMemberTemplatecOallocatorlEReflexcLcLOwnedMemberTemplategRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_ReflexcLcLTypeTemplateName);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLICallback),sizeof(Reflex::ICallback),-1,1282,(char*)NULL,G__setup_memvarReflexcLcLICallback,G__setup_memfuncReflexcLcLICallback);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_ReflexcLcLMemberBase);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEFUNDAMENTALTYPE),sizeof(int),-1,0,(char*)NULL,NULL,NULL);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTools),0,-1,0,(char*)NULL,G__setup_memvarReflexcLcLTools,G__setup_memfuncReflexcLcLTools);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_ReflexcLcLMemberTemplateName);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNamespaceBuilder),sizeof(Reflex::NamespaceBuilder),-1,33792,(char*)NULL,G__setup_memvarReflexcLcLNamespaceBuilder,G__setup_memfuncReflexcLcLNamespaceBuilder);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLFunctionBuilder),sizeof(Reflex::FunctionBuilder),-1,33792,(char*)NULL,G__setup_memvarReflexcLcLFunctionBuilder,G__setup_memfuncReflexcLcLFunctionBuilder);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLFunctionBuilderImpl),sizeof(Reflex::FunctionBuilderImpl),-1,33792,(char*)NULL,G__setup_memvarReflexcLcLFunctionBuilderImpl,G__setup_memfuncReflexcLcLFunctionBuilderImpl);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_vectorlEReflexcLcLValueObjectcOallocatorlEReflexcLcLValueObjectgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_reverse_iteratorlEvectorlEReflexcLcLValueObjectcOallocatorlEReflexcLcLValueObjectgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilder),sizeof(Reflex::ClassBuilder),-1,33792,(char*)NULL,G__setup_memvarReflexcLcLClassBuilder,G__setup_memfuncReflexcLcLClassBuilder);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_ReflexcLcLOnDemandBuilderForScope);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLClassBuilderImpl),sizeof(Reflex::ClassBuilderImpl),-1,33792,(char*)NULL,G__setup_memvarReflexcLcLClassBuilderImpl,G__setup_memfuncReflexcLcLClassBuilderImpl);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLCollFuncTable),sizeof(Reflex::CollFuncTable),-1,0,(char*)NULL,G__setup_memvarReflexcLcLCollFuncTable,G__setup_memfuncReflexcLcLCollFuncTable);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_ReflexcLcLSelection);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT),sizeof(Reflex::Selection::NO_SELF_AUTOSELECT),-1,0,(char*)NULL,G__setup_memvarReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT,G__setup_memfuncReflexcLcLSelectioncLcLNO_SELF_AUTOSELECT);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLTRANSIENT),sizeof(Reflex::Selection::TRANSIENT),-1,0,(char*)NULL,G__setup_memvarReflexcLcLSelectioncLcLTRANSIENT,G__setup_memfuncReflexcLcLSelectioncLcLTRANSIENT);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLAUTOSELECT),sizeof(Reflex::Selection::AUTOSELECT),-1,0,(char*)NULL,G__setup_memvarReflexcLcLSelectioncLcLAUTOSELECT,G__setup_memfuncReflexcLcLSelectioncLcLAUTOSELECT);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLSelectioncLcLNODEFAULT),sizeof(Reflex::Selection::NODEFAULT),-1,0,(char*)NULL,G__setup_memvarReflexcLcLSelectioncLcLNODEFAULT,G__setup_memfuncReflexcLcLSelectioncLcLNODEFAULT);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_ReflexcLcLEnum);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLEnumBuilder),sizeof(Reflex::EnumBuilder),-1,33792,(char*)NULL,G__setup_memvarReflexcLcLEnumBuilder,G__setup_memfuncReflexcLcLEnumBuilder);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLNewDelFunctions),sizeof(Reflex::NewDelFunctions),-1,0,(char*)NULL,G__setup_memvarReflexcLcLNewDelFunctions,G__setup_memfuncReflexcLcLNewDelFunctions);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLTypedefBuilderImpl),sizeof(Reflex::TypedefBuilderImpl),-1,33792,(char*)NULL,G__setup_memvarReflexcLcLTypedefBuilderImpl,G__setup_memfuncReflexcLcLTypedefBuilderImpl);
   G__get_linked_tagnum_fwd(&G__G__ReflexLN_ReflexcLcLUnion);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLUnionBuilderImpl),sizeof(Reflex::UnionBuilderImpl),-1,33792,(char*)NULL,G__setup_memvarReflexcLcLUnionBuilderImpl,G__setup_memfuncReflexcLcLUnionBuilderImpl);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLVariableBuilder),sizeof(Reflex::VariableBuilder),-1,33792,(char*)NULL,G__setup_memvarReflexcLcLVariableBuilder,G__setup_memfuncReflexcLcLVariableBuilder);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__ReflexLN_ReflexcLcLVariableBuilderImpl),sizeof(Reflex::VariableBuilderImpl),-1,33792,(char*)NULL,G__setup_memvarReflexcLcLVariableBuilderImpl,G__setup_memfuncReflexcLcLVariableBuilderImpl);
}
extern "C" void G__cpp_setupG__Reflex(void) {
  G__check_setup_version(30051515,"G__cpp_setupG__Reflex()");
  G__set_cpp_environmentG__Reflex();
  G__cpp_setup_tagtableG__Reflex();

  G__cpp_setup_inheritanceG__Reflex();

  G__cpp_setup_typetableG__Reflex();

  G__cpp_setup_memvarG__Reflex();

  G__cpp_setup_memfuncG__Reflex();
  G__cpp_setup_globalG__Reflex();
  G__cpp_setup_funcG__Reflex();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfuncG__Reflex();
  return;
}
class G__cpp_setup_initG__Reflex {
  public:
    G__cpp_setup_initG__Reflex() { G__add_setup_func("G__Reflex",(G__incsetup)(&G__cpp_setupG__Reflex)); G__call_setup_funcs(); }
   ~G__cpp_setup_initG__Reflex() { G__remove_setup_func("G__Reflex"); }
};
G__cpp_setup_initG__Reflex G__cpp_setup_initializerG__Reflex;

