//
// File generated by core/utils/src/rootcint_tmp at Mon Apr 13 13:40:21 2015

// Do NOT change. Changes will be lost next time file is generated
//

#include "RConfig.h" //rootcint 4834
#if !defined(R__ACCESS_IN_SYMBOL)
//Break the privacy of classes -- Disabled for the moment
#define private public
#define protected public
#endif

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;
#include "G__MathCore.h"

#include "TCollectionProxyInfo.h"
#include "TClass.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"

// START OF SHADOWS

namespace ROOT {
   namespace Shadow {
      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TKDTree< int, double > TKDTreelEintcOdoublegR;
      #else
      class TKDTreelEintcOdoublegR  :  public ::TObject {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~TKDTreelEintcOdoublegR() throw() {};
         int fDataOwner; //! 0 - not owner, 2 - owner of the pointer array, 1 - owner of the whole 2-d array
         int fNNodes; //size of node array
         int fTotalNodes; //total number of nodes (fNNodes + terminal nodes)
         int fNDim; //number of dimensions
         int fNDimm; //dummy 2*fNDim
         int fNPoints; //number of multidimensional points
         int fBucketSize; //size of the terminal nodes
         unsigned char* fAxis; //[fNNodes] nodes cutting axis
         double* fValue; //[fNNodes] nodes cutting value
         double* fRange; //[fNDimm] range of data for each dimension
         double** fData; //! data points
         double* fBoundaries; //! nodes boundaries
         int* fIndPoints; //! array of points indexes
         int fRowT0; //! smallest terminal row - first row that contains terminal nodes
         int fCrossNode; //! cross node - node that begins the last row (with terminal nodes only)
         int fOffset; //! offset in fIndPoints - if there are 2 rows, that contain terminal nodes
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TKDTree< int, float > TKDTreelEintcOfloatgR;
      #else
      class TKDTreelEintcOfloatgR  :  public ::TObject {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~TKDTreelEintcOfloatgR() throw() {};
         int fDataOwner; //! 0 - not owner, 2 - owner of the pointer array, 1 - owner of the whole 2-d array
         int fNNodes; //size of node array
         int fTotalNodes; //total number of nodes (fNNodes + terminal nodes)
         int fNDim; //number of dimensions
         int fNDimm; //dummy 2*fNDim
         int fNPoints; //number of multidimensional points
         int fBucketSize; //size of the terminal nodes
         unsigned char* fAxis; //[fNNodes] nodes cutting axis
         float* fValue; //[fNNodes] nodes cutting value
         float* fRange; //[fNDimm] range of data for each dimension
         float** fData; //! data points
         float* fBoundaries; //! nodes boundaries
         int* fIndPoints; //! array of points indexes
         int fRowT0; //! smallest terminal row - first row that contains terminal nodes
         int fCrossNode; //! cross node - node that begins the last row (with terminal nodes only)
         int fOffset; //! offset in fIndPoints - if there are 2 rows, that contain terminal nodes
      };
      #endif

      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IBaseFunctionOneDim IBaseFunctionOneDim;
      #else
      class IBaseFunctionOneDim  {
         public:
         //friend XX;
         typedef ::ROOT::Math::IBaseFunctionOneDim BaseFunc;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IBaseFunctionOneDim() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IGradientFunctionOneDim IGradientFunctionOneDim;
      #else
      class IGradientFunctionOneDim  :  virtual public ::ROOT::Math::IBaseFunctionOneDim,  public ::ROOT::Math::IGradientOneDim {
         public:
         //friend XX;
         typedef ::ROOT::Math::IBaseFunctionOneDim BaseFunc;
         typedef ::ROOT::Math::IGradientOneDim BaseGrad;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IGradientFunctionOneDim() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IBaseFunctionMultiDim IBaseFunctionMultiDim;
      #else
      class IBaseFunctionMultiDim  {
         public:
         //friend XX;
         typedef ::ROOT::Math::IBaseFunctionMultiDim BaseFunc;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IBaseFunctionMultiDim() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IGradientFunctionMultiDim IGradientFunctionMultiDim;
      #else
      class IGradientFunctionMultiDim  :  virtual public ::ROOT::Math::IBaseFunctionMultiDim,  public ::ROOT::Math::IGradientMultiDim {
         public:
         //friend XX;
         typedef ::ROOT::Math::IBaseFunctionMultiDim BaseFunc;
         typedef ::ROOT::Math::IGradientMultiDim BaseGrad;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IGradientFunctionMultiDim() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IGradientMultiDim IGradientMultiDim;
      #else
      class IGradientMultiDim  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IGradientMultiDim() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IGradientOneDim IGradientOneDim;
      #else
      class IGradientOneDim  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IGradientOneDim() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IParametricFunctionOneDim IParametricFunctionOneDim;
      #else
      class IParametricFunctionOneDim  :  virtual public ::ROOT::Math::IBaseFunctionOneDim,  public ::ROOT::Math::IBaseParam {
         public:
         //friend XX;
         typedef ::ROOT::Math::IBaseFunctionOneDim BaseFunc;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IParametricFunctionOneDim() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IParametricGradFunctionOneDim IParametricGradFunctionOneDim;
      #else
      class IParametricGradFunctionOneDim  :  public ::ROOT::Math::IParametricFunctionOneDim {
         public:
         //friend XX;
         typedef ::ROOT::Math::IParametricFunctionOneDim BaseParamFunc;
         typedef ::ROOT::Math::IGradientFunctionOneDim BaseGradFunc;
         typedef ::ROOT::Math::IBaseFunctionOneDim BaseFunc;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IParametricGradFunctionOneDim() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IParametricFunctionMultiDim IParametricFunctionMultiDim;
      #else
      class IParametricFunctionMultiDim  :  virtual public ::ROOT::Math::IBaseFunctionMultiDim,  public ::ROOT::Math::IBaseParam {
         public:
         //friend XX;
         typedef ::ROOT::Math::IBaseFunctionMultiDim BaseFunc;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IParametricFunctionMultiDim() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IParametricGradFunctionMultiDim IParametricGradFunctionMultiDim;
      #else
      class IParametricGradFunctionMultiDim  :  public ::ROOT::Math::IParametricFunctionMultiDim {
         public:
         //friend XX;
         typedef ::ROOT::Math::IParametricFunctionMultiDim BaseParamFunc;
         typedef ::ROOT::Math::IGradientFunctionMultiDim BaseGradFunc;
         typedef ::ROOT::Math::IBaseFunctionMultiDim BaseFunc;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IParametricGradFunctionMultiDim() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IBaseParam IBaseParam;
      #else
      class IBaseParam  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IBaseParam() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::ParamFunctor ParamFunctor;
      #else
      class ParamFunctor  {
         public:
         //friend XX;
         typedef ::ROOT::Math::ParamFunctionBase Impl;
         typedef void* (*FreeFunc)() ;
         // To force the creation of a virtual table, throw just in case.
         virtual ~ParamFunctor() throw() {};
         ::ROOT::Math::ParamFunctionBase* fImpl; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::Minimizer Minimizer;
      #else
      class Minimizer  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~Minimizer() throw() {};
         bool fValidError; //flag to control if errors have been validated (Hesse has been run in case of Minuit)
         int fDebug; //print level
         int fStrategy; //minimizer strategy
         int fStatus; //status of minimizer    
         unsigned int fMaxCalls; //max number of function calls 
         unsigned int fMaxIter; //max number or iterations used to find the minimum
         double fTol; //tolerance (absolute)
         double fPrec; //precision
         double fUp; //error scale 
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::MinimizerOptions MinimizerOptions;
      #else
      class MinimizerOptions  {
         public:
         //friend XX;
         int fLevel; //debug print level 
         int fMaxCalls; //maximum number of function calls
         int fMaxIter; //maximum number of iterations
         int fStrategy; //minimizer strategy (used by Minuit)
         double fErrorDef; //error definition (=1. for getting 1 sigma error for chi2 fits)
         double fTolerance; //minimize tolerance to reach solution
         double fPrecision; //precision of the objective funciton evaluation (value <=0 means left to default)
         string fMinimType; //Minimizer type (Minuit, Minuit2, etc..
         string fAlgoType; //Minimizer algorithmic specification (Migrad, Minimize, ...)
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::VirtualIntegrator VirtualIntegrator;
      #else
      class VirtualIntegrator  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~VirtualIntegrator() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::VirtualIntegratorOneDim VirtualIntegratorOneDim;
      #else
      class VirtualIntegratorOneDim  :  public ::ROOT::Math::VirtualIntegrator {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~VirtualIntegratorOneDim() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::VirtualIntegratorMultiDim VirtualIntegratorMultiDim;
      #else
      class VirtualIntegratorMultiDim  :  public ::ROOT::Math::VirtualIntegrator {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~VirtualIntegratorMultiDim() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IntegratorOneDim IntegratorOneDim;
      #else
      class IntegratorOneDim  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IntegratorOneDim() throw() {};
         ::ROOT::Math::VirtualIntegratorOneDim* fIntegrator; //pointer to integrator interface class
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::AdaptiveIntegratorMultiDim AdaptiveIntegratorMultiDim;
      #else
      class AdaptiveIntegratorMultiDim  :  public ::ROOT::Math::VirtualIntegratorMultiDim {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AdaptiveIntegratorMultiDim() throw() {};
         unsigned int fDim; //dimentionality of integrand
         double fAbsTol; //absolute tolerance
         double fRelTol; //relative tolerance
         unsigned int fSize; //max size of working array (explode with dimension)
         double fResult; //last integration result 
         double fError; //integration error 
         double fRelError; //Relative error
         unsigned int fNEval; //number of function evaluation
         int fStatus; //status of algorithm (error if not zero)
         :: ROOT::Math::IBaseFunctionMultiDim* fFun; //pointer to integrand function 
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IntegratorMultiDim IntegratorMultiDim;
      #else
      class IntegratorMultiDim  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IntegratorMultiDim() throw() {};
         ::ROOT::Math::VirtualIntegratorMultiDim* fIntegrator; //pointer to multi-dimensional integrator base class
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::Factory Factory;
      #else
      class Factory  {
         public:
         //friend XX;
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::BasicFitMethodFunction< ::ROOT::Math::IBaseFunctionMultiDim > BasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR;
      #else
      class BasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR  :  public ::ROOT::Math::IBaseFunctionMultiDim {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::ROOT::Math::BasicFitMethodFunction< ::ROOT::Math::IBaseFunctionMultiDim >::Type_t Type_t;
         #else
         enum Type_t  {
         };
         #endif

         typedef ::ROOT::Math::IBaseFunctionMultiDim BaseFunction;
         // To force the creation of a virtual table, throw just in case.
         virtual ~BasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR() throw() {};
         unsigned int fNDim; //function dimension 
         unsigned int fNPoints; //size of the data
         unsigned int fNCalls; //number of function calls
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::BasicFitMethodFunction< ::ROOT::Math::IGradientFunctionMultiDim > BasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR;
      #else
      class BasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR  :  public ::ROOT::Math::IGradientFunctionMultiDim {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::ROOT::Math::BasicFitMethodFunction< ::ROOT::Math::IGradientFunctionMultiDim >::Type_t Type_t;
         #else
         enum Type_t  {
         };
         #endif

         typedef ::ROOT::Math::IBaseFunctionMultiDim BaseFunction;
         // To force the creation of a virtual table, throw just in case.
         virtual ~BasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR() throw() {};
         unsigned int fNDim; //function dimension 
         unsigned int fNPoints; //size of the data
         unsigned int fNCalls; //number of function calls
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GaussIntegrator GaussIntegrator;
      #else
      class GaussIntegrator  :  public ::ROOT::Math::VirtualIntegratorOneDim {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~GaussIntegrator() throw() {};
         double fEpsilon; //Relative error.
         bool fUsedOnce; //Bool value to check if the function was at least called once.
         double fLastResult; //Result from the last stimation.
         double fLastError; //Error from the last stimation.
         :: ROOT::Math::IBaseFunctionOneDim* fFunction; //Pointer to function used.
         bool fFunctionCopied; //Bool value to check if the function was copied when set.
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::GaussLegendreIntegrator GaussLegendreIntegrator;
      #else
      class GaussLegendreIntegrator  :  public ::ROOT::Math::VirtualIntegratorOneDim {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~GaussLegendreIntegrator() throw() {};
         int fNum; //Number of points used in the stimation of the integral.
         double* fX; //Abscisa of the points used.
         double* fW; //Weights of the points used.
         double fEpsilon; //Desired relative error.
         bool fUsedOnce; //Bool value to check if the function was at least called once.
         double fLastResult; //Result from the last stimation.
         double fLastError; //Error from the last stimation.
         :: ROOT::Math::IBaseFunctionOneDim* fFunction; //Pointer to function used.
         bool fFunctionCopied; //Bool value to check if the function was copied when set.
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::IRootFinderMethod IRootFinderMethod;
      #else
      class IRootFinderMethod  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~IRootFinderMethod() throw() {};
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::RootFinder RootFinder;
      #else
      class RootFinder  {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::ROOT::Math::RootFinder::EType EType;
         #else
         enum EType  {
         };
         #endif

         // To force the creation of a virtual table, throw just in case.
         virtual ~RootFinder() throw() {};
         ::ROOT::Math::IRootFinderMethod* fSolver; //type of algorithm to be used 
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::RichardsonDerivator RichardsonDerivator;
      #else
      class RichardsonDerivator  {
         public:
         //friend XX;
         bool fFunctionCopied; //flag to control if function is copied in the class
         double fStepSize; //step size used for derivative calculation
         double fLastError; //error estimate of last derivative calculation
         :: ROOT::Math::IBaseFunctionOneDim* fFunction; //pointer to function
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::BrentMinimizer1D BrentMinimizer1D;
      #else
      class BrentMinimizer1D  :  private ::ROOT::Math::IMinimizer1D {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~BrentMinimizer1D() throw() {};
         :: ROOT::Math::IBaseFunctionOneDim* fFunction; //Pointer to the function.
         double fXMin; //Lower bound of the search interval.
         double fXMax; //Upper bound of the search interval
         double fXMinimum; //Position of the stimated minimum.
         int fNIter; //Number of iterations needed for the last stimation.
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::BrentRootFinder BrentRootFinder;
      #else
      class BrentRootFinder  :  public ::ROOT::Math::IRootFinderMethod {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~BrentRootFinder() throw() {};
         :: ROOT::Math::IBaseFunctionOneDim* fFunction; //Pointer to the function.
         double fXMin; //Lower bound of the search interval.
         double fXMax; //Upper bound of the search interval
         double fRoot; //Current stimation of the function root.
      };
      #endif
      } } 
   } // of namespace Shadow
} // of namespace ROOT
// END OF SHADOWS

   namespace ROOT {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static void ROOT_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("ROOT", 0 /*version*/, "include/Math/QuantFuncMathCore.h", 36,
                     ::ROOT::DefineBehavior((void*)0,(void*)0),
                     &ROOT_Dictionary, 0);
         return &instance;
      }
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_(Init));

      // Dictionary for non-ClassDef classes
      static void ROOT_Dictionary() {
         GenerateInitInstance()->GetClass();
      }

   }

namespace ROOT {
   void TRandom_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void *new_TRandom(void *p = 0);
   static void *newArray_TRandom(Long_t size, void *p);
   static void delete_TRandom(void *p);
   static void deleteArray_TRandom(void *p);
   static void destruct_TRandom(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TRandom*)
   {
      ::TRandom *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TRandom >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TRandom", ::TRandom::Class_Version(), "include/TRandom.h", 29,
                  typeid(::TRandom), DefineBehavior(ptr, ptr),
                  &::TRandom::Dictionary, isa_proxy, 4,
                  sizeof(::TRandom) );
      instance.SetNew(&new_TRandom);
      instance.SetNewArray(&newArray_TRandom);
      instance.SetDelete(&delete_TRandom);
      instance.SetDeleteArray(&deleteArray_TRandom);
      instance.SetDestructor(&destruct_TRandom);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TRandom*)
   {
      return GenerateInitInstanceLocal((::TRandom*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TRandom*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TRandom1_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void *new_TRandom1(void *p = 0);
   static void *newArray_TRandom1(Long_t size, void *p);
   static void delete_TRandom1(void *p);
   static void deleteArray_TRandom1(void *p);
   static void destruct_TRandom1(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TRandom1*)
   {
      ::TRandom1 *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TRandom1 >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TRandom1", ::TRandom1::Class_Version(), "include/TRandom1.h", 29,
                  typeid(::TRandom1), DefineBehavior(ptr, ptr),
                  &::TRandom1::Dictionary, isa_proxy, 4,
                  sizeof(::TRandom1) );
      instance.SetNew(&new_TRandom1);
      instance.SetNewArray(&newArray_TRandom1);
      instance.SetDelete(&delete_TRandom1);
      instance.SetDeleteArray(&deleteArray_TRandom1);
      instance.SetDestructor(&destruct_TRandom1);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TRandom1*)
   {
      return GenerateInitInstanceLocal((::TRandom1*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TRandom1*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TRandom2_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void *new_TRandom2(void *p = 0);
   static void *newArray_TRandom2(Long_t size, void *p);
   static void delete_TRandom2(void *p);
   static void deleteArray_TRandom2(void *p);
   static void destruct_TRandom2(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TRandom2*)
   {
      ::TRandom2 *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TRandom2 >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TRandom2", ::TRandom2::Class_Version(), "include/TRandom2.h", 29,
                  typeid(::TRandom2), DefineBehavior(ptr, ptr),
                  &::TRandom2::Dictionary, isa_proxy, 4,
                  sizeof(::TRandom2) );
      instance.SetNew(&new_TRandom2);
      instance.SetNewArray(&newArray_TRandom2);
      instance.SetDelete(&delete_TRandom2);
      instance.SetDeleteArray(&deleteArray_TRandom2);
      instance.SetDestructor(&destruct_TRandom2);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TRandom2*)
   {
      return GenerateInitInstanceLocal((::TRandom2*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TRandom2*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TRandom3_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void *new_TRandom3(void *p = 0);
   static void *newArray_TRandom3(Long_t size, void *p);
   static void delete_TRandom3(void *p);
   static void deleteArray_TRandom3(void *p);
   static void destruct_TRandom3(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TRandom3*)
   {
      ::TRandom3 *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TRandom3 >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TRandom3", ::TRandom3::Class_Version(), "include/TRandom3.h", 29,
                  typeid(::TRandom3), DefineBehavior(ptr, ptr),
                  &::TRandom3::Dictionary, isa_proxy, 1,
                  sizeof(::TRandom3) );
      instance.SetNew(&new_TRandom3);
      instance.SetNewArray(&newArray_TRandom3);
      instance.SetDelete(&delete_TRandom3);
      instance.SetDeleteArray(&deleteArray_TRandom3);
      instance.SetDestructor(&destruct_TRandom3);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TRandom3*)
   {
      return GenerateInitInstanceLocal((::TRandom3*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TRandom3*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TVirtualFitter_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void delete_TVirtualFitter(void *p);
   static void deleteArray_TVirtualFitter(void *p);
   static void destruct_TVirtualFitter(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualFitter*)
   {
      ::TVirtualFitter *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TVirtualFitter >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualFitter", ::TVirtualFitter::Class_Version(), "include/TVirtualFitter.h", 33,
                  typeid(::TVirtualFitter), DefineBehavior(ptr, ptr),
                  &::TVirtualFitter::Dictionary, isa_proxy, 4,
                  sizeof(::TVirtualFitter) );
      instance.SetDelete(&delete_TVirtualFitter);
      instance.SetDeleteArray(&deleteArray_TVirtualFitter);
      instance.SetDestructor(&destruct_TVirtualFitter);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualFitter*)
   {
      return GenerateInitInstanceLocal((::TVirtualFitter*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TVirtualFitter*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TKDTreelEintcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void TKDTreelEintcOdoublegR_Dictionary();
   static void *new_TKDTreelEintcOdoublegR(void *p = 0);
   static void *newArray_TKDTreelEintcOdoublegR(Long_t size, void *p);
   static void delete_TKDTreelEintcOdoublegR(void *p);
   static void deleteArray_TKDTreelEintcOdoublegR(void *p);
   static void destruct_TKDTreelEintcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TKDTree<int,double>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TKDTree<int,double>) == sizeof(::ROOT::Shadow::TKDTreelEintcOdoublegR));
      ::TKDTree<int,double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TKDTree<int,double> >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TKDTree<int,double>", ::TKDTree<int,double>::Class_Version(), "include/TKDTree.h", 12,
                  typeid(::TKDTree<int,double>), DefineBehavior(ptr, ptr),
                  &TKDTreelEintcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(::TKDTree<int,double>) );
      instance.SetNew(&new_TKDTreelEintcOdoublegR);
      instance.SetNewArray(&newArray_TKDTreelEintcOdoublegR);
      instance.SetDelete(&delete_TKDTreelEintcOdoublegR);
      instance.SetDeleteArray(&deleteArray_TKDTreelEintcOdoublegR);
      instance.SetDestructor(&destruct_TKDTreelEintcOdoublegR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TKDTree<int,double>*)
   {
      return GenerateInitInstanceLocal((::TKDTree<int,double>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TKDTree<int,double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TKDTreelEintcOdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TKDTree<int,double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TKDTreelEintcOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void TKDTreelEintcOfloatgR_Dictionary();
   static void *new_TKDTreelEintcOfloatgR(void *p = 0);
   static void *newArray_TKDTreelEintcOfloatgR(Long_t size, void *p);
   static void delete_TKDTreelEintcOfloatgR(void *p);
   static void deleteArray_TKDTreelEintcOfloatgR(void *p);
   static void destruct_TKDTreelEintcOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TKDTree<int,float>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TKDTree<int,float>) == sizeof(::ROOT::Shadow::TKDTreelEintcOfloatgR));
      ::TKDTree<int,float> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TKDTree<int,float> >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TKDTree<int,float>", ::TKDTree<int,float>::Class_Version(), "include/TKDTree.h", 12,
                  typeid(::TKDTree<int,float>), DefineBehavior(ptr, ptr),
                  &TKDTreelEintcOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(::TKDTree<int,float>) );
      instance.SetNew(&new_TKDTreelEintcOfloatgR);
      instance.SetNewArray(&newArray_TKDTreelEintcOfloatgR);
      instance.SetDelete(&delete_TKDTreelEintcOfloatgR);
      instance.SetDeleteArray(&deleteArray_TKDTreelEintcOfloatgR);
      instance.SetDestructor(&destruct_TKDTreelEintcOfloatgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TKDTree<int,float>*)
   {
      return GenerateInitInstanceLocal((::TKDTree<int,float>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TKDTree<int,float>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TKDTreelEintcOfloatgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TKDTree<int,float>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
namespace Math {
   namespace ROOT {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static void ROOTcLcLMath_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("ROOT::Math", 0 /*version*/, "include/Math/QuantFuncMathCore.h", 37,
                     ::ROOT::DefineBehavior((void*)0,(void*)0),
                     &ROOTcLcLMath_Dictionary, 0);
         return &instance;
      }
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_(Init));

      // Dictionary for non-ClassDef classes
      static void ROOTcLcLMath_Dictionary() {
         GenerateInitInstance()->GetClass();
      }

   }
}
}

namespace ROOT {
   void ROOTcLcLMathcLcLIBaseFunctionOneDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLIBaseFunctionOneDim_Dictionary();
   static void delete_ROOTcLcLMathcLcLIBaseFunctionOneDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIBaseFunctionOneDim(void *p);
   static void destruct_ROOTcLcLMathcLcLIBaseFunctionOneDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IBaseFunctionOneDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IBaseFunctionOneDim) == sizeof(::ROOT::Shadow::ROOT::Math::IBaseFunctionOneDim));
      ::ROOT::Math::IBaseFunctionOneDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IBaseFunctionOneDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IBaseFunctionOneDim", "include/Math/IFunction.h", 130,
                  typeid(::ROOT::Math::IBaseFunctionOneDim), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLIBaseFunctionOneDim_ShowMembers, &ROOTcLcLMathcLcLIBaseFunctionOneDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IBaseFunctionOneDim) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIBaseFunctionOneDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIBaseFunctionOneDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIBaseFunctionOneDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IBaseFunctionOneDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IBaseFunctionOneDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IBaseFunctionOneDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIBaseFunctionOneDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IBaseFunctionOneDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIGradientFunctionOneDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLIGradientFunctionOneDim_Dictionary();
   static void delete_ROOTcLcLMathcLcLIGradientFunctionOneDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIGradientFunctionOneDim(void *p);
   static void destruct_ROOTcLcLMathcLcLIGradientFunctionOneDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IGradientFunctionOneDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IGradientFunctionOneDim) == sizeof(::ROOT::Shadow::ROOT::Math::IGradientFunctionOneDim));
      ::ROOT::Math::IGradientFunctionOneDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IGradientFunctionOneDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IGradientFunctionOneDim", "include/Math/IFunction.h", 380,
                  typeid(::ROOT::Math::IGradientFunctionOneDim), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLIGradientFunctionOneDim_ShowMembers, &ROOTcLcLMathcLcLIGradientFunctionOneDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IGradientFunctionOneDim) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIGradientFunctionOneDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIGradientFunctionOneDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIGradientFunctionOneDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IGradientFunctionOneDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IGradientFunctionOneDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IGradientFunctionOneDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIGradientFunctionOneDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IGradientFunctionOneDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIBaseFunctionMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLIBaseFunctionMultiDim_Dictionary();
   static void delete_ROOTcLcLMathcLcLIBaseFunctionMultiDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIBaseFunctionMultiDim(void *p);
   static void destruct_ROOTcLcLMathcLcLIBaseFunctionMultiDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IBaseFunctionMultiDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IBaseFunctionMultiDim) == sizeof(::ROOT::Shadow::ROOT::Math::IBaseFunctionMultiDim));
      ::ROOT::Math::IBaseFunctionMultiDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IBaseFunctionMultiDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IBaseFunctionMultiDim", "include/Math/IFunction.h", 60,
                  typeid(::ROOT::Math::IBaseFunctionMultiDim), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLIBaseFunctionMultiDim_ShowMembers, &ROOTcLcLMathcLcLIBaseFunctionMultiDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IBaseFunctionMultiDim) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIBaseFunctionMultiDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIBaseFunctionMultiDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIBaseFunctionMultiDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IBaseFunctionMultiDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IBaseFunctionMultiDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IBaseFunctionMultiDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIBaseFunctionMultiDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IBaseFunctionMultiDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIGradientFunctionMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLIGradientFunctionMultiDim_Dictionary();
   static void delete_ROOTcLcLMathcLcLIGradientFunctionMultiDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIGradientFunctionMultiDim(void *p);
   static void destruct_ROOTcLcLMathcLcLIGradientFunctionMultiDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IGradientFunctionMultiDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IGradientFunctionMultiDim) == sizeof(::ROOT::Shadow::ROOT::Math::IGradientFunctionMultiDim));
      ::ROOT::Math::IGradientFunctionMultiDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IGradientFunctionMultiDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IGradientFunctionMultiDim", "include/Math/IFunction.h", 320,
                  typeid(::ROOT::Math::IGradientFunctionMultiDim), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLIGradientFunctionMultiDim_ShowMembers, &ROOTcLcLMathcLcLIGradientFunctionMultiDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IGradientFunctionMultiDim) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIGradientFunctionMultiDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIGradientFunctionMultiDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIGradientFunctionMultiDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IGradientFunctionMultiDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IGradientFunctionMultiDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IGradientFunctionMultiDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIGradientFunctionMultiDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IGradientFunctionMultiDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIGradientMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLIGradientMultiDim_Dictionary();
   static void delete_ROOTcLcLMathcLcLIGradientMultiDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIGradientMultiDim(void *p);
   static void destruct_ROOTcLcLMathcLcLIGradientMultiDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IGradientMultiDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IGradientMultiDim) == sizeof(::ROOT::Shadow::ROOT::Math::IGradientMultiDim));
      ::ROOT::Math::IGradientMultiDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IGradientMultiDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IGradientMultiDim", "include/Math/IFunction.h", 193,
                  typeid(::ROOT::Math::IGradientMultiDim), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLIGradientMultiDim_ShowMembers, &ROOTcLcLMathcLcLIGradientMultiDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IGradientMultiDim) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIGradientMultiDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIGradientMultiDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIGradientMultiDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IGradientMultiDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IGradientMultiDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IGradientMultiDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIGradientMultiDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IGradientMultiDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIGradientOneDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLIGradientOneDim_Dictionary();
   static void delete_ROOTcLcLMathcLcLIGradientOneDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIGradientOneDim(void *p);
   static void destruct_ROOTcLcLMathcLcLIGradientOneDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IGradientOneDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IGradientOneDim) == sizeof(::ROOT::Shadow::ROOT::Math::IGradientOneDim));
      ::ROOT::Math::IGradientOneDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IGradientOneDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IGradientOneDim", "include/Math/IFunction.h", 244,
                  typeid(::ROOT::Math::IGradientOneDim), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLIGradientOneDim_ShowMembers, &ROOTcLcLMathcLcLIGradientOneDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IGradientOneDim) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIGradientOneDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIGradientOneDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIGradientOneDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IGradientOneDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IGradientOneDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IGradientOneDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIGradientOneDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IGradientOneDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIParametricFunctionOneDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLIParametricFunctionOneDim_Dictionary();
   static void delete_ROOTcLcLMathcLcLIParametricFunctionOneDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIParametricFunctionOneDim(void *p);
   static void destruct_ROOTcLcLMathcLcLIParametricFunctionOneDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IParametricFunctionOneDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IParametricFunctionOneDim) == sizeof(::ROOT::Shadow::ROOT::Math::IParametricFunctionOneDim));
      ::ROOT::Math::IParametricFunctionOneDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IParametricFunctionOneDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IParametricFunctionOneDim", "include/Math/IParamFunction.h", 159,
                  typeid(::ROOT::Math::IParametricFunctionOneDim), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLIParametricFunctionOneDim_ShowMembers, &ROOTcLcLMathcLcLIParametricFunctionOneDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IParametricFunctionOneDim) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIParametricFunctionOneDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIParametricFunctionOneDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIParametricFunctionOneDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IParametricFunctionOneDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IParametricFunctionOneDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IParametricFunctionOneDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIParametricFunctionOneDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IParametricFunctionOneDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIParametricGradFunctionOneDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLIParametricGradFunctionOneDim_Dictionary();
   static void delete_ROOTcLcLMathcLcLIParametricGradFunctionOneDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIParametricGradFunctionOneDim(void *p);
   static void destruct_ROOTcLcLMathcLcLIParametricGradFunctionOneDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IParametricGradFunctionOneDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IParametricGradFunctionOneDim) == sizeof(::ROOT::Shadow::ROOT::Math::IParametricGradFunctionOneDim));
      ::ROOT::Math::IParametricGradFunctionOneDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IParametricGradFunctionOneDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IParametricGradFunctionOneDim", "include/Math/IParamFunction.h", 302,
                  typeid(::ROOT::Math::IParametricGradFunctionOneDim), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLIParametricGradFunctionOneDim_ShowMembers, &ROOTcLcLMathcLcLIParametricGradFunctionOneDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IParametricGradFunctionOneDim) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIParametricGradFunctionOneDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIParametricGradFunctionOneDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIParametricGradFunctionOneDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IParametricGradFunctionOneDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IParametricGradFunctionOneDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IParametricGradFunctionOneDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIParametricGradFunctionOneDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IParametricGradFunctionOneDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIParametricFunctionMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLIParametricFunctionMultiDim_Dictionary();
   static void delete_ROOTcLcLMathcLcLIParametricFunctionMultiDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIParametricFunctionMultiDim(void *p);
   static void destruct_ROOTcLcLMathcLcLIParametricFunctionMultiDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IParametricFunctionMultiDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IParametricFunctionMultiDim) == sizeof(::ROOT::Shadow::ROOT::Math::IParametricFunctionMultiDim));
      ::ROOT::Math::IParametricFunctionMultiDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IParametricFunctionMultiDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IParametricFunctionMultiDim", "include/Math/IParamFunction.h", 109,
                  typeid(::ROOT::Math::IParametricFunctionMultiDim), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLIParametricFunctionMultiDim_ShowMembers, &ROOTcLcLMathcLcLIParametricFunctionMultiDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IParametricFunctionMultiDim) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIParametricFunctionMultiDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIParametricFunctionMultiDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIParametricFunctionMultiDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IParametricFunctionMultiDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IParametricFunctionMultiDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IParametricFunctionMultiDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIParametricFunctionMultiDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IParametricFunctionMultiDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIParametricGradFunctionMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLIParametricGradFunctionMultiDim_Dictionary();
   static void delete_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim(void *p);
   static void destruct_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IParametricGradFunctionMultiDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IParametricGradFunctionMultiDim) == sizeof(::ROOT::Shadow::ROOT::Math::IParametricGradFunctionMultiDim));
      ::ROOT::Math::IParametricGradFunctionMultiDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IParametricGradFunctionMultiDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IParametricGradFunctionMultiDim", "include/Math/IParamFunction.h", 225,
                  typeid(::ROOT::Math::IParametricGradFunctionMultiDim), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLIParametricGradFunctionMultiDim_ShowMembers, &ROOTcLcLMathcLcLIParametricGradFunctionMultiDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IParametricGradFunctionMultiDim) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IParametricGradFunctionMultiDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IParametricGradFunctionMultiDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IParametricGradFunctionMultiDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIParametricGradFunctionMultiDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IParametricGradFunctionMultiDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIBaseParam_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLIBaseParam_Dictionary();
   static void delete_ROOTcLcLMathcLcLIBaseParam(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIBaseParam(void *p);
   static void destruct_ROOTcLcLMathcLcLIBaseParam(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IBaseParam*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IBaseParam) == sizeof(::ROOT::Shadow::ROOT::Math::IBaseParam));
      ::ROOT::Math::IBaseParam *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IBaseParam),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IBaseParam", "include/Math/IParamFunction.h", 53,
                  typeid(::ROOT::Math::IBaseParam), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLIBaseParam_ShowMembers, &ROOTcLcLMathcLcLIBaseParam_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IBaseParam) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIBaseParam);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIBaseParam);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIBaseParam);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IBaseParam*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IBaseParam*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IBaseParam*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIBaseParam_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IBaseParam*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLParamFunctor_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLParamFunctor_Dictionary();
   static void *new_ROOTcLcLMathcLcLParamFunctor(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLParamFunctor(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLParamFunctor(void *p);
   static void deleteArray_ROOTcLcLMathcLcLParamFunctor(void *p);
   static void destruct_ROOTcLcLMathcLcLParamFunctor(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::ParamFunctor*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::ParamFunctor) == sizeof(::ROOT::Shadow::ROOT::Math::ParamFunctor));
      ::ROOT::Math::ParamFunctor *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::ParamFunctor),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::ParamFunctor", "include/Math/ParamFunctor.h", 209,
                  typeid(::ROOT::Math::ParamFunctor), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLParamFunctor_ShowMembers, &ROOTcLcLMathcLcLParamFunctor_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::ParamFunctor) );
      instance.SetNew(&new_ROOTcLcLMathcLcLParamFunctor);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLParamFunctor);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLParamFunctor);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLParamFunctor);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLParamFunctor);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::ParamFunctor*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::ParamFunctor*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::ParamFunctor*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLParamFunctor_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::ParamFunctor*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLFunctor_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLFunctor_Dictionary();
   static void *new_ROOTcLcLMathcLcLFunctor(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLFunctor(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLFunctor(void *p);
   static void deleteArray_ROOTcLcLMathcLcLFunctor(void *p);
   static void destruct_ROOTcLcLMathcLcLFunctor(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Functor*)
   {
      ::ROOT::Math::Functor *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Functor),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Functor", "include/Math/Functor.h", 340,
                  typeid(::ROOT::Math::Functor), DefineBehavior(ptr, ptr),
                  0, &ROOTcLcLMathcLcLFunctor_Dictionary, isa_proxy, 1,
                  sizeof(::ROOT::Math::Functor) );
      instance.SetNew(&new_ROOTcLcLMathcLcLFunctor);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLFunctor);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLFunctor);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLFunctor);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLFunctor);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Functor*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Functor*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Functor*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLFunctor_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Functor*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLFunctor1D_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLFunctor1D_Dictionary();
   static void *new_ROOTcLcLMathcLcLFunctor1D(void *p = 0);
   static void delete_ROOTcLcLMathcLcLFunctor1D(void *p);
   static void deleteArray_ROOTcLcLMathcLcLFunctor1D(void *p);
   static void destruct_ROOTcLcLMathcLcLFunctor1D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Functor1D*)
   {
      ::ROOT::Math::Functor1D *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Functor1D),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Functor1D", "include/Math/Functor.h", 447,
                  typeid(::ROOT::Math::Functor1D), DefineBehavior(ptr, ptr),
                  0, &ROOTcLcLMathcLcLFunctor1D_Dictionary, isa_proxy, 1,
                  sizeof(::ROOT::Math::Functor1D) );
      instance.SetNew(&new_ROOTcLcLMathcLcLFunctor1D);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLFunctor1D);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLFunctor1D);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLFunctor1D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Functor1D*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Functor1D*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Functor1D*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLFunctor1D_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Functor1D*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGradFunctor_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLGradFunctor_Dictionary();
   static void *new_ROOTcLcLMathcLcLGradFunctor(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGradFunctor(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGradFunctor(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGradFunctor(void *p);
   static void destruct_ROOTcLcLMathcLcLGradFunctor(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GradFunctor*)
   {
      ::ROOT::Math::GradFunctor *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GradFunctor),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GradFunctor", "include/Math/Functor.h", 554,
                  typeid(::ROOT::Math::GradFunctor), DefineBehavior(ptr, ptr),
                  0, &ROOTcLcLMathcLcLGradFunctor_Dictionary, isa_proxy, 1,
                  sizeof(::ROOT::Math::GradFunctor) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGradFunctor);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGradFunctor);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGradFunctor);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGradFunctor);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGradFunctor);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GradFunctor*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GradFunctor*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GradFunctor*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGradFunctor_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GradFunctor*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGradFunctor1D_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLGradFunctor1D_Dictionary();
   static void *new_ROOTcLcLMathcLcLGradFunctor1D(void *p = 0);
   static void delete_ROOTcLcLMathcLcLGradFunctor1D(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGradFunctor1D(void *p);
   static void destruct_ROOTcLcLMathcLcLGradFunctor1D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GradFunctor1D*)
   {
      ::ROOT::Math::GradFunctor1D *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GradFunctor1D),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GradFunctor1D", "include/Math/Functor.h", 677,
                  typeid(::ROOT::Math::GradFunctor1D), DefineBehavior(ptr, ptr),
                  0, &ROOTcLcLMathcLcLGradFunctor1D_Dictionary, isa_proxy, 1,
                  sizeof(::ROOT::Math::GradFunctor1D) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGradFunctor1D);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGradFunctor1D);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGradFunctor1D);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGradFunctor1D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GradFunctor1D*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GradFunctor1D*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GradFunctor1D*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGradFunctor1D_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GradFunctor1D*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLMinimizer_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLMinimizer_Dictionary();
   static void delete_ROOTcLcLMathcLcLMinimizer(void *p);
   static void deleteArray_ROOTcLcLMathcLcLMinimizer(void *p);
   static void destruct_ROOTcLcLMathcLcLMinimizer(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Minimizer*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::Minimizer) == sizeof(::ROOT::Shadow::ROOT::Math::Minimizer));
      ::ROOT::Math::Minimizer *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Minimizer),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Minimizer", "include/Math/Minimizer.h", 77,
                  typeid(::ROOT::Math::Minimizer), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLMinimizer_ShowMembers, &ROOTcLcLMathcLcLMinimizer_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::Minimizer) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLMinimizer);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLMinimizer);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLMinimizer);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Minimizer*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Minimizer*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Minimizer*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLMinimizer_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Minimizer*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLMinimizerOptions_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLMinimizerOptions_Dictionary();
   static void *new_ROOTcLcLMathcLcLMinimizerOptions(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLMinimizerOptions(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLMinimizerOptions(void *p);
   static void deleteArray_ROOTcLcLMathcLcLMinimizerOptions(void *p);
   static void destruct_ROOTcLcLMathcLcLMinimizerOptions(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::MinimizerOptions*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::MinimizerOptions) == sizeof(::ROOT::Shadow::ROOT::Math::MinimizerOptions));
      ::ROOT::Math::MinimizerOptions *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::MinimizerOptions),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::MinimizerOptions", "include/Math/MinimizerOptions.h", 27,
                  typeid(::ROOT::Math::MinimizerOptions), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLMinimizerOptions_ShowMembers, &ROOTcLcLMathcLcLMinimizerOptions_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::MinimizerOptions) );
      instance.SetNew(&new_ROOTcLcLMathcLcLMinimizerOptions);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLMinimizerOptions);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLMinimizerOptions);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLMinimizerOptions);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLMinimizerOptions);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::MinimizerOptions*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::MinimizerOptions*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::MinimizerOptions*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLMinimizerOptions_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::MinimizerOptions*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
namespace Math {
namespace IntegrationOneDim {
   namespace ROOT {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static void ROOTcLcLMathcLcLIntegrationOneDim_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("ROOT::Math::IntegrationOneDim", 0 /*version*/, "include/Math/AllIntegrationTypes.h", 30,
                     ::ROOT::DefineBehavior((void*)0,(void*)0),
                     &ROOTcLcLMathcLcLIntegrationOneDim_Dictionary, 0);
         return &instance;
      }
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_(Init));

      // Dictionary for non-ClassDef classes
      static void ROOTcLcLMathcLcLIntegrationOneDim_Dictionary() {
         GenerateInitInstance()->GetClass();
      }

   }
}
}
}

namespace ROOT {
namespace Math {
namespace IntegrationMultiDim {
   namespace ROOT {
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance();
      static void ROOTcLcLMathcLcLIntegrationMultiDim_Dictionary();

      // Function generating the singleton type initializer
      inline ::ROOT::TGenericClassInfo *GenerateInitInstance()
      {
         static ::ROOT::TGenericClassInfo 
            instance("ROOT::Math::IntegrationMultiDim", 0 /*version*/, "include/Math/AllIntegrationTypes.h", 48,
                     ::ROOT::DefineBehavior((void*)0,(void*)0),
                     &ROOTcLcLMathcLcLIntegrationMultiDim_Dictionary, 0);
         return &instance;
      }
      // Static variable to force the class initialization
      static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance(); R__UseDummy(_R__UNIQUE_(Init));

      // Dictionary for non-ClassDef classes
      static void ROOTcLcLMathcLcLIntegrationMultiDim_Dictionary() {
         GenerateInitInstance()->GetClass();
      }

   }
}
}
}

namespace ROOT {
   void ROOTcLcLMathcLcLVirtualIntegrator_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLVirtualIntegrator_Dictionary();
   static void delete_ROOTcLcLMathcLcLVirtualIntegrator(void *p);
   static void deleteArray_ROOTcLcLMathcLcLVirtualIntegrator(void *p);
   static void destruct_ROOTcLcLMathcLcLVirtualIntegrator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::VirtualIntegrator*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::VirtualIntegrator) == sizeof(::ROOT::Shadow::ROOT::Math::VirtualIntegrator));
      ::ROOT::Math::VirtualIntegrator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::VirtualIntegrator),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::VirtualIntegrator", "include/Math/VirtualIntegrator.h", 50,
                  typeid(::ROOT::Math::VirtualIntegrator), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLVirtualIntegrator_ShowMembers, &ROOTcLcLMathcLcLVirtualIntegrator_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::VirtualIntegrator) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLVirtualIntegrator);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLVirtualIntegrator);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLVirtualIntegrator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::VirtualIntegrator*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::VirtualIntegrator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::VirtualIntegrator*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLVirtualIntegrator_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::VirtualIntegrator*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLVirtualIntegratorOneDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLVirtualIntegratorOneDim_Dictionary();
   static void delete_ROOTcLcLMathcLcLVirtualIntegratorOneDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLVirtualIntegratorOneDim(void *p);
   static void destruct_ROOTcLcLMathcLcLVirtualIntegratorOneDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::VirtualIntegratorOneDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::VirtualIntegratorOneDim) == sizeof(::ROOT::Shadow::ROOT::Math::VirtualIntegratorOneDim));
      ::ROOT::Math::VirtualIntegratorOneDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::VirtualIntegratorOneDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::VirtualIntegratorOneDim", "include/Math/VirtualIntegrator.h", 97,
                  typeid(::ROOT::Math::VirtualIntegratorOneDim), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLVirtualIntegratorOneDim_ShowMembers, &ROOTcLcLMathcLcLVirtualIntegratorOneDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::VirtualIntegratorOneDim) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLVirtualIntegratorOneDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLVirtualIntegratorOneDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLVirtualIntegratorOneDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::VirtualIntegratorOneDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::VirtualIntegratorOneDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::VirtualIntegratorOneDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLVirtualIntegratorOneDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::VirtualIntegratorOneDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator_Dictionary();
   static void *new_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator(void *p = 0);
   static void *newArray_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator(Long_t size, void *p);
   static void delete_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator(void *p);
   static void deleteArray_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator(void *p);
   static void destruct_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::vector<double,allocator<double> >::iterator*)
   {
      ::vector<double,allocator<double> >::iterator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::vector<double,allocator<double> >::iterator),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<double,allocator<double> >::iterator", "prec_stl/vector", 215,
                  typeid(::vector<double,allocator<double> >::iterator), DefineBehavior(ptr, ptr),
                  0, &vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator_Dictionary, isa_proxy, 0,
                  sizeof(::vector<double,allocator<double> >::iterator) );
      instance.SetNew(&new_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator);
      instance.SetNewArray(&newArray_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator);
      instance.SetDelete(&delete_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator);
      instance.SetDeleteArray(&deleteArray_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator);
      instance.SetDestructor(&destruct_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::vector<double,allocator<double> >::iterator*)
   {
      return GenerateInitInstanceLocal((::vector<double,allocator<double> >::iterator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::vector<double,allocator<double> >::iterator*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::vector<double,allocator<double> >::iterator*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR_Dictionary();
   static void *new_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR(void *p = 0);
   static void *newArray_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR(Long_t size, void *p);
   static void delete_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR(void *p);
   static void deleteArray_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR(void *p);
   static void destruct_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::reverse_iterator<vector<double,allocator<double> >::iterator>*)
   {
      ::reverse_iterator<vector<double,allocator<double> >::iterator> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::reverse_iterator<vector<double,allocator<double> >::iterator>),0);
      static ::ROOT::TGenericClassInfo 
         instance("reverse_iterator<vector<double,allocator<double> >::iterator>", "prec_stl/iterator", 166,
                  typeid(::reverse_iterator<vector<double,allocator<double> >::iterator>), DefineBehavior(ptr, ptr),
                  0, &reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR_Dictionary, isa_proxy, 0,
                  sizeof(::reverse_iterator<vector<double,allocator<double> >::iterator>) );
      instance.SetNew(&new_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR);
      instance.SetNewArray(&newArray_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR);
      instance.SetDelete(&delete_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR);
      instance.SetDeleteArray(&deleteArray_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR);
      instance.SetDestructor(&destruct_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::reverse_iterator<vector<double,allocator<double> >::iterator>*)
   {
      return GenerateInitInstanceLocal((::reverse_iterator<vector<double,allocator<double> >::iterator>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::reverse_iterator<vector<double,allocator<double> >::iterator>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::reverse_iterator<vector<double,allocator<double> >::iterator>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLVirtualIntegratorMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLVirtualIntegratorMultiDim_Dictionary();
   static void delete_ROOTcLcLMathcLcLVirtualIntegratorMultiDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLVirtualIntegratorMultiDim(void *p);
   static void destruct_ROOTcLcLMathcLcLVirtualIntegratorMultiDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::VirtualIntegratorMultiDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::VirtualIntegratorMultiDim) == sizeof(::ROOT::Shadow::ROOT::Math::VirtualIntegratorMultiDim));
      ::ROOT::Math::VirtualIntegratorMultiDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::VirtualIntegratorMultiDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::VirtualIntegratorMultiDim", "include/Math/VirtualIntegrator.h", 140,
                  typeid(::ROOT::Math::VirtualIntegratorMultiDim), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLVirtualIntegratorMultiDim_ShowMembers, &ROOTcLcLMathcLcLVirtualIntegratorMultiDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::VirtualIntegratorMultiDim) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLVirtualIntegratorMultiDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLVirtualIntegratorMultiDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLVirtualIntegratorMultiDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::VirtualIntegratorMultiDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::VirtualIntegratorMultiDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::VirtualIntegratorMultiDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLVirtualIntegratorMultiDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::VirtualIntegratorMultiDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIntegratorOneDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLIntegratorOneDim_Dictionary();
   static void *new_ROOTcLcLMathcLcLIntegratorOneDim(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLIntegratorOneDim(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLIntegratorOneDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIntegratorOneDim(void *p);
   static void destruct_ROOTcLcLMathcLcLIntegratorOneDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IntegratorOneDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IntegratorOneDim) == sizeof(::ROOT::Shadow::ROOT::Math::IntegratorOneDim));
      ::ROOT::Math::IntegratorOneDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IntegratorOneDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IntegratorOneDim", "include/Math/Integrator.h", 80,
                  typeid(::ROOT::Math::IntegratorOneDim), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLIntegratorOneDim_ShowMembers, &ROOTcLcLMathcLcLIntegratorOneDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IntegratorOneDim) );
      instance.SetNew(&new_ROOTcLcLMathcLcLIntegratorOneDim);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLIntegratorOneDim);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIntegratorOneDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIntegratorOneDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIntegratorOneDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IntegratorOneDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IntegratorOneDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IntegratorOneDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIntegratorOneDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IntegratorOneDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim_Dictionary();
   static void *new_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim(void *p);
   static void destruct_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::AdaptiveIntegratorMultiDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::AdaptiveIntegratorMultiDim) == sizeof(::ROOT::Shadow::ROOT::Math::AdaptiveIntegratorMultiDim));
      ::ROOT::Math::AdaptiveIntegratorMultiDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::AdaptiveIntegratorMultiDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::AdaptiveIntegratorMultiDim", "include/Math/AdaptiveIntegratorMultiDim.h", 41,
                  typeid(::ROOT::Math::AdaptiveIntegratorMultiDim), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim_ShowMembers, &ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::AdaptiveIntegratorMultiDim) );
      instance.SetNew(&new_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::AdaptiveIntegratorMultiDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::AdaptiveIntegratorMultiDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::AdaptiveIntegratorMultiDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::AdaptiveIntegratorMultiDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIntegratorMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLIntegratorMultiDim_Dictionary();
   static void *new_ROOTcLcLMathcLcLIntegratorMultiDim(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLIntegratorMultiDim(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLIntegratorMultiDim(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIntegratorMultiDim(void *p);
   static void destruct_ROOTcLcLMathcLcLIntegratorMultiDim(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IntegratorMultiDim*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IntegratorMultiDim) == sizeof(::ROOT::Shadow::ROOT::Math::IntegratorMultiDim));
      ::ROOT::Math::IntegratorMultiDim *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IntegratorMultiDim),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IntegratorMultiDim", "include/Math/IntegratorMultiDim.h", 55,
                  typeid(::ROOT::Math::IntegratorMultiDim), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLIntegratorMultiDim_ShowMembers, &ROOTcLcLMathcLcLIntegratorMultiDim_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IntegratorMultiDim) );
      instance.SetNew(&new_ROOTcLcLMathcLcLIntegratorMultiDim);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLIntegratorMultiDim);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIntegratorMultiDim);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIntegratorMultiDim);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIntegratorMultiDim);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IntegratorMultiDim*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IntegratorMultiDim*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IntegratorMultiDim*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIntegratorMultiDim_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IntegratorMultiDim*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLFactory_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLFactory_Dictionary();
   static void *new_ROOTcLcLMathcLcLFactory(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLFactory(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLFactory(void *p);
   static void deleteArray_ROOTcLcLMathcLcLFactory(void *p);
   static void destruct_ROOTcLcLMathcLcLFactory(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::Factory*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::Factory) == sizeof(::ROOT::Shadow::ROOT::Math::Factory));
      ::ROOT::Math::Factory *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::Factory),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::Factory", "include/Math/Factory.h", 30,
                  typeid(::ROOT::Math::Factory), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLFactory_ShowMembers, &ROOTcLcLMathcLcLFactory_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::Factory) );
      instance.SetNew(&new_ROOTcLcLMathcLcLFactory);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLFactory);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLFactory);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLFactory);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLFactory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::Factory*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::Factory*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::Factory*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLFactory_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Factory*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR_Dictionary();
   static void delete_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR(void *p);
   static void deleteArray_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR(void *p);
   static void destruct_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>) == sizeof(::ROOT::Shadow::ROOT::Math::BasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR));
      ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>", "include/Math/FitMethodFunction.h", 34,
                  typeid(::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR_ShowMembers, &ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR_Dictionary();
   static void delete_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR(void *p);
   static void deleteArray_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR(void *p);
   static void destruct_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>) == sizeof(::ROOT::Shadow::ROOT::Math::BasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR));
      ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>", "include/Math/FitMethodFunction.h", 34,
                  typeid(::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR_ShowMembers, &ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGaussIntegrator_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLGaussIntegrator_Dictionary();
   static void *new_ROOTcLcLMathcLcLGaussIntegrator(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGaussIntegrator(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGaussIntegrator(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGaussIntegrator(void *p);
   static void destruct_ROOTcLcLMathcLcLGaussIntegrator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GaussIntegrator*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GaussIntegrator) == sizeof(::ROOT::Shadow::ROOT::Math::GaussIntegrator));
      ::ROOT::Math::GaussIntegrator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GaussIntegrator),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GaussIntegrator", "include/Math/GaussIntegrator.h", 37,
                  typeid(::ROOT::Math::GaussIntegrator), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLGaussIntegrator_ShowMembers, &ROOTcLcLMathcLcLGaussIntegrator_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GaussIntegrator) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGaussIntegrator);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGaussIntegrator);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGaussIntegrator);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGaussIntegrator);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGaussIntegrator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GaussIntegrator*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GaussIntegrator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GaussIntegrator*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGaussIntegrator_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GaussIntegrator*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLGaussLegendreIntegrator_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLGaussLegendreIntegrator_Dictionary();
   static void *new_ROOTcLcLMathcLcLGaussLegendreIntegrator(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLGaussLegendreIntegrator(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLGaussLegendreIntegrator(void *p);
   static void deleteArray_ROOTcLcLMathcLcLGaussLegendreIntegrator(void *p);
   static void destruct_ROOTcLcLMathcLcLGaussLegendreIntegrator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::GaussLegendreIntegrator*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::GaussLegendreIntegrator) == sizeof(::ROOT::Shadow::ROOT::Math::GaussLegendreIntegrator));
      ::ROOT::Math::GaussLegendreIntegrator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::GaussLegendreIntegrator),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::GaussLegendreIntegrator", "include/Math/GaussLegendreIntegrator.h", 36,
                  typeid(::ROOT::Math::GaussLegendreIntegrator), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLGaussLegendreIntegrator_ShowMembers, &ROOTcLcLMathcLcLGaussLegendreIntegrator_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::GaussLegendreIntegrator) );
      instance.SetNew(&new_ROOTcLcLMathcLcLGaussLegendreIntegrator);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLGaussLegendreIntegrator);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLGaussLegendreIntegrator);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLGaussLegendreIntegrator);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLGaussLegendreIntegrator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::GaussLegendreIntegrator*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::GaussLegendreIntegrator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::GaussLegendreIntegrator*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLGaussLegendreIntegrator_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GaussLegendreIntegrator*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLIRootFinderMethod_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLIRootFinderMethod_Dictionary();
   static void delete_ROOTcLcLMathcLcLIRootFinderMethod(void *p);
   static void deleteArray_ROOTcLcLMathcLcLIRootFinderMethod(void *p);
   static void destruct_ROOTcLcLMathcLcLIRootFinderMethod(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::IRootFinderMethod*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::IRootFinderMethod) == sizeof(::ROOT::Shadow::ROOT::Math::IRootFinderMethod));
      ::ROOT::Math::IRootFinderMethod *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::IRootFinderMethod),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::IRootFinderMethod", "include/Math/IRootFinderMethod.h", 36,
                  typeid(::ROOT::Math::IRootFinderMethod), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLIRootFinderMethod_ShowMembers, &ROOTcLcLMathcLcLIRootFinderMethod_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::IRootFinderMethod) );
      instance.SetDelete(&delete_ROOTcLcLMathcLcLIRootFinderMethod);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLIRootFinderMethod);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLIRootFinderMethod);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::IRootFinderMethod*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::IRootFinderMethod*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::IRootFinderMethod*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLIRootFinderMethod_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IRootFinderMethod*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLRootFinder_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLRootFinder_Dictionary();
   static void *new_ROOTcLcLMathcLcLRootFinder(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLRootFinder(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLRootFinder(void *p);
   static void deleteArray_ROOTcLcLMathcLcLRootFinder(void *p);
   static void destruct_ROOTcLcLMathcLcLRootFinder(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::RootFinder*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::RootFinder) == sizeof(::ROOT::Shadow::ROOT::Math::RootFinder));
      ::ROOT::Math::RootFinder *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::RootFinder),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::RootFinder", "include/Math/RootFinder.h", 79,
                  typeid(::ROOT::Math::RootFinder), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLRootFinder_ShowMembers, &ROOTcLcLMathcLcLRootFinder_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::RootFinder) );
      instance.SetNew(&new_ROOTcLcLMathcLcLRootFinder);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLRootFinder);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLRootFinder);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLRootFinder);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLRootFinder);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::RootFinder*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::RootFinder*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::RootFinder*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLRootFinder_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::RootFinder*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLRichardsonDerivator_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLRichardsonDerivator_Dictionary();
   static void *new_ROOTcLcLMathcLcLRichardsonDerivator(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLRichardsonDerivator(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLRichardsonDerivator(void *p);
   static void deleteArray_ROOTcLcLMathcLcLRichardsonDerivator(void *p);
   static void destruct_ROOTcLcLMathcLcLRichardsonDerivator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::RichardsonDerivator*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::RichardsonDerivator) == sizeof(::ROOT::Shadow::ROOT::Math::RichardsonDerivator));
      ::ROOT::Math::RichardsonDerivator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::RichardsonDerivator),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::RichardsonDerivator", "include/Math/RichardsonDerivator.h", 48,
                  typeid(::ROOT::Math::RichardsonDerivator), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLRichardsonDerivator_ShowMembers, &ROOTcLcLMathcLcLRichardsonDerivator_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::RichardsonDerivator) );
      instance.SetNew(&new_ROOTcLcLMathcLcLRichardsonDerivator);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLRichardsonDerivator);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLRichardsonDerivator);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLRichardsonDerivator);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLRichardsonDerivator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::RichardsonDerivator*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::RichardsonDerivator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::RichardsonDerivator*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLRichardsonDerivator_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::RichardsonDerivator*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLBrentMinimizer1D_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLBrentMinimizer1D_Dictionary();
   static void *new_ROOTcLcLMathcLcLBrentMinimizer1D(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLBrentMinimizer1D(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLBrentMinimizer1D(void *p);
   static void deleteArray_ROOTcLcLMathcLcLBrentMinimizer1D(void *p);
   static void destruct_ROOTcLcLMathcLcLBrentMinimizer1D(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::BrentMinimizer1D*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::BrentMinimizer1D) == sizeof(::ROOT::Shadow::ROOT::Math::BrentMinimizer1D));
      ::ROOT::Math::BrentMinimizer1D *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::BrentMinimizer1D),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::BrentMinimizer1D", "include/Math/BrentMinimizer1D.h", 57,
                  typeid(::ROOT::Math::BrentMinimizer1D), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLBrentMinimizer1D_ShowMembers, &ROOTcLcLMathcLcLBrentMinimizer1D_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::BrentMinimizer1D) );
      instance.SetNew(&new_ROOTcLcLMathcLcLBrentMinimizer1D);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLBrentMinimizer1D);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLBrentMinimizer1D);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLBrentMinimizer1D);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLBrentMinimizer1D);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::BrentMinimizer1D*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::BrentMinimizer1D*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::BrentMinimizer1D*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLBrentMinimizer1D_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::BrentMinimizer1D*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLBrentRootFinder_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ROOTcLcLMathcLcLBrentRootFinder_Dictionary();
   static void *new_ROOTcLcLMathcLcLBrentRootFinder(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLBrentRootFinder(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLBrentRootFinder(void *p);
   static void deleteArray_ROOTcLcLMathcLcLBrentRootFinder(void *p);
   static void destruct_ROOTcLcLMathcLcLBrentRootFinder(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::BrentRootFinder*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::BrentRootFinder) == sizeof(::ROOT::Shadow::ROOT::Math::BrentRootFinder));
      ::ROOT::Math::BrentRootFinder *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::BrentRootFinder),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::BrentRootFinder", "include/Math/BrentRootFinder.h", 50,
                  typeid(::ROOT::Math::BrentRootFinder), DefineBehavior(ptr, ptr),
                  (void*)&ROOTcLcLMathcLcLBrentRootFinder_ShowMembers, &ROOTcLcLMathcLcLBrentRootFinder_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::BrentRootFinder) );
      instance.SetNew(&new_ROOTcLcLMathcLcLBrentRootFinder);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLBrentRootFinder);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLBrentRootFinder);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLBrentRootFinder);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLBrentRootFinder);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::BrentRootFinder*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::BrentRootFinder*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::BrentRootFinder*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLBrentRootFinder_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::BrentRootFinder*)0x0)->GetClass();
   }

} // end of namespace ROOT

//______________________________________________________________________________
TClass *TRandom::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TRandom::Class_Name()
{
   return "TRandom";
}

//______________________________________________________________________________
const char *TRandom::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRandom*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TRandom::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRandom*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TRandom::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRandom*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TRandom::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRandom*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TRandom1::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TRandom1::Class_Name()
{
   return "TRandom1";
}

//______________________________________________________________________________
const char *TRandom1::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRandom1*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TRandom1::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRandom1*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TRandom1::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRandom1*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TRandom1::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRandom1*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TRandom2::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TRandom2::Class_Name()
{
   return "TRandom2";
}

//______________________________________________________________________________
const char *TRandom2::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRandom2*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TRandom2::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRandom2*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TRandom2::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRandom2*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TRandom2::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRandom2*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TRandom3::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TRandom3::Class_Name()
{
   return "TRandom3";
}

//______________________________________________________________________________
const char *TRandom3::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRandom3*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TRandom3::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRandom3*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TRandom3::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRandom3*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TRandom3::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRandom3*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TVirtualFitter::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualFitter::Class_Name()
{
   return "TVirtualFitter";
}

//______________________________________________________________________________
const char *TVirtualFitter::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualFitter*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualFitter::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualFitter*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TVirtualFitter::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualFitter*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TVirtualFitter::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualFitter*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *TKDTree<int,double>::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
template <> const char *TKDTree<int,double>::Class_Name()
{
   return "TKDTree<int,double>";
}

//______________________________________________________________________________
template <> const char *TKDTree<int,double>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TKDTree<int,double>*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
template <> int TKDTree<int,double>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TKDTree<int,double>*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
template <> void TKDTree<int,double>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TKDTree<int,double>*)0x0)->GetClass();
}

//______________________________________________________________________________
template <> TClass *TKDTree<int,double>::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TKDTree<int,double>*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *TKDTree<int,float>::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
template <> const char *TKDTree<int,float>::Class_Name()
{
   return "TKDTree<int,float>";
}

//______________________________________________________________________________
template <> const char *TKDTree<int,float>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TKDTree<int,float>*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
template <> int TKDTree<int,float>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TKDTree<int,float>*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
template <> void TKDTree<int,float>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TKDTree<int,float>*)0x0)->GetClass();
}

//______________________________________________________________________________
template <> TClass *TKDTree<int,float>::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TKDTree<int,float>*)0x0)->GetClass();
   return fgIsA;
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::vector<double,allocator<double> >::iterator : new ::vector<double,allocator<double> >::iterator;
   }
   static void *newArray_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::vector<double,allocator<double> >::iterator[nElements] : new ::vector<double,allocator<double> >::iterator[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator(void *p) {
      delete ((::vector<double,allocator<double> >::iterator*)p);
   }
   static void deleteArray_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator(void *p) {
      delete [] ((::vector<double,allocator<double> >::iterator*)p);
   }
   static void destruct_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator(void *p) {
      typedef ::vector<double,allocator<double> >::iterator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::vector<double,allocator<double> >::iterator

namespace ROOT {
   // Wrappers around operator new
   static void *new_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::reverse_iterator<vector<double,allocator<double> >::iterator> : new ::reverse_iterator<vector<double,allocator<double> >::iterator>;
   }
   static void *newArray_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::reverse_iterator<vector<double,allocator<double> >::iterator>[nElements] : new ::reverse_iterator<vector<double,allocator<double> >::iterator>[nElements];
   }
   // Wrapper around operator delete
   static void delete_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR(void *p) {
      delete ((::reverse_iterator<vector<double,allocator<double> >::iterator>*)p);
   }
   static void deleteArray_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR(void *p) {
      delete [] ((::reverse_iterator<vector<double,allocator<double> >::iterator>*)p);
   }
   static void destruct_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR(void *p) {
      typedef ::reverse_iterator<vector<double,allocator<double> >::iterator> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::reverse_iterator<vector<double,allocator<double> >::iterator>

//______________________________________________________________________________
void TRandom::Streamer(TBuffer &R__b)
{
   // Stream an object of class TRandom.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TRandom::Class(),this);
   } else {
      R__b.WriteClassBuffer(TRandom::Class(),this);
   }
}

//______________________________________________________________________________
void TRandom::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class TRandom.
      TClass *R__cl = ::TRandom::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fSeed", &fSeed);
      TNamed::ShowMembers(R__insp, R__parent);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TRandom(void *p) {
      return  p ? new(p) ::TRandom : new ::TRandom;
   }
   static void *newArray_TRandom(Long_t nElements, void *p) {
      return p ? new(p) ::TRandom[nElements] : new ::TRandom[nElements];
   }
   // Wrapper around operator delete
   static void delete_TRandom(void *p) {
      delete ((::TRandom*)p);
   }
   static void deleteArray_TRandom(void *p) {
      delete [] ((::TRandom*)p);
   }
   static void destruct_TRandom(void *p) {
      typedef ::TRandom current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TRandom

//______________________________________________________________________________
void TRandom1::Streamer(TBuffer &R__b)
{
   // Stream an object of class TRandom1.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TRandom1::Class(),this);
   } else {
      R__b.WriteClassBuffer(TRandom1::Class(),this);
   }
}

//______________________________________________________________________________
void TRandom1::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class TRandom1.
      TClass *R__cl = ::TRandom1::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fNskip", &fNskip);
      R__insp.Inspect(R__cl, R__parent, "fLuxury", &fLuxury);
      R__insp.Inspect(R__cl, R__parent, "fIlag", &fIlag);
      R__insp.Inspect(R__cl, R__parent, "fJlag", &fJlag);
      R__insp.Inspect(R__cl, R__parent, "fCount24", &fCount24);
      R__insp.Inspect(R__cl, R__parent, "fFloatSeedTable[24]", fFloatSeedTable);
      R__insp.Inspect(R__cl, R__parent, "fCarry", &fCarry);
      R__insp.Inspect(R__cl, R__parent, "fIntModulus", &fIntModulus);
      R__insp.Inspect(R__cl, R__parent, "*fTheSeeds", &fTheSeeds);
      R__insp.Inspect(R__cl, R__parent, "fMantissaBit24", &fMantissaBit24);
      R__insp.Inspect(R__cl, R__parent, "fMantissaBit12", &fMantissaBit12);
      TRandom::ShowMembers(R__insp, R__parent);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TRandom1(void *p) {
      return  p ? new(p) ::TRandom1 : new ::TRandom1;
   }
   static void *newArray_TRandom1(Long_t nElements, void *p) {
      return p ? new(p) ::TRandom1[nElements] : new ::TRandom1[nElements];
   }
   // Wrapper around operator delete
   static void delete_TRandom1(void *p) {
      delete ((::TRandom1*)p);
   }
   static void deleteArray_TRandom1(void *p) {
      delete [] ((::TRandom1*)p);
   }
   static void destruct_TRandom1(void *p) {
      typedef ::TRandom1 current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TRandom1

//______________________________________________________________________________
void TRandom2::Streamer(TBuffer &R__b)
{
   // Stream an object of class TRandom2.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TRandom2::Class(),this);
   } else {
      R__b.WriteClassBuffer(TRandom2::Class(),this);
   }
}

//______________________________________________________________________________
void TRandom2::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class TRandom2.
      TClass *R__cl = ::TRandom2::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fSeed1", &fSeed1);
      R__insp.Inspect(R__cl, R__parent, "fSeed2", &fSeed2);
      TRandom::ShowMembers(R__insp, R__parent);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TRandom2(void *p) {
      return  p ? new(p) ::TRandom2 : new ::TRandom2;
   }
   static void *newArray_TRandom2(Long_t nElements, void *p) {
      return p ? new(p) ::TRandom2[nElements] : new ::TRandom2[nElements];
   }
   // Wrapper around operator delete
   static void delete_TRandom2(void *p) {
      delete ((::TRandom2*)p);
   }
   static void deleteArray_TRandom2(void *p) {
      delete [] ((::TRandom2*)p);
   }
   static void destruct_TRandom2(void *p) {
      typedef ::TRandom2 current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TRandom2

//______________________________________________________________________________
void TRandom3::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class TRandom3.
      TClass *R__cl = ::TRandom3::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fMt[624]", fMt);
      R__insp.Inspect(R__cl, R__parent, "fCount624", &fCount624);
      TRandom::ShowMembers(R__insp, R__parent);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TRandom3(void *p) {
      return  p ? new(p) ::TRandom3 : new ::TRandom3;
   }
   static void *newArray_TRandom3(Long_t nElements, void *p) {
      return p ? new(p) ::TRandom3[nElements] : new ::TRandom3[nElements];
   }
   // Wrapper around operator delete
   static void delete_TRandom3(void *p) {
      delete ((::TRandom3*)p);
   }
   static void deleteArray_TRandom3(void *p) {
      delete [] ((::TRandom3*)p);
   }
   static void destruct_TRandom3(void *p) {
      typedef ::TRandom3 current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TRandom3

//______________________________________________________________________________
void TVirtualFitter::Streamer(TBuffer &R__b)
{
   // Stream an object of class TVirtualFitter.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TVirtualFitter::Class(),this);
   } else {
      R__b.WriteClassBuffer(TVirtualFitter::Class(),this);
   }
}

//______________________________________________________________________________
void TVirtualFitter::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class TVirtualFitter.
      TClass *R__cl = ::TVirtualFitter::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fOption", (void*)&fOption);
      ::ROOT::GenericShowMembers("Foption_t", (void*)&fOption, R__insp, strcat(R__parent,"fOption."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fXfirst", &fXfirst);
      R__insp.Inspect(R__cl, R__parent, "fXlast", &fXlast);
      R__insp.Inspect(R__cl, R__parent, "fYfirst", &fYfirst);
      R__insp.Inspect(R__cl, R__parent, "fYlast", &fYlast);
      R__insp.Inspect(R__cl, R__parent, "fZfirst", &fZfirst);
      R__insp.Inspect(R__cl, R__parent, "fZlast", &fZlast);
      R__insp.Inspect(R__cl, R__parent, "fNpoints", &fNpoints);
      R__insp.Inspect(R__cl, R__parent, "fPointSize", &fPointSize);
      R__insp.Inspect(R__cl, R__parent, "fCacheSize", &fCacheSize);
      R__insp.Inspect(R__cl, R__parent, "*fCache", &fCache);
      R__insp.Inspect(R__cl, R__parent, "*fObjectFit", &fObjectFit);
      R__insp.Inspect(R__cl, R__parent, "*fUserFunc", &fUserFunc);
      R__insp.Inspect(R__cl, R__parent, "*fMethodCall", &fMethodCall);
      R__insp.Inspect(R__cl, R__parent, "fFCN", &fFCN);
      TNamed::ShowMembers(R__insp, R__parent);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TVirtualFitter(void *p) {
      delete ((::TVirtualFitter*)p);
   }
   static void deleteArray_TVirtualFitter(void *p) {
      delete [] ((::TVirtualFitter*)p);
   }
   static void destruct_TVirtualFitter(void *p) {
      typedef ::TVirtualFitter current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TVirtualFitter

//______________________________________________________________________________
template <> void TKDTree<int,double>::Streamer(TBuffer &R__b)
{
   // Stream an object of class TKDTree<int,double>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TKDTree<int,double>::Class(),this);
   } else {
      R__b.WriteClassBuffer(TKDTree<int,double>::Class(),this);
   }
}

//______________________________________________________________________________
namespace ROOT {
   void TKDTreelEintcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class TKDTree<int,double>.
      typedef ::ROOT::Shadow::TKDTreelEintcOdoublegR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TKDTree<int,double>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fDataOwner", &sobj->fDataOwner);
      R__insp.Inspect(R__cl, R__parent, "fNNodes", &sobj->fNNodes);
      R__insp.Inspect(R__cl, R__parent, "fTotalNodes", &sobj->fTotalNodes);
      R__insp.Inspect(R__cl, R__parent, "fNDim", &sobj->fNDim);
      R__insp.Inspect(R__cl, R__parent, "fNDimm", &sobj->fNDimm);
      R__insp.Inspect(R__cl, R__parent, "fNPoints", &sobj->fNPoints);
      R__insp.Inspect(R__cl, R__parent, "fBucketSize", &sobj->fBucketSize);
      R__insp.Inspect(R__cl, R__parent, "*fAxis", &sobj->fAxis);
      R__insp.Inspect(R__cl, R__parent, "*fValue", &sobj->fValue);
      R__insp.Inspect(R__cl, R__parent, "*fRange", &sobj->fRange);
      R__insp.Inspect(R__cl, R__parent, "*fData", &sobj->fData);
      R__insp.Inspect(R__cl, R__parent, "*fBoundaries", &sobj->fBoundaries);
      R__insp.Inspect(R__cl, R__parent, "*fIndPoints", &sobj->fIndPoints);
      R__insp.Inspect(R__cl, R__parent, "fRowT0", &sobj->fRowT0);
      R__insp.Inspect(R__cl, R__parent, "fCrossNode", &sobj->fCrossNode);
      R__insp.Inspect(R__cl, R__parent, "fOffset", &sobj->fOffset);
      sobj->TObject::ShowMembers(R__insp, R__parent);
   }

}

template <> void TKDTree<int,double>::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
   ::ROOT::TKDTreelEintcOdoublegR_ShowMembers(this, R__insp, R__parent);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TKDTreelEintcOdoublegR(void *p) {
      return  p ? new(p) ::TKDTree<int,double> : new ::TKDTree<int,double>;
   }
   static void *newArray_TKDTreelEintcOdoublegR(Long_t nElements, void *p) {
      return p ? new(p) ::TKDTree<int,double>[nElements] : new ::TKDTree<int,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_TKDTreelEintcOdoublegR(void *p) {
      delete ((::TKDTree<int,double>*)p);
   }
   static void deleteArray_TKDTreelEintcOdoublegR(void *p) {
      delete [] ((::TKDTree<int,double>*)p);
   }
   static void destruct_TKDTreelEintcOdoublegR(void *p) {
      typedef ::TKDTree<int,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TKDTree<int,double>

//______________________________________________________________________________
template <> void TKDTree<int,float>::Streamer(TBuffer &R__b)
{
   // Stream an object of class TKDTree<int,float>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TKDTree<int,float>::Class(),this);
   } else {
      R__b.WriteClassBuffer(TKDTree<int,float>::Class(),this);
   }
}

//______________________________________________________________________________
namespace ROOT {
   void TKDTreelEintcOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class TKDTree<int,float>.
      typedef ::ROOT::Shadow::TKDTreelEintcOfloatgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TKDTree<int,float>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fDataOwner", &sobj->fDataOwner);
      R__insp.Inspect(R__cl, R__parent, "fNNodes", &sobj->fNNodes);
      R__insp.Inspect(R__cl, R__parent, "fTotalNodes", &sobj->fTotalNodes);
      R__insp.Inspect(R__cl, R__parent, "fNDim", &sobj->fNDim);
      R__insp.Inspect(R__cl, R__parent, "fNDimm", &sobj->fNDimm);
      R__insp.Inspect(R__cl, R__parent, "fNPoints", &sobj->fNPoints);
      R__insp.Inspect(R__cl, R__parent, "fBucketSize", &sobj->fBucketSize);
      R__insp.Inspect(R__cl, R__parent, "*fAxis", &sobj->fAxis);
      R__insp.Inspect(R__cl, R__parent, "*fValue", &sobj->fValue);
      R__insp.Inspect(R__cl, R__parent, "*fRange", &sobj->fRange);
      R__insp.Inspect(R__cl, R__parent, "*fData", &sobj->fData);
      R__insp.Inspect(R__cl, R__parent, "*fBoundaries", &sobj->fBoundaries);
      R__insp.Inspect(R__cl, R__parent, "*fIndPoints", &sobj->fIndPoints);
      R__insp.Inspect(R__cl, R__parent, "fRowT0", &sobj->fRowT0);
      R__insp.Inspect(R__cl, R__parent, "fCrossNode", &sobj->fCrossNode);
      R__insp.Inspect(R__cl, R__parent, "fOffset", &sobj->fOffset);
      sobj->TObject::ShowMembers(R__insp, R__parent);
   }

}

template <> void TKDTree<int,float>::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
   ::ROOT::TKDTreelEintcOfloatgR_ShowMembers(this, R__insp, R__parent);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TKDTreelEintcOfloatgR(void *p) {
      return  p ? new(p) ::TKDTree<int,float> : new ::TKDTree<int,float>;
   }
   static void *newArray_TKDTreelEintcOfloatgR(Long_t nElements, void *p) {
      return p ? new(p) ::TKDTree<int,float>[nElements] : new ::TKDTree<int,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_TKDTreelEintcOfloatgR(void *p) {
      delete ((::TKDTree<int,float>*)p);
   }
   static void deleteArray_TKDTreelEintcOfloatgR(void *p) {
      delete [] ((::TKDTree<int,float>*)p);
   }
   static void destruct_TKDTreelEintcOfloatgR(void *p) {
      typedef ::TKDTree<int,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TKDTree<int,float>

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIBaseFunctionOneDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::IBaseFunctionOneDim.
      typedef ::ROOT::Shadow::ROOT::Math::IBaseFunctionOneDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IBaseFunctionOneDim*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIBaseFunctionOneDim(void *p) {
      delete ((::ROOT::Math::IBaseFunctionOneDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIBaseFunctionOneDim(void *p) {
      delete [] ((::ROOT::Math::IBaseFunctionOneDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIBaseFunctionOneDim(void *p) {
      typedef ::ROOT::Math::IBaseFunctionOneDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IBaseFunctionOneDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIGradientOneDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::IGradientOneDim.
      typedef ::ROOT::Shadow::ROOT::Math::IGradientOneDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IGradientOneDim*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIGradientOneDim(void *p) {
      delete ((::ROOT::Math::IGradientOneDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIGradientOneDim(void *p) {
      delete [] ((::ROOT::Math::IGradientOneDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIGradientOneDim(void *p) {
      typedef ::ROOT::Math::IGradientOneDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IGradientOneDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIGradientFunctionOneDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::IGradientFunctionOneDim.
      typedef ::ROOT::Shadow::ROOT::Math::IGradientFunctionOneDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IGradientFunctionOneDim*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      ::ROOT::GenericShowMembers("ROOT::Math::IBaseFunctionOneDim", ( ::ROOT::Math::IBaseFunctionOneDim * )( (::ROOT::Math::IGradientFunctionOneDim*) obj ), R__insp, R__parent, false);
      ::ROOT::GenericShowMembers("ROOT::Math::IGradientOneDim", ( ::ROOT::Math::IGradientOneDim * )( (::ROOT::Math::IGradientFunctionOneDim*) obj ), R__insp, R__parent, false);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIGradientFunctionOneDim(void *p) {
      delete ((::ROOT::Math::IGradientFunctionOneDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIGradientFunctionOneDim(void *p) {
      delete [] ((::ROOT::Math::IGradientFunctionOneDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIGradientFunctionOneDim(void *p) {
      typedef ::ROOT::Math::IGradientFunctionOneDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IGradientFunctionOneDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIBaseParam_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::IBaseParam.
      typedef ::ROOT::Shadow::ROOT::Math::IBaseParam ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IBaseParam*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIBaseParam(void *p) {
      delete ((::ROOT::Math::IBaseParam*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIBaseParam(void *p) {
      delete [] ((::ROOT::Math::IBaseParam*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIBaseParam(void *p) {
      typedef ::ROOT::Math::IBaseParam current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IBaseParam

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIParametricFunctionOneDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::IParametricFunctionOneDim.
      typedef ::ROOT::Shadow::ROOT::Math::IParametricFunctionOneDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IParametricFunctionOneDim*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      ::ROOT::GenericShowMembers("ROOT::Math::IBaseFunctionOneDim", ( ::ROOT::Math::IBaseFunctionOneDim * )( (::ROOT::Math::IParametricFunctionOneDim*) obj ), R__insp, R__parent, false);
      ::ROOT::GenericShowMembers("ROOT::Math::IBaseParam", ( ::ROOT::Math::IBaseParam * )( (::ROOT::Math::IParametricFunctionOneDim*) obj ), R__insp, R__parent, false);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIParametricFunctionOneDim(void *p) {
      delete ((::ROOT::Math::IParametricFunctionOneDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIParametricFunctionOneDim(void *p) {
      delete [] ((::ROOT::Math::IParametricFunctionOneDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIParametricFunctionOneDim(void *p) {
      typedef ::ROOT::Math::IParametricFunctionOneDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IParametricFunctionOneDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIParametricGradFunctionOneDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::IParametricGradFunctionOneDim.
      typedef ::ROOT::Shadow::ROOT::Math::IParametricGradFunctionOneDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IParametricGradFunctionOneDim*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      ::ROOT::GenericShowMembers("ROOT::Math::IParametricFunctionOneDim", ( ::ROOT::Math::IParametricFunctionOneDim * )( (::ROOT::Math::IParametricGradFunctionOneDim*) obj ), R__insp, R__parent, false);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIParametricGradFunctionOneDim(void *p) {
      delete ((::ROOT::Math::IParametricGradFunctionOneDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIParametricGradFunctionOneDim(void *p) {
      delete [] ((::ROOT::Math::IParametricGradFunctionOneDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIParametricGradFunctionOneDim(void *p) {
      typedef ::ROOT::Math::IParametricGradFunctionOneDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IParametricGradFunctionOneDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIBaseFunctionMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::IBaseFunctionMultiDim.
      typedef ::ROOT::Shadow::ROOT::Math::IBaseFunctionMultiDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IBaseFunctionMultiDim*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIBaseFunctionMultiDim(void *p) {
      delete ((::ROOT::Math::IBaseFunctionMultiDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIBaseFunctionMultiDim(void *p) {
      delete [] ((::ROOT::Math::IBaseFunctionMultiDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIBaseFunctionMultiDim(void *p) {
      typedef ::ROOT::Math::IBaseFunctionMultiDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IBaseFunctionMultiDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIGradientMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::IGradientMultiDim.
      typedef ::ROOT::Shadow::ROOT::Math::IGradientMultiDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IGradientMultiDim*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIGradientMultiDim(void *p) {
      delete ((::ROOT::Math::IGradientMultiDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIGradientMultiDim(void *p) {
      delete [] ((::ROOT::Math::IGradientMultiDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIGradientMultiDim(void *p) {
      typedef ::ROOT::Math::IGradientMultiDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IGradientMultiDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIGradientFunctionMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::IGradientFunctionMultiDim.
      typedef ::ROOT::Shadow::ROOT::Math::IGradientFunctionMultiDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IGradientFunctionMultiDim*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      ::ROOT::GenericShowMembers("ROOT::Math::IBaseFunctionMultiDim", ( ::ROOT::Math::IBaseFunctionMultiDim * )( (::ROOT::Math::IGradientFunctionMultiDim*) obj ), R__insp, R__parent, false);
      ::ROOT::GenericShowMembers("ROOT::Math::IGradientMultiDim", ( ::ROOT::Math::IGradientMultiDim * )( (::ROOT::Math::IGradientFunctionMultiDim*) obj ), R__insp, R__parent, false);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIGradientFunctionMultiDim(void *p) {
      delete ((::ROOT::Math::IGradientFunctionMultiDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIGradientFunctionMultiDim(void *p) {
      delete [] ((::ROOT::Math::IGradientFunctionMultiDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIGradientFunctionMultiDim(void *p) {
      typedef ::ROOT::Math::IGradientFunctionMultiDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IGradientFunctionMultiDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIParametricFunctionMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::IParametricFunctionMultiDim.
      typedef ::ROOT::Shadow::ROOT::Math::IParametricFunctionMultiDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IParametricFunctionMultiDim*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      ::ROOT::GenericShowMembers("ROOT::Math::IBaseFunctionMultiDim", ( ::ROOT::Math::IBaseFunctionMultiDim * )( (::ROOT::Math::IParametricFunctionMultiDim*) obj ), R__insp, R__parent, false);
      ::ROOT::GenericShowMembers("ROOT::Math::IBaseParam", ( ::ROOT::Math::IBaseParam * )( (::ROOT::Math::IParametricFunctionMultiDim*) obj ), R__insp, R__parent, false);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIParametricFunctionMultiDim(void *p) {
      delete ((::ROOT::Math::IParametricFunctionMultiDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIParametricFunctionMultiDim(void *p) {
      delete [] ((::ROOT::Math::IParametricFunctionMultiDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIParametricFunctionMultiDim(void *p) {
      typedef ::ROOT::Math::IParametricFunctionMultiDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IParametricFunctionMultiDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIParametricGradFunctionMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::IParametricGradFunctionMultiDim.
      typedef ::ROOT::Shadow::ROOT::Math::IParametricGradFunctionMultiDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IParametricGradFunctionMultiDim*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      ::ROOT::GenericShowMembers("ROOT::Math::IParametricFunctionMultiDim", ( ::ROOT::Math::IParametricFunctionMultiDim * )( (::ROOT::Math::IParametricGradFunctionMultiDim*) obj ), R__insp, R__parent, false);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim(void *p) {
      delete ((::ROOT::Math::IParametricGradFunctionMultiDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim(void *p) {
      delete [] ((::ROOT::Math::IParametricGradFunctionMultiDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim(void *p) {
      typedef ::ROOT::Math::IParametricGradFunctionMultiDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IParametricGradFunctionMultiDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLParamFunctor_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::ParamFunctor.
      typedef ::ROOT::Shadow::ROOT::Math::ParamFunctor ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::ParamFunctor*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "*fImpl", &sobj->fImpl);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLParamFunctor(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::ParamFunctor : new ::ROOT::Math::ParamFunctor;
   }
   static void *newArray_ROOTcLcLMathcLcLParamFunctor(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::ParamFunctor[nElements] : new ::ROOT::Math::ParamFunctor[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLParamFunctor(void *p) {
      delete ((::ROOT::Math::ParamFunctor*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLParamFunctor(void *p) {
      delete [] ((::ROOT::Math::ParamFunctor*)p);
   }
   static void destruct_ROOTcLcLMathcLcLParamFunctor(void *p) {
      typedef ::ROOT::Math::ParamFunctor current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::ParamFunctor

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLFunctor(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Functor : new ::ROOT::Math::Functor;
   }
   static void *newArray_ROOTcLcLMathcLcLFunctor(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Functor[nElements] : new ::ROOT::Math::Functor[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLFunctor(void *p) {
      delete ((::ROOT::Math::Functor*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLFunctor(void *p) {
      delete [] ((::ROOT::Math::Functor*)p);
   }
   static void destruct_ROOTcLcLMathcLcLFunctor(void *p) {
      typedef ::ROOT::Math::Functor current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Functor

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGradFunctor(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GradFunctor : new ::ROOT::Math::GradFunctor;
   }
   static void *newArray_ROOTcLcLMathcLcLGradFunctor(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GradFunctor[nElements] : new ::ROOT::Math::GradFunctor[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGradFunctor(void *p) {
      delete ((::ROOT::Math::GradFunctor*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGradFunctor(void *p) {
      delete [] ((::ROOT::Math::GradFunctor*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGradFunctor(void *p) {
      typedef ::ROOT::Math::GradFunctor current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GradFunctor

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLFunctor1D(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Functor1D( (TRootIOCtor*)0 ) : new ::ROOT::Math::Functor1D( (TRootIOCtor*)0 );
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLFunctor1D(void *p) {
      delete ((::ROOT::Math::Functor1D*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLFunctor1D(void *p) {
      delete [] ((::ROOT::Math::Functor1D*)p);
   }
   static void destruct_ROOTcLcLMathcLcLFunctor1D(void *p) {
      typedef ::ROOT::Math::Functor1D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Functor1D

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGradFunctor1D(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GradFunctor1D( (TRootIOCtor*)0 ) : new ::ROOT::Math::GradFunctor1D( (TRootIOCtor*)0 );
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGradFunctor1D(void *p) {
      delete ((::ROOT::Math::GradFunctor1D*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGradFunctor1D(void *p) {
      delete [] ((::ROOT::Math::GradFunctor1D*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGradFunctor1D(void *p) {
      typedef ::ROOT::Math::GradFunctor1D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GradFunctor1D

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLMinimizer_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::Minimizer.
      typedef ::ROOT::Shadow::ROOT::Math::Minimizer ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Minimizer*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fValidError", &sobj->fValidError);
      R__insp.Inspect(R__cl, R__parent, "fDebug", &sobj->fDebug);
      R__insp.Inspect(R__cl, R__parent, "fStrategy", &sobj->fStrategy);
      R__insp.Inspect(R__cl, R__parent, "fStatus", &sobj->fStatus);
      R__insp.Inspect(R__cl, R__parent, "fMaxCalls", &sobj->fMaxCalls);
      R__insp.Inspect(R__cl, R__parent, "fMaxIter", &sobj->fMaxIter);
      R__insp.Inspect(R__cl, R__parent, "fTol", &sobj->fTol);
      R__insp.Inspect(R__cl, R__parent, "fPrec", &sobj->fPrec);
      R__insp.Inspect(R__cl, R__parent, "fUp", &sobj->fUp);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLMinimizer(void *p) {
      delete ((::ROOT::Math::Minimizer*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLMinimizer(void *p) {
      delete [] ((::ROOT::Math::Minimizer*)p);
   }
   static void destruct_ROOTcLcLMathcLcLMinimizer(void *p) {
      typedef ::ROOT::Math::Minimizer current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Minimizer

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLMinimizerOptions_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::MinimizerOptions.
      typedef ::ROOT::Shadow::ROOT::Math::MinimizerOptions ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::MinimizerOptions*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fLevel", &sobj->fLevel);
      R__insp.Inspect(R__cl, R__parent, "fMaxCalls", &sobj->fMaxCalls);
      R__insp.Inspect(R__cl, R__parent, "fMaxIter", &sobj->fMaxIter);
      R__insp.Inspect(R__cl, R__parent, "fStrategy", &sobj->fStrategy);
      R__insp.Inspect(R__cl, R__parent, "fErrorDef", &sobj->fErrorDef);
      R__insp.Inspect(R__cl, R__parent, "fTolerance", &sobj->fTolerance);
      R__insp.Inspect(R__cl, R__parent, "fPrecision", &sobj->fPrecision);
      R__insp.Inspect(R__cl, R__parent, "fMinimType", (void*)&sobj->fMinimType);
      ::ROOT::GenericShowMembers("string", (void*)&sobj->fMinimType, R__insp, strcat(R__parent,"fMinimType."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fAlgoType", (void*)&sobj->fAlgoType);
      ::ROOT::GenericShowMembers("string", (void*)&sobj->fAlgoType, R__insp, strcat(R__parent,"fAlgoType."),false);
      R__parent[R__ncp] = 0;
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLMinimizerOptions(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::MinimizerOptions : new ::ROOT::Math::MinimizerOptions;
   }
   static void *newArray_ROOTcLcLMathcLcLMinimizerOptions(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::MinimizerOptions[nElements] : new ::ROOT::Math::MinimizerOptions[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLMinimizerOptions(void *p) {
      delete ((::ROOT::Math::MinimizerOptions*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLMinimizerOptions(void *p) {
      delete [] ((::ROOT::Math::MinimizerOptions*)p);
   }
   static void destruct_ROOTcLcLMathcLcLMinimizerOptions(void *p) {
      typedef ::ROOT::Math::MinimizerOptions current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::MinimizerOptions

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIntegratorOneDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::IntegratorOneDim.
      typedef ::ROOT::Shadow::ROOT::Math::IntegratorOneDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IntegratorOneDim*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "*fIntegrator", &sobj->fIntegrator);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLIntegratorOneDim(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::IntegratorOneDim : new ::ROOT::Math::IntegratorOneDim;
   }
   static void *newArray_ROOTcLcLMathcLcLIntegratorOneDim(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::IntegratorOneDim[nElements] : new ::ROOT::Math::IntegratorOneDim[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIntegratorOneDim(void *p) {
      delete ((::ROOT::Math::IntegratorOneDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIntegratorOneDim(void *p) {
      delete [] ((::ROOT::Math::IntegratorOneDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIntegratorOneDim(void *p) {
      typedef ::ROOT::Math::IntegratorOneDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IntegratorOneDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIntegratorMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::IntegratorMultiDim.
      typedef ::ROOT::Shadow::ROOT::Math::IntegratorMultiDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IntegratorMultiDim*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "*fIntegrator", &sobj->fIntegrator);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLIntegratorMultiDim(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::IntegratorMultiDim : new ::ROOT::Math::IntegratorMultiDim;
   }
   static void *newArray_ROOTcLcLMathcLcLIntegratorMultiDim(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::IntegratorMultiDim[nElements] : new ::ROOT::Math::IntegratorMultiDim[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIntegratorMultiDim(void *p) {
      delete ((::ROOT::Math::IntegratorMultiDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIntegratorMultiDim(void *p) {
      delete [] ((::ROOT::Math::IntegratorMultiDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIntegratorMultiDim(void *p) {
      typedef ::ROOT::Math::IntegratorMultiDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IntegratorMultiDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLVirtualIntegrator_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::VirtualIntegrator.
      typedef ::ROOT::Shadow::ROOT::Math::VirtualIntegrator ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::VirtualIntegrator*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLVirtualIntegrator(void *p) {
      delete ((::ROOT::Math::VirtualIntegrator*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLVirtualIntegrator(void *p) {
      delete [] ((::ROOT::Math::VirtualIntegrator*)p);
   }
   static void destruct_ROOTcLcLMathcLcLVirtualIntegrator(void *p) {
      typedef ::ROOT::Math::VirtualIntegrator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::VirtualIntegrator

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLVirtualIntegratorOneDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::VirtualIntegratorOneDim.
      typedef ::ROOT::Shadow::ROOT::Math::VirtualIntegratorOneDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::VirtualIntegratorOneDim*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      ::ROOT::GenericShowMembers("ROOT::Math::VirtualIntegrator", ( ::ROOT::Math::VirtualIntegrator * )( (::ROOT::Math::VirtualIntegratorOneDim*) obj ), R__insp, R__parent, false);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLVirtualIntegratorOneDim(void *p) {
      delete ((::ROOT::Math::VirtualIntegratorOneDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLVirtualIntegratorOneDim(void *p) {
      delete [] ((::ROOT::Math::VirtualIntegratorOneDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLVirtualIntegratorOneDim(void *p) {
      typedef ::ROOT::Math::VirtualIntegratorOneDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::VirtualIntegratorOneDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLVirtualIntegratorMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::VirtualIntegratorMultiDim.
      typedef ::ROOT::Shadow::ROOT::Math::VirtualIntegratorMultiDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::VirtualIntegratorMultiDim*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      ::ROOT::GenericShowMembers("ROOT::Math::VirtualIntegrator", ( ::ROOT::Math::VirtualIntegrator * )( (::ROOT::Math::VirtualIntegratorMultiDim*) obj ), R__insp, R__parent, false);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLVirtualIntegratorMultiDim(void *p) {
      delete ((::ROOT::Math::VirtualIntegratorMultiDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLVirtualIntegratorMultiDim(void *p) {
      delete [] ((::ROOT::Math::VirtualIntegratorMultiDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLVirtualIntegratorMultiDim(void *p) {
      typedef ::ROOT::Math::VirtualIntegratorMultiDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::VirtualIntegratorMultiDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::AdaptiveIntegratorMultiDim.
      typedef ::ROOT::Shadow::ROOT::Math::AdaptiveIntegratorMultiDim ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::AdaptiveIntegratorMultiDim*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fDim", &sobj->fDim);
      R__insp.Inspect(R__cl, R__parent, "fAbsTol", &sobj->fAbsTol);
      R__insp.Inspect(R__cl, R__parent, "fRelTol", &sobj->fRelTol);
      R__insp.Inspect(R__cl, R__parent, "fSize", &sobj->fSize);
      R__insp.Inspect(R__cl, R__parent, "fResult", &sobj->fResult);
      R__insp.Inspect(R__cl, R__parent, "fError", &sobj->fError);
      R__insp.Inspect(R__cl, R__parent, "fRelError", &sobj->fRelError);
      R__insp.Inspect(R__cl, R__parent, "fNEval", &sobj->fNEval);
      R__insp.Inspect(R__cl, R__parent, "fStatus", &sobj->fStatus);
      R__insp.Inspect(R__cl, R__parent, "*fFun", &sobj->fFun);
      ::ROOT::GenericShowMembers("ROOT::Math::VirtualIntegratorMultiDim", ( ::ROOT::Math::VirtualIntegratorMultiDim * )( (::ROOT::Math::AdaptiveIntegratorMultiDim*) obj ), R__insp, R__parent, false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::AdaptiveIntegratorMultiDim : new ::ROOT::Math::AdaptiveIntegratorMultiDim;
   }
   static void *newArray_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::AdaptiveIntegratorMultiDim[nElements] : new ::ROOT::Math::AdaptiveIntegratorMultiDim[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim(void *p) {
      delete ((::ROOT::Math::AdaptiveIntegratorMultiDim*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim(void *p) {
      delete [] ((::ROOT::Math::AdaptiveIntegratorMultiDim*)p);
   }
   static void destruct_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim(void *p) {
      typedef ::ROOT::Math::AdaptiveIntegratorMultiDim current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::AdaptiveIntegratorMultiDim

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>.
      typedef ::ROOT::Shadow::ROOT::Math::BasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fNDim", &sobj->fNDim);
      R__insp.Inspect(R__cl, R__parent, "fNPoints", &sobj->fNPoints);
      R__insp.Inspect(R__cl, R__parent, "fNCalls", &sobj->fNCalls);
      ::ROOT::GenericShowMembers("ROOT::Math::IBaseFunctionMultiDim", ( ::ROOT::Math::IBaseFunctionMultiDim * )( (::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) obj ), R__insp, R__parent, false);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR(void *p) {
      delete ((::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR(void *p) {
      delete [] ((::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*)p);
   }
   static void destruct_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR(void *p) {
      typedef ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>.
      typedef ::ROOT::Shadow::ROOT::Math::BasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fNDim", &sobj->fNDim);
      R__insp.Inspect(R__cl, R__parent, "fNPoints", &sobj->fNPoints);
      R__insp.Inspect(R__cl, R__parent, "fNCalls", &sobj->fNCalls);
      ::ROOT::GenericShowMembers("ROOT::Math::IGradientFunctionMultiDim", ( ::ROOT::Math::IGradientFunctionMultiDim * )( (::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) obj ), R__insp, R__parent, false);
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR(void *p) {
      delete ((::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR(void *p) {
      delete [] ((::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*)p);
   }
   static void destruct_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR(void *p) {
      typedef ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLFactory_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::Factory.
      typedef ::ROOT::Shadow::ROOT::Math::Factory ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::Factory*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLFactory(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Factory : new ::ROOT::Math::Factory;
   }
   static void *newArray_ROOTcLcLMathcLcLFactory(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::Factory[nElements] : new ::ROOT::Math::Factory[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLFactory(void *p) {
      delete ((::ROOT::Math::Factory*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLFactory(void *p) {
      delete [] ((::ROOT::Math::Factory*)p);
   }
   static void destruct_ROOTcLcLMathcLcLFactory(void *p) {
      typedef ::ROOT::Math::Factory current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::Factory

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGaussIntegrator_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::GaussIntegrator.
      typedef ::ROOT::Shadow::ROOT::Math::GaussIntegrator ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GaussIntegrator*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fEpsilon", &sobj->fEpsilon);
      R__insp.Inspect(R__cl, R__parent, "fUsedOnce", &sobj->fUsedOnce);
      R__insp.Inspect(R__cl, R__parent, "fLastResult", &sobj->fLastResult);
      R__insp.Inspect(R__cl, R__parent, "fLastError", &sobj->fLastError);
      R__insp.Inspect(R__cl, R__parent, "*fFunction", &sobj->fFunction);
      R__insp.Inspect(R__cl, R__parent, "fFunctionCopied", &sobj->fFunctionCopied);
      ::ROOT::GenericShowMembers("ROOT::Math::VirtualIntegratorOneDim", ( ::ROOT::Math::VirtualIntegratorOneDim * )( (::ROOT::Math::GaussIntegrator*) obj ), R__insp, R__parent, false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGaussIntegrator(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GaussIntegrator : new ::ROOT::Math::GaussIntegrator;
   }
   static void *newArray_ROOTcLcLMathcLcLGaussIntegrator(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GaussIntegrator[nElements] : new ::ROOT::Math::GaussIntegrator[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGaussIntegrator(void *p) {
      delete ((::ROOT::Math::GaussIntegrator*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGaussIntegrator(void *p) {
      delete [] ((::ROOT::Math::GaussIntegrator*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGaussIntegrator(void *p) {
      typedef ::ROOT::Math::GaussIntegrator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GaussIntegrator

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLGaussLegendreIntegrator_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::GaussLegendreIntegrator.
      typedef ::ROOT::Shadow::ROOT::Math::GaussLegendreIntegrator ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::GaussLegendreIntegrator*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fNum", &sobj->fNum);
      R__insp.Inspect(R__cl, R__parent, "*fX", &sobj->fX);
      R__insp.Inspect(R__cl, R__parent, "*fW", &sobj->fW);
      R__insp.Inspect(R__cl, R__parent, "fEpsilon", &sobj->fEpsilon);
      R__insp.Inspect(R__cl, R__parent, "fUsedOnce", &sobj->fUsedOnce);
      R__insp.Inspect(R__cl, R__parent, "fLastResult", &sobj->fLastResult);
      R__insp.Inspect(R__cl, R__parent, "fLastError", &sobj->fLastError);
      R__insp.Inspect(R__cl, R__parent, "*fFunction", &sobj->fFunction);
      R__insp.Inspect(R__cl, R__parent, "fFunctionCopied", &sobj->fFunctionCopied);
      ::ROOT::GenericShowMembers("ROOT::Math::VirtualIntegratorOneDim", ( ::ROOT::Math::VirtualIntegratorOneDim * )( (::ROOT::Math::GaussLegendreIntegrator*) obj ), R__insp, R__parent, false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLGaussLegendreIntegrator(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GaussLegendreIntegrator : new ::ROOT::Math::GaussLegendreIntegrator;
   }
   static void *newArray_ROOTcLcLMathcLcLGaussLegendreIntegrator(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::GaussLegendreIntegrator[nElements] : new ::ROOT::Math::GaussLegendreIntegrator[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLGaussLegendreIntegrator(void *p) {
      delete ((::ROOT::Math::GaussLegendreIntegrator*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLGaussLegendreIntegrator(void *p) {
      delete [] ((::ROOT::Math::GaussLegendreIntegrator*)p);
   }
   static void destruct_ROOTcLcLMathcLcLGaussLegendreIntegrator(void *p) {
      typedef ::ROOT::Math::GaussLegendreIntegrator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::GaussLegendreIntegrator

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLRichardsonDerivator_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::RichardsonDerivator.
      typedef ::ROOT::Shadow::ROOT::Math::RichardsonDerivator ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::RichardsonDerivator*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fFunctionCopied", &sobj->fFunctionCopied);
      R__insp.Inspect(R__cl, R__parent, "fStepSize", &sobj->fStepSize);
      R__insp.Inspect(R__cl, R__parent, "fLastError", &sobj->fLastError);
      R__insp.Inspect(R__cl, R__parent, "*fFunction", &sobj->fFunction);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLRichardsonDerivator(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::RichardsonDerivator : new ::ROOT::Math::RichardsonDerivator;
   }
   static void *newArray_ROOTcLcLMathcLcLRichardsonDerivator(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::RichardsonDerivator[nElements] : new ::ROOT::Math::RichardsonDerivator[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLRichardsonDerivator(void *p) {
      delete ((::ROOT::Math::RichardsonDerivator*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLRichardsonDerivator(void *p) {
      delete [] ((::ROOT::Math::RichardsonDerivator*)p);
   }
   static void destruct_ROOTcLcLMathcLcLRichardsonDerivator(void *p) {
      typedef ::ROOT::Math::RichardsonDerivator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::RichardsonDerivator

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLRootFinder_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::RootFinder.
      typedef ::ROOT::Shadow::ROOT::Math::RootFinder ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::RootFinder*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "*fSolver", &sobj->fSolver);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLRootFinder(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::RootFinder : new ::ROOT::Math::RootFinder;
   }
   static void *newArray_ROOTcLcLMathcLcLRootFinder(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::RootFinder[nElements] : new ::ROOT::Math::RootFinder[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLRootFinder(void *p) {
      delete ((::ROOT::Math::RootFinder*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLRootFinder(void *p) {
      delete [] ((::ROOT::Math::RootFinder*)p);
   }
   static void destruct_ROOTcLcLMathcLcLRootFinder(void *p) {
      typedef ::ROOT::Math::RootFinder current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::RootFinder

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLIRootFinderMethod_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::IRootFinderMethod.
      typedef ::ROOT::Shadow::ROOT::Math::IRootFinderMethod ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::IRootFinderMethod*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLIRootFinderMethod(void *p) {
      delete ((::ROOT::Math::IRootFinderMethod*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLIRootFinderMethod(void *p) {
      delete [] ((::ROOT::Math::IRootFinderMethod*)p);
   }
   static void destruct_ROOTcLcLMathcLcLIRootFinderMethod(void *p) {
      typedef ::ROOT::Math::IRootFinderMethod current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::IRootFinderMethod

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLBrentRootFinder_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::BrentRootFinder.
      typedef ::ROOT::Shadow::ROOT::Math::BrentRootFinder ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::BrentRootFinder*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "*fFunction", &sobj->fFunction);
      R__insp.Inspect(R__cl, R__parent, "fXMin", &sobj->fXMin);
      R__insp.Inspect(R__cl, R__parent, "fXMax", &sobj->fXMax);
      R__insp.Inspect(R__cl, R__parent, "fRoot", &sobj->fRoot);
      ::ROOT::GenericShowMembers("ROOT::Math::IRootFinderMethod", ( ::ROOT::Math::IRootFinderMethod * )( (::ROOT::Math::BrentRootFinder*) obj ), R__insp, R__parent, false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLBrentRootFinder(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::BrentRootFinder : new ::ROOT::Math::BrentRootFinder;
   }
   static void *newArray_ROOTcLcLMathcLcLBrentRootFinder(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::BrentRootFinder[nElements] : new ::ROOT::Math::BrentRootFinder[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLBrentRootFinder(void *p) {
      delete ((::ROOT::Math::BrentRootFinder*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLBrentRootFinder(void *p) {
      delete [] ((::ROOT::Math::BrentRootFinder*)p);
   }
   static void destruct_ROOTcLcLMathcLcLBrentRootFinder(void *p) {
      typedef ::ROOT::Math::BrentRootFinder current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::BrentRootFinder

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLBrentMinimizer1D_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class ROOT::Math::BrentMinimizer1D.
      typedef ::ROOT::Shadow::ROOT::Math::BrentMinimizer1D ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::BrentMinimizer1D*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "*fFunction", &sobj->fFunction);
      R__insp.Inspect(R__cl, R__parent, "fXMin", &sobj->fXMin);
      R__insp.Inspect(R__cl, R__parent, "fXMax", &sobj->fXMax);
      R__insp.Inspect(R__cl, R__parent, "fXMinimum", &sobj->fXMinimum);
      R__insp.Inspect(R__cl, R__parent, "fNIter", &sobj->fNIter);
      ::ROOT::GenericShowMembers("ROOT::Math::IMinimizer1D", ( ::ROOT::Math::IMinimizer1D * )( (::ROOT::Math::BrentMinimizer1D*) obj ), R__insp, R__parent, false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLBrentMinimizer1D(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::BrentMinimizer1D : new ::ROOT::Math::BrentMinimizer1D;
   }
   static void *newArray_ROOTcLcLMathcLcLBrentMinimizer1D(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::BrentMinimizer1D[nElements] : new ::ROOT::Math::BrentMinimizer1D[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLBrentMinimizer1D(void *p) {
      delete ((::ROOT::Math::BrentMinimizer1D*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLBrentMinimizer1D(void *p) {
      delete [] ((::ROOT::Math::BrentMinimizer1D*)p);
   }
   static void destruct_ROOTcLcLMathcLcLBrentMinimizer1D(void *p) {
      typedef ::ROOT::Math::BrentMinimizer1D current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::BrentMinimizer1D

namespace ROOT {
   void vectorlEdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void vectorlEdoublegR_Dictionary();
   static void *new_vectorlEdoublegR(void *p = 0);
   static void *newArray_vectorlEdoublegR(Long_t size, void *p);
   static void delete_vectorlEdoublegR(void *p);
   static void deleteArray_vectorlEdoublegR(void *p);
   static void destruct_vectorlEdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<double>*)
   {
      vector<double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<double>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<double>", -2, "prec_stl/vector", 49,
                  typeid(vector<double>), DefineBehavior(ptr, ptr),
                  0, &vectorlEdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(vector<double>) );
      instance.SetNew(&new_vectorlEdoublegR);
      instance.SetNewArray(&newArray_vectorlEdoublegR);
      instance.SetDelete(&delete_vectorlEdoublegR);
      instance.SetDeleteArray(&deleteArray_vectorlEdoublegR);
      instance.SetDestructor(&destruct_vectorlEdoublegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<double> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEdoublegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<double> : new vector<double>;
   }
   static void *newArray_vectorlEdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<double>[nElements] : new vector<double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEdoublegR(void *p) {
      delete ((vector<double>*)p);
   }
   static void deleteArray_vectorlEdoublegR(void *p) {
      delete [] ((vector<double>*)p);
   }
   static void destruct_vectorlEdoublegR(void *p) {
      typedef vector<double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<double>

/********************************************************
* math/mathcore/src/G__MathCore.cxx
* CAUTION: DON'T CHANGE THIS FILE. THIS FILE IS AUTOMATICALLY GENERATED
*          FROM HEADER FILES LISTED IN G__setup_cpp_environmentXXX().
*          CHANGE THOSE HEADER FILES AND REGENERATE THIS FILE.
********************************************************/

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

#if defined(__GNUC__) && __GNUC__ >= 4 && ((__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ >= 1) || (__GNUC_MINOR__ >= 3))
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif

extern "C" void G__cpp_reset_tagtableG__MathCore();

extern "C" void G__set_cpp_environmentG__MathCore() {
  G__add_compiledheader("TObject.h");
  G__add_compiledheader("TMemberInspector.h");
  G__add_compiledheader("TRandom.h");
  G__add_compiledheader("TRandom1.h");
  G__add_compiledheader("TRandom2.h");
  G__add_compiledheader("TRandom3.h");
  G__add_compiledheader("TVirtualFitter.h");
  G__add_compiledheader("TKDTree.h");
  G__add_compiledheader("Math/IParamFunction.h");
  G__add_compiledheader("Math/IFunction.h");
  G__add_compiledheader("Math/ParamFunctor.h");
  G__add_compiledheader("Math/Functor.h");
  G__add_compiledheader("Math/Minimizer.h");
  G__add_compiledheader("Math/MinimizerOptions.h");
  G__add_compiledheader("Math/Integrator.h");
  G__add_compiledheader("Math/VirtualIntegrator.h");
  G__add_compiledheader("Math/AllIntegrationTypes.h");
  G__add_compiledheader("Math/AdaptiveIntegratorMultiDim.h");
  G__add_compiledheader("Math/IntegratorMultiDim.h");
  G__add_compiledheader("Math/Factory.h");
  G__add_compiledheader("Math/FitMethodFunction.h");
  G__add_compiledheader("Math/GaussIntegrator.h");
  G__add_compiledheader("Math/GaussLegendreIntegrator.h");
  G__add_compiledheader("Math/RootFinder.h");
  G__add_compiledheader("Math/IRootFinderMethod.h");
  G__add_compiledheader("Math/RichardsonDerivator.h");
  G__add_compiledheader("Math/BrentMethods.h");
  G__add_compiledheader("Math/BrentMinimizer1D.h");
  G__add_compiledheader("Math/BrentRootFinder.h");
  G__add_compiledheader("Math/SpecFuncMathCore.h");
  G__add_compiledheader("Math/DistFuncMathCore.h");
  G__cpp_reset_tagtableG__MathCore();
}
#include <new>
extern "C" int G__cpp_dllrevG__MathCore() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* ROOT */
static int G__G__MathCore_18_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ROOT::CreateClass(
(const char*) G__int(libp->para[0]), (Version_t) G__int(libp->para[1])
, *(type_info*) libp->para[2].ref, (TVirtualIsAProxy*) G__int(libp->para[3])
, (ShowMembersFunc_t) G__int(libp->para[4]), (const char*) G__int(libp->para[5])
, (const char*) G__int(libp->para[6]), (Int_t) G__int(libp->para[7])
, (Int_t) G__int(libp->para[8])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_18_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::AddClass((const char*) G__int(libp->para[0]), (Version_t) G__int(libp->para[1])
, *(type_info*) libp->para[2].ref, (VoidFuncPtr_t) G__int(libp->para[3])
, (Int_t) G__int(libp->para[4]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_18_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::RemoveClass((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_18_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::ResetClassVersion((TClass*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (Short_t) G__int(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_18_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ROOT::RegisterClassTemplate((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_18_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ROOT::DefineBehavior((void*) G__int(libp->para[0]), (void*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}


/* TRandom */
static int G__G__MathCore_106_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRandom* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRandom((UInt_t) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) TRandom((UInt_t) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new TRandom[n];
       } else {
         p = new((void*) gvp) TRandom[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new TRandom;
       } else {
         p = new((void*) gvp) TRandom;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TRandom));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TRandom*) G__getstructoffset())->Binomial((Int_t) G__int(libp->para[0]), (Double_t) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->BreitWigner((Double_t) G__double(libp->para[0]), (Double_t) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->BreitWigner((Double_t) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->BreitWigner());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRandom*) G__getstructoffset())->Circle(*(Double_t*) G__Doubleref(&libp->para[0]), *(Double_t*) G__Doubleref(&libp->para[1])
, (Double_t) G__double(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->Exp((Double_t) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->Gaus((Double_t) G__double(libp->para[0]), (Double_t) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->Gaus((Double_t) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->Gaus());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const TRandom*) G__getstructoffset())->GetSeed());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((TRandom*) G__getstructoffset())->Integer((UInt_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->Landau((Double_t) G__double(libp->para[0]), (Double_t) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->Landau((Double_t) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->Landau());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TRandom*) G__getstructoffset())->Poisson((Double_t) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->PoissonD((Double_t) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRandom*) G__getstructoffset())->Rannor(*(Float_t*) G__Floatref(&libp->para[0]), *(Float_t*) G__Floatref(&libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRandom*) G__getstructoffset())->Rannor(*(Double_t*) G__Doubleref(&libp->para[0]), *(Double_t*) G__Doubleref(&libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRandom*) G__getstructoffset())->ReadRandom((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TRandom*) G__getstructoffset())->SetSeed((UInt_t) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      ((TRandom*) G__getstructoffset())->SetSeed();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->Rndm((Int_t) G__int(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->Rndm());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRandom*) G__getstructoffset())->RndmArray((Int_t) G__int(libp->para[0]), (Float_t*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRandom*) G__getstructoffset())->RndmArray((Int_t) G__int(libp->para[0]), (Double_t*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRandom*) G__getstructoffset())->Sphere(*(Double_t*) G__Doubleref(&libp->para[0]), *(Double_t*) G__Doubleref(&libp->para[1])
, *(Double_t*) G__Doubleref(&libp->para[2]), (Double_t) G__double(libp->para[3]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->Uniform((Double_t) G__double(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->Uniform());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((TRandom*) G__getstructoffset())->Uniform((Double_t) G__double(libp->para[0]), (Double_t) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRandom*) G__getstructoffset())->WriteRandom((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TRandom::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRandom::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TRandom::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TRandom::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRandom*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRandom::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TRandom::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRandom::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_106_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TRandom::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_106_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TRandom* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TRandom(*(TRandom*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TRandom));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TRandom G__TTRandom;
static int G__G__MathCore_106_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TRandom*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TRandom*) (soff+(sizeof(TRandom)*i)))->~G__TTRandom();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TRandom*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TRandom*) (soff))->~G__TTRandom();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_106_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRandom* dest = (TRandom*) G__getstructoffset();
   *dest = *(TRandom*) libp->para[0].ref;
   const TRandom& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TRandom1 */
static int G__G__MathCore_107_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRandom1* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRandom1[n];
     } else {
       p = new((void*) gvp) TRandom1[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRandom1;
     } else {
       p = new((void*) gvp) TRandom1;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_107_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRandom1* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRandom1((UInt_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) TRandom1((UInt_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRandom1((UInt_t) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) TRandom1((UInt_t) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_107_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRandom1* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 3
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TRandom1(
(Int_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2]));
   } else {
     p = new((void*) gvp) TRandom1(
(Int_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_107_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TRandom1*) G__getstructoffset())->GetLuxury());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_107_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 72, (long) ((const TRandom1*) G__getstructoffset())->GetTheSeeds());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_107_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TRandom1::GetTableSeeds((UInt_t*) G__int(libp->para[0]), (Int_t) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_107_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((TRandom1*) G__getstructoffset())->SetSeed2((UInt_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((TRandom1*) G__getstructoffset())->SetSeed2((UInt_t) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_107_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((TRandom1*) G__getstructoffset())->SetSeeds((const UInt_t*) G__int(libp->para[0]), (Int_t) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((TRandom1*) G__getstructoffset())->SetSeeds((const UInt_t*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_107_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TRandom1::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_107_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRandom1::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_107_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TRandom1::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_107_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TRandom1::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_107_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRandom1*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_107_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRandom1::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_107_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TRandom1::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_107_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRandom1::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_107_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TRandom1::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_107_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TRandom1* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TRandom1(*(TRandom1*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TRandom1 G__TTRandom1;
static int G__G__MathCore_107_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TRandom1*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TRandom1*) (soff+(sizeof(TRandom1)*i)))->~G__TTRandom1();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TRandom1*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TRandom1*) (soff))->~G__TTRandom1();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TRandom2 */
static int G__G__MathCore_108_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRandom2* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRandom2((UInt_t) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) TRandom2((UInt_t) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new TRandom2[n];
       } else {
         p = new((void*) gvp) TRandom2[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new TRandom2;
       } else {
         p = new((void*) gvp) TRandom2;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TRandom2));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_108_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TRandom2::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_108_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRandom2::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_108_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TRandom2::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_108_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TRandom2::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_108_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRandom2*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_108_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRandom2::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_108_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TRandom2::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_108_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRandom2::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_108_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TRandom2::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_108_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TRandom2* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TRandom2(*(TRandom2*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TRandom2));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TRandom2 G__TTRandom2;
static int G__G__MathCore_108_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TRandom2*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TRandom2*) (soff+(sizeof(TRandom2)*i)))->~G__TTRandom2();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TRandom2*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TRandom2*) (soff))->~G__TTRandom2();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_108_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRandom2* dest = (TRandom2*) G__getstructoffset();
   *dest = *(TRandom2*) libp->para[0].ref;
   const TRandom2& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TRandom3 */
static int G__G__MathCore_109_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRandom3* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRandom3((UInt_t) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) TRandom3((UInt_t) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new TRandom3[n];
       } else {
         p = new((void*) gvp) TRandom3[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new TRandom3;
       } else {
         p = new((void*) gvp) TRandom3;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TRandom3));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_109_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TRandom3::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_109_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRandom3::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_109_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TRandom3::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_109_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TRandom3::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_109_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRandom3*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_109_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRandom3::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_109_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TRandom3::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_109_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRandom3::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_109_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TRandom3::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_109_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TRandom3* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TRandom3(*(TRandom3*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TRandom3));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TRandom3 G__TTRandom3;
static int G__G__MathCore_109_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TRandom3*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TRandom3*) (soff+(sizeof(TRandom3)*i)))->~G__TTRandom3();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TRandom3*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TRandom3*) (soff))->~G__TTRandom3();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_109_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRandom3* dest = (TRandom3*) G__getstructoffset();
   *dest = *(TRandom3*) libp->para[0].ref;
   const TRandom3& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TVirtualFitter */
static int G__G__MathCore_117_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const TVirtualFitter*) G__getstructoffset())->Chisquare((Int_t) G__int(libp->para[0]), (Double_t*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TVirtualFitter*) G__getstructoffset())->ExecuteCommand((const char*) G__int(libp->para[0]), (Double_t*) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->FixParameter((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      ((TVirtualFitter*) G__getstructoffset())->GetConfidenceIntervals((Int_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])
, (const Double_t*) G__int(libp->para[2]), (Double_t*) G__int(libp->para[3])
, (Double_t) G__double(libp->para[4]));
      G__setnull(result7);
      break;
   case 4:
      ((TVirtualFitter*) G__getstructoffset())->GetConfidenceIntervals((Int_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])
, (const Double_t*) G__int(libp->para[2]), (Double_t*) G__int(libp->para[3]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((TVirtualFitter*) G__getstructoffset())->GetConfidenceIntervals((TObject*) G__int(libp->para[0]), (Double_t) G__double(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((TVirtualFitter*) G__getstructoffset())->GetConfidenceIntervals((TObject*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((const TVirtualFitter*) G__getstructoffset())->GetCovarianceMatrix());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const TVirtualFitter*) G__getstructoffset())->GetCovarianceMatrixElement((Int_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TVirtualFitter*) G__getstructoffset())->GetErrors((Int_t) G__int(libp->para[0]), *(Double_t*) G__Doubleref(&libp->para[1])
, *(Double_t*) G__Doubleref(&libp->para[2]), *(Double_t*) G__Doubleref(&libp->para[3])
, *(Double_t*) G__Doubleref(&libp->para[4])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 89, (long) ((TVirtualFitter*) G__getstructoffset())->GetFCN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const Foption_t* pobj;
         const Foption_t xobj = ((const TVirtualFitter*) G__getstructoffset())->GetFitOption();
         pobj = new Foption_t(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const TVirtualFitter*) G__getstructoffset())->GetMethodCall());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TVirtualFitter*) G__getstructoffset())->GetNumberTotalParameters());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TVirtualFitter*) G__getstructoffset())->GetNumberFreeParameters());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const TVirtualFitter*) G__getstructoffset())->GetObjectFit());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const TVirtualFitter*) G__getstructoffset())->GetParError((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const TVirtualFitter*) G__getstructoffset())->GetParameter((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TVirtualFitter*) G__getstructoffset())->GetParameter((Int_t) G__int(libp->para[0]), (char*) G__int(libp->para[1])
, *(Double_t*) G__Doubleref(&libp->para[2]), *(Double_t*) G__Doubleref(&libp->para[3])
, *(Double_t*) G__Doubleref(&libp->para[4]), *(Double_t*) G__Doubleref(&libp->para[5])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const TVirtualFitter*) G__getstructoffset())->GetParName((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TVirtualFitter*) G__getstructoffset())->GetStats(*(Double_t*) G__Doubleref(&libp->para[0]), *(Double_t*) G__Doubleref(&libp->para[1])
, *(Double_t*) G__Doubleref(&libp->para[2]), *(Int_t*) G__Intref(&libp->para[3])
, *(Int_t*) G__Intref(&libp->para[4])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((TVirtualFitter*) G__getstructoffset())->GetSumLog((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const TVirtualFitter*) G__getstructoffset())->GetUserFunc());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TVirtualFitter*) G__getstructoffset())->GetXfirst());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TVirtualFitter*) G__getstructoffset())->GetXlast());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TVirtualFitter*) G__getstructoffset())->GetYfirst());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TVirtualFitter*) G__getstructoffset())->GetYlast());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TVirtualFitter*) G__getstructoffset())->GetZfirst());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TVirtualFitter*) G__getstructoffset())->GetZlast());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TVirtualFitter*) G__getstructoffset())->IsFixed((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const TVirtualFitter*) G__getstructoffset())->PrintResults((Int_t) G__int(libp->para[0]), (Double_t) G__double(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->ReleaseParameter((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((TVirtualFitter*) G__getstructoffset())->SetCache((Int_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->SetFCN((void*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->SetFCN((void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t)) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->SetFitMethod((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->SetFitOption(*((Foption_t*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->SetObjectFit((TObject*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TVirtualFitter*) G__getstructoffset())->SetParameter((Int_t) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (Double_t) G__double(libp->para[2]), (Double_t) G__double(libp->para[3])
, (Double_t) G__double(libp->para[4]), (Double_t) G__double(libp->para[5])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_42(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->SetUserFunc((TObject*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_43(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->SetXfirst((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_44(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->SetXlast((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_45(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->SetYfirst((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_46(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->SetYlast((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_47(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->SetZfirst((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_48(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->SetZlast((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_49(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TVirtualFitter::GetFitter());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_50(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 85, (long) TVirtualFitter::Fitter((TObject*) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 85, (long) TVirtualFitter::Fitter((TObject*) G__int(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_51(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualFitter::GetDefaultFitter());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_52(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TVirtualFitter::GetMaxIterations());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_53(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) TVirtualFitter::GetErrorDef());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_54(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) TVirtualFitter::GetPrecision());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_55(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      TVirtualFitter::SetDefaultFitter((const char*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      TVirtualFitter::SetDefaultFitter();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_56(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      TVirtualFitter::SetFitter((TVirtualFitter*) G__int(libp->para[0]), (Int_t) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      TVirtualFitter::SetFitter((TVirtualFitter*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_57(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      TVirtualFitter::SetMaxIterations((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      TVirtualFitter::SetMaxIterations();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_58(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      TVirtualFitter::SetErrorDef((Double_t) G__double(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      TVirtualFitter::SetErrorDef();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_59(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      TVirtualFitter::SetPrecision((Double_t) G__double(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      TVirtualFitter::SetPrecision();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_60(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TVirtualFitter::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_61(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualFitter::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_62(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TVirtualFitter::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_63(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TVirtualFitter::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_67(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualFitter*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_68(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualFitter::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_69(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TVirtualFitter::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_70(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualFitter::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_117_0_71(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TVirtualFitter::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TVirtualFitter G__TTVirtualFitter;
static int G__G__MathCore_117_0_72(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TVirtualFitter*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TVirtualFitter*) (soff+(sizeof(TVirtualFitter)*i)))->~G__TTVirtualFitter();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TVirtualFitter*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TVirtualFitter*) (soff))->~G__TTVirtualFitter();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TKDTree<int,double> */
static int G__G__MathCore_118_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TKDTree<int,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TKDTree<int,double>[n];
     } else {
       p = new((void*) gvp) TKDTree<int,double>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TKDTree<int,double>;
     } else {
       p = new((void*) gvp) TKDTree<int,double>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TKDTree<int,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 3
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TKDTree<int,double>(
(int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]));
   } else {
     p = new((void*) gvp) TKDTree<int,double>(
(int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TKDTree<int,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 4
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TKDTree<int,double>(
(int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (double**) G__int(libp->para[3]));
   } else {
     p = new((void*) gvp) TKDTree<int,double>(
(int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (double**) G__int(libp->para[3]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,double>*) G__getstructoffset())->Build();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ((const TKDTree<int,double>*) G__getstructoffset())->Distance((const double*) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ((const TKDTree<int,double>*) G__getstructoffset())->Distance((const double*) G__int(libp->para[0]), (int) G__int(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      ((TKDTree<int,double>*) G__getstructoffset())->DistanceToNode((const double*) G__int(libp->para[0]), (int) G__int(libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]), *(double*) G__Doubleref(&libp->para[3])
, (Int_t) G__int(libp->para[4]));
      G__setnull(result7);
      break;
   case 4:
      ((TKDTree<int,double>*) G__getstructoffset())->DistanceToNode((const double*) G__int(libp->para[0]), (int) G__int(libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]), *(double*) G__Doubleref(&libp->para[3]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,double>*) G__getstructoffset())->GetLeft((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,double>*) G__getstructoffset())->GetRight((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,double>*) G__getstructoffset())->GetParent((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 73, (long) ((const TKDTree<int,double>*) G__getstructoffset())->GetPointsIndexes((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const TKDTree<int,double>*) G__getstructoffset())->GetNodePointsIndexes((Int_t) G__int(libp->para[0]), *(Int_t*) G__Intref(&libp->para[1])
, *(Int_t*) G__Intref(&libp->para[2]), *(Int_t*) G__Intref(&libp->para[3])
, *(Int_t*) G__Intref(&libp->para[4]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 98, (long) ((const TKDTree<int,double>*) G__getstructoffset())->GetNodeAxis((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const TKDTree<int,double>*) G__getstructoffset())->GetNodeValue((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,double>*) G__getstructoffset())->GetNNodes());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,double>*) G__getstructoffset())->GetTotalNodes());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((TKDTree<int,double>*) G__getstructoffset())->GetBoundaries());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((TKDTree<int,double>*) G__getstructoffset())->GetBoundariesExact());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((TKDTree<int,double>*) G__getstructoffset())->GetBoundary((const Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((TKDTree<int,double>*) G__getstructoffset())->GetBoundaryExact((const Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,double>*) G__getstructoffset())->GetNPoints());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,double>*) G__getstructoffset())->GetNDim());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,double>*) G__getstructoffset())->GetNPointsNode((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,double>*) G__getstructoffset())->GetRowT0());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,double>*) G__getstructoffset())->GetCrossNode());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,double>*) G__getstructoffset())->GetOffset());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 73, (long) ((TKDTree<int,double>*) G__getstructoffset())->GetIndPoints());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,double>*) G__getstructoffset())->GetBucketSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,double>*) G__getstructoffset())->FindNearestNeighbors((const double*) G__int(libp->para[0]), (const Int_t) G__int(libp->para[1])
, (int*) G__int(libp->para[2]), (double*) G__int(libp->para[3]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,double>*) G__getstructoffset())->FindNode((const double*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,double>*) G__getstructoffset())->FindPoint((double*) G__int(libp->para[0]), *(int*) G__Intref(&libp->para[1])
, *(Int_t*) G__Intref(&libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,double>*) G__getstructoffset())->FindInRange((double*) G__int(libp->para[0]), (double) G__double(libp->para[1])
, *(vector<int>*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,double>*) G__getstructoffset())->FindBNodeA((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1])
, *(Int_t*) G__Intref(&libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TKDTree<int,double>*) G__getstructoffset())->IsTerminal((int) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,double>*) G__getstructoffset())->IsOwner());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const TKDTree<int,double>*) G__getstructoffset())->KOrdStat((int) G__int(libp->para[0]), (double*) G__int(libp->para[1])
, (int) G__int(libp->para[2]), (int*) G__int(libp->para[3])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TKDTree<int,double>*) G__getstructoffset())->MakeBoundaries((double*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      ((TKDTree<int,double>*) G__getstructoffset())->MakeBoundaries();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,double>*) G__getstructoffset())->MakeBoundariesExact();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,double>*) G__getstructoffset())->SetData((int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (double**) G__int(libp->para[3]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,double>*) G__getstructoffset())->SetData((int) G__int(libp->para[0]), (double*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,double>*) G__getstructoffset())->SetOwner((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const TKDTree<int,double>*) G__getstructoffset())->Spread((int) G__int(libp->para[0]), (double*) G__int(libp->para[1])
, (int*) G__int(libp->para[2]), *(double*) G__Doubleref(&libp->para[3])
, *(double*) G__Doubleref(&libp->para[4]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_47(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TKDTree<int,double>::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_48(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TKDTree<int,double>::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_49(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TKDTree<int,double>::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_50(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TKDTree<int,double>::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_54(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,double>*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_55(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TKDTree<int,double>::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_56(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TKDTree<int,double>::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_57(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TKDTree<int,double>::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_118_0_58(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TKDTree<int,double>::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TKDTree<int,double> G__TTKDTreelEintcOdoublegR;
static int G__G__MathCore_118_0_59(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TKDTree<int,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TKDTree<int,double>*) (soff+(sizeof(TKDTree<int,double>)*i)))->~G__TTKDTreelEintcOdoublegR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TKDTree<int,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TKDTree<int,double>*) (soff))->~G__TTKDTreelEintcOdoublegR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TKDTree<int,float> */
static int G__G__MathCore_123_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TKDTree<int,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TKDTree<int,float>[n];
     } else {
       p = new((void*) gvp) TKDTree<int,float>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TKDTree<int,float>;
     } else {
       p = new((void*) gvp) TKDTree<int,float>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TKDTree<int,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 3
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TKDTree<int,float>(
(int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]));
   } else {
     p = new((void*) gvp) TKDTree<int,float>(
(int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TKDTree<int,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 4
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TKDTree<int,float>(
(int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (float**) G__int(libp->para[3]));
   } else {
     p = new((void*) gvp) TKDTree<int,float>(
(int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (float**) G__int(libp->para[3]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,float>*) G__getstructoffset())->Build();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ((const TKDTree<int,float>*) G__getstructoffset())->Distance((const float*) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ((const TKDTree<int,float>*) G__getstructoffset())->Distance((const float*) G__int(libp->para[0]), (int) G__int(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      ((TKDTree<int,float>*) G__getstructoffset())->DistanceToNode((const float*) G__int(libp->para[0]), (int) G__int(libp->para[1])
, *(float*) G__Floatref(&libp->para[2]), *(float*) G__Floatref(&libp->para[3])
, (Int_t) G__int(libp->para[4]));
      G__setnull(result7);
      break;
   case 4:
      ((TKDTree<int,float>*) G__getstructoffset())->DistanceToNode((const float*) G__int(libp->para[0]), (int) G__int(libp->para[1])
, *(float*) G__Floatref(&libp->para[2]), *(float*) G__Floatref(&libp->para[3]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,float>*) G__getstructoffset())->GetLeft((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,float>*) G__getstructoffset())->GetRight((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,float>*) G__getstructoffset())->GetParent((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 73, (long) ((const TKDTree<int,float>*) G__getstructoffset())->GetPointsIndexes((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const TKDTree<int,float>*) G__getstructoffset())->GetNodePointsIndexes((Int_t) G__int(libp->para[0]), *(Int_t*) G__Intref(&libp->para[1])
, *(Int_t*) G__Intref(&libp->para[2]), *(Int_t*) G__Intref(&libp->para[3])
, *(Int_t*) G__Intref(&libp->para[4]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 98, (long) ((const TKDTree<int,float>*) G__getstructoffset())->GetNodeAxis((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const TKDTree<int,float>*) G__getstructoffset())->GetNodeValue((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,float>*) G__getstructoffset())->GetNNodes());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,float>*) G__getstructoffset())->GetTotalNodes());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 70, (long) ((TKDTree<int,float>*) G__getstructoffset())->GetBoundaries());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 70, (long) ((TKDTree<int,float>*) G__getstructoffset())->GetBoundariesExact());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 70, (long) ((TKDTree<int,float>*) G__getstructoffset())->GetBoundary((const Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 70, (long) ((TKDTree<int,float>*) G__getstructoffset())->GetBoundaryExact((const Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,float>*) G__getstructoffset())->GetNPoints());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,float>*) G__getstructoffset())->GetNDim());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,float>*) G__getstructoffset())->GetNPointsNode((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,float>*) G__getstructoffset())->GetRowT0());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,float>*) G__getstructoffset())->GetCrossNode());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,float>*) G__getstructoffset())->GetOffset());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 73, (long) ((TKDTree<int,float>*) G__getstructoffset())->GetIndPoints());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,float>*) G__getstructoffset())->GetBucketSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,float>*) G__getstructoffset())->FindNearestNeighbors((const float*) G__int(libp->para[0]), (const Int_t) G__int(libp->para[1])
, (int*) G__int(libp->para[2]), (float*) G__int(libp->para[3]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TKDTree<int,float>*) G__getstructoffset())->FindNode((const float*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,float>*) G__getstructoffset())->FindPoint((float*) G__int(libp->para[0]), *(int*) G__Intref(&libp->para[1])
, *(Int_t*) G__Intref(&libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,float>*) G__getstructoffset())->FindInRange((float*) G__int(libp->para[0]), (float) G__double(libp->para[1])
, *(vector<int>*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,float>*) G__getstructoffset())->FindBNodeA((float*) G__int(libp->para[0]), (float*) G__int(libp->para[1])
, *(Int_t*) G__Intref(&libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TKDTree<int,float>*) G__getstructoffset())->IsTerminal((int) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,float>*) G__getstructoffset())->IsOwner());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const TKDTree<int,float>*) G__getstructoffset())->KOrdStat((int) G__int(libp->para[0]), (float*) G__int(libp->para[1])
, (int) G__int(libp->para[2]), (int*) G__int(libp->para[3])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TKDTree<int,float>*) G__getstructoffset())->MakeBoundaries((float*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      ((TKDTree<int,float>*) G__getstructoffset())->MakeBoundaries();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,float>*) G__getstructoffset())->MakeBoundariesExact();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,float>*) G__getstructoffset())->SetData((int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (float**) G__int(libp->para[3]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TKDTree<int,float>*) G__getstructoffset())->SetData((int) G__int(libp->para[0]), (float*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,float>*) G__getstructoffset())->SetOwner((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const TKDTree<int,float>*) G__getstructoffset())->Spread((int) G__int(libp->para[0]), (float*) G__int(libp->para[1])
, (int*) G__int(libp->para[2]), *(float*) G__Floatref(&libp->para[3])
, *(float*) G__Floatref(&libp->para[4]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_47(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TKDTree<int,float>::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_48(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TKDTree<int,float>::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_49(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TKDTree<int,float>::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_50(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TKDTree<int,float>::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_54(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TKDTree<int,float>*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_55(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TKDTree<int,float>::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_56(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TKDTree<int,float>::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_57(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TKDTree<int,float>::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_123_0_58(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TKDTree<int,float>::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TKDTree<int,float> G__TTKDTreelEintcOfloatgR;
static int G__G__MathCore_123_0_59(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TKDTree<int,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TKDTree<int,float>*) (soff+(sizeof(TKDTree<int,float>)*i)))->~G__TTKDTreelEintcOfloatgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TKDTree<int,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TKDTree<int,float>*) (soff))->~G__TTKDTreelEintcOfloatgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math */
static int G__G__MathCore_124_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 6:
      G__letdouble(result7, 100, (double) ROOT::Math::MinimStep((const ROOT::Math::IGenFunction*) G__int(libp->para[0]), (int) G__int(libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]), *(double*) G__Doubleref(&libp->para[3])
, (double) G__double(libp->para[4]), (int) G__int(libp->para[5])));
      break;
   case 5:
      G__letdouble(result7, 100, (double) ROOT::Math::MinimStep((const ROOT::Math::IGenFunction*) G__int(libp->para[0]), (int) G__int(libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]), *(double*) G__Doubleref(&libp->para[3])
, (double) G__double(libp->para[4])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::MinimBrent(
(const ROOT::Math::IGenFunction*) G__int(libp->para[0]), (int) G__int(libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]), *(double*) G__Doubleref(&libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5])
, *(bool*) G__Boolref(&libp->para[6])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::erf((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::erfc((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::tgamma((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::lgamma((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::inc_gamma((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::inc_gamma_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::beta((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::inc_beta((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::beta_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::binomial_pdf((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (unsigned int) G__int(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::breitwigner_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::breitwigner_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::cauchy_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::cauchy_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ROOT::Math::cauchy_pdf((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::chisquared_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::chisquared_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::exponential_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::exponential_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::fdistribution_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::fdistribution_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::gamma_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::gamma_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::gaussian_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::gaussian_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ROOT::Math::gaussian_pdf((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_pdf((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::lognormal_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::lognormal_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::normal_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::normal_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ROOT::Math::normal_pdf((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::poisson_pdf((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::tdistribution_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::tdistribution_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::uniform_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::uniform_pdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::beta_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::beta_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::breitwigner_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::breitwigner_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::breitwigner_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::breitwigner_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::cauchy_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::cauchy_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::cauchy_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::cauchy_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::chisquared_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::chisquared_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::chisquared_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::chisquared_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::exponential_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::exponential_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::exponential_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::exponential_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::fdistribution_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::fdistribution_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::fdistribution_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::fdistribution_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::gamma_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::gamma_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::gamma_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::gamma_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_cdf((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ROOT::Math::landau_cdf_c((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_42(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::lognormal_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::lognormal_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_43(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::lognormal_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::lognormal_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_44(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::normal_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::normal_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ROOT::Math::normal_cdf_c((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_45(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::gaussian_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::gaussian_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ROOT::Math::gaussian_cdf_c((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_46(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::normal_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::normal_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ROOT::Math::normal_cdf((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_47(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::gaussian_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::gaussian_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ROOT::Math::gaussian_cdf((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_48(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::tdistribution_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::tdistribution_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_49(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::tdistribution_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ROOT::Math::tdistribution_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_50(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::uniform_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::uniform_cdf_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_51(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letdouble(result7, 100, (double) ROOT::Math::uniform_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
      break;
   case 3:
      G__letdouble(result7, 100, (double) ROOT::Math::uniform_cdf((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_52(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::poisson_cdf_c((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_53(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::poisson_cdf((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_54(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::binomial_cdf_c((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (unsigned int) G__int(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_55(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::binomial_cdf((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (unsigned int) G__int(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_56(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::beta_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_57(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::beta_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_58(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::cauchy_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_59(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::cauchy_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_60(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::breitwigner_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_61(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::breitwigner_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_62(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::chisquared_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_63(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::chisquared_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_64(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::exponential_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_65(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::exponential_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_66(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::fdistribution_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_67(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::fdistribution_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_68(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::gamma_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_69(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::gamma_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_70(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::gaussian_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_71(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::gaussian_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_72(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::lognormal_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_73(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::lognormal_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_74(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::normal_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_75(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::normal_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_76(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::uniform_quantile_c((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_124_0_77(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::uniform_quantile((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IBaseFunctionOneDim */
static int G__G__MathCore_125_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const ROOT::Math::IBaseFunctionOneDim*) G__getstructoffset())->Clone());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_125_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IBaseFunctionOneDim*) G__getstructoffset())->operator()((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_125_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IBaseFunctionOneDim*) G__getstructoffset())->operator()((const double*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IBaseFunctionOneDim G__TROOTcLcLMathcLcLIBaseFunctionOneDim;
static int G__G__MathCore_125_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IBaseFunctionOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IBaseFunctionOneDim*) (soff+(sizeof(ROOT::Math::IBaseFunctionOneDim)*i)))->~G__TROOTcLcLMathcLcLIBaseFunctionOneDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IBaseFunctionOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IBaseFunctionOneDim*) (soff))->~G__TROOTcLcLMathcLcLIBaseFunctionOneDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_125_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IBaseFunctionOneDim* dest = (ROOT::Math::IBaseFunctionOneDim*) G__getstructoffset();
   *dest = *(ROOT::Math::IBaseFunctionOneDim*) libp->para[0].ref;
   const ROOT::Math::IBaseFunctionOneDim& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IGradientFunctionOneDim */
// automatic destructor
typedef ROOT::Math::IGradientFunctionOneDim G__TROOTcLcLMathcLcLIGradientFunctionOneDim;
static int G__G__MathCore_126_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IGradientFunctionOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IGradientFunctionOneDim*) (soff+(sizeof(ROOT::Math::IGradientFunctionOneDim)*i)))->~G__TROOTcLcLMathcLcLIGradientFunctionOneDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IGradientFunctionOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IGradientFunctionOneDim*) (soff))->~G__TROOTcLcLMathcLcLIGradientFunctionOneDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_126_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IGradientFunctionOneDim* dest = (ROOT::Math::IGradientFunctionOneDim*) G__getstructoffset();
   *dest = *(ROOT::Math::IGradientFunctionOneDim*) libp->para[0].ref;
   const ROOT::Math::IGradientFunctionOneDim& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IBaseFunctionMultiDim */
static int G__G__MathCore_127_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const ROOT::Math::IBaseFunctionMultiDim*) G__getstructoffset())->Clone());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::IBaseFunctionMultiDim*) G__getstructoffset())->NDim());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_127_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IBaseFunctionMultiDim*) G__getstructoffset())->operator()((const double*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IBaseFunctionMultiDim G__TROOTcLcLMathcLcLIBaseFunctionMultiDim;
static int G__G__MathCore_127_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IBaseFunctionMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IBaseFunctionMultiDim*) (soff+(sizeof(ROOT::Math::IBaseFunctionMultiDim)*i)))->~G__TROOTcLcLMathcLcLIBaseFunctionMultiDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IBaseFunctionMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IBaseFunctionMultiDim*) (soff))->~G__TROOTcLcLMathcLcLIBaseFunctionMultiDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_127_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IBaseFunctionMultiDim* dest = (ROOT::Math::IBaseFunctionMultiDim*) G__getstructoffset();
   *dest = *(ROOT::Math::IBaseFunctionMultiDim*) libp->para[0].ref;
   const ROOT::Math::IBaseFunctionMultiDim& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IGradientFunctionMultiDim */
// automatic destructor
typedef ROOT::Math::IGradientFunctionMultiDim G__TROOTcLcLMathcLcLIGradientFunctionMultiDim;
static int G__G__MathCore_128_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IGradientFunctionMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IGradientFunctionMultiDim*) (soff+(sizeof(ROOT::Math::IGradientFunctionMultiDim)*i)))->~G__TROOTcLcLMathcLcLIGradientFunctionMultiDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IGradientFunctionMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IGradientFunctionMultiDim*) (soff))->~G__TROOTcLcLMathcLcLIGradientFunctionMultiDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_128_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IGradientFunctionMultiDim* dest = (ROOT::Math::IGradientFunctionMultiDim*) G__getstructoffset();
   *dest = *(ROOT::Math::IGradientFunctionMultiDim*) libp->para[0].ref;
   const ROOT::Math::IGradientFunctionMultiDim& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IGradientMultiDim */
static int G__G__MathCore_129_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::IGradientMultiDim*) G__getstructoffset())->Gradient((const double*) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_129_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IGradientMultiDim*) G__getstructoffset())->Derivative((const double*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IGradientMultiDim*) G__getstructoffset())->Derivative((const double*) G__int(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_129_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::IGradientMultiDim*) G__getstructoffset())->FdF((const double*) G__int(libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, (double*) G__int(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IGradientMultiDim G__TROOTcLcLMathcLcLIGradientMultiDim;
static int G__G__MathCore_129_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IGradientMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IGradientMultiDim*) (soff+(sizeof(ROOT::Math::IGradientMultiDim)*i)))->~G__TROOTcLcLMathcLcLIGradientMultiDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IGradientMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IGradientMultiDim*) (soff))->~G__TROOTcLcLMathcLcLIGradientMultiDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_129_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IGradientMultiDim* dest = (ROOT::Math::IGradientMultiDim*) G__getstructoffset();
   *dest = *(ROOT::Math::IGradientMultiDim*) libp->para[0].ref;
   const ROOT::Math::IGradientMultiDim& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IGradientOneDim */
static int G__G__MathCore_130_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IGradientOneDim*) G__getstructoffset())->Derivative((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::IGradientOneDim*) G__getstructoffset())->FdF((double) G__double(libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IGradientOneDim*) G__getstructoffset())->Derivative((const double*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::IGradientOneDim*) G__getstructoffset())->Gradient((const double*) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_130_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::IGradientOneDim*) G__getstructoffset())->FdF((const double*) G__int(libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, (double*) G__int(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IGradientOneDim G__TROOTcLcLMathcLcLIGradientOneDim;
static int G__G__MathCore_130_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IGradientOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IGradientOneDim*) (soff+(sizeof(ROOT::Math::IGradientOneDim)*i)))->~G__TROOTcLcLMathcLcLIGradientOneDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IGradientOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IGradientOneDim*) (soff))->~G__TROOTcLcLMathcLcLIGradientOneDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_130_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IGradientOneDim* dest = (ROOT::Math::IGradientOneDim*) G__getstructoffset();
   *dest = *(ROOT::Math::IGradientOneDim*) libp->para[0].ref;
   const ROOT::Math::IGradientOneDim& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IParametricFunctionOneDim */
static int G__G__MathCore_131_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricFunctionOneDim*) G__getstructoffset())->operator()((double) G__double(libp->para[0]), (const double*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_131_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IParametricFunctionOneDim*) G__getstructoffset())->operator()((const double*) G__int(libp->para[0]), (const double*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IParametricFunctionOneDim G__TROOTcLcLMathcLcLIParametricFunctionOneDim;
static int G__G__MathCore_131_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IParametricFunctionOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IParametricFunctionOneDim*) (soff+(sizeof(ROOT::Math::IParametricFunctionOneDim)*i)))->~G__TROOTcLcLMathcLcLIParametricFunctionOneDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IParametricFunctionOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IParametricFunctionOneDim*) (soff))->~G__TROOTcLcLMathcLcLIParametricFunctionOneDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_131_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IParametricFunctionOneDim* dest = (ROOT::Math::IParametricFunctionOneDim*) G__getstructoffset();
   *dest = *(ROOT::Math::IParametricFunctionOneDim*) libp->para[0].ref;
   const ROOT::Math::IParametricFunctionOneDim& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IParametricGradFunctionOneDim */
static int G__G__MathCore_132_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset())->ParameterGradient((double) G__double(libp->para[0]), (const double*) G__int(libp->para[1])
, (double*) G__int(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset())->ParameterGradient((double) G__double(libp->para[0]), (double*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset())->ParameterGradient((const double*) G__int(libp->para[0]), (const double*) G__int(libp->para[1])
, (double*) G__int(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset())->ParameterGradient((const double*) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset())->ParameterDerivative((double) G__double(libp->para[0]), (const double*) G__int(libp->para[1])
, (unsigned int) G__int(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset())->ParameterDerivative((double) G__double(libp->para[0]), (const double*) G__int(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset())->ParameterDerivative((double) G__double(libp->para[0]), (unsigned int) G__int(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset())->ParameterDerivative((double) G__double(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset())->ParameterDerivative((const double*) G__int(libp->para[0]), (const double*) G__int(libp->para[1])
, (unsigned int) G__int(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset())->ParameterDerivative((const double*) G__int(libp->para[0]), (const double*) G__int(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_132_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset())->ParameterDerivative((const double*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset())->ParameterDerivative((const double*) G__int(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IParametricGradFunctionOneDim G__TROOTcLcLMathcLcLIParametricGradFunctionOneDim;
static int G__G__MathCore_132_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IParametricGradFunctionOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IParametricGradFunctionOneDim*) (soff+(sizeof(ROOT::Math::IParametricGradFunctionOneDim)*i)))->~G__TROOTcLcLMathcLcLIParametricGradFunctionOneDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IParametricGradFunctionOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IParametricGradFunctionOneDim*) (soff))->~G__TROOTcLcLMathcLcLIParametricGradFunctionOneDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_132_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IParametricGradFunctionOneDim* dest = (ROOT::Math::IParametricGradFunctionOneDim*) G__getstructoffset();
   *dest = *(ROOT::Math::IParametricGradFunctionOneDim*) libp->para[0].ref;
   const ROOT::Math::IParametricGradFunctionOneDim& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IParametricFunctionMultiDim */
static int G__G__MathCore_133_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricFunctionMultiDim*) G__getstructoffset())->operator()((const double*) G__int(libp->para[0]), (const double*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IParametricFunctionMultiDim G__TROOTcLcLMathcLcLIParametricFunctionMultiDim;
static int G__G__MathCore_133_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IParametricFunctionMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IParametricFunctionMultiDim*) (soff+(sizeof(ROOT::Math::IParametricFunctionMultiDim)*i)))->~G__TROOTcLcLMathcLcLIParametricFunctionMultiDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IParametricFunctionMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IParametricFunctionMultiDim*) (soff))->~G__TROOTcLcLMathcLcLIParametricFunctionMultiDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_133_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IParametricFunctionMultiDim* dest = (ROOT::Math::IParametricFunctionMultiDim*) G__getstructoffset();
   *dest = *(ROOT::Math::IParametricFunctionMultiDim*) libp->para[0].ref;
   const ROOT::Math::IParametricFunctionMultiDim& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IParametricGradFunctionMultiDim */
static int G__G__MathCore_134_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::IParametricGradFunctionMultiDim*) G__getstructoffset())->ParameterGradient((const double*) G__int(libp->para[0]), (const double*) G__int(libp->para[1])
, (double*) G__int(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_134_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricGradFunctionMultiDim*) G__getstructoffset())->ParameterDerivative((const double*) G__int(libp->para[0]), (const double*) G__int(libp->para[1])
, (unsigned int) G__int(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricGradFunctionMultiDim*) G__getstructoffset())->ParameterDerivative((const double*) G__int(libp->para[0]), (const double*) G__int(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_134_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::IParametricGradFunctionMultiDim*) G__getstructoffset())->ParameterGradient((const double*) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_134_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricGradFunctionMultiDim*) G__getstructoffset())->ParameterDerivative((const double*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])));
      break;
   case 1:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IParametricGradFunctionMultiDim*) G__getstructoffset())->ParameterDerivative((const double*) G__int(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IParametricGradFunctionMultiDim G__TROOTcLcLMathcLcLIParametricGradFunctionMultiDim;
static int G__G__MathCore_134_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IParametricGradFunctionMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IParametricGradFunctionMultiDim*) (soff+(sizeof(ROOT::Math::IParametricGradFunctionMultiDim)*i)))->~G__TROOTcLcLMathcLcLIParametricGradFunctionMultiDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IParametricGradFunctionMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IParametricGradFunctionMultiDim*) (soff))->~G__TROOTcLcLMathcLcLIParametricGradFunctionMultiDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_134_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IParametricGradFunctionMultiDim* dest = (ROOT::Math::IParametricGradFunctionMultiDim*) G__getstructoffset();
   *dest = *(ROOT::Math::IParametricGradFunctionMultiDim*) libp->para[0].ref;
   const ROOT::Math::IParametricGradFunctionMultiDim& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IBaseParam */
static int G__G__MathCore_136_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((const ROOT::Math::IBaseParam*) G__getstructoffset())->Parameters());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_136_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IBaseParam*) G__getstructoffset())->SetParameters((const double*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_136_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::IBaseParam*) G__getstructoffset())->NPar());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_136_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const ROOT::Math::IBaseParam*) G__getstructoffset())->ParameterName((unsigned int) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IBaseParam G__TROOTcLcLMathcLcLIBaseParam;
static int G__G__MathCore_136_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IBaseParam*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IBaseParam*) (soff+(sizeof(ROOT::Math::IBaseParam)*i)))->~G__TROOTcLcLMathcLcLIBaseParam();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IBaseParam*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IBaseParam*) (soff))->~G__TROOTcLcLMathcLcLIBaseParam();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_136_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IBaseParam* dest = (ROOT::Math::IBaseParam*) G__getstructoffset();
   *dest = *(ROOT::Math::IBaseParam*) libp->para[0].ref;
   const ROOT::Math::IBaseParam& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::ParamFunctor */
static int G__G__MathCore_138_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::ParamFunctor* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::ParamFunctor[n];
     } else {
       p = new((void*) gvp) ROOT::Math::ParamFunctor[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::ParamFunctor;
     } else {
       p = new((void*) gvp) ROOT::Math::ParamFunctor;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_138_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::ParamFunctor* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::ParamFunctor((ROOT::Math::ParamFunctor::FreeFunc) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) ROOT::Math::ParamFunctor((ROOT::Math::ParamFunctor::FreeFunc) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_138_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::ParamFunctor* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::ParamFunctor(*(ROOT::Math::ParamFunctor*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ROOT::Math::ParamFunctor(*(ROOT::Math::ParamFunctor*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_138_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::ParamFunctor& obj = ((ROOT::Math::ParamFunctor*) G__getstructoffset())->operator=(*(ROOT::Math::ParamFunctor*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_138_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 89, (long) ((ROOT::Math::ParamFunctor*) G__getstructoffset())->GetImpl());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_138_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::ParamFunctor*) G__getstructoffset())->operator()((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_138_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::ParamFunctor*) G__getstructoffset())->Empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_138_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::ParamFunctor*) G__getstructoffset())->SetFunction((ROOT::Math::ParamFunctor::Impl*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::ParamFunctor G__TROOTcLcLMathcLcLParamFunctor;
static int G__G__MathCore_138_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::ParamFunctor*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::ParamFunctor*) (soff+(sizeof(ROOT::Math::ParamFunctor)*i)))->~G__TROOTcLcLMathcLcLParamFunctor();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::ParamFunctor*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::ParamFunctor*) (soff))->~G__TROOTcLcLMathcLcLParamFunctor();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Functor */
static int G__G__MathCore_139_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Functor* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Functor[n];
     } else {
       p = new((void*) gvp) ROOT::Math::Functor[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Functor;
     } else {
       p = new((void*) gvp) ROOT::Math::Functor;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_139_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Functor* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Functor(
(void*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (const char*) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) ROOT::Math::Functor(
(void*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (const char*) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Functor(
(void*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::Functor(
(void*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Functor((void*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::Functor((void*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_139_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::Functor& obj = ((ROOT::Math::Functor*) G__getstructoffset())->operator=(*(ROOT::Math::Functor*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_139_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::Functor* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::Functor(*(ROOT::Math::Functor*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Functor G__TROOTcLcLMathcLcLFunctor;
static int G__G__MathCore_139_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Functor*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Functor*) (soff+(sizeof(ROOT::Math::Functor)*i)))->~G__TROOTcLcLMathcLcLFunctor();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Functor*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Functor*) (soff))->~G__TROOTcLcLMathcLcLFunctor();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Functor1D */
static int G__G__MathCore_141_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Functor1D* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Functor1D[n];
     } else {
       p = new((void*) gvp) ROOT::Math::Functor1D[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Functor1D;
     } else {
       p = new((void*) gvp) ROOT::Math::Functor1D;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_141_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Functor1D* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Functor1D(
(void*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::Functor1D(
(void*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Functor1D((void*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::Functor1D((void*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Functor1D((void*) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::Functor1D((void*) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_141_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::Functor1D& obj = ((ROOT::Math::Functor1D*) G__getstructoffset())->operator=(*(ROOT::Math::Functor1D*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_141_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::Functor1D* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::Functor1D(*(ROOT::Math::Functor1D*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Functor1D G__TROOTcLcLMathcLcLFunctor1D;
static int G__G__MathCore_141_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Functor1D*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Functor1D*) (soff+(sizeof(ROOT::Math::Functor1D)*i)))->~G__TROOTcLcLMathcLcLFunctor1D();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Functor1D*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Functor1D*) (soff))->~G__TROOTcLcLMathcLcLFunctor1D();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GradFunctor */
static int G__G__MathCore_143_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GradFunctor* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GradFunctor[n];
     } else {
       p = new((void*) gvp) ROOT::Math::GradFunctor[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GradFunctor;
     } else {
       p = new((void*) gvp) ROOT::Math::GradFunctor;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_143_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GradFunctor* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 5
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::GradFunctor(
(void*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (const char*) G__int(libp->para[3])
, (const char*) G__int(libp->para[4]));
   } else {
     p = new((void*) gvp) ROOT::Math::GradFunctor(
(void*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (const char*) G__int(libp->para[3])
, (const char*) G__int(libp->para[4]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_143_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GradFunctor* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 3
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::GradFunctor(
(void*) G__int(libp->para[0]), (void*) G__int(libp->para[1])
, (unsigned int) G__int(libp->para[2]));
   } else {
     p = new((void*) gvp) ROOT::Math::GradFunctor(
(void*) G__int(libp->para[0]), (void*) G__int(libp->para[1])
, (unsigned int) G__int(libp->para[2]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_143_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::GradFunctor& obj = ((ROOT::Math::GradFunctor*) G__getstructoffset())->operator=(*(ROOT::Math::GradFunctor*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_143_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::GradFunctor* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::GradFunctor(*(ROOT::Math::GradFunctor*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GradFunctor G__TROOTcLcLMathcLcLGradFunctor;
static int G__G__MathCore_143_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GradFunctor*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GradFunctor*) (soff+(sizeof(ROOT::Math::GradFunctor)*i)))->~G__TROOTcLcLMathcLcLGradFunctor();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GradFunctor*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GradFunctor*) (soff))->~G__TROOTcLcLMathcLcLGradFunctor();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GradFunctor1D */
static int G__G__MathCore_145_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GradFunctor1D* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GradFunctor1D[n];
     } else {
       p = new((void*) gvp) ROOT::Math::GradFunctor1D[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GradFunctor1D;
     } else {
       p = new((void*) gvp) ROOT::Math::GradFunctor1D;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_145_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GradFunctor1D* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 4
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::GradFunctor1D(
(void*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (const char*) G__int(libp->para[3]));
   } else {
     p = new((void*) gvp) ROOT::Math::GradFunctor1D(
(void*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (const char*) G__int(libp->para[3]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_145_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GradFunctor1D* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::GradFunctor1D((void*) G__int(libp->para[0]), (void*) G__int(libp->para[1]));
   } else {
     p = new((void*) gvp) ROOT::Math::GradFunctor1D((void*) G__int(libp->para[0]), (void*) G__int(libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_145_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::GradFunctor1D& obj = ((ROOT::Math::GradFunctor1D*) G__getstructoffset())->operator=(*(ROOT::Math::GradFunctor1D*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_145_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::GradFunctor1D* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::GradFunctor1D(*(ROOT::Math::GradFunctor1D*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GradFunctor1D G__TROOTcLcLMathcLcLGradFunctor1D;
static int G__G__MathCore_145_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GradFunctor1D*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GradFunctor1D*) (soff+(sizeof(ROOT::Math::GradFunctor1D)*i)))->~G__TROOTcLcLMathcLcLGradFunctor1D();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GradFunctor1D*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GradFunctor1D*) (soff))->~G__TROOTcLcLMathcLcLGradFunctor1D();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Minimizer */
static int G__G__MathCore_147_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->Clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->SetFunction(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->SetFunction(*(ROOT::Math::IMultiGradFunction*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->SetVariable((unsigned int) G__int(libp->para[0]), *(string*) libp->para[1].ref
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->SetLowerLimitedVariable((unsigned int) G__int(libp->para[0]), *(string*) libp->para[1].ref
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->SetUpperLimitedVariable((unsigned int) G__int(libp->para[0]), *(string*) libp->para[1].ref
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->SetLimitedVariable((unsigned int) G__int(libp->para[0]), *(string*) libp->para[1].ref
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->SetFixedVariable((unsigned int) G__int(libp->para[0]), *(string*) libp->para[1].ref
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->SetVariableValue((unsigned int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->SetVariableValues((const double*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->Minimize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Minimizer*) G__getstructoffset())->MinValue());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Minimizer*) G__getstructoffset())->Edm());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->X());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->MinGradient());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->NCalls());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->NDim());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->NFree());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->ProvidesError());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->Errors());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Minimizer*) G__getstructoffset())->CovMatrix((unsigned int) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->CovMatrixStatus());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Minimizer*) G__getstructoffset())->Correlation((unsigned int) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Minimizer*) G__getstructoffset())->GlobalCC((unsigned int) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->GetMinosError((unsigned int) G__int(libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]), (int) G__int(libp->para[3])));
      break;
   case 3:
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->GetMinosError((unsigned int) G__int(libp->para[0]), *(double*) G__Doubleref(&libp->para[1])
, *(double*) G__Doubleref(&libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->Hesse());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 6:
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->Scan((unsigned int) G__int(libp->para[0]), *(unsigned int*) G__UIntref(&libp->para[1])
, (double*) G__int(libp->para[2]), (double*) G__int(libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5])));
      break;
   case 5:
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->Scan((unsigned int) G__int(libp->para[0]), *(unsigned int*) G__UIntref(&libp->para[1])
, (double*) G__int(libp->para[2]), (double*) G__int(libp->para[3])
, (double) G__double(libp->para[4])));
      break;
   case 4:
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->Scan((unsigned int) G__int(libp->para[0]), *(unsigned int*) G__UIntref(&libp->para[1])
, (double*) G__int(libp->para[2]), (double*) G__int(libp->para[3])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->Contour((unsigned int) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])
, *(unsigned int*) G__UIntref(&libp->para[2]), (double*) G__int(libp->para[3])
, (double*) G__int(libp->para[4])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->PrintResults();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string* pobj;
         const string xobj = ((const ROOT::Math::Minimizer*) G__getstructoffset())->VariableName((unsigned int) G__int(libp->para[0]));
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->VariableIndex(*(string*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->PrintLevel());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->MaxFunctionCalls());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((ROOT::Math::Minimizer*) G__getstructoffset())->MaxIterations());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Minimizer*) G__getstructoffset())->Tolerance());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Minimizer*) G__getstructoffset())->Precision());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->Strategy());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->Status());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_42(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::Minimizer*) G__getstructoffset())->ErrorDef());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_43(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const ROOT::Math::Minimizer*) G__getstructoffset())->IsValidError());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_44(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->SetPrintLevel((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_45(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->SetMaxFunctionCalls((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_46(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->SetMaxIterations((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_47(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->SetTolerance((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_48(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->SetPrecision((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_49(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->SetStrategy((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_50(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->SetErrorDef((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_147_0_51(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::Minimizer*) G__getstructoffset())->SetValidError((bool) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Minimizer G__TROOTcLcLMathcLcLMinimizer;
static int G__G__MathCore_147_0_52(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Minimizer*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Minimizer*) (soff+(sizeof(ROOT::Math::Minimizer)*i)))->~G__TROOTcLcLMathcLcLMinimizer();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Minimizer*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Minimizer*) (soff))->~G__TROOTcLcLMathcLcLMinimizer();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::MinimizerOptions */
static int G__G__MathCore_148_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ROOT::Math::MinimizerOptions::SetDefaultMinimizer((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ROOT::Math::MinimizerOptions::SetDefaultMinimizer((const char*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::MinimizerOptions::SetDefaultErrorDef((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::MinimizerOptions::SetDefaultTolerance((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::MinimizerOptions::SetDefaultPrecision((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::MinimizerOptions::SetDefaultMaxIterations((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::MinimizerOptions::SetDefaultStrategy((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ROOT::Math::MinimizerOptions::SetDefaultPrintLevel((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string& obj = ROOT::Math::MinimizerOptions::DefaultMinimizerType();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string& obj = ROOT::Math::MinimizerOptions::DefaultMinimizerAlgo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::MinimizerOptions::DefaultErrorDef());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::MinimizerOptions::DefaultTolerance());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ROOT::Math::MinimizerOptions::DefaultPrecision());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ROOT::Math::MinimizerOptions::DefaultMaxFunctionCalls());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ROOT::Math::MinimizerOptions::DefaultMaxIterations());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ROOT::Math::MinimizerOptions::DefaultStrategy());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ROOT::Math::MinimizerOptions::DefaultPrintLevel());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::MinimizerOptions* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::MinimizerOptions[n];
     } else {
       p = new((void*) gvp) ROOT::Math::MinimizerOptions[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::MinimizerOptions;
     } else {
       p = new((void*) gvp) ROOT::Math::MinimizerOptions;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizerOptions));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::MinimizerOptions*) G__getstructoffset())->PrintLevel());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::MinimizerOptions*) G__getstructoffset())->MaxFunctionCalls());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::MinimizerOptions*) G__getstructoffset())->MaxIterations());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::MinimizerOptions*) G__getstructoffset())->Strategy());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::MinimizerOptions*) G__getstructoffset())->Tolerance());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::MinimizerOptions*) G__getstructoffset())->Precision());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::MinimizerOptions*) G__getstructoffset())->ErrorDef());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string& obj = ((const ROOT::Math::MinimizerOptions*) G__getstructoffset())->MinimizerType();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const string& obj = ((const ROOT::Math::MinimizerOptions*) G__getstructoffset())->MinimizerAlgorithm();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::MinimizerOptions*) G__getstructoffset())->SetPrintLevel((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::MinimizerOptions*) G__getstructoffset())->SetMaxFunctionCalls((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::MinimizerOptions*) G__getstructoffset())->SetMaxIterations((unsigned int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::MinimizerOptions*) G__getstructoffset())->SetTolerance((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::MinimizerOptions*) G__getstructoffset())->SetPrecision((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::MinimizerOptions*) G__getstructoffset())->SetStrategy((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::MinimizerOptions*) G__getstructoffset())->SetErrorDef((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::MinimizerOptions*) G__getstructoffset())->SetMinimizerType((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_148_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::MinimizerOptions*) G__getstructoffset())->SetMinimizerAlgorithm((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_148_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::MinimizerOptions* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::MinimizerOptions(*(ROOT::Math::MinimizerOptions*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizerOptions));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::MinimizerOptions G__TROOTcLcLMathcLcLMinimizerOptions;
static int G__G__MathCore_148_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::MinimizerOptions*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::MinimizerOptions*) (soff+(sizeof(ROOT::Math::MinimizerOptions)*i)))->~G__TROOTcLcLMathcLcLMinimizerOptions();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::MinimizerOptions*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::MinimizerOptions*) (soff))->~G__TROOTcLcLMathcLcLMinimizerOptions();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_148_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::MinimizerOptions* dest = (ROOT::Math::MinimizerOptions*) G__getstructoffset();
   *dest = *(ROOT::Math::MinimizerOptions*) libp->para[0].ref;
   const ROOT::Math::MinimizerOptions& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IntegrationOneDim */

/* ROOT::Math::IntegrationMultiDim */

/* ROOT::Math::VirtualIntegrator */
static int G__G__MathCore_153_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::VirtualIntegrator*) G__getstructoffset())->SetRelTolerance((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_153_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::VirtualIntegrator*) G__getstructoffset())->SetAbsTolerance((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_153_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::VirtualIntegrator*) G__getstructoffset())->Result());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_153_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::VirtualIntegrator*) G__getstructoffset())->Error());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_153_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::VirtualIntegrator*) G__getstructoffset())->Status());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::VirtualIntegrator G__TROOTcLcLMathcLcLVirtualIntegrator;
static int G__G__MathCore_153_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::VirtualIntegrator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::VirtualIntegrator*) (soff+(sizeof(ROOT::Math::VirtualIntegrator)*i)))->~G__TROOTcLcLMathcLcLVirtualIntegrator();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::VirtualIntegrator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::VirtualIntegrator*) (soff))->~G__TROOTcLcLMathcLcLVirtualIntegrator();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_153_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::VirtualIntegrator* dest = (ROOT::Math::VirtualIntegrator*) G__getstructoffset();
   *dest = *(ROOT::Math::VirtualIntegrator*) libp->para[0].ref;
   const ROOT::Math::VirtualIntegrator& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::VirtualIntegratorOneDim */
static int G__G__MathCore_154_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::VirtualIntegratorOneDim*) G__getstructoffset())->Integral((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_154_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((ROOT::Math::VirtualIntegratorOneDim*) G__getstructoffset())->SetFunction(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (bool) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((ROOT::Math::VirtualIntegratorOneDim*) G__getstructoffset())->SetFunction(*(ROOT::Math::IGenFunction*) libp->para[0].ref);
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_154_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::VirtualIntegratorOneDim*) G__getstructoffset())->Integral());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_154_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::VirtualIntegratorOneDim*) G__getstructoffset())->IntegralUp((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_154_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::VirtualIntegratorOneDim*) G__getstructoffset())->IntegralLow((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_154_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::VirtualIntegratorOneDim*) G__getstructoffset())->Integral(*(vector<double>*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_154_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::VirtualIntegratorOneDim*) G__getstructoffset())->IntegralCauchy((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::VirtualIntegratorOneDim G__TROOTcLcLMathcLcLVirtualIntegratorOneDim;
static int G__G__MathCore_154_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::VirtualIntegratorOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::VirtualIntegratorOneDim*) (soff+(sizeof(ROOT::Math::VirtualIntegratorOneDim)*i)))->~G__TROOTcLcLMathcLcLVirtualIntegratorOneDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::VirtualIntegratorOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::VirtualIntegratorOneDim*) (soff))->~G__TROOTcLcLMathcLcLVirtualIntegratorOneDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_154_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::VirtualIntegratorOneDim* dest = (ROOT::Math::VirtualIntegratorOneDim*) G__getstructoffset();
   *dest = *(ROOT::Math::VirtualIntegratorOneDim*) libp->para[0].ref;
   const ROOT::Math::VirtualIntegratorOneDim& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<double,allocator<double> > */
static int G__G__MathCore_156_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const double& obj = ((vector<double,allocator<double> >*) G__getstructoffset())->at((vector<double,allocator<double> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.d = (double) (obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<double,allocator<double> >::iterator* pobj;
         vector<double,allocator<double> >::iterator xobj = ((vector<double,allocator<double> >*) G__getstructoffset())->begin();
         pobj = new vector<double,allocator<double> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<double,allocator<double> >::iterator* pobj;
         vector<double,allocator<double> >::iterator xobj = ((vector<double,allocator<double> >*) G__getstructoffset())->end();
         pobj = new vector<double,allocator<double> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<double,allocator<double> >::reverse_iterator* pobj;
         vector<double,allocator<double> >::reverse_iterator xobj = ((vector<double,allocator<double> >*) G__getstructoffset())->rbegin();
         pobj = new vector<double,allocator<double> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<double,allocator<double> >::reverse_iterator* pobj;
         vector<double,allocator<double> >::reverse_iterator xobj = ((vector<double,allocator<double> >*) G__getstructoffset())->rend();
         pobj = new vector<double,allocator<double> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<double,allocator<double> >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<double,allocator<double> >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<double,allocator<double> >*) G__getstructoffset())->resize((vector<double,allocator<double> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<double,allocator<double> >*) G__getstructoffset())->resize((vector<double,allocator<double> >::size_type) G__int(libp->para[0]), (double) G__double(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<double,allocator<double> >*) G__getstructoffset())->capacity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const vector<double,allocator<double> >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const double& obj = ((vector<double,allocator<double> >*) G__getstructoffset())->operator[]((vector<double,allocator<double> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.d = (double) (obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<double,allocator<double> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<double,allocator<double> >[n];
     } else {
       p = new((void*) gvp) vector<double,allocator<double> >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<double,allocator<double> >;
     } else {
       p = new((void*) gvp) vector<double,allocator<double> >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<double,allocator<double> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<double,allocator<double> >((vector<double,allocator<double> >::size_type) G__int(libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
     } else {
       p = new((void*) gvp) vector<double,allocator<double> >((vector<double,allocator<double> >::size_type) G__int(libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<double,allocator<double> >((vector<double,allocator<double> >::size_type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) vector<double,allocator<double> >((vector<double,allocator<double> >::size_type) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<double,allocator<double> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<double,allocator<double> >(*(vector<double,allocator<double> >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) vector<double,allocator<double> >(*(vector<double,allocator<double> >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<double,allocator<double> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<double,allocator<double> >(*((vector<double,allocator<double> >::const_iterator*) G__int(libp->para[0])), *((vector<double,allocator<double> >::const_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) vector<double,allocator<double> >(*((vector<double,allocator<double> >::const_iterator*) G__int(libp->para[0])), *((vector<double,allocator<double> >::const_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double,allocator<double> >& obj = ((vector<double,allocator<double> >*) G__getstructoffset())->operator=(*(vector<double,allocator<double> >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<double,allocator<double> >*) G__getstructoffset())->reserve((vector<double,allocator<double> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const double& obj = ((vector<double,allocator<double> >*) G__getstructoffset())->front();
         result7->ref = (long) (&obj);
         result7->obj.d = (double) (obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const double& obj = ((vector<double,allocator<double> >*) G__getstructoffset())->back();
         result7->ref = (long) (&obj);
         result7->obj.d = (double) (obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<double,allocator<double> >*) G__getstructoffset())->push_back(*(double*) G__Doubleref(&libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<double,allocator<double> >*) G__getstructoffset())->swap(*(vector<double,allocator<double> >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<double,allocator<double> >::iterator* pobj;
         vector<double,allocator<double> >::iterator xobj = ((vector<double,allocator<double> >*) G__getstructoffset())->insert(*((vector<double,allocator<double> >::iterator*) G__int(libp->para[0])), *(double*) G__Doubleref(&libp->para[1]));
         pobj = new vector<double,allocator<double> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<double,allocator<double> >*) G__getstructoffset())->insert(*((vector<double,allocator<double> >::iterator*) G__int(libp->para[0])), *((vector<double,allocator<double> >::const_iterator*) G__int(libp->para[1]))
, *((vector<double,allocator<double> >::const_iterator*) G__int(libp->para[2])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<double,allocator<double> >*) G__getstructoffset())->insert(*((vector<double,allocator<double> >::iterator*) G__int(libp->para[0])), (vector<double,allocator<double> >::size_type) G__int(libp->para[1])
, *(double*) G__Doubleref(&libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<double,allocator<double> >*) G__getstructoffset())->pop_back();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<double,allocator<double> >*) G__getstructoffset())->erase(*((vector<double,allocator<double> >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<double,allocator<double> >*) G__getstructoffset())->erase(*((vector<double,allocator<double> >::iterator*) G__int(libp->para[0])), *((vector<double,allocator<double> >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_156_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<double,allocator<double> >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<double,allocator<double> > G__TvectorlEdoublecOallocatorlEdoublegRsPgR;
static int G__G__MathCore_156_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<double,allocator<double> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<double,allocator<double> >*) (soff+(sizeof(vector<double,allocator<double> >)*i)))->~G__TvectorlEdoublecOallocatorlEdoublegRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<double,allocator<double> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<double,allocator<double> >*) (soff))->~G__TvectorlEdoublecOallocatorlEdoublegRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<double,allocator<double> >::iterator */
static int G__G__MathCore_157_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<double,allocator<double> >::iterator* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<double,allocator<double> >::iterator[n];
     } else {
       p = new((void*) gvp) vector<double,allocator<double> >::iterator[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<double,allocator<double> >::iterator;
     } else {
       p = new((void*) gvp) vector<double,allocator<double> >::iterator;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_157_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<double,allocator<double> >::iterator* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<double,allocator<double> >::iterator(libp->para[0].ref ? *(const vector<double,allocator<double> >::iterator::pointer*) libp->para[0].ref : *(const vector<double,allocator<double> >::iterator::pointer*) (&G__Mlong(libp->para[0])));
   } else {
     p = new((void*) gvp) vector<double,allocator<double> >::iterator(libp->para[0].ref ? *(const vector<double,allocator<double> >::iterator::pointer*) libp->para[0].ref : *(const vector<double,allocator<double> >::iterator::pointer*) (&G__Mlong(libp->para[0])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_157_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double,allocator<double> >::iterator::reference obj = ((const vector<double,allocator<double> >::iterator*) G__getstructoffset())->operator*();
         result7->ref = (long) (&obj);
         result7->obj.d = (double) (obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_157_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((const vector<double,allocator<double> >::iterator*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_157_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double,allocator<double> >::iterator& obj = ((vector<double,allocator<double> >::iterator*) G__getstructoffset())->operator++();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_157_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<double,allocator<double> >::iterator* pobj;
         vector<double,allocator<double> >::iterator xobj = ((vector<double,allocator<double> >::iterator*) G__getstructoffset())->operator++((int) G__int(libp->para[0]));
         pobj = new vector<double,allocator<double> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_157_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double,allocator<double> >::iterator& obj = ((vector<double,allocator<double> >::iterator*) G__getstructoffset())->operator--();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_157_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<double,allocator<double> >::iterator* pobj;
         vector<double,allocator<double> >::iterator xobj = ((vector<double,allocator<double> >::iterator*) G__getstructoffset())->operator--((int) G__int(libp->para[0]));
         pobj = new vector<double,allocator<double> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_157_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double,allocator<double> >::iterator::reference obj = ((const vector<double,allocator<double> >::iterator*) G__getstructoffset())->operator[](*(vector<double,allocator<double> >::iterator::difference_type*) G__Longref(&libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.d = (double) (obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_157_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double,allocator<double> >::iterator& obj = ((vector<double,allocator<double> >::iterator*) G__getstructoffset())->operator+=(*(vector<double,allocator<double> >::iterator::difference_type*) G__Longref(&libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_157_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double,allocator<double> >::iterator* pobj;
         const vector<double,allocator<double> >::iterator xobj = ((const vector<double,allocator<double> >::iterator*) G__getstructoffset())->operator+(*(vector<double,allocator<double> >::iterator::difference_type*) G__Longref(&libp->para[0]));
         pobj = new vector<double,allocator<double> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_157_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double,allocator<double> >::iterator& obj = ((vector<double,allocator<double> >::iterator*) G__getstructoffset())->operator-=(*(vector<double,allocator<double> >::iterator::difference_type*) G__Longref(&libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_157_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double,allocator<double> >::iterator* pobj;
         const vector<double,allocator<double> >::iterator xobj = ((const vector<double,allocator<double> >::iterator*) G__getstructoffset())->operator-(*(vector<double,allocator<double> >::iterator::difference_type*) G__Longref(&libp->para[0]));
         pobj = new vector<double,allocator<double> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_157_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double,allocator<double> >::iterator::pointer& obj = ((const vector<double,allocator<double> >::iterator*) G__getstructoffset())->base();
         result7->ref = (long) (&obj);
         G__letint(result7, 'D', (long)obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_157_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<double,allocator<double> >::iterator* pobj;
         vector<double,allocator<double> >::iterator xobj = ((vector<double,allocator<double> >::iterator*) G__getstructoffset())->operator=(*(vector<double,allocator<double> >::iterator*) libp->para[0].ref);
         pobj = new vector<double,allocator<double> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_157_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   vector<double,allocator<double> >::iterator* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new vector<double,allocator<double> >::iterator(*(vector<double,allocator<double> >::iterator*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<double,allocator<double> >::iterator G__TvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator;
static int G__G__MathCore_157_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<double,allocator<double> >::iterator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<double,allocator<double> >::iterator*) (soff+(sizeof(vector<double,allocator<double> >::iterator)*i)))->~G__TvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<double,allocator<double> >::iterator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<double,allocator<double> >::iterator*) (soff))->~G__TvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* reverse_iterator<vector<double,allocator<double> >::iterator> */
static int G__G__MathCore_158_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   reverse_iterator<vector<double,allocator<double> >::iterator>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new reverse_iterator<vector<double,allocator<double> >::iterator>[n];
     } else {
       p = new((void*) gvp) reverse_iterator<vector<double,allocator<double> >::iterator>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new reverse_iterator<vector<double,allocator<double> >::iterator>;
     } else {
       p = new((void*) gvp) reverse_iterator<vector<double,allocator<double> >::iterator>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_158_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double,allocator<double> >::iterator* pobj;
         const vector<double,allocator<double> >::iterator xobj = ((const reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset())->base();
         pobj = new vector<double,allocator<double> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_158_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const reverse_iterator<vector<double,allocator<double> >::iterator>::reference obj = ((const reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset())->operator*();
         result7->ref = (long) (&obj);
         result7->obj.d = (double) (obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_158_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((const reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_158_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const reverse_iterator<vector<double,allocator<double> >::iterator>& obj = ((reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset())->operator++();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_158_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         reverse_iterator<vector<double,allocator<double> >::iterator>* pobj;
         reverse_iterator<vector<double,allocator<double> >::iterator> xobj = ((reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset())->operator++((int) G__int(libp->para[0]));
         pobj = new reverse_iterator<vector<double,allocator<double> >::iterator>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_158_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const reverse_iterator<vector<double,allocator<double> >::iterator>& obj = ((reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset())->operator--();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_158_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         reverse_iterator<vector<double,allocator<double> >::iterator>* pobj;
         reverse_iterator<vector<double,allocator<double> >::iterator> xobj = ((reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset())->operator--((int) G__int(libp->para[0]));
         pobj = new reverse_iterator<vector<double,allocator<double> >::iterator>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_158_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const reverse_iterator<vector<double,allocator<double> >::iterator>* pobj;
         const reverse_iterator<vector<double,allocator<double> >::iterator> xobj = ((const reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset())->operator+((reverse_iterator<vector<double,allocator<double> >::iterator>::difference_type) G__int(libp->para[0]));
         pobj = new reverse_iterator<vector<double,allocator<double> >::iterator>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_158_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const reverse_iterator<vector<double,allocator<double> >::iterator>& obj = ((reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset())->operator+=((reverse_iterator<vector<double,allocator<double> >::iterator>::difference_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_158_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const reverse_iterator<vector<double,allocator<double> >::iterator>* pobj;
         const reverse_iterator<vector<double,allocator<double> >::iterator> xobj = ((const reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset())->operator-((reverse_iterator<vector<double,allocator<double> >::iterator>::difference_type) G__int(libp->para[0]));
         pobj = new reverse_iterator<vector<double,allocator<double> >::iterator>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_158_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const reverse_iterator<vector<double,allocator<double> >::iterator>& obj = ((reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset())->operator-=((reverse_iterator<vector<double,allocator<double> >::iterator>::difference_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_158_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const reverse_iterator<vector<double,allocator<double> >::iterator>::reference obj = ((const reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset())->operator[]((reverse_iterator<vector<double,allocator<double> >::iterator>::difference_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.d = (double) (obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_158_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   reverse_iterator<vector<double,allocator<double> >::iterator>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new reverse_iterator<vector<double,allocator<double> >::iterator>(*(reverse_iterator<vector<double,allocator<double> >::iterator>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef reverse_iterator<vector<double,allocator<double> >::iterator> G__Treverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR;
static int G__G__MathCore_158_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (reverse_iterator<vector<double,allocator<double> >::iterator>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((reverse_iterator<vector<double,allocator<double> >::iterator>*) (soff+(sizeof(reverse_iterator<vector<double,allocator<double> >::iterator>)*i)))->~G__Treverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (reverse_iterator<vector<double,allocator<double> >::iterator>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((reverse_iterator<vector<double,allocator<double> >::iterator>*) (soff))->~G__Treverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_158_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   reverse_iterator<vector<double,allocator<double> >::iterator>* dest = (reverse_iterator<vector<double,allocator<double> >::iterator>*) G__getstructoffset();
   const reverse_iterator<vector<double,allocator<double> >::iterator>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::VirtualIntegratorMultiDim */
static int G__G__MathCore_159_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::VirtualIntegratorMultiDim*) G__getstructoffset())->Integral((const double*) G__int(libp->para[0]), (const double*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_159_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::VirtualIntegratorMultiDim*) G__getstructoffset())->SetFunction(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::VirtualIntegratorMultiDim G__TROOTcLcLMathcLcLVirtualIntegratorMultiDim;
static int G__G__MathCore_159_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::VirtualIntegratorMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::VirtualIntegratorMultiDim*) (soff+(sizeof(ROOT::Math::VirtualIntegratorMultiDim)*i)))->~G__TROOTcLcLMathcLcLVirtualIntegratorMultiDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::VirtualIntegratorMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::VirtualIntegratorMultiDim*) (soff))->~G__TROOTcLcLMathcLcLVirtualIntegratorMultiDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_159_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::VirtualIntegratorMultiDim* dest = (ROOT::Math::VirtualIntegratorMultiDim*) G__getstructoffset();
   *dest = *(ROOT::Math::VirtualIntegratorMultiDim*) libp->para[0].ref;
   const ROOT::Math::VirtualIntegratorMultiDim& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IntegratorOneDim */
static int G__G__MathCore_160_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IntegratorOneDim* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 5:
     //m: 5
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorOneDim(
(ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (unsigned int) G__int(libp->para[3])
, (unsigned int) G__int(libp->para[4]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorOneDim(
(ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (unsigned int) G__int(libp->para[3])
, (unsigned int) G__int(libp->para[4]));
     }
     break;
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorOneDim(
(ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (unsigned int) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorOneDim(
(ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (unsigned int) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorOneDim(
(ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorOneDim(
(ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorOneDim((ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorOneDim((ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorOneDim((ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorOneDim((ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::IntegratorOneDim[n];
       } else {
         p = new((void*) gvp) ROOT::Math::IntegratorOneDim[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::IntegratorOneDim;
       } else {
         p = new((void*) gvp) ROOT::Math::IntegratorOneDim;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_160_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IntegratorOneDim* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 6:
     //m: 6
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorOneDim(
*(ROOT::Math::IGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (unsigned int) G__int(libp->para[4]), (int) G__int(libp->para[5]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorOneDim(
*(ROOT::Math::IGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (unsigned int) G__int(libp->para[4]), (int) G__int(libp->para[5]));
     }
     break;
   case 5:
     //m: 5
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorOneDim(
*(ROOT::Math::IGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (unsigned int) G__int(libp->para[4]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorOneDim(
*(ROOT::Math::IGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (unsigned int) G__int(libp->para[4]));
     }
     break;
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorOneDim(
*(ROOT::Math::IGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorOneDim(
*(ROOT::Math::IGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorOneDim(
*(ROOT::Math::IGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorOneDim(
*(ROOT::Math::IGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorOneDim(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorOneDim(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationOneDim::Type) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorOneDim(*(ROOT::Math::IGenFunction*) libp->para[0].ref);
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorOneDim(*(ROOT::Math::IGenFunction*) libp->para[0].ref);
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_160_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->SetFunction(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (bool) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->SetFunction(*(ROOT::Math::IGenFunction*) libp->para[0].ref);
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_160_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->SetFunction(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (unsigned int) G__int(libp->para[1])
, (const double*) G__int(libp->para[2]));
      G__setnull(result7);
      break;
   case 2:
      ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->SetFunction(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (unsigned int) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->SetFunction(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref);
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_160_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->Integral(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_160_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->Integral(*(ROOT::Math::IGenFunction*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_160_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->IntegralUp(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_160_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->IntegralLow(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_160_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->Integral(*(ROOT::Math::IGenFunction*) libp->para[0].ref, *(vector<double>*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_160_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->IntegralCauchy(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_160_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->Integral((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_160_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->Integral());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_160_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->IntegralUp((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_160_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->IntegralLow((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_160_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->operator()((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_160_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->Integral(*(vector<double>*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_160_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->IntegralCauchy((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_160_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IntegratorOneDim*) G__getstructoffset())->Result());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_160_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IntegratorOneDim*) G__getstructoffset())->Error());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_160_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::IntegratorOneDim*) G__getstructoffset())->Status());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_160_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->SetRelTolerance((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_160_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->SetAbsTolerance((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_160_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((ROOT::Math::IntegratorOneDim*) G__getstructoffset())->GetIntegrator());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IntegratorOneDim G__TROOTcLcLMathcLcLIntegratorOneDim;
static int G__G__MathCore_160_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IntegratorOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IntegratorOneDim*) (soff+(sizeof(ROOT::Math::IntegratorOneDim)*i)))->~G__TROOTcLcLMathcLcLIntegratorOneDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IntegratorOneDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IntegratorOneDim*) (soff))->~G__TROOTcLcLMathcLcLIntegratorOneDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::AdaptiveIntegratorMultiDim */
static int G__G__MathCore_161_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::AdaptiveIntegratorMultiDim* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::AdaptiveIntegratorMultiDim(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (unsigned int) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::AdaptiveIntegratorMultiDim(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (unsigned int) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::AdaptiveIntegratorMultiDim((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::AdaptiveIntegratorMultiDim((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::AdaptiveIntegratorMultiDim((double) G__double(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::AdaptiveIntegratorMultiDim((double) G__double(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::AdaptiveIntegratorMultiDim[n];
       } else {
         p = new((void*) gvp) ROOT::Math::AdaptiveIntegratorMultiDim[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::AdaptiveIntegratorMultiDim;
       } else {
         p = new((void*) gvp) ROOT::Math::AdaptiveIntegratorMultiDim;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_161_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::AdaptiveIntegratorMultiDim* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::AdaptiveIntegratorMultiDim(
*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (unsigned int) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) ROOT::Math::AdaptiveIntegratorMultiDim(
*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (unsigned int) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::AdaptiveIntegratorMultiDim(
*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::AdaptiveIntegratorMultiDim(
*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::AdaptiveIntegratorMultiDim(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::AdaptiveIntegratorMultiDim(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::AdaptiveIntegratorMultiDim(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref);
     } else {
       p = new((void*) gvp) ROOT::Math::AdaptiveIntegratorMultiDim(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref);
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_161_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::AdaptiveIntegratorMultiDim*) G__getstructoffset())->Integral(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (const double*) G__int(libp->para[1])
, (const double*) G__int(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_161_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::AdaptiveIntegratorMultiDim*) G__getstructoffset())->RelError());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_161_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::AdaptiveIntegratorMultiDim*) G__getstructoffset())->NEval());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_161_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::AdaptiveIntegratorMultiDim* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::AdaptiveIntegratorMultiDim(*(ROOT::Math::AdaptiveIntegratorMultiDim*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::AdaptiveIntegratorMultiDim G__TROOTcLcLMathcLcLAdaptiveIntegratorMultiDim;
static int G__G__MathCore_161_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::AdaptiveIntegratorMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::AdaptiveIntegratorMultiDim*) (soff+(sizeof(ROOT::Math::AdaptiveIntegratorMultiDim)*i)))->~G__TROOTcLcLMathcLcLAdaptiveIntegratorMultiDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::AdaptiveIntegratorMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::AdaptiveIntegratorMultiDim*) (soff))->~G__TROOTcLcLMathcLcLAdaptiveIntegratorMultiDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IntegratorMultiDim */
static int G__G__MathCore_162_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IntegratorMultiDim* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorMultiDim(
(ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (unsigned int) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorMultiDim(
(ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (unsigned int) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorMultiDim(
(ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorMultiDim(
(ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorMultiDim((ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorMultiDim((ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]), (double) G__double(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorMultiDim((ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorMultiDim((ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::IntegratorMultiDim[n];
       } else {
         p = new((void*) gvp) ROOT::Math::IntegratorMultiDim[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::IntegratorMultiDim;
       } else {
         p = new((void*) gvp) ROOT::Math::IntegratorMultiDim;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDim));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_162_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IntegratorMultiDim* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 5:
     //m: 5
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorMultiDim(
*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (unsigned int) G__int(libp->para[4]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorMultiDim(
*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (unsigned int) G__int(libp->para[4]));
     }
     break;
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorMultiDim(
*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorMultiDim(
*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorMultiDim(
*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorMultiDim(
*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[1])
, (double) G__double(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorMultiDim(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorMultiDim(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (ROOT::Math::IntegrationMultiDim::Type) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::IntegratorMultiDim(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref);
     } else {
       p = new((void*) gvp) ROOT::Math::IntegratorMultiDim(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref);
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDim));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_162_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorMultiDim*) G__getstructoffset())->Integral((const double*) G__int(libp->para[0]), (const double*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_162_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::IntegratorMultiDim*) G__getstructoffset())->Integral(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref, (const double*) G__int(libp->para[1])
, (const double*) G__int(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_162_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IntegratorMultiDim*) G__getstructoffset())->SetFunction(*(ROOT::Math::IMultiGenFunction*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_162_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IntegratorMultiDim*) G__getstructoffset())->Result());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_162_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IntegratorMultiDim*) G__getstructoffset())->Error());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_162_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::IntegratorMultiDim*) G__getstructoffset())->Status());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_162_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IntegratorMultiDim*) G__getstructoffset())->SetRelTolerance((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_162_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::IntegratorMultiDim*) G__getstructoffset())->SetAbsTolerance((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_162_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((ROOT::Math::IntegratorMultiDim*) G__getstructoffset())->GetIntegrator());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IntegratorMultiDim G__TROOTcLcLMathcLcLIntegratorMultiDim;
static int G__G__MathCore_162_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IntegratorMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IntegratorMultiDim*) (soff+(sizeof(ROOT::Math::IntegratorMultiDim)*i)))->~G__TROOTcLcLMathcLcLIntegratorMultiDim();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IntegratorMultiDim*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IntegratorMultiDim*) (soff))->~G__TROOTcLcLMathcLcLIntegratorMultiDim();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::Factory */
static int G__G__MathCore_163_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 85, (long) ROOT::Math::Factory::CreateMinimizer(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref));
      break;
   case 1:
      G__letint(result7, 85, (long) ROOT::Math::Factory::CreateMinimizer(*(string*) libp->para[0].ref));
      break;
   case 0:
      G__letint(result7, 85, (long) ROOT::Math::Factory::CreateMinimizer());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic default constructor
static int G__G__MathCore_163_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Factory *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Factory[n];
     } else {
       p = new((void*) gvp) ROOT::Math::Factory[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::Factory;
     } else {
       p = new((void*) gvp) ROOT::Math::Factory;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFactory));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_163_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::Factory* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::Factory(*(ROOT::Math::Factory*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFactory));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::Factory G__TROOTcLcLMathcLcLFactory;
static int G__G__MathCore_163_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::Factory*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::Factory*) (soff+(sizeof(ROOT::Math::Factory)*i)))->~G__TROOTcLcLMathcLcLFactory();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::Factory*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::Factory*) (soff))->~G__TROOTcLcLMathcLcLFactory();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_163_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::Factory* dest = (ROOT::Math::Factory*) G__getstructoffset();
   const ROOT::Math::Factory& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim> */
static int G__G__MathCore_164_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) G__getstructoffset())->DataElement((const double*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])
, (double*) G__int(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) G__getstructoffset())->DataElement((const double*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_164_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) G__getstructoffset())->NPoints());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_164_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) G__getstructoffset())->Type());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_164_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) G__getstructoffset())->NCalls());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_164_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) G__getstructoffset())->UpdateNCalls();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_164_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) G__getstructoffset())->ResetNCalls();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim> G__TROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR;
static int G__G__MathCore_164_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) (soff+(sizeof(ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>)*i)))->~G__TROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) (soff))->~G__TROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_164_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>* dest = (ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) G__getstructoffset();
   *dest = *(ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*) libp->para[0].ref;
   const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim> */
static int G__G__MathCore_166_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) G__getstructoffset())->DataElement((const double*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])
, (double*) G__int(libp->para[2])));
      break;
   case 2:
      G__letdouble(result7, 100, (double) ((const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) G__getstructoffset())->DataElement((const double*) G__int(libp->para[0]), (unsigned int) G__int(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_166_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) G__getstructoffset())->NPoints());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_166_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) G__getstructoffset())->Type());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_166_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) G__getstructoffset())->NCalls());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_166_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) G__getstructoffset())->UpdateNCalls();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_166_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) G__getstructoffset())->ResetNCalls();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim> G__TROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR;
static int G__G__MathCore_166_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) (soff+(sizeof(ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>)*i)))->~G__TROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) (soff))->~G__TROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_166_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>* dest = (ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) G__getstructoffset();
   *dest = *(ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*) libp->para[0].ref;
   const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GaussIntegrator */
static int G__G__MathCore_168_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GaussIntegrator* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GaussIntegrator[n];
     } else {
       p = new((void*) gvp) ROOT::Math::GaussIntegrator[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GaussIntegrator;
     } else {
       p = new((void*) gvp) ROOT::Math::GaussIntegrator;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_168_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::GaussIntegrator*) G__getstructoffset())->AbsValue((bool) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_168_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::GaussIntegrator* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::GaussIntegrator(*(ROOT::Math::GaussIntegrator*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GaussIntegrator G__TROOTcLcLMathcLcLGaussIntegrator;
static int G__G__MathCore_168_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GaussIntegrator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GaussIntegrator*) (soff+(sizeof(ROOT::Math::GaussIntegrator)*i)))->~G__TROOTcLcLMathcLcLGaussIntegrator();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GaussIntegrator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GaussIntegrator*) (soff))->~G__TROOTcLcLMathcLcLGaussIntegrator();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::GaussLegendreIntegrator */
static int G__G__MathCore_169_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::GaussLegendreIntegrator* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GaussLegendreIntegrator((int) G__int(libp->para[0]), (double) G__double(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::GaussLegendreIntegrator((int) G__int(libp->para[0]), (double) G__double(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::GaussLegendreIntegrator((int) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::GaussLegendreIntegrator((int) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::GaussLegendreIntegrator[n];
       } else {
         p = new((void*) gvp) ROOT::Math::GaussLegendreIntegrator[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::GaussLegendreIntegrator;
       } else {
         p = new((void*) gvp) ROOT::Math::GaussLegendreIntegrator;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_169_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::GaussLegendreIntegrator*) G__getstructoffset())->SetNumberPoints((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_169_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::GaussLegendreIntegrator*) G__getstructoffset())->GetWeightVectors((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_169_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::GaussLegendreIntegrator* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::GaussLegendreIntegrator(*(ROOT::Math::GaussLegendreIntegrator*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::GaussLegendreIntegrator G__TROOTcLcLMathcLcLGaussLegendreIntegrator;
static int G__G__MathCore_169_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::GaussLegendreIntegrator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::GaussLegendreIntegrator*) (soff+(sizeof(ROOT::Math::GaussLegendreIntegrator)*i)))->~G__TROOTcLcLMathcLcLGaussLegendreIntegrator();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::GaussLegendreIntegrator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::GaussLegendreIntegrator*) (soff))->~G__TROOTcLcLMathcLcLGaussLegendreIntegrator();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::IRootFinderMethod */
static int G__G__MathCore_170_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((ROOT::Math::IRootFinderMethod*) G__getstructoffset())->SetFunction(*(ROOT::Math::IGradFunction*) libp->para[0].ref, (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((ROOT::Math::IRootFinderMethod*) G__getstructoffset())->SetFunction(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::IRootFinderMethod*) G__getstructoffset())->Root());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letint(result7, 105, (long) ((ROOT::Math::IRootFinderMethod*) G__getstructoffset())->Solve((int) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letint(result7, 105, (long) ((ROOT::Math::IRootFinderMethod*) G__getstructoffset())->Solve((int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 105, (long) ((ROOT::Math::IRootFinderMethod*) G__getstructoffset())->Solve((int) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 105, (long) ((ROOT::Math::IRootFinderMethod*) G__getstructoffset())->Solve());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const ROOT::Math::IRootFinderMethod*) G__getstructoffset())->Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((ROOT::Math::IRootFinderMethod*) G__getstructoffset())->Iterate());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_170_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::IRootFinderMethod*) G__getstructoffset())->Iterations());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::IRootFinderMethod G__TROOTcLcLMathcLcLIRootFinderMethod;
static int G__G__MathCore_170_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::IRootFinderMethod*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::IRootFinderMethod*) (soff+(sizeof(ROOT::Math::IRootFinderMethod)*i)))->~G__TROOTcLcLMathcLcLIRootFinderMethod();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::IRootFinderMethod*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::IRootFinderMethod*) (soff))->~G__TROOTcLcLMathcLcLIRootFinderMethod();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__MathCore_170_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::IRootFinderMethod* dest = (ROOT::Math::IRootFinderMethod*) G__getstructoffset();
   *dest = *(ROOT::Math::IRootFinderMethod*) libp->para[0].ref;
   const ROOT::Math::IRootFinderMethod& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::RootFinder */
static int G__G__MathCore_171_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::RootFinder* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::RootFinder((ROOT::Math::RootFinder::EType) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::RootFinder((ROOT::Math::RootFinder::EType) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::RootFinder[n];
       } else {
         p = new((void*) gvp) ROOT::Math::RootFinder[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::RootFinder;
       } else {
         p = new((void*) gvp) ROOT::Math::RootFinder;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFinder));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_171_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 105, (long) ((ROOT::Math::RootFinder*) G__getstructoffset())->SetMethod((ROOT::Math::RootFinder::EType) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 105, (long) ((ROOT::Math::RootFinder*) G__getstructoffset())->SetMethod());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_171_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((ROOT::Math::RootFinder*) G__getstructoffset())->SetFunction(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_171_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((ROOT::Math::RootFinder*) G__getstructoffset())->SetFunction(*(ROOT::Math::IGradFunction*) libp->para[0].ref, (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_171_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letint(result7, 105, (long) ((ROOT::Math::RootFinder*) G__getstructoffset())->Solve((int) G__int(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
      break;
   case 2:
      G__letint(result7, 105, (long) ((ROOT::Math::RootFinder*) G__getstructoffset())->Solve((int) G__int(libp->para[0]), (double) G__double(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 105, (long) ((ROOT::Math::RootFinder*) G__getstructoffset())->Solve((int) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 105, (long) ((ROOT::Math::RootFinder*) G__getstructoffset())->Solve());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_171_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const ROOT::Math::RootFinder*) G__getstructoffset())->Iterations());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_171_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((ROOT::Math::RootFinder*) G__getstructoffset())->Iterate());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_171_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::RootFinder*) G__getstructoffset())->Root());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_171_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const ROOT::Math::RootFinder*) G__getstructoffset())->Name());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::RootFinder G__TROOTcLcLMathcLcLRootFinder;
static int G__G__MathCore_171_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::RootFinder*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::RootFinder*) (soff+(sizeof(ROOT::Math::RootFinder)*i)))->~G__TROOTcLcLMathcLcLRootFinder();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::RootFinder*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::RootFinder*) (soff))->~G__TROOTcLcLMathcLcLRootFinder();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::RichardsonDerivator */
static int G__G__MathCore_174_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::RichardsonDerivator* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::RichardsonDerivator((double) G__double(libp->para[0]));
     } else {
       p = new((void*) gvp) ROOT::Math::RichardsonDerivator((double) G__double(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::RichardsonDerivator[n];
       } else {
         p = new((void*) gvp) ROOT::Math::RichardsonDerivator[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new ROOT::Math::RichardsonDerivator;
       } else {
         p = new((void*) gvp) ROOT::Math::RichardsonDerivator;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRichardsonDerivator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_174_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::RichardsonDerivator* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::RichardsonDerivator(
*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (bool) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) ROOT::Math::RichardsonDerivator(
*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (bool) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::RichardsonDerivator(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1]));
     } else {
       p = new((void*) gvp) ROOT::Math::RichardsonDerivator(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::RichardsonDerivator(*(ROOT::Math::IGenFunction*) libp->para[0].ref);
     } else {
       p = new((void*) gvp) ROOT::Math::RichardsonDerivator(*(ROOT::Math::IGenFunction*) libp->para[0].ref);
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRichardsonDerivator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_174_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::RichardsonDerivator* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::RichardsonDerivator(*(ROOT::Math::RichardsonDerivator*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ROOT::Math::RichardsonDerivator(*(ROOT::Math::RichardsonDerivator*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRichardsonDerivator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_174_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::RichardsonDerivator& obj = ((ROOT::Math::RichardsonDerivator*) G__getstructoffset())->operator=(*(ROOT::Math::RichardsonDerivator*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_174_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const ROOT::Math::RichardsonDerivator*) G__getstructoffset())->Error());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_174_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::RichardsonDerivator*) G__getstructoffset())->Derivative1((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_174_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::RichardsonDerivator*) G__getstructoffset())->operator()((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_174_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::RichardsonDerivator*) G__getstructoffset())->Derivative1(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_174_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::RichardsonDerivator*) G__getstructoffset())->Derivative2((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_174_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::RichardsonDerivator*) G__getstructoffset())->Derivative2(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_174_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::RichardsonDerivator*) G__getstructoffset())->Derivative3((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_174_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((ROOT::Math::RichardsonDerivator*) G__getstructoffset())->Derivative3(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_174_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::RichardsonDerivator*) G__getstructoffset())->SetFunction(*(ROOT::Math::IGenFunction*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_174_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::RichardsonDerivator*) G__getstructoffset())->SetStepSize((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::RichardsonDerivator G__TROOTcLcLMathcLcLRichardsonDerivator;
static int G__G__MathCore_174_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::RichardsonDerivator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::RichardsonDerivator*) (soff+(sizeof(ROOT::Math::RichardsonDerivator)*i)))->~G__TROOTcLcLMathcLcLRichardsonDerivator();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::RichardsonDerivator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::RichardsonDerivator*) (soff))->~G__TROOTcLcLMathcLcLRichardsonDerivator();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::BrentMinimizer1D */
static int G__G__MathCore_176_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::BrentMinimizer1D* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::BrentMinimizer1D[n];
     } else {
       p = new((void*) gvp) ROOT::Math::BrentMinimizer1D[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::BrentMinimizer1D;
     } else {
       p = new((void*) gvp) ROOT::Math::BrentMinimizer1D;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentMinimizer1D));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore_176_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((ROOT::Math::BrentMinimizer1D*) G__getstructoffset())->SetFunction(*(ROOT::Math::IGenFunction*) libp->para[0].ref, (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_176_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::BrentMinimizer1D* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::BrentMinimizer1D(*(ROOT::Math::BrentMinimizer1D*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentMinimizer1D));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::BrentMinimizer1D G__TROOTcLcLMathcLcLBrentMinimizer1D;
static int G__G__MathCore_176_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::BrentMinimizer1D*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::BrentMinimizer1D*) (soff+(sizeof(ROOT::Math::BrentMinimizer1D)*i)))->~G__TROOTcLcLMathcLcLBrentMinimizer1D();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::BrentMinimizer1D*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::BrentMinimizer1D*) (soff))->~G__TROOTcLcLMathcLcLBrentMinimizer1D();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::BrentRootFinder */
static int G__G__MathCore_177_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::BrentRootFinder* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::BrentRootFinder[n];
     } else {
       p = new((void*) gvp) ROOT::Math::BrentRootFinder[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::BrentRootFinder;
     } else {
       p = new((void*) gvp) ROOT::Math::BrentRootFinder;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentRootFinder));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__MathCore_177_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::BrentRootFinder* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::BrentRootFinder(*(ROOT::Math::BrentRootFinder*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentRootFinder));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::BrentRootFinder G__TROOTcLcLMathcLcLBrentRootFinder;
static int G__G__MathCore_177_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::BrentRootFinder*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::BrentRootFinder*) (soff+(sizeof(ROOT::Math::BrentRootFinder)*i)))->~G__TROOTcLcLMathcLcLBrentRootFinder();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::BrentRootFinder*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::BrentRootFinder*) (soff))->~G__TROOTcLcLMathcLcLBrentRootFinder();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */
static int G__G__MathCore__0_373(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator==(*(vector<double,allocator<double> >::iterator*) libp->para[0].ref, *(vector<double,allocator<double> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_374(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator!=(*(vector<double,allocator<double> >::iterator*) libp->para[0].ref, *(vector<double,allocator<double> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_375(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator<(*(vector<double,allocator<double> >::iterator*) libp->para[0].ref, *(vector<double,allocator<double> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_376(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator>(*(vector<double,allocator<double> >::iterator*) libp->para[0].ref, *(vector<double,allocator<double> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_377(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator<=(*(vector<double,allocator<double> >::iterator*) libp->para[0].ref, *(vector<double,allocator<double> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_378(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator>=(*(vector<double,allocator<double> >::iterator*) libp->para[0].ref, *(vector<double,allocator<double> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_379(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 108, (long) operator-(*(vector<double,allocator<double> >::iterator*) libp->para[0].ref, *(vector<double,allocator<double> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_380(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<double,allocator<double> >::iterator* pobj;
         const vector<double,allocator<double> >::iterator xobj = operator+((const vector<double,allocator<double> >::iterator::difference_type) G__int(libp->para[0]), *(vector<double,allocator<double> >::iterator*) libp->para[1].ref);
         pobj = new vector<double,allocator<double> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_381(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator==(*(vector<double,allocator<double> >::reverse_iterator*) libp->para[0].ref, *(vector<double,allocator<double> >::reverse_iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_382(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator!=(*(vector<double,allocator<double> >::reverse_iterator*) libp->para[0].ref, *(vector<double,allocator<double> >::reverse_iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_383(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator==(*(vector<double,allocator<double> >*) libp->para[0].ref, *(vector<double,allocator<double> >*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_384(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator<(*(vector<double,allocator<double> >*) libp->para[0].ref, *(vector<double,allocator<double> >*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_385(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator!=(*(vector<double,allocator<double> >*) libp->para[0].ref, *(vector<double,allocator<double> >*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_386(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator>(*(vector<double,allocator<double> >*) libp->para[0].ref, *(vector<double,allocator<double> >*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_387(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator>=(*(vector<double,allocator<double> >*) libp->para[0].ref, *(vector<double,allocator<double> >*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__MathCore__0_388(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator<=(*(vector<double,allocator<double> >*) libp->para[0].ref, *(vector<double,allocator<double> >*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}


/*********************************************************
* Member function Stub
*********************************************************/

/* ROOT */

/* TRandom */

/* TRandom1 */

/* TRandom2 */

/* TRandom3 */

/* TVirtualFitter */

/* TKDTree<int,double> */

/* TKDTree<int,float> */

/* ROOT::Math */

/* ROOT::Math::IBaseFunctionOneDim */

/* ROOT::Math::IGradientFunctionOneDim */

/* ROOT::Math::IBaseFunctionMultiDim */

/* ROOT::Math::IGradientFunctionMultiDim */

/* ROOT::Math::IGradientMultiDim */

/* ROOT::Math::IGradientOneDim */

/* ROOT::Math::IParametricFunctionOneDim */

/* ROOT::Math::IParametricGradFunctionOneDim */

/* ROOT::Math::IParametricFunctionMultiDim */

/* ROOT::Math::IParametricGradFunctionMultiDim */

/* ROOT::Math::IBaseParam */

/* ROOT::Math::ParamFunctor */

/* ROOT::Math::Functor */

/* ROOT::Math::Functor1D */

/* ROOT::Math::GradFunctor */

/* ROOT::Math::GradFunctor1D */

/* ROOT::Math::Minimizer */

/* ROOT::Math::MinimizerOptions */

/* ROOT::Math::IntegrationOneDim */

/* ROOT::Math::IntegrationMultiDim */

/* ROOT::Math::VirtualIntegrator */

/* ROOT::Math::VirtualIntegratorOneDim */

/* vector<double,allocator<double> > */

/* vector<double,allocator<double> >::iterator */

/* reverse_iterator<vector<double,allocator<double> >::iterator> */

/* ROOT::Math::VirtualIntegratorMultiDim */

/* ROOT::Math::IntegratorOneDim */

/* ROOT::Math::AdaptiveIntegratorMultiDim */

/* ROOT::Math::IntegratorMultiDim */

/* ROOT::Math::Factory */

/* ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim> */

/* ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim> */

/* ROOT::Math::GaussIntegrator */

/* ROOT::Math::GaussLegendreIntegrator */

/* ROOT::Math::IRootFinderMethod */

/* ROOT::Math::RootFinder */

/* ROOT::Math::RichardsonDerivator */

/* ROOT::Math::BrentMinimizer1D */

/* ROOT::Math::BrentRootFinder */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfuncG__MathCore {
 public:
  G__Sizep2memfuncG__MathCore(): p(&G__Sizep2memfuncG__MathCore::sizep2memfunc) {}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfuncG__MathCore::*p)();
};

size_t G__get_sizep2memfuncG__MathCore()
{
  G__Sizep2memfuncG__MathCore a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */
static long G__2vbo_ROOTcLcLMathcLcLIGradientFunctionOneDim_ROOTcLcLMathcLcLIBaseFunctionOneDim_0(long pobject) {
  ROOT::Math::IGradientFunctionOneDim *G__Lderived=(ROOT::Math::IGradientFunctionOneDim*)pobject;
  ROOT::Math::IBaseFunctionOneDim *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_ROOTcLcLMathcLcLIGradientFunctionMultiDim_ROOTcLcLMathcLcLIBaseFunctionMultiDim_0(long pobject) {
  ROOT::Math::IGradientFunctionMultiDim *G__Lderived=(ROOT::Math::IGradientFunctionMultiDim*)pobject;
  ROOT::Math::IBaseFunctionMultiDim *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_ROOTcLcLMathcLcLIParametricFunctionOneDim_ROOTcLcLMathcLcLIBaseFunctionOneDim_0(long pobject) {
  ROOT::Math::IParametricFunctionOneDim *G__Lderived=(ROOT::Math::IParametricFunctionOneDim*)pobject;
  ROOT::Math::IBaseFunctionOneDim *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_ROOTcLcLMathcLcLIParametricGradFunctionOneDim_ROOTcLcLMathcLcLIBaseFunctionOneDim_1(long pobject) {
  ROOT::Math::IParametricGradFunctionOneDim *G__Lderived=(ROOT::Math::IParametricGradFunctionOneDim*)pobject;
  ROOT::Math::IBaseFunctionOneDim *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_ROOTcLcLMathcLcLIParametricFunctionMultiDim_ROOTcLcLMathcLcLIBaseFunctionMultiDim_0(long pobject) {
  ROOT::Math::IParametricFunctionMultiDim *G__Lderived=(ROOT::Math::IParametricFunctionMultiDim*)pobject;
  ROOT::Math::IBaseFunctionMultiDim *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim_ROOTcLcLMathcLcLIBaseFunctionMultiDim_1(long pobject) {
  ROOT::Math::IParametricGradFunctionMultiDim *G__Lderived=(ROOT::Math::IParametricGradFunctionMultiDim*)pobject;
  ROOT::Math::IBaseFunctionMultiDim *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_ROOTcLcLMathcLcLGradFunctor_ROOTcLcLMathcLcLIBaseFunctionMultiDim_1(long pobject) {
  ROOT::Math::GradFunctor *G__Lderived=(ROOT::Math::GradFunctor*)pobject;
  ROOT::Math::IBaseFunctionMultiDim *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_ROOTcLcLMathcLcLGradFunctor1D_ROOTcLcLMathcLcLIBaseFunctionOneDim_1(long pobject) {
  ROOT::Math::GradFunctor1D *G__Lderived=(ROOT::Math::GradFunctor1D*)pobject;
  ROOT::Math::IBaseFunctionOneDim *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}

static long G__2vbo_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR_ROOTcLcLMathcLcLIBaseFunctionMultiDim_1(long pobject) {
  ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim> *G__Lderived=(ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*)pobject;
  ROOT::Math::IBaseFunctionMultiDim *G__Lbase=G__Lderived;
  return((long)G__Lbase-(long)G__Lderived);
}


/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritanceG__MathCore() {

   /* Setting up class inheritance */
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom))) {
     TRandom *G__Lderived;
     G__Lderived=(TRandom*)0x1000;
     {
       TNamed *G__Lpbase=(TNamed*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom),G__get_linked_tagnum(&G__G__MathCoreLN_TNamed),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom),G__get_linked_tagnum(&G__G__MathCoreLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1))) {
     TRandom1 *G__Lderived;
     G__Lderived=(TRandom1*)0x1000;
     {
       TRandom *G__Lpbase=(TRandom*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1),G__get_linked_tagnum(&G__G__MathCoreLN_TRandom),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TNamed *G__Lpbase=(TNamed*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1),G__get_linked_tagnum(&G__G__MathCoreLN_TNamed),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1),G__get_linked_tagnum(&G__G__MathCoreLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom2))) {
     TRandom2 *G__Lderived;
     G__Lderived=(TRandom2*)0x1000;
     {
       TRandom *G__Lpbase=(TRandom*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom2),G__get_linked_tagnum(&G__G__MathCoreLN_TRandom),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TNamed *G__Lpbase=(TNamed*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom2),G__get_linked_tagnum(&G__G__MathCoreLN_TNamed),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom2),G__get_linked_tagnum(&G__G__MathCoreLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom3))) {
     TRandom3 *G__Lderived;
     G__Lderived=(TRandom3*)0x1000;
     {
       TRandom *G__Lpbase=(TRandom*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom3),G__get_linked_tagnum(&G__G__MathCoreLN_TRandom),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TNamed *G__Lpbase=(TNamed*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom3),G__get_linked_tagnum(&G__G__MathCoreLN_TNamed),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom3),G__get_linked_tagnum(&G__G__MathCoreLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_TVirtualFitter))) {
     TVirtualFitter *G__Lderived;
     G__Lderived=(TVirtualFitter*)0x1000;
     {
       TNamed *G__Lpbase=(TNamed*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TVirtualFitter),G__get_linked_tagnum(&G__G__MathCoreLN_TNamed),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TVirtualFitter),G__get_linked_tagnum(&G__G__MathCoreLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR))) {
     TKDTree<int,double> *G__Lderived;
     G__Lderived=(TKDTree<int,double>*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR),G__get_linked_tagnum(&G__G__MathCoreLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR))) {
     TKDTree<int,float> *G__Lderived;
     G__Lderived=(TKDTree<int,float>*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR),G__get_linked_tagnum(&G__G__MathCoreLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim))) {
     ROOT::Math::IGradientFunctionOneDim *G__Lderived;
     G__Lderived=(ROOT::Math::IGradientFunctionOneDim*)0x1000;
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),(long)G__2vbo_ROOTcLcLMathcLcLIGradientFunctionOneDim_ROOTcLcLMathcLcLIBaseFunctionOneDim_0,1,3);
     }
     {
       ROOT::Math::IGradientOneDim *G__Lpbase=(ROOT::Math::IGradientOneDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientOneDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim))) {
     ROOT::Math::IGradientFunctionMultiDim *G__Lderived;
     G__Lderived=(ROOT::Math::IGradientFunctionMultiDim*)0x1000;
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),(long)G__2vbo_ROOTcLcLMathcLcLIGradientFunctionMultiDim_ROOTcLcLMathcLcLIBaseFunctionMultiDim_0,1,3);
     }
     {
       ROOT::Math::IGradientMultiDim *G__Lpbase=(ROOT::Math::IGradientMultiDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientMultiDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim))) {
     ROOT::Math::IParametricFunctionOneDim *G__Lderived;
     G__Lderived=(ROOT::Math::IParametricFunctionOneDim*)0x1000;
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),(long)G__2vbo_ROOTcLcLMathcLcLIParametricFunctionOneDim_ROOTcLcLMathcLcLIBaseFunctionOneDim_0,1,3);
     }
     {
       ROOT::Math::IBaseParam *G__Lpbase=(ROOT::Math::IBaseParam*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseParam),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim))) {
     ROOT::Math::IParametricGradFunctionOneDim *G__Lderived;
     G__Lderived=(ROOT::Math::IParametricGradFunctionOneDim*)0x1000;
     {
       ROOT::Math::IParametricFunctionOneDim *G__Lpbase=(ROOT::Math::IParametricFunctionOneDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),(long)G__2vbo_ROOTcLcLMathcLcLIParametricGradFunctionOneDim_ROOTcLcLMathcLcLIBaseFunctionOneDim_1,1,2);
     }
     {
       ROOT::Math::IBaseParam *G__Lpbase=(ROOT::Math::IBaseParam*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseParam),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim))) {
     ROOT::Math::IParametricFunctionMultiDim *G__Lderived;
     G__Lderived=(ROOT::Math::IParametricFunctionMultiDim*)0x1000;
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),(long)G__2vbo_ROOTcLcLMathcLcLIParametricFunctionMultiDim_ROOTcLcLMathcLcLIBaseFunctionMultiDim_0,1,3);
     }
     {
       ROOT::Math::IBaseParam *G__Lpbase=(ROOT::Math::IBaseParam*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseParam),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim))) {
     ROOT::Math::IParametricGradFunctionMultiDim *G__Lderived;
     G__Lderived=(ROOT::Math::IParametricGradFunctionMultiDim*)0x1000;
     {
       ROOT::Math::IParametricFunctionMultiDim *G__Lpbase=(ROOT::Math::IParametricFunctionMultiDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),(long)G__2vbo_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim_ROOTcLcLMathcLcLIBaseFunctionMultiDim_1,1,2);
     }
     {
       ROOT::Math::IBaseParam *G__Lpbase=(ROOT::Math::IBaseParam*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseParam),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor))) {
     ROOT::Math::Functor *G__Lderived;
     G__Lderived=(ROOT::Math::Functor*)0x1000;
     {
       ROOT::Math::IBaseFunctionMultiDim *G__Lpbase=(ROOT::Math::IBaseFunctionMultiDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D))) {
     ROOT::Math::Functor1D *G__Lderived;
     G__Lderived=(ROOT::Math::Functor1D*)0x1000;
     {
       ROOT::Math::IBaseFunctionOneDim *G__Lpbase=(ROOT::Math::IBaseFunctionOneDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor))) {
     ROOT::Math::GradFunctor *G__Lderived;
     G__Lderived=(ROOT::Math::GradFunctor*)0x1000;
     {
       ROOT::Math::IGradientFunctionMultiDim *G__Lpbase=(ROOT::Math::IGradientFunctionMultiDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),(long)G__2vbo_ROOTcLcLMathcLcLGradFunctor_ROOTcLcLMathcLcLIBaseFunctionMultiDim_1,1,2);
     }
     {
       ROOT::Math::IGradientMultiDim *G__Lpbase=(ROOT::Math::IGradientMultiDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientMultiDim),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D))) {
     ROOT::Math::GradFunctor1D *G__Lderived;
     G__Lderived=(ROOT::Math::GradFunctor1D*)0x1000;
     {
       ROOT::Math::IGradientFunctionOneDim *G__Lpbase=(ROOT::Math::IGradientFunctionOneDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),(long)G__2vbo_ROOTcLcLMathcLcLGradFunctor1D_ROOTcLcLMathcLcLIBaseFunctionOneDim_1,1,2);
     }
     {
       ROOT::Math::IGradientOneDim *G__Lpbase=(ROOT::Math::IGradientOneDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientOneDim),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim))) {
     ROOT::Math::VirtualIntegratorOneDim *G__Lderived;
     G__Lderived=(ROOT::Math::VirtualIntegratorOneDim*)0x1000;
     {
       ROOT::Math::VirtualIntegrator *G__Lpbase=(ROOT::Math::VirtualIntegrator*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegrator),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim))) {
     ROOT::Math::VirtualIntegratorMultiDim *G__Lderived;
     G__Lderived=(ROOT::Math::VirtualIntegratorMultiDim*)0x1000;
     {
       ROOT::Math::VirtualIntegrator *G__Lpbase=(ROOT::Math::VirtualIntegrator*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegrator),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim))) {
     ROOT::Math::AdaptiveIntegratorMultiDim *G__Lderived;
     G__Lderived=(ROOT::Math::AdaptiveIntegratorMultiDim*)0x1000;
     {
       ROOT::Math::VirtualIntegratorMultiDim *G__Lpbase=(ROOT::Math::VirtualIntegratorMultiDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       ROOT::Math::VirtualIntegrator *G__Lpbase=(ROOT::Math::VirtualIntegrator*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegrator),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR))) {
     ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim> *G__Lderived;
     G__Lderived=(ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*)0x1000;
     {
       ROOT::Math::IBaseFunctionMultiDim *G__Lpbase=(ROOT::Math::IBaseFunctionMultiDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR))) {
     ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim> *G__Lderived;
     G__Lderived=(ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*)0x1000;
     {
       ROOT::Math::IGradientFunctionMultiDim *G__Lpbase=(ROOT::Math::IGradientFunctionMultiDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),(long)G__2vbo_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR_ROOTcLcLMathcLcLIBaseFunctionMultiDim_1,1,2);
     }
     {
       ROOT::Math::IGradientMultiDim *G__Lpbase=(ROOT::Math::IGradientMultiDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientMultiDim),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator))) {
     ROOT::Math::GaussIntegrator *G__Lderived;
     G__Lderived=(ROOT::Math::GaussIntegrator*)0x1000;
     {
       ROOT::Math::VirtualIntegratorOneDim *G__Lpbase=(ROOT::Math::VirtualIntegratorOneDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       ROOT::Math::VirtualIntegrator *G__Lpbase=(ROOT::Math::VirtualIntegrator*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegrator),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator))) {
     ROOT::Math::GaussLegendreIntegrator *G__Lderived;
     G__Lderived=(ROOT::Math::GaussLegendreIntegrator*)0x1000;
     {
       ROOT::Math::VirtualIntegratorOneDim *G__Lpbase=(ROOT::Math::VirtualIntegratorOneDim*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       ROOT::Math::VirtualIntegrator *G__Lpbase=(ROOT::Math::VirtualIntegrator*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegrator),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentMinimizer1D))) {
     ROOT::Math::BrentMinimizer1D *G__Lderived;
     G__Lderived=(ROOT::Math::BrentMinimizer1D*)0x1000;
     {
       ROOT::Math::IMinimizer1D *G__Lpbase=(ROOT::Math::IMinimizer1D*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentMinimizer1D),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIMinimizer1D),(long)G__Lpbase-(long)G__Lderived,4,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentRootFinder))) {
     ROOT::Math::BrentRootFinder *G__Lderived;
     G__Lderived=(ROOT::Math::BrentRootFinder*)0x1000;
     {
       ROOT::Math::IRootFinderMethod *G__Lpbase=(ROOT::Math::IRootFinderMethod*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentRootFinder),G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIRootFinderMethod),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetableG__MathCore() {

   /* Setting up typedef entry */
   G__search_typename2("UChar_t",98,-1,0,-1);
   G__setnewtype(-1,"Unsigned Character 1 byte (unsigned char)",0);
   G__search_typename2("Short_t",115,-1,0,-1);
   G__setnewtype(-1,"Signed Short integer 2 bytes (short)",0);
   G__search_typename2("Int_t",105,-1,0,-1);
   G__setnewtype(-1,"Signed integer 4 bytes (int)",0);
   G__search_typename2("UInt_t",104,-1,0,-1);
   G__setnewtype(-1,"Unsigned integer 4 bytes (unsigned int)",0);
   G__search_typename2("Float_t",102,-1,0,-1);
   G__setnewtype(-1,"Float 4 bytes (float)",0);
   G__search_typename2("Double_t",100,-1,0,-1);
   G__setnewtype(-1,"Double 8 bytes",0);
   G__search_typename2("Bool_t",103,-1,0,-1);
   G__setnewtype(-1,"Boolean (0=false, 1=true) (bool)",0);
   G__search_typename2("Version_t",115,-1,0,-1);
   G__setnewtype(-1,"Class version identifier (short)",0);
   G__search_typename2("VoidFuncPtr_t",89,-1,0,-1);
   G__setnewtype(-1,"pointer to void function",0);
   G__search_typename2("ShowMembersFunc_t",89,-1,0,-1);
   G__setnewtype(-1,"void (*ShowMembersFunc_t)(void *obj, TMemberInspector &R__insp, char *R__parent);",0);
   G__search_typename2("NewFunc_t",89,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOT));
   G__setnewtype(-1,"void *(*NewFunc_t)(void *);",0);
   G__search_typename2("NewArrFunc_t",89,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOT));
   G__setnewtype(-1,"void *(*NewArrFunc_t)(Long_t size, void *arena);",0);
   G__search_typename2("DelFunc_t",89,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOT));
   G__setnewtype(-1,"void  (*DelFunc_t)(void *);",0);
   G__search_typename2("DelArrFunc_t",89,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOT));
   G__setnewtype(-1,"void  (*DelArrFunc_t)(void *);",0);
   G__search_typename2("DesFunc_t",89,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOT));
   G__setnewtype(-1,"void  (*DesFunc_t)(void *);",0);
   G__search_typename2("DirAutoAdd_t",89,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOT));
   G__setnewtype(-1,"void  (*DirAutoAdd_t)(void *, TDirectory*);",0);
   G__search_typename2("vector<TSchemaHelper>",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("FCNFunc_t",89,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_TVirtualFitter));
   G__setnewtype(-1,"void   (* FCNFunc_t )(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);",0);
   G__search_typename2("void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t)",49,-1,0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TKDTree<Int_t,Double_t>",117,G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<int>",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEintcOallocatorlEintgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEintcOallocatorlEintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEintcOallocatorlEintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TKDTreeID",117,G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TKDTree<Int_t,Float_t>",117,G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TKDTreeIF",117,G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("IGenFunction",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("IMultiGenFunction",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("IGradFunction",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("IMultiGradFunction",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseFunc",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseFunc",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseFunc",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseGrad",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseFunc",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseGrad",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("IParamFunction",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("IParamMultiFunction",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("IParamGradFunction",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("IParamMultiGradFunction",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseFunc",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseFunc",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseParamFunc",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseGradFunc",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseFunc",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseParamFunc",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseGradFunc",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseFunc",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Impl",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctionBase),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("FreeFunc",89,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor));
   G__setnewtype(-1,"double (* FreeFunc ) (double * , double *);",0);
   G__search_typename2("Impl",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("ImplBase",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("auto_ptr<Impl>",117,G__get_linked_tagnum(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Impl",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("ImplBase",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("auto_ptr<Impl>",117,G__get_linked_tagnum(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionOneDimgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Impl",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("ImplBase",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("auto_ptr<Impl>",117,G__get_linked_tagnum(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Impl",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("ImplBase",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("auto_ptr<Impl>",117,G__get_linked_tagnum(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIGradientFunctionOneDimgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<double>",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",100,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",68,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",68,-1,256,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",100,-1,1,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",100,-1,257,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",104,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",68,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",68,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",100,-1,1,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",100,-1,1,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",104,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator),256,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",68,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",100,-1,1,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator",117,G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Integrator",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BasicFitMethodFunction<ROOT::Math::IMultiGenFunction>",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseFunction",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("FitMethodFunction",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BasicFitMethodFunction<ROOT::Math::IMultiGradFunction>",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BaseFunction",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("FitMethodGradFunction",117,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR),0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("double",121,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,"double( * FreeFunctionPtr ) (double );",0);
   G__search_typename2("constdouble*",121,-1,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__setnewtype(-1,"double( * FreeMultiFunctionPtr ) (const double *);",0);
   G__search_typename2("vector<Double_t>",117,G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* ROOT */
static void G__setup_memvarROOT(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOT));
   {
   }
   G__tag_memvar_reset();
}


   /* TRandom */
static void G__setup_memvarTRandom(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom));
   { TRandom *p; p=(TRandom*)0x1000; if (p) { }
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("UInt_t"),-1,2,"fSeed=",0,"Random number generator seed");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TRandom1 */
static void G__setup_memvarTRandom1(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1));
   { TRandom1 *p; p=(TRandom1*)0x1000; if (p) { }
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fNskip=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fLuxury=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fIlag=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fJlag=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fCount24=",0,(char*)NULL);
   G__memvar_setup((void*)0,102,0,0,-1,G__defined_typename("Float_t"),-1,2,"fFloatSeedTable[24]=",0,(char*)NULL);
   G__memvar_setup((void*)0,102,0,0,-1,G__defined_typename("Float_t"),-1,2,"fCarry=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,1,-1,G__defined_typename("Int_t"),-1,2,"fIntModulus=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-2,2,"fgNumEngines=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-2,2,"fgMaxIndex=",0,(char*)NULL);
   G__memvar_setup((void*)0,72,0,1,-1,G__defined_typename("UInt_t"),-1,2,"fTheSeeds=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,1,-1,G__defined_typename("Double_t"),-1,2,"fMantissaBit24=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,1,-1,G__defined_typename("Double_t"),-1,2,"fMantissaBit12=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TRandom2 */
static void G__setup_memvarTRandom2(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom2));
   { TRandom2 *p; p=(TRandom2*)0x1000; if (p) { }
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("UInt_t"),-1,2,"fSeed1=",0,"Random number generator seed 1");
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("UInt_t"),-1,2,"fSeed2=",0,"Random number generator seed 2");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TRandom3 */
static void G__setup_memvarTRandom3(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom3));
   { TRandom3 *p; p=(TRandom3*)0x1000; if (p) { }
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("UInt_t"),-1,4,"fMt[624]=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,4,"fCount624=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TVirtualFitter */
static void G__setup_memvarTVirtualFitter(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TVirtualFitter));
   { TVirtualFitter *p; p=(TVirtualFitter*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_Foption_t),-1,-1,2,"fOption=",0,"struct with the fit options");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fXfirst=",0,"first bin on X axis");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fXlast=",0,"last  bin on X axis");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fYfirst=",0,"first bin on Y axis");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fYlast=",0,"last  bin on Y axis");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fZfirst=",0,"first bin on Z axis");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fZlast=",0,"last  bin on Z axis");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fNpoints=",0,"Number of points to fit");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fPointSize=",0,"Number of words per point in the cache");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fCacheSize=",0,"Size of the fCache array");
   G__memvar_setup((void*)0,68,0,0,-1,G__defined_typename("Double_t"),-1,2,"fCache=",0,"[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words)");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TObject),-1,-1,2,"fObjectFit=",0,"pointer to object being fitted");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TObject),-1,-1,2,"fUserFunc=",0,"pointer to user theoretical function (a TF1*)");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TMethodCall),-1,-1,2,"fMethodCall=",0,"Pointer to MethodCall in case of interpreted function");
   G__memvar_setup((void*)0,49,0,0,-1,G__defined_typename("void (*)(Int_t&npar, Double_t*gin, Double_t&f, Double_t*u, Int_t flag)"),-1,2,"fFCN=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TVirtualFitter),-1,-2,2,"fgFitter=",0,"Current fitter (default TFitter)");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-2,2,"fgMaxpar=",0,"Maximum number of fit parameters for current fitter");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-2,2,"fgMaxiter=",0,"Maximum number of iterations");
   G__memvar_setup((void*)0,100,0,0,-1,G__defined_typename("Double_t"),-2,2,"fgErrorDef=",0,"Error definition (default=1)");
   G__memvar_setup((void*)0,100,0,0,-1,G__defined_typename("Double_t"),-2,2,"fgPrecision=",0,"maximum precision");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TString),-1,-2,2,"fgDefault=",0,"name of the default fitter (\"Minuit\",\"Fumili\",etc)");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TKDTree<int,double> */
static void G__setup_memvarTKDTreelEintcOdoublegR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR));
   { TKDTree<int,double> *p; p=(TKDTree<int,double>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fDataOwner=",0,"! 0 - not owner, 2 - owner of the pointer array, 1 - owner of the whole 2-d array");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fNNodes=",0,"size of node array");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fTotalNodes=",0,"total number of nodes (fNNodes + terminal nodes)");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fNDim=",0,"number of dimensions");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fNDimm=",0,"dummy 2*fNDim");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fNPoints=",0,"number of multidimensional points");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fBucketSize=",0,"size of the terminal nodes");
   G__memvar_setup((void*)0,66,0,0,-1,G__defined_typename("UChar_t"),-1,2,"fAxis=",0,"[fNNodes] nodes cutting axis");
   G__memvar_setup((void*)0,68,0,0,-1,-1,-1,2,"fValue=",0,"[fNNodes] nodes cutting value");
   G__memvar_setup((void*)0,68,0,0,-1,-1,-1,2,"fRange=",0,"[fNDimm] range of data for each dimension");
   G__memvar_setup((void*)0,68,2,0,-1,-1,-1,2,"fData=",0,"! data points");
   G__memvar_setup((void*)0,68,0,0,-1,-1,-1,2,"fBoundaries=",0,"! nodes boundaries");
   G__memvar_setup((void*)0,73,0,0,-1,-1,-1,2,"fIndPoints=",0,"! array of points indexes");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fRowT0=",0,"! smallest terminal row - first row that contains terminal nodes");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fCrossNode=",0,"! cross node - node that begins the last row (with terminal nodes only)");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fOffset=",0,"! offset in fIndPoints - if there are 2 rows, that contain terminal nodes");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TKDTree<int,float> */
static void G__setup_memvarTKDTreelEintcOfloatgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR));
   { TKDTree<int,float> *p; p=(TKDTree<int,float>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fDataOwner=",0,"! 0 - not owner, 2 - owner of the pointer array, 1 - owner of the whole 2-d array");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fNNodes=",0,"size of node array");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fTotalNodes=",0,"total number of nodes (fNNodes + terminal nodes)");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fNDim=",0,"number of dimensions");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fNDimm=",0,"dummy 2*fNDim");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fNPoints=",0,"number of multidimensional points");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fBucketSize=",0,"size of the terminal nodes");
   G__memvar_setup((void*)0,66,0,0,-1,G__defined_typename("UChar_t"),-1,2,"fAxis=",0,"[fNNodes] nodes cutting axis");
   G__memvar_setup((void*)0,70,0,0,-1,-1,-1,2,"fValue=",0,"[fNNodes] nodes cutting value");
   G__memvar_setup((void*)0,70,0,0,-1,-1,-1,2,"fRange=",0,"[fNDimm] range of data for each dimension");
   G__memvar_setup((void*)0,70,2,0,-1,-1,-1,2,"fData=",0,"! data points");
   G__memvar_setup((void*)0,70,0,0,-1,-1,-1,2,"fBoundaries=",0,"! nodes boundaries");
   G__memvar_setup((void*)0,73,0,0,-1,-1,-1,2,"fIndPoints=",0,"! array of points indexes");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fRowT0=",0,"! smallest terminal row - first row that contains terminal nodes");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fCrossNode=",0,"! cross node - node that begins the last row (with terminal nodes only)");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,2,"fOffset=",0,"! offset in fIndPoints - if there are 2 rows, that contain terminal nodes");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math */
static void G__setup_memvarROOTcLcLMath(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   {
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IBaseFunctionOneDim */
static void G__setup_memvarROOTcLcLMathcLcLIBaseFunctionOneDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim));
   { ROOT::Math::IBaseFunctionOneDim *p; p=(ROOT::Math::IBaseFunctionOneDim*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IGradientFunctionOneDim */
static void G__setup_memvarROOTcLcLMathcLcLIGradientFunctionOneDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim));
   { ROOT::Math::IGradientFunctionOneDim *p; p=(ROOT::Math::IGradientFunctionOneDim*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IBaseFunctionMultiDim */
static void G__setup_memvarROOTcLcLMathcLcLIBaseFunctionMultiDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim));
   { ROOT::Math::IBaseFunctionMultiDim *p; p=(ROOT::Math::IBaseFunctionMultiDim*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IGradientFunctionMultiDim */
static void G__setup_memvarROOTcLcLMathcLcLIGradientFunctionMultiDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim));
   { ROOT::Math::IGradientFunctionMultiDim *p; p=(ROOT::Math::IGradientFunctionMultiDim*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IGradientMultiDim */
static void G__setup_memvarROOTcLcLMathcLcLIGradientMultiDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientMultiDim));
   { ROOT::Math::IGradientMultiDim *p; p=(ROOT::Math::IGradientMultiDim*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IGradientOneDim */
static void G__setup_memvarROOTcLcLMathcLcLIGradientOneDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientOneDim));
   { ROOT::Math::IGradientOneDim *p; p=(ROOT::Math::IGradientOneDim*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IParametricFunctionOneDim */
static void G__setup_memvarROOTcLcLMathcLcLIParametricFunctionOneDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim));
   { ROOT::Math::IParametricFunctionOneDim *p; p=(ROOT::Math::IParametricFunctionOneDim*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IParametricGradFunctionOneDim */
static void G__setup_memvarROOTcLcLMathcLcLIParametricGradFunctionOneDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim));
   { ROOT::Math::IParametricGradFunctionOneDim *p; p=(ROOT::Math::IParametricGradFunctionOneDim*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IParametricFunctionMultiDim */
static void G__setup_memvarROOTcLcLMathcLcLIParametricFunctionMultiDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim));
   { ROOT::Math::IParametricFunctionMultiDim *p; p=(ROOT::Math::IParametricFunctionMultiDim*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IParametricGradFunctionMultiDim */
static void G__setup_memvarROOTcLcLMathcLcLIParametricGradFunctionMultiDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim));
   { ROOT::Math::IParametricGradFunctionMultiDim *p; p=(ROOT::Math::IParametricGradFunctionMultiDim*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IBaseParam */
static void G__setup_memvarROOTcLcLMathcLcLIBaseParam(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseParam));
   { ROOT::Math::IBaseParam *p; p=(ROOT::Math::IBaseParam*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::ParamFunctor */
static void G__setup_memvarROOTcLcLMathcLcLParamFunctor(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor));
   { ROOT::Math::ParamFunctor *p; p=(ROOT::Math::ParamFunctor*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctionBase),G__defined_typename("Impl"),-1,4,"fImpl=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Functor */
static void G__setup_memvarROOTcLcLMathcLcLFunctor(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor));
   { ROOT::Math::Functor *p; p=(ROOT::Math::Functor*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR),-1,-1,4,"fImpl=",0,"pointer to base functor handler");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Functor1D */
static void G__setup_memvarROOTcLcLMathcLcLFunctor1D(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D));
   { ROOT::Math::Functor1D *p; p=(ROOT::Math::Functor1D*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionOneDimgR),-1,-1,4,"fImpl=",0,"pointer to base functor handler");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GradFunctor */
static void G__setup_memvarROOTcLcLMathcLcLGradFunctor(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor));
   { ROOT::Math::GradFunctor *p; p=(ROOT::Math::GradFunctor*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR),-1,-1,4,"fImpl=",0,"pointer to base grad functor handler");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GradFunctor1D */
static void G__setup_memvarROOTcLcLMathcLcLGradFunctor1D(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D));
   { ROOT::Math::GradFunctor1D *p; p=(ROOT::Math::GradFunctor1D*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIGradientFunctionOneDimgR),-1,-1,4,"fImpl=",0,"pointer to base gradient functor handler");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Minimizer */
static void G__setup_memvarROOTcLcLMathcLcLMinimizer(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizer));
   { ROOT::Math::Minimizer *p; p=(ROOT::Math::Minimizer*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,2,"fValidError=",0,"flag to control if errors have been validated (Hesse has been run in case of Minuit)");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fDebug=",0,"print level");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fStrategy=",0,"minimizer strategy");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fStatus=",0,"status of minimizer    ");
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,2,"fMaxCalls=",0,"max number of function calls ");
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,2,"fMaxIter=",0,"max number or iterations used to find the minimum");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fTol=",0,"tolerance (absolute)");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fPrec=",0,"precision");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fUp=",0,"error scale ");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::MinimizerOptions */
static void G__setup_memvarROOTcLcLMathcLcLMinimizerOptions(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizerOptions));
   { ROOT::Math::MinimizerOptions *p; p=(ROOT::Math::MinimizerOptions*)0x1000; if (p) { }
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fLevel=",0,"debug print level ");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fMaxCalls=",0,"maximum number of function calls");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fMaxIter=",0,"maximum number of iterations");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fStrategy=",0,"minimizer strategy (used by Minuit)");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fErrorDef=",0,"error definition (=1. for getting 1 sigma error for chi2 fits)");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fTolerance=",0,"minimize tolerance to reach solution");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fPrecision=",0,"precision of the objective funciton evaluation (value <=0 means left to default)");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_string),-1,-1,4,"fMinimType=",0,"Minimizer type (Minuit, Minuit2, etc..");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_string),-1,-1,4,"fAlgoType=",0,"Minimizer algorithmic specification (Migrad, Minimize, ...)");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IntegrationOneDim */
static void G__setup_memvarROOTcLcLMathcLcLIntegrationOneDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDim));
   {
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType),-1,-2,1,"kGAUSS=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType),-1,-2,1,"kADAPTIVE=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType),-1,-2,1,"kADAPTIVESINGULAR=2",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType),-1,-2,1,"kNONADAPTIVE=3",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IntegrationMultiDim */
static void G__setup_memvarROOTcLcLMathcLcLIntegrationMultiDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDim));
   {
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType),-1,-2,1,"kADAPTIVE=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType),-1,-2,1,"kVEGAS=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType),-1,-2,1,"kMISER=2",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType),-1,-2,1,"kPLAIN=3",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::VirtualIntegrator */
static void G__setup_memvarROOTcLcLMathcLcLVirtualIntegrator(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegrator));
   { ROOT::Math::VirtualIntegrator *p; p=(ROOT::Math::VirtualIntegrator*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::VirtualIntegratorOneDim */
static void G__setup_memvarROOTcLcLMathcLcLVirtualIntegratorOneDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim));
   { ROOT::Math::VirtualIntegratorOneDim *p; p=(ROOT::Math::VirtualIntegratorOneDim*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* vector<double,allocator<double> > */
static void G__setup_memvarvectorlEdoublecOallocatorlEdoublegRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   { vector<double,allocator<double> > *p; p=(vector<double,allocator<double> >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* vector<double,allocator<double> >::iterator */
static void G__setup_memvarvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator));
   { vector<double,allocator<double> >::iterator *p; p=(vector<double,allocator<double> >::iterator*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* reverse_iterator<vector<double,allocator<double> >::iterator> */
static void G__setup_memvarreverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR));
   { reverse_iterator<vector<double,allocator<double> >::iterator> *p; p=(reverse_iterator<vector<double,allocator<double> >::iterator>*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::VirtualIntegratorMultiDim */
static void G__setup_memvarROOTcLcLMathcLcLVirtualIntegratorMultiDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim));
   { ROOT::Math::VirtualIntegratorMultiDim *p; p=(ROOT::Math::VirtualIntegratorMultiDim*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IntegratorOneDim */
static void G__setup_memvarROOTcLcLMathcLcLIntegratorOneDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim));
   { ROOT::Math::IntegratorOneDim *p; p=(ROOT::Math::IntegratorOneDim*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim),-1,-1,4,"fIntegrator=",0,"pointer to integrator interface class");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::AdaptiveIntegratorMultiDim */
static void G__setup_memvarROOTcLcLMathcLcLAdaptiveIntegratorMultiDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim));
   { ROOT::Math::AdaptiveIntegratorMultiDim *p; p=(ROOT::Math::AdaptiveIntegratorMultiDim*)0x1000; if (p) { }
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fDim=",0,"dimentionality of integrand");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fAbsTol=",0,"absolute tolerance");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fRelTol=",0,"relative tolerance");
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fSize=",0,"max size of working array (explode with dimension)");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fResult=",0,"last integration result ");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fError=",0,"integration error ");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fRelError=",0,"Relative error");
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fNEval=",0,"number of function evaluation");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fStatus=",0,"status of algorithm (error if not zero)");
   G__memvar_setup((void*)0,85,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),G__defined_typename("IMultiGenFunction"),-1,4,"fFun=",0,"pointer to integrand function ");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IntegratorMultiDim */
static void G__setup_memvarROOTcLcLMathcLcLIntegratorMultiDim(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDim));
   { ROOT::Math::IntegratorMultiDim *p; p=(ROOT::Math::IntegratorMultiDim*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim),-1,-1,4,"fIntegrator=",0,"pointer to multi-dimensional integrator base class");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::Factory */
static void G__setup_memvarROOTcLcLMathcLcLFactory(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFactory));
   { ROOT::Math::Factory *p; p=(ROOT::Math::Factory*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim> */
static void G__setup_memvarROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR));
   { ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim> *p; p=(ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgRcLcLType_t),-1,-2,1,"kUndefined=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgRcLcLType_t),-1,-2,1,"kLeastSquare=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgRcLcLType_t),-1,-2,1,"kLogLikelihood=2",0,(char*)NULL);
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fNDim=",0,"function dimension ");
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fNPoints=",0,"size of the data");
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fNCalls=",0,"number of function calls");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim> */
static void G__setup_memvarROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR));
   { ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim> *p; p=(ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgRcLcLType_t),-1,-2,1,"kUndefined=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgRcLcLType_t),-1,-2,1,"kLeastSquare=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgRcLcLType_t),-1,-2,1,"kLogLikelihood=2",0,(char*)NULL);
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fNDim=",0,"function dimension ");
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fNPoints=",0,"size of the data");
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"fNCalls=",0,"number of function calls");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GaussIntegrator */
static void G__setup_memvarROOTcLcLMathcLcLGaussIntegrator(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator));
   { ROOT::Math::GaussIntegrator *p; p=(ROOT::Math::GaussIntegrator*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-2,2,"fgAbsValue=",0,"AbsValue used for the calculation of the integral");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fEpsilon=",0,"Relative error.");
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,2,"fUsedOnce=",0,"Bool value to check if the function was at least called once.");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fLastResult=",0,"Result from the last stimation.");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fLastError=",0,"Error from the last stimation.");
   G__memvar_setup((void*)0,85,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),G__defined_typename("IGenFunction"),-1,2,"fFunction=",0,"Pointer to function used.");
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,2,"fFunctionCopied=",0,"Bool value to check if the function was copied when set.");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::GaussLegendreIntegrator */
static void G__setup_memvarROOTcLcLMathcLcLGaussLegendreIntegrator(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator));
   { ROOT::Math::GaussLegendreIntegrator *p; p=(ROOT::Math::GaussLegendreIntegrator*)0x1000; if (p) { }
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fNum=",0,"Number of points used in the stimation of the integral.");
   G__memvar_setup((void*)0,68,0,0,-1,-1,-1,2,"fX=",0,"Abscisa of the points used.");
   G__memvar_setup((void*)0,68,0,0,-1,-1,-1,2,"fW=",0,"Weights of the points used.");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fEpsilon=",0,"Desired relative error.");
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,2,"fUsedOnce=",0,"Bool value to check if the function was at least called once.");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fLastResult=",0,"Result from the last stimation.");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fLastError=",0,"Error from the last stimation.");
   G__memvar_setup((void*)0,85,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),G__defined_typename("IGenFunction"),-1,2,"fFunction=",0,"Pointer to function used.");
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,2,"fFunctionCopied=",0,"Bool value to check if the function was copied when set.");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::IRootFinderMethod */
static void G__setup_memvarROOTcLcLMathcLcLIRootFinderMethod(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIRootFinderMethod));
   { ROOT::Math::IRootFinderMethod *p; p=(ROOT::Math::IRootFinderMethod*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::RootFinder */
static void G__setup_memvarROOTcLcLMathcLcLRootFinder(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFinder));
   { ROOT::Math::RootFinder *p; p=(ROOT::Math::RootFinder*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFindercLcLEType),-1,-2,1,"kBRENT=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFindercLcLEType),-1,-2,1,"kGSL_BISECTION=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFindercLcLEType),-1,-2,1,"kGSL_FALSE_POS=2",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFindercLcLEType),-1,-2,1,"kGSL_BRENT=3",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFindercLcLEType),-1,-2,1,"kGSL_NEWTON=4",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFindercLcLEType),-1,-2,1,"kGSL_SECANT=5",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFindercLcLEType),-1,-2,1,"kGSL_STEFFENSON=6",0,(char*)NULL);
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIRootFinderMethod),-1,-1,4,"fSolver=",0,"type of algorithm to be used ");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::RichardsonDerivator */
static void G__setup_memvarROOTcLcLMathcLcLRichardsonDerivator(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRichardsonDerivator));
   { ROOT::Math::RichardsonDerivator *p; p=(ROOT::Math::RichardsonDerivator*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,2,"fFunctionCopied=",0,"flag to control if function is copied in the class");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fStepSize=",0,"step size used for derivative calculation");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fLastError=",0,"error estimate of last derivative calculation");
   G__memvar_setup((void*)0,85,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),G__defined_typename("IGenFunction"),-1,2,"fFunction=",0,"pointer to function");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::BrentMinimizer1D */
static void G__setup_memvarROOTcLcLMathcLcLBrentMinimizer1D(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentMinimizer1D));
   { ROOT::Math::BrentMinimizer1D *p; p=(ROOT::Math::BrentMinimizer1D*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),G__defined_typename("IGenFunction"),-1,2,"fFunction=",0,"Pointer to the function.");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fXMin=",0,"Lower bound of the search interval.");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fXMax=",0,"Upper bound of the search interval");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fXMinimum=",0,"Position of the stimated minimum.");
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,2,"fNIter=",0,"Number of iterations needed for the last stimation.");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::BrentRootFinder */
static void G__setup_memvarROOTcLcLMathcLcLBrentRootFinder(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentRootFinder));
   { ROOT::Math::BrentRootFinder *p; p=(ROOT::Math::BrentRootFinder*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,1,G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),G__defined_typename("IGenFunction"),-1,2,"fFunction=",0,"Pointer to the function.");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fXMin=",0,"Lower bound of the search interval.");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fXMax=",0,"Upper bound of the search interval");
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,2,"fRoot=",0,"Current stimation of the function root.");
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvarG__MathCore() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncROOT(void) {
   /* ROOT */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOT));
   G__memfunc_setup("CreateClass",1098,G__G__MathCore_18_0_1, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 9, 1, 1, 0, 
"C - - 10 - cname s - 'Version_t' 0 - id "
"u 'type_info' - 11 - info U 'TVirtualIsAProxy' - 0 - isa "
"Y - 'ShowMembersFunc_t' 0 - show C - - 10 - dfil "
"C - - 10 - ifil i - 'Int_t' 0 - dl "
"i - 'Int_t' 0 - il", (char*)NULL, (void*) G__func2void( (TClass* (*)(const char*, Version_t, const type_info&, TVirtualIsAProxy*, ShowMembersFunc_t, const char*, const char*, Int_t, Int_t))(&ROOT::CreateClass) ), 0);
   G__memfunc_setup("AddClass",767,G__G__MathCore_18_0_2, 121, -1, -1, 0, 5, 1, 1, 0, 
"C - - 10 - cname s - 'Version_t' 0 - id "
"u 'type_info' - 11 - info Y - 'VoidFuncPtr_t' 0 - dict "
"i - 'Int_t' 0 - pragmabits", (char*)NULL, (void*) G__func2void( (void (*)(const char*, Version_t, const type_info&, VoidFuncPtr_t, Int_t))(&ROOT::AddClass) ), 0);
   G__memfunc_setup("RemoveClass",1124,G__G__MathCore_18_0_3, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - cname", (char*)NULL, (void*) G__func2void( (void (*)(const char*))(&ROOT::RemoveClass) ), 0);
   G__memfunc_setup("ResetClassVersion",1759,G__G__MathCore_18_0_4, 121, -1, -1, 0, 3, 1, 1, 0, 
"U 'TClass' - 0 - - C - - 10 - - "
"s - 'Short_t' 0 - -", (char*)NULL, (void*) G__func2void( (void (*)(TClass*, const char*, Short_t))(&ROOT::ResetClassVersion) ), 0);
   G__memfunc_setup("RegisterClassTemplate",2167,G__G__MathCore_18_0_5, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TNamed), -1, 0, 3, 1, 1, 0, 
"C - - 10 - name C - - 10 - file "
"i - 'Int_t' 0 - line", (char*)NULL, (void*) G__func2void( (TNamed* (*)(const char*, const char*, Int_t))(&ROOT::RegisterClassTemplate) ), 0);
   G__memfunc_setup("DefineBehavior",1403,G__G__MathCore_18_0_6, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLTInitBehavior), -1, 0, 2, 1, 1, 1, 
"Y - - 0 - - Y - - 0 - -", (char*)NULL, (void*) G__func2void( (const ROOT::TInitBehavior* (*)(void*, void*))(&ROOT::DefineBehavior) ), 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTRandom(void) {
   /* TRandom */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom));
   G__memfunc_setup("TRandom",693,G__G__MathCore_106_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TRandom), -1, 0, 1, 1, 1, 0, "h - 'UInt_t' 0 '65539' seed", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Binomial",811,G__G__MathCore_106_0_2, 105, -1, G__defined_typename("Int_t"), 0, 2, 1, 1, 0, 
"i - 'Int_t' 0 - ntot d - 'Double_t' 0 - prob", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("BreitWigner",1122,G__G__MathCore_106_0_3, 100, -1, G__defined_typename("Double_t"), 0, 2, 1, 1, 0, 
"d - 'Double_t' 0 '0' mean d - 'Double_t' 0 '1' gamma", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Circle",594,G__G__MathCore_106_0_4, 121, -1, -1, 0, 3, 1, 1, 0, 
"d - 'Double_t' 1 - x d - 'Double_t' 1 - y "
"d - 'Double_t' 0 - r", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Exp",301,G__G__MathCore_106_0_5, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 0, "d - 'Double_t' 0 - tau", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Gaus",400,G__G__MathCore_106_0_6, 100, -1, G__defined_typename("Double_t"), 0, 2, 1, 1, 0, 
"d - 'Double_t' 0 '0' mean d - 'Double_t' 0 '1' sigma", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetSeed",673,G__G__MathCore_106_0_7, 104, -1, G__defined_typename("UInt_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Integer",718,G__G__MathCore_106_0_8, 104, -1, G__defined_typename("UInt_t"), 0, 1, 1, 1, 0, "h - 'UInt_t' 0 - imax", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Landau",597,G__G__MathCore_106_0_9, 100, -1, G__defined_typename("Double_t"), 0, 2, 1, 1, 0, 
"d - 'Double_t' 0 '0' mean d - 'Double_t' 0 '1' sigma", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Poisson",747,G__G__MathCore_106_0_10, 105, -1, G__defined_typename("Int_t"), 0, 1, 1, 1, 0, "d - 'Double_t' 0 - mean", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("PoissonD",815,G__G__MathCore_106_0_11, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 0, "d - 'Double_t' 0 - mean", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Rannor",624,G__G__MathCore_106_0_12, 121, -1, -1, 0, 2, 1, 1, 0, 
"f - 'Float_t' 1 - a f - 'Float_t' 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Rannor",624,G__G__MathCore_106_0_13, 121, -1, -1, 0, 2, 1, 1, 0, 
"d - 'Double_t' 1 - a d - 'Double_t' 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ReadRandom",989,G__G__MathCore_106_0_14, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - filename", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetSeed",685,G__G__MathCore_106_0_15, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'UInt_t' 0 '65539' seed", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Rndm",401,G__G__MathCore_106_0_16, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 0, "i - 'Int_t' 0 '0' i", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("RndmArray",912,G__G__MathCore_106_0_17, 121, -1, -1, 0, 2, 1, 1, 0, 
"i - 'Int_t' 0 - n F - 'Float_t' 0 - array", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("RndmArray",912,G__G__MathCore_106_0_18, 121, -1, -1, 0, 2, 1, 1, 0, 
"i - 'Int_t' 0 - n D - 'Double_t' 0 - array", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Sphere",615,G__G__MathCore_106_0_19, 121, -1, -1, 0, 4, 1, 1, 0, 
"d - 'Double_t' 1 - x d - 'Double_t' 1 - y "
"d - 'Double_t' 1 - z d - 'Double_t' 0 - r", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Uniform",736,G__G__MathCore_106_0_20, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 0, "d - 'Double_t' 0 '1' x1", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Uniform",736,G__G__MathCore_106_0_21, 100, -1, G__defined_typename("Double_t"), 0, 2, 1, 1, 0, 
"d - 'Double_t' 0 - x1 d - 'Double_t' 0 - x2", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("WriteRandom",1132,G__G__MathCore_106_0_22, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - filename", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Class",502,G__G__MathCore_106_0_23, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TRandom::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__MathCore_106_0_24, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRandom::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__MathCore_106_0_25, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TRandom::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__MathCore_106_0_26, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TRandom::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__MathCore_106_0_30, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__MathCore_106_0_31, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRandom::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__MathCore_106_0_32, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TRandom::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__MathCore_106_0_33, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRandom::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__MathCore_106_0_34, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TRandom::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("TRandom", 693, G__G__MathCore_106_0_35, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_TRandom), -1, 0, 1, 1, 1, 0, "u 'TRandom' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TRandom", 819, G__G__MathCore_106_0_36, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_106_0_37, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_TRandom), -1, 1, 1, 1, 1, 0, "u 'TRandom' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTRandom1(void) {
   /* TRandom1 */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1));
   G__memfunc_setup("TRandom1",742,G__G__MathCore_107_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TRandom1",742,G__G__MathCore_107_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1), -1, 0, 2, 1, 1, 0, 
"h - 'UInt_t' 0 - seed i - 'Int_t' 0 '3' lux", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TRandom1",742,G__G__MathCore_107_0_3, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1), -1, 0, 3, 1, 1, 0, 
"i - 'Int_t' 0 - rowIndex i - 'Int_t' 0 - colIndex "
"i - 'Int_t' 0 - lux", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetLuxury",953,G__G__MathCore_107_0_4, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetTheSeeds",1077,G__G__MathCore_107_0_5, 72, -1, G__defined_typename("UInt_t"), 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetTableSeeds",1276,G__G__MathCore_107_0_6, 121, -1, -1, 0, 2, 3, 1, 0, 
"H - 'UInt_t' 0 - seeds i - 'Int_t' 0 - index", (char*)NULL, (void*) G__func2void( (void (*)(UInt_t*, Int_t))(&TRandom1::GetTableSeeds) ), 0);
   G__memfunc_setup("Rndm",401,(G__InterfaceMethod) NULL,100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 0, "i - 'Int_t' 0 '0' i", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("RndmArray",912,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"i - 'Int_t' 0 - size F - 'Float_t' 0 - vect", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("RndmArray",912,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"i - 'Int_t' 0 - size D - 'Double_t' 0 - vect", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetSeed2",735,G__G__MathCore_107_0_10, 121, -1, -1, 0, 2, 1, 1, 0, 
"h - 'UInt_t' 0 - seed i - 'Int_t' 0 '3' lux", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetSeeds",800,G__G__MathCore_107_0_11, 121, -1, -1, 0, 2, 1, 1, 0, 
"H - 'UInt_t' 10 - seeds i - 'Int_t' 0 '3' lux", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetSeed",685,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "h - 'UInt_t' 0 - seed", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Class",502,G__G__MathCore_107_0_13, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TRandom1::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__MathCore_107_0_14, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRandom1::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__MathCore_107_0_15, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TRandom1::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__MathCore_107_0_16, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TRandom1::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__MathCore_107_0_20, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__MathCore_107_0_21, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRandom1::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__MathCore_107_0_22, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TRandom1::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__MathCore_107_0_23, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRandom1::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__MathCore_107_0_24, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TRandom1::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("TRandom1", 742, G__G__MathCore_107_0_25, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1), -1, 0, 1, 1, 1, 0, "u 'TRandom1' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TRandom1", 868, G__G__MathCore_107_0_26, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTRandom2(void) {
   /* TRandom2 */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom2));
   G__memfunc_setup("TRandom2",743,G__G__MathCore_108_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TRandom2), -1, 0, 1, 1, 1, 0, "h - 'UInt_t' 0 '1' seed", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Rndm",401,(G__InterfaceMethod) NULL,100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 0, "i - 'Int_t' 0 '0' i", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("RndmArray",912,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"i - 'Int_t' 0 - n F - 'Float_t' 0 - array", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("RndmArray",912,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"i - 'Int_t' 0 - n D - 'Double_t' 0 - array", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetSeed",685,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "h - 'UInt_t' 0 '0' seed", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Class",502,G__G__MathCore_108_0_6, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TRandom2::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__MathCore_108_0_7, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRandom2::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__MathCore_108_0_8, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TRandom2::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__MathCore_108_0_9, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TRandom2::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__MathCore_108_0_13, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__MathCore_108_0_14, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRandom2::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__MathCore_108_0_15, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TRandom2::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__MathCore_108_0_16, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRandom2::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__MathCore_108_0_17, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TRandom2::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("TRandom2", 743, G__G__MathCore_108_0_18, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_TRandom2), -1, 0, 1, 1, 1, 0, "u 'TRandom2' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TRandom2", 869, G__G__MathCore_108_0_19, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_108_0_20, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_TRandom2), -1, 1, 1, 1, 1, 0, "u 'TRandom2' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTRandom3(void) {
   /* TRandom3 */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom3));
   G__memfunc_setup("TRandom3",744,G__G__MathCore_109_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TRandom3), -1, 0, 1, 1, 1, 0, "h - 'UInt_t' 0 '4357' seed", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Rndm",401,(G__InterfaceMethod) NULL,100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 0, "i - 'Int_t' 0 '0' i", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("RndmArray",912,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"i - 'Int_t' 0 - n F - 'Float_t' 0 - array", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("RndmArray",912,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"i - 'Int_t' 0 - n D - 'Double_t' 0 - array", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetSeed",685,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "h - 'UInt_t' 0 '0' seed", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Class",502,G__G__MathCore_109_0_6, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TRandom3::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__MathCore_109_0_7, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRandom3::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__MathCore_109_0_8, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TRandom3::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__MathCore_109_0_9, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TRandom3::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__MathCore_109_0_13, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__MathCore_109_0_14, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRandom3::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__MathCore_109_0_15, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TRandom3::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__MathCore_109_0_16, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRandom3::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__MathCore_109_0_17, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TRandom3::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("TRandom3", 744, G__G__MathCore_109_0_18, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_TRandom3), -1, 0, 1, 1, 1, 0, "u 'TRandom3' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TRandom3", 870, G__G__MathCore_109_0_19, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_109_0_20, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_TRandom3), -1, 1, 1, 1, 1, 0, "u 'TRandom3' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTVirtualFitter(void) {
   /* TVirtualFitter */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TVirtualFitter));
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathCoreLN_TVirtualFitter), -1, 1, 1, 1, 2, 0, "u 'TVirtualFitter' - 11 - tvf", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Chisquare",933,G__G__MathCore_117_0_4, 100, -1, G__defined_typename("Double_t"), 0, 2, 1, 1, 8, 
"i - 'Int_t' 0 - npar D - 'Double_t' 0 - params", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Clear",487,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "C - 'Option_t' 10 '\"\"' option", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("ExecuteCommand",1426,G__G__MathCore_117_0_6, 105, -1, G__defined_typename("Int_t"), 0, 3, 1, 1, 0, 
"C - - 10 - command D - 'Double_t' 0 - args "
"i - 'Int_t' 0 - nargs", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("FixParameter",1224,G__G__MathCore_117_0_7, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - ipar", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetConfidenceIntervals",2246,G__G__MathCore_117_0_8, 121, -1, -1, 0, 5, 1, 1, 0, 
"i - 'Int_t' 0 - n i - 'Int_t' 0 - ndim "
"D - 'Double_t' 10 - x D - 'Double_t' 0 - ci "
"d - 'Double_t' 0 '0.95' cl", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetConfidenceIntervals",2246,G__G__MathCore_117_0_9, 121, -1, -1, 0, 2, 1, 1, 0, 
"U 'TObject' - 0 - obj d - 'Double_t' 0 '0.95' cl", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetCovarianceMatrix",1936,G__G__MathCore_117_0_10, 68, -1, G__defined_typename("Double_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetCovarianceMatrixElement",2650,G__G__MathCore_117_0_11, 100, -1, G__defined_typename("Double_t"), 0, 2, 1, 1, 8, 
"i - 'Int_t' 0 - i i - 'Int_t' 0 - j", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetErrors",925,G__G__MathCore_117_0_12, 105, -1, G__defined_typename("Int_t"), 0, 5, 1, 1, 8, 
"i - 'Int_t' 0 - ipar d - 'Double_t' 1 - eplus "
"d - 'Double_t' 1 - eminus d - 'Double_t' 1 - eparab "
"d - 'Double_t' 1 - globcc", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetFCN",503,G__G__MathCore_117_0_13, 89, -1, G__defined_typename("TVirtualFitter::FCNFunc_t"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetFitOption",1212,G__G__MathCore_117_0_14, 117, G__get_linked_tagnum(&G__G__MathCoreLN_Foption_t), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetMethodCall",1277,G__G__MathCore_117_0_15, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TMethodCall), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNumberTotalParameters",2465,G__G__MathCore_117_0_16, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetNumberFreeParameters",2335,G__G__MathCore_117_0_17, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetObjectFit",1178,G__G__MathCore_117_0_18, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TObject), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetParError",1101,G__G__MathCore_117_0_19, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 8, "i - 'Int_t' 0 - ipar", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetParameter",1217,G__G__MathCore_117_0_20, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 8, "i - 'Int_t' 0 - ipar", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetParameter",1217,G__G__MathCore_117_0_21, 105, -1, G__defined_typename("Int_t"), 0, 6, 1, 1, 8, 
"i - 'Int_t' 0 - ipar C - - 0 - name "
"d - 'Double_t' 1 - value d - 'Double_t' 1 - verr "
"d - 'Double_t' 1 - vlow d - 'Double_t' 1 - vhigh", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetParName",964,G__G__MathCore_117_0_22, 67, -1, -1, 0, 1, 1, 1, 9, "i - 'Int_t' 0 - ipar", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetStats",815,G__G__MathCore_117_0_23, 105, -1, G__defined_typename("Int_t"), 0, 5, 1, 1, 8, 
"d - 'Double_t' 1 - amin d - 'Double_t' 1 - edm "
"d - 'Double_t' 1 - errdef i - 'Int_t' 1 - nvpar "
"i - 'Int_t' 1 - nparx", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetSumLog",887,G__G__MathCore_117_0_24, 100, -1, G__defined_typename("Double_t"), 0, 1, 1, 1, 0, "i - 'Int_t' 0 - i", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetUserFunc",1099,G__G__MathCore_117_0_25, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TObject), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetXfirst",928,G__G__MathCore_117_0_26, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetXlast",812,G__G__MathCore_117_0_27, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetYfirst",929,G__G__MathCore_117_0_28, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetYlast",813,G__G__MathCore_117_0_29, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetZfirst",930,G__G__MathCore_117_0_30, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetZlast",814,G__G__MathCore_117_0_31, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("IsFixed",684,G__G__MathCore_117_0_32, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 8, "i - 'Int_t' 0 - ipar", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("PrintResults",1279,G__G__MathCore_117_0_33, 121, -1, -1, 0, 2, 1, 1, 8, 
"i - 'Int_t' 0 - level d - 'Double_t' 0 - amin", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("ReleaseParameter",1634,G__G__MathCore_117_0_34, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - ipar", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("SetCache",768,G__G__MathCore_117_0_35, 68, -1, G__defined_typename("Double_t"), 0, 2, 1, 1, 0, 
"i - 'Int_t' 0 - npoints i - 'Int_t' 0 - psize", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFCN",515,G__G__MathCore_117_0_36, 121, -1, -1, 0, 1, 1, 1, 0, "Y - - 0 - fcn", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFCN",515,G__G__MathCore_117_0_37, 121, -1, -1, 0, 1, 1, 1, 0, "1 - 'void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t)' 0 - fcn", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFitMethod",1200,G__G__MathCore_117_0_38, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - name", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("SetFitOption",1224,G__G__MathCore_117_0_39, 121, -1, -1, 0, 1, 1, 1, 0, "u 'Foption_t' - 0 - option", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetObjectFit",1190,G__G__MathCore_117_0_40, 121, -1, -1, 0, 1, 1, 1, 0, "U 'TObject' - 0 - obj", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetParameter",1229,G__G__MathCore_117_0_41, 105, -1, G__defined_typename("Int_t"), 0, 6, 1, 1, 0, 
"i - 'Int_t' 0 - ipar C - - 10 - parname "
"d - 'Double_t' 0 - value d - 'Double_t' 0 - verr "
"d - 'Double_t' 0 - vlow d - 'Double_t' 0 - vhigh", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("SetUserFunc",1111,G__G__MathCore_117_0_42, 121, -1, -1, 0, 1, 1, 1, 0, "U 'TObject' - 0 - userfunc", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetXfirst",940,G__G__MathCore_117_0_43, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - first", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetXlast",824,G__G__MathCore_117_0_44, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - last", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetYfirst",941,G__G__MathCore_117_0_45, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - first", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetYlast",825,G__G__MathCore_117_0_46, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - last", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetZfirst",942,G__G__MathCore_117_0_47, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - first", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetZlast",826,G__G__MathCore_117_0_48, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - last", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetFitter",910,G__G__MathCore_117_0_49, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TVirtualFitter), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TVirtualFitter* (*)())(&TVirtualFitter::GetFitter) ), 0);
   G__memfunc_setup("Fitter",622,G__G__MathCore_117_0_50, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TVirtualFitter), -1, 0, 2, 3, 1, 0, 
"U 'TObject' - 0 - obj i - 'Int_t' 0 '25' maxpar", (char*)NULL, (void*) G__func2void( (TVirtualFitter* (*)(TObject*, Int_t))(&TVirtualFitter::Fitter) ), 0);
   G__memfunc_setup("GetDefaultFitter",1619,G__G__MathCore_117_0_51, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualFitter::GetDefaultFitter) ), 0);
   G__memfunc_setup("GetMaxIterations",1640,G__G__MathCore_117_0_52, 105, -1, G__defined_typename("Int_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Int_t (*)())(&TVirtualFitter::GetMaxIterations) ), 0);
   G__memfunc_setup("GetErrorDef",1081,G__G__MathCore_117_0_53, 100, -1, G__defined_typename("Double_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Double_t (*)())(&TVirtualFitter::GetErrorDef) ), 0);
   G__memfunc_setup("GetPrecision",1228,G__G__MathCore_117_0_54, 100, -1, G__defined_typename("Double_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Double_t (*)())(&TVirtualFitter::GetPrecision) ), 0);
   G__memfunc_setup("SetDefaultFitter",1631,G__G__MathCore_117_0_55, 121, -1, -1, 0, 1, 3, 1, 0, "C - - 10 '\"\"' name", (char*)NULL, (void*) G__func2void( (void (*)(const char*))(&TVirtualFitter::SetDefaultFitter) ), 0);
   G__memfunc_setup("SetFitter",922,G__G__MathCore_117_0_56, 121, -1, -1, 0, 2, 3, 1, 0, 
"U 'TVirtualFitter' - 0 - fitter i - 'Int_t' 0 '25' maxpar", (char*)NULL, (void*) G__func2void( (void (*)(TVirtualFitter*, Int_t))(&TVirtualFitter::SetFitter) ), 0);
   G__memfunc_setup("SetMaxIterations",1652,G__G__MathCore_117_0_57, 121, -1, -1, 0, 1, 3, 1, 0, "i - 'Int_t' 0 '5000' niter", (char*)NULL, (void*) G__func2void( (void (*)(Int_t))(&TVirtualFitter::SetMaxIterations) ), 0);
   G__memfunc_setup("SetErrorDef",1093,G__G__MathCore_117_0_58, 121, -1, -1, 0, 1, 3, 1, 0, "d - 'Double_t' 0 '1' errdef", (char*)NULL, (void*) G__func2void( (void (*)(Double_t))(&TVirtualFitter::SetErrorDef) ), 0);
   G__memfunc_setup("SetPrecision",1240,G__G__MathCore_117_0_59, 121, -1, -1, 0, 1, 3, 1, 0, "d - 'Double_t' 0 '1e-6' prec", (char*)NULL, (void*) G__func2void( (void (*)(Double_t))(&TVirtualFitter::SetPrecision) ), 0);
   G__memfunc_setup("Class",502,G__G__MathCore_117_0_60, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TVirtualFitter::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__MathCore_117_0_61, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualFitter::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__MathCore_117_0_62, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TVirtualFitter::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__MathCore_117_0_63, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TVirtualFitter::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__MathCore_117_0_67, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__MathCore_117_0_68, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualFitter::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__MathCore_117_0_69, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TVirtualFitter::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__MathCore_117_0_70, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualFitter::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__MathCore_117_0_71, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TVirtualFitter::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~TVirtualFitter", 1575, G__G__MathCore_117_0_72, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTKDTreelEintcOdoublegR(void) {
   /* TKDTree<int,double> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR));
   G__memfunc_setup("TKDTree<int,double>",1759,G__G__MathCore_118_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TKDTree<int,double>",1759,G__G__MathCore_118_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR), -1, 0, 3, 1, 1, 0, 
"i - - 0 - npoints i - - 0 - ndim "
"h - 'UInt_t' 0 - bsize", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TKDTree<int,double>",1759,G__G__MathCore_118_0_3, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR), -1, 0, 4, 1, 1, 0, 
"i - - 0 - npoints i - - 0 - ndim "
"h - 'UInt_t' 0 - bsize D - - 2 - data", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Build",496,G__G__MathCore_118_0_4, 121, -1, -1, 0, 0, 1, 1, 0, "", "build the tree", (void*) NULL, 0);
   G__memfunc_setup("Distance",811,G__G__MathCore_118_0_5, 100, -1, G__defined_typename("Double_t"), 0, 3, 1, 1, 8, 
"D - - 10 - point i - - 0 - ind "
"i - 'Int_t' 0 '2' type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DistanceToNode",1396,G__G__MathCore_118_0_6, 121, -1, -1, 0, 5, 1, 1, 0, 
"D - - 10 - point i - - 0 - inode "
"d - - 1 - min d - - 1 - max "
"i - 'Int_t' 0 '2' type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetLeft",683,G__G__MathCore_118_0_7, 105, -1, G__defined_typename("Int_t"), 0, 1, 1, 1, 8, "i - 'Int_t' 0 - inode", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetRight",798,G__G__MathCore_118_0_8, 105, -1, G__defined_typename("Int_t"), 0, 1, 1, 1, 8, "i - 'Int_t' 0 - inode", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetParent",906,G__G__MathCore_118_0_9, 105, -1, G__defined_typename("Int_t"), 0, 1, 1, 1, 8, "i - 'Int_t' 0 - inode", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetPointsIndexes",1645,G__G__MathCore_118_0_10, 73, -1, -1, 0, 1, 1, 1, 8, "i - 'Int_t' 0 - node", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNodePointsIndexes",2035,G__G__MathCore_118_0_11, 121, -1, -1, 0, 5, 1, 1, 8, 
"i - 'Int_t' 0 - node i - 'Int_t' 1 - first1 "
"i - 'Int_t' 1 - last1 i - 'Int_t' 1 - first2 "
"i - 'Int_t' 1 - last2", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNodeAxis",1083,G__G__MathCore_118_0_12, 98, -1, G__defined_typename("UChar_t"), 0, 1, 1, 1, 8, "i - 'Int_t' 0 - id", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNodeValue",1187,G__G__MathCore_118_0_13, 100, -1, -1, 0, 1, 1, 1, 8, "i - 'Int_t' 0 - id", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNNodes",871,G__G__MathCore_118_0_14, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetTotalNodes",1309,G__G__MathCore_118_0_15, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBoundaries",1324,G__G__MathCore_118_0_16, 68, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBoundariesExact",1825,G__G__MathCore_118_0_17, 68, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBoundary",1124,G__G__MathCore_118_0_18, 68, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 10 - node", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBoundaryExact",1625,G__G__MathCore_118_0_19, 68, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 10 - node", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNPoints",1003,G__G__MathCore_118_0_20, 105, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNDim",648,G__G__MathCore_118_0_21, 105, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNPointsNode",1393,G__G__MathCore_118_0_22, 105, -1, -1, 0, 1, 1, 1, 8, "i - 'Int_t' 0 - node", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetRowT0",732,G__G__MathCore_118_0_23, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 0, "", "! smallest terminal row", (void*) NULL, 0);
   G__memfunc_setup("GetCrossNode",1200,G__G__MathCore_118_0_24, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 0, "", "! cross node", (void*) NULL, 0);
   G__memfunc_setup("GetOffset",903,G__G__MathCore_118_0_25, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 0, "", "! offset in fIndPoints", (void*) NULL, 0);
   G__memfunc_setup("GetIndPoints",1208,G__G__MathCore_118_0_26, 73, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBucketSize",1305,G__G__MathCore_118_0_27, 105, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FindNearestNeighbors",2036,G__G__MathCore_118_0_28, 121, -1, -1, 0, 4, 1, 1, 0, 
"D - - 10 - point i - 'Int_t' 10 - k "
"I - - 0 - ind D - - 0 - dist", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FindNode",775,G__G__MathCore_118_0_29, 105, -1, -1, 0, 1, 1, 1, 8, "D - - 10 - point", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FindPoint",907,G__G__MathCore_118_0_30, 121, -1, -1, 0, 3, 1, 1, 0, 
"D - - 0 - point i - - 1 - index "
"i - 'Int_t' 1 - iter", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FindInRange",1061,G__G__MathCore_118_0_31, 121, -1, -1, 0, 3, 1, 1, 0, 
"D - - 0 - point d - - 0 - range "
"u 'vector<int,allocator<int> >' 'vector<int>' 1 - res", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FindBNodeA",906,G__G__MathCore_118_0_32, 121, -1, -1, 0, 3, 1, 1, 0, 
"D - - 0 - point D - - 0 - delta "
"i - 'Int_t' 1 - inode", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsTerminal",1016,G__G__MathCore_118_0_33, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 8, "i - - 0 - inode", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsOwner",711,G__G__MathCore_118_0_34, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("KOrdStat",780,G__G__MathCore_118_0_35, 100, -1, -1, 0, 4, 1, 1, 8, 
"i - - 0 - ntotal D - - 0 - a "
"i - - 0 - k I - - 0 - index", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MakeBoundaries",1418,G__G__MathCore_118_0_36, 121, -1, -1, 0, 1, 1, 1, 0, "D - - 0 '0x0' range", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MakeBoundariesExact",1919,G__G__MathCore_118_0_37, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetData",678,G__G__MathCore_118_0_38, 121, -1, -1, 0, 4, 1, 1, 0, 
"i - - 0 - npoints i - - 0 - ndim "
"h - 'UInt_t' 0 - bsize D - - 2 - data", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetData",678,G__G__MathCore_118_0_39, 105, -1, G__defined_typename("Int_t"), 0, 2, 1, 1, 0, 
"i - - 0 - idim D - - 0 - data", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetOwner",823,G__G__MathCore_118_0_40, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - owner", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Spread",607,G__G__MathCore_118_0_41, 121, -1, -1, 0, 5, 1, 1, 8, 
"i - - 0 - ntotal D - - 0 - a "
"I - - 0 - index d - - 1 - min "
"d - - 1 - max", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TKDTree<int,double>",1759,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR), -1, 0, 1, 1, 4, 0, "u 'TKDTree<int,double>' - 11 - -", "not implemented", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR), -1, 1, 1, 1, 4, 0, "u 'TKDTree<int,double>' - 11 - -", "not implemented", (void*) NULL, 0);
   G__memfunc_setup("CookBoundaries",1432,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 2, 1, 4, 0, 
"i - 'Int_t' 10 - node g - 'Bool_t' 0 - left", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("UpdateNearestNeighbors",2262,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 5, 1, 4, 0, 
"i - - 0 - inode D - - 10 - point "
"i - 'Int_t' 0 - kNN I - - 0 - ind "
"D - - 0 - dist", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("UpdateRange",1104,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 4, 1, 4, 0, 
"i - - 0 - inode D - - 0 - point "
"d - - 0 - range u 'vector<int,allocator<int> >' 'vector<int>' 1 - res", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__G__MathCore_118_0_47, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TKDTree<int,double>::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__MathCore_118_0_48, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TKDTree<int,double>::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__MathCore_118_0_49, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TKDTree<int,double>::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__MathCore_118_0_50, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TKDTree<int,double>::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__MathCore_118_0_54, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__MathCore_118_0_55, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TKDTree<int,double>::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__MathCore_118_0_56, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TKDTree<int,double>::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__MathCore_118_0_57, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TKDTree<int,double>::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__MathCore_118_0_58, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TKDTree<int,double>::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~TKDTree<int,double>", 1885, G__G__MathCore_118_0_59, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTKDTreelEintcOfloatgR(void) {
   /* TKDTree<int,float> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR));
   G__memfunc_setup("TKDTree<int,float>",1658,G__G__MathCore_123_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TKDTree<int,float>",1658,G__G__MathCore_123_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR), -1, 0, 3, 1, 1, 0, 
"i - - 0 - npoints i - - 0 - ndim "
"h - 'UInt_t' 0 - bsize", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TKDTree<int,float>",1658,G__G__MathCore_123_0_3, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR), -1, 0, 4, 1, 1, 0, 
"i - - 0 - npoints i - - 0 - ndim "
"h - 'UInt_t' 0 - bsize F - - 2 - data", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Build",496,G__G__MathCore_123_0_4, 121, -1, -1, 0, 0, 1, 1, 0, "", "build the tree", (void*) NULL, 0);
   G__memfunc_setup("Distance",811,G__G__MathCore_123_0_5, 100, -1, G__defined_typename("Double_t"), 0, 3, 1, 1, 8, 
"F - - 10 - point i - - 0 - ind "
"i - 'Int_t' 0 '2' type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DistanceToNode",1396,G__G__MathCore_123_0_6, 121, -1, -1, 0, 5, 1, 1, 0, 
"F - - 10 - point i - - 0 - inode "
"f - - 1 - min f - - 1 - max "
"i - 'Int_t' 0 '2' type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetLeft",683,G__G__MathCore_123_0_7, 105, -1, G__defined_typename("Int_t"), 0, 1, 1, 1, 8, "i - 'Int_t' 0 - inode", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetRight",798,G__G__MathCore_123_0_8, 105, -1, G__defined_typename("Int_t"), 0, 1, 1, 1, 8, "i - 'Int_t' 0 - inode", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetParent",906,G__G__MathCore_123_0_9, 105, -1, G__defined_typename("Int_t"), 0, 1, 1, 1, 8, "i - 'Int_t' 0 - inode", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetPointsIndexes",1645,G__G__MathCore_123_0_10, 73, -1, -1, 0, 1, 1, 1, 8, "i - 'Int_t' 0 - node", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNodePointsIndexes",2035,G__G__MathCore_123_0_11, 121, -1, -1, 0, 5, 1, 1, 8, 
"i - 'Int_t' 0 - node i - 'Int_t' 1 - first1 "
"i - 'Int_t' 1 - last1 i - 'Int_t' 1 - first2 "
"i - 'Int_t' 1 - last2", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNodeAxis",1083,G__G__MathCore_123_0_12, 98, -1, G__defined_typename("UChar_t"), 0, 1, 1, 1, 8, "i - 'Int_t' 0 - id", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNodeValue",1187,G__G__MathCore_123_0_13, 102, -1, -1, 0, 1, 1, 1, 8, "i - 'Int_t' 0 - id", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNNodes",871,G__G__MathCore_123_0_14, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetTotalNodes",1309,G__G__MathCore_123_0_15, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBoundaries",1324,G__G__MathCore_123_0_16, 70, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBoundariesExact",1825,G__G__MathCore_123_0_17, 70, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBoundary",1124,G__G__MathCore_123_0_18, 70, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 10 - node", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBoundaryExact",1625,G__G__MathCore_123_0_19, 70, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 10 - node", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNPoints",1003,G__G__MathCore_123_0_20, 105, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNDim",648,G__G__MathCore_123_0_21, 105, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNPointsNode",1393,G__G__MathCore_123_0_22, 105, -1, -1, 0, 1, 1, 1, 8, "i - 'Int_t' 0 - node", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetRowT0",732,G__G__MathCore_123_0_23, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 0, "", "! smallest terminal row", (void*) NULL, 0);
   G__memfunc_setup("GetCrossNode",1200,G__G__MathCore_123_0_24, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 0, "", "! cross node", (void*) NULL, 0);
   G__memfunc_setup("GetOffset",903,G__G__MathCore_123_0_25, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 0, "", "! offset in fIndPoints", (void*) NULL, 0);
   G__memfunc_setup("GetIndPoints",1208,G__G__MathCore_123_0_26, 73, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetBucketSize",1305,G__G__MathCore_123_0_27, 105, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FindNearestNeighbors",2036,G__G__MathCore_123_0_28, 121, -1, -1, 0, 4, 1, 1, 0, 
"F - - 10 - point i - 'Int_t' 10 - k "
"I - - 0 - ind F - - 0 - dist", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FindNode",775,G__G__MathCore_123_0_29, 105, -1, -1, 0, 1, 1, 1, 8, "F - - 10 - point", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FindPoint",907,G__G__MathCore_123_0_30, 121, -1, -1, 0, 3, 1, 1, 0, 
"F - - 0 - point i - - 1 - index "
"i - 'Int_t' 1 - iter", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FindInRange",1061,G__G__MathCore_123_0_31, 121, -1, -1, 0, 3, 1, 1, 0, 
"F - - 0 - point f - - 0 - range "
"u 'vector<int,allocator<int> >' 'vector<int>' 1 - res", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FindBNodeA",906,G__G__MathCore_123_0_32, 121, -1, -1, 0, 3, 1, 1, 0, 
"F - - 0 - point F - - 0 - delta "
"i - 'Int_t' 1 - inode", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsTerminal",1016,G__G__MathCore_123_0_33, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 8, "i - - 0 - inode", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsOwner",711,G__G__MathCore_123_0_34, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("KOrdStat",780,G__G__MathCore_123_0_35, 102, -1, -1, 0, 4, 1, 1, 8, 
"i - - 0 - ntotal F - - 0 - a "
"i - - 0 - k I - - 0 - index", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MakeBoundaries",1418,G__G__MathCore_123_0_36, 121, -1, -1, 0, 1, 1, 1, 0, "F - - 0 '0x0' range", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MakeBoundariesExact",1919,G__G__MathCore_123_0_37, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetData",678,G__G__MathCore_123_0_38, 121, -1, -1, 0, 4, 1, 1, 0, 
"i - - 0 - npoints i - - 0 - ndim "
"h - 'UInt_t' 0 - bsize F - - 2 - data", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetData",678,G__G__MathCore_123_0_39, 105, -1, G__defined_typename("Int_t"), 0, 2, 1, 1, 0, 
"i - - 0 - idim F - - 0 - data", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetOwner",823,G__G__MathCore_123_0_40, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - owner", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Spread",607,G__G__MathCore_123_0_41, 121, -1, -1, 0, 5, 1, 1, 8, 
"i - - 0 - ntotal F - - 0 - a "
"I - - 0 - index f - - 1 - min "
"f - - 1 - max", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TKDTree<int,float>",1658,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR), -1, 0, 1, 1, 4, 0, "u 'TKDTree<int,float>' - 11 - -", "not implemented", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR), -1, 1, 1, 1, 4, 0, "u 'TKDTree<int,float>' - 11 - -", "not implemented", (void*) NULL, 0);
   G__memfunc_setup("CookBoundaries",1432,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 2, 1, 4, 0, 
"i - 'Int_t' 10 - node g - 'Bool_t' 0 - left", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("UpdateNearestNeighbors",2262,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 5, 1, 4, 0, 
"i - - 0 - inode F - - 10 - point "
"i - 'Int_t' 0 - kNN I - - 0 - ind "
"F - - 0 - dist", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("UpdateRange",1104,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 4, 1, 4, 0, 
"i - - 0 - inode F - - 0 - point "
"f - - 0 - range u 'vector<int,allocator<int> >' 'vector<int>' 1 - res", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__G__MathCore_123_0_47, 85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TKDTree<int,float>::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__MathCore_123_0_48, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TKDTree<int,float>::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__MathCore_123_0_49, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TKDTree<int,float>::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__MathCore_123_0_50, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TKDTree<int,float>::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathCoreLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__MathCore_123_0_54, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__MathCore_123_0_55, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TKDTree<int,float>::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__MathCore_123_0_56, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TKDTree<int,float>::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__MathCore_123_0_57, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TKDTree<int,float>::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__MathCore_123_0_58, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TKDTree<int,float>::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~TKDTree<int,float>", 1784, G__G__MathCore_123_0_59, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMath(void) {
   /* ROOT::Math */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath));
   G__memfunc_setup("MinimStep",918,G__G__MathCore_124_0_1, 100, -1, -1, 0, 6, 1, 1, 0, 
"U 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 10 - f i - - 0 - type "
"d - - 1 - xmin d - - 1 - xmax "
"d - - 0 - fy i - - 0 '100' fNpx", (char*)NULL, (void*) G__func2void( (double (*)(const ROOT::Math::IGenFunction*, int, double&, double&, double, int))(&ROOT::Math::MinimStep) ), 0);
   G__memfunc_setup("MinimBrent",1013,G__G__MathCore_124_0_2, 100, -1, -1, 0, 7, 1, 1, 0, 
"U 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 10 - f i - - 0 - type "
"d - - 1 - xmin d - - 1 - xmax "
"d - - 0 - xmiddle d - - 0 - fy "
"g - - 1 - ok", (char*)NULL, (void*) G__func2void( (double (*)(const ROOT::Math::IGenFunction*, int, double&, double&, double, double, bool&))(&ROOT::Math::MinimBrent) ), 0);
   G__memfunc_setup("erf",317,G__G__MathCore_124_0_3, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::erf) ), 0);
   G__memfunc_setup("erfc",416,G__G__MathCore_124_0_4, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::erfc) ), 0);
   G__memfunc_setup("tgamma",631,G__G__MathCore_124_0_5, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::tgamma) ), 0);
   G__memfunc_setup("lgamma",623,G__G__MathCore_124_0_6, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double))(&ROOT::Math::lgamma) ), 0);
   G__memfunc_setup("inc_gamma",924,G__G__MathCore_124_0_7, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::inc_gamma) ), 0);
   G__memfunc_setup("inc_gamma_c",1118,G__G__MathCore_124_0_8, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 - x", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::inc_gamma_c) ), 0);
   G__memfunc_setup("beta",412,G__G__MathCore_124_0_9, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - x d - - 0 - y", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::beta) ), 0);
   G__memfunc_setup("inc_beta",821,G__G__MathCore_124_0_10, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - a "
"d - - 0 - b", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::inc_beta) ), 0);
   G__memfunc_setup("beta_pdf",821,G__G__MathCore_124_0_11, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - a "
"d - - 0 - b", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::beta_pdf) ), 0);
   G__memfunc_setup("binomial_pdf",1252,G__G__MathCore_124_0_12, 100, -1, -1, 0, 3, 1, 1, 0, 
"h - - 0 - k d - - 0 - p "
"h - - 0 - n", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int, double, unsigned int))(&ROOT::Math::binomial_pdf) ), 0);
   G__memfunc_setup("breitwigner_pdf",1595,G__G__MathCore_124_0_13, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - gamma "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::breitwigner_pdf) ), 0);
   G__memfunc_setup("cauchy_pdf",1046,G__G__MathCore_124_0_14, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 '1' b "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::cauchy_pdf) ), 0);
   G__memfunc_setup("chisquared_pdf",1474,G__G__MathCore_124_0_15, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - r "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::chisquared_pdf) ), 0);
   G__memfunc_setup("exponential_pdf",1600,G__G__MathCore_124_0_16, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - lambda "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::exponential_pdf) ), 0);
   G__memfunc_setup("fdistribution_pdf",1823,G__G__MathCore_124_0_17, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - x d - - 0 - n "
"d - - 0 - m d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::fdistribution_pdf) ), 0);
   G__memfunc_setup("gamma_pdf",924,G__G__MathCore_124_0_18, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - x d - - 0 - alpha "
"d - - 0 - theta d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::gamma_pdf) ), 0);
   G__memfunc_setup("gaussian_pdf",1268,G__G__MathCore_124_0_19, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 '1' sigma "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::gaussian_pdf) ), 0);
   G__memfunc_setup("landau_pdf",1038,G__G__MathCore_124_0_20, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 '1' s "
"d - - 0 '0.' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::landau_pdf) ), 0);
   G__memfunc_setup("lognormal_pdf",1380,G__G__MathCore_124_0_21, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - x d - - 0 - m "
"d - - 0 - s d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::lognormal_pdf) ), 0);
   G__memfunc_setup("normal_pdf",1058,G__G__MathCore_124_0_22, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 '1' sigma "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::normal_pdf) ), 0);
   G__memfunc_setup("poisson_pdf",1188,G__G__MathCore_124_0_23, 100, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - n d - - 0 - mu", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int, double))(&ROOT::Math::poisson_pdf) ), 0);
   G__memfunc_setup("tdistribution_pdf",1837,G__G__MathCore_124_0_24, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - r "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::tdistribution_pdf) ), 0);
   G__memfunc_setup("uniform_pdf",1177,G__G__MathCore_124_0_25, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - x d - - 0 - a "
"d - - 0 - b d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::uniform_pdf) ), 0);
   G__memfunc_setup("beta_cdf_c",1002,G__G__MathCore_124_0_26, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - a "
"d - - 0 - b", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::beta_cdf_c) ), 0);
   G__memfunc_setup("beta_cdf",808,G__G__MathCore_124_0_27, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - a "
"d - - 0 - b", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::beta_cdf) ), 0);
   G__memfunc_setup("breitwigner_cdf_c",1776,G__G__MathCore_124_0_28, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - gamma "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::breitwigner_cdf_c) ), 0);
   G__memfunc_setup("breitwigner_cdf",1582,G__G__MathCore_124_0_29, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - gamma "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::breitwigner_cdf) ), 0);
   G__memfunc_setup("cauchy_cdf_c",1227,G__G__MathCore_124_0_30, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - b "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::cauchy_cdf_c) ), 0);
   G__memfunc_setup("cauchy_cdf",1033,G__G__MathCore_124_0_31, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - b "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::cauchy_cdf) ), 0);
   G__memfunc_setup("chisquared_cdf_c",1655,G__G__MathCore_124_0_32, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - r "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::chisquared_cdf_c) ), 0);
   G__memfunc_setup("chisquared_cdf",1461,G__G__MathCore_124_0_33, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - r "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::chisquared_cdf) ), 0);
   G__memfunc_setup("exponential_cdf_c",1781,G__G__MathCore_124_0_34, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - lambda "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::exponential_cdf_c) ), 0);
   G__memfunc_setup("exponential_cdf",1587,G__G__MathCore_124_0_35, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - lambda "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::exponential_cdf) ), 0);
   G__memfunc_setup("fdistribution_cdf_c",2004,G__G__MathCore_124_0_36, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - x d - - 0 - n "
"d - - 0 - m d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::fdistribution_cdf_c) ), 0);
   G__memfunc_setup("fdistribution_cdf",1810,G__G__MathCore_124_0_37, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - x d - - 0 - n "
"d - - 0 - m d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::fdistribution_cdf) ), 0);
   G__memfunc_setup("gamma_cdf_c",1105,G__G__MathCore_124_0_38, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - x d - - 0 - alpha "
"d - - 0 - theta d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::gamma_cdf_c) ), 0);
   G__memfunc_setup("gamma_cdf",911,G__G__MathCore_124_0_39, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - x d - - 0 - alpha "
"d - - 0 - theta d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::gamma_cdf) ), 0);
   G__memfunc_setup("landau_cdf",1025,G__G__MathCore_124_0_40, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 '1' sigma "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::landau_cdf) ), 0);
   G__memfunc_setup("landau_cdf_c",1219,G__G__MathCore_124_0_41, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 '1' sigma "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::landau_cdf_c) ), 0);
   G__memfunc_setup("lognormal_cdf_c",1561,G__G__MathCore_124_0_42, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - x d - - 0 - m "
"d - - 0 - s d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::lognormal_cdf_c) ), 0);
   G__memfunc_setup("lognormal_cdf",1367,G__G__MathCore_124_0_43, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - x d - - 0 - m "
"d - - 0 - s d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::lognormal_cdf) ), 0);
   G__memfunc_setup("normal_cdf_c",1239,G__G__MathCore_124_0_44, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 '1' sigma "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::normal_cdf_c) ), 0);
   G__memfunc_setup("gaussian_cdf_c",1449,G__G__MathCore_124_0_45, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 '1' sigma "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::gaussian_cdf_c) ), 0);
   G__memfunc_setup("normal_cdf",1045,G__G__MathCore_124_0_46, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 '1' sigma "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::normal_cdf) ), 0);
   G__memfunc_setup("gaussian_cdf",1255,G__G__MathCore_124_0_47, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 '1' sigma "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::gaussian_cdf) ), 0);
   G__memfunc_setup("tdistribution_cdf_c",2018,G__G__MathCore_124_0_48, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - r "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::tdistribution_cdf_c) ), 0);
   G__memfunc_setup("tdistribution_cdf",1824,G__G__MathCore_124_0_49, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - r "
"d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::tdistribution_cdf) ), 0);
   G__memfunc_setup("uniform_cdf_c",1358,G__G__MathCore_124_0_50, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - x d - - 0 - a "
"d - - 0 - b d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::uniform_cdf_c) ), 0);
   G__memfunc_setup("uniform_cdf",1164,G__G__MathCore_124_0_51, 100, -1, -1, 0, 4, 1, 1, 0, 
"d - - 0 - x d - - 0 - a "
"d - - 0 - b d - - 0 '0' x0", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double, double))(&ROOT::Math::uniform_cdf) ), 0);
   G__memfunc_setup("poisson_cdf_c",1369,G__G__MathCore_124_0_52, 100, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - n d - - 0 - mu", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int, double))(&ROOT::Math::poisson_cdf_c) ), 0);
   G__memfunc_setup("poisson_cdf",1175,G__G__MathCore_124_0_53, 100, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - n d - - 0 - mu", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int, double))(&ROOT::Math::poisson_cdf) ), 0);
   G__memfunc_setup("binomial_cdf_c",1433,G__G__MathCore_124_0_54, 100, -1, -1, 0, 3, 1, 1, 0, 
"h - - 0 - k d - - 0 - p "
"h - - 0 - n", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int, double, unsigned int))(&ROOT::Math::binomial_cdf_c) ), 0);
   G__memfunc_setup("binomial_cdf",1239,G__G__MathCore_124_0_55, 100, -1, -1, 0, 3, 1, 1, 0, 
"h - - 0 - k d - - 0 - p "
"h - - 0 - n", (char*)NULL, (void*) G__func2void( (double (*)(unsigned int, double, unsigned int))(&ROOT::Math::binomial_cdf) ), 0);
   G__memfunc_setup("beta_quantile",1374,G__G__MathCore_124_0_56, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - a "
"d - - 0 - b", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::beta_quantile) ), 0);
   G__memfunc_setup("beta_quantile_c",1568,G__G__MathCore_124_0_57, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - a "
"d - - 0 - b", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::beta_quantile_c) ), 0);
   G__memfunc_setup("cauchy_quantile_c",1793,G__G__MathCore_124_0_58, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - b", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::cauchy_quantile_c) ), 0);
   G__memfunc_setup("cauchy_quantile",1599,G__G__MathCore_124_0_59, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - b", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::cauchy_quantile) ), 0);
   G__memfunc_setup("breitwigner_quantile_c",2342,G__G__MathCore_124_0_60, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - gamma", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::breitwigner_quantile_c) ), 0);
   G__memfunc_setup("breitwigner_quantile",2148,G__G__MathCore_124_0_61, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - gamma", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::breitwigner_quantile) ), 0);
   G__memfunc_setup("chisquared_quantile_c",2221,G__G__MathCore_124_0_62, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - r", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::chisquared_quantile_c) ), 0);
   G__memfunc_setup("chisquared_quantile",2027,G__G__MathCore_124_0_63, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - r", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::chisquared_quantile) ), 0);
   G__memfunc_setup("exponential_quantile_c",2347,G__G__MathCore_124_0_64, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - lambda", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::exponential_quantile_c) ), 0);
   G__memfunc_setup("exponential_quantile",2153,G__G__MathCore_124_0_65, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - lambda", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::exponential_quantile) ), 0);
   G__memfunc_setup("fdistribution_quantile",2376,G__G__MathCore_124_0_66, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - z d - - 0 - n "
"d - - 0 - m", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::fdistribution_quantile) ), 0);
   G__memfunc_setup("fdistribution_quantile_c",2570,G__G__MathCore_124_0_67, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - z d - - 0 - n "
"d - - 0 - m", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::fdistribution_quantile_c) ), 0);
   G__memfunc_setup("gamma_quantile_c",1671,G__G__MathCore_124_0_68, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - z d - - 0 - alpha "
"d - - 0 - theta", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::gamma_quantile_c) ), 0);
   G__memfunc_setup("gamma_quantile",1477,G__G__MathCore_124_0_69, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - z d - - 0 - alpha "
"d - - 0 - theta", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::gamma_quantile) ), 0);
   G__memfunc_setup("gaussian_quantile_c",2015,G__G__MathCore_124_0_70, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - sigma", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::gaussian_quantile_c) ), 0);
   G__memfunc_setup("gaussian_quantile",1821,G__G__MathCore_124_0_71, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - sigma", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::gaussian_quantile) ), 0);
   G__memfunc_setup("lognormal_quantile_c",2127,G__G__MathCore_124_0_72, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - m "
"d - - 0 - s", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::lognormal_quantile_c) ), 0);
   G__memfunc_setup("lognormal_quantile",1933,G__G__MathCore_124_0_73, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - m "
"d - - 0 - s", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::lognormal_quantile) ), 0);
   G__memfunc_setup("normal_quantile_c",1805,G__G__MathCore_124_0_74, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - sigma", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::normal_quantile_c) ), 0);
   G__memfunc_setup("normal_quantile",1611,G__G__MathCore_124_0_75, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - z d - - 0 - sigma", (char*)NULL, (void*) G__func2void( (double (*)(double, double))(&ROOT::Math::normal_quantile) ), 0);
   G__memfunc_setup("uniform_quantile_c",1924,G__G__MathCore_124_0_76, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - z d - - 0 - a "
"d - - 0 - b", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::uniform_quantile_c) ), 0);
   G__memfunc_setup("uniform_quantile",1730,G__G__MathCore_124_0_77, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - z d - - 0 - a "
"d - - 0 - b", (char*)NULL, (void*) G__func2void( (double (*)(double, double, double))(&ROOT::Math::uniform_quantile) ), 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIBaseFunctionOneDim(void) {
   /* ROOT::Math::IBaseFunctionOneDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim));
   G__memfunc_setup("Clone",497,G__G__MathCore_125_0_2, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("operator()",957,G__G__MathCore_125_0_3, 100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator()",957,G__G__MathCore_125_0_4, 100, -1, -1, 0, 1, 1, 1, 8, "D - - 10 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DoEval",571,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 4, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 3);
   // automatic destructor
   G__memfunc_setup("~IBaseFunctionOneDim", 1988, G__G__MathCore_125_0_6, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_125_0_7, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionOneDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIGradientFunctionOneDim(void) {
   /* ROOT::Math::IGradientFunctionOneDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim));
   G__memfunc_setup("FdF",240,(G__InterfaceMethod) NULL,121, -1, -1, 0, 3, 1, 1, 8, 
"d - - 0 - x d - - 1 - f "
"d - - 1 - df", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~IGradientFunctionOneDim", 2423, G__G__MathCore_126_0_2, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_126_0_3, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IGradientFunctionOneDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIBaseFunctionMultiDim(void) {
   /* ROOT::Math::IBaseFunctionMultiDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim));
   G__memfunc_setup("Clone",497,G__G__MathCore_127_0_2, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("NDim",360,G__G__MathCore_127_0_3, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("operator()",957,G__G__MathCore_127_0_4, 100, -1, -1, 0, 1, 1, 1, 8, "D - - 10 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DoEval",571,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 4, 8, "D - - 10 - x", (char*)NULL, (void*) NULL, 3);
   // automatic destructor
   G__memfunc_setup("~IBaseFunctionMultiDim", 2221, G__G__MathCore_127_0_6, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_127_0_7, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionMultiDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIGradientFunctionMultiDim(void) {
   /* ROOT::Math::IGradientFunctionMultiDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim));
   G__memfunc_setup("Gradient",814,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 8, 
"D - - 10 - x D - - 0 - grad", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("FdF",240,(G__InterfaceMethod) NULL,121, -1, -1, 0, 3, 1, 1, 8, 
"D - - 10 - x d - - 1 - f "
"D - - 0 - df", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~IGradientFunctionMultiDim", 2656, G__G__MathCore_128_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_128_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IGradientFunctionMultiDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIGradientMultiDim(void) {
   /* ROOT::Math::IGradientMultiDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientMultiDim));
   G__memfunc_setup("Gradient",814,G__G__MathCore_129_0_1, 121, -1, -1, 0, 2, 1, 1, 8, 
"D - - 10 - x D - - 0 - grad", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Derivative",1043,G__G__MathCore_129_0_2, 100, -1, -1, 0, 2, 1, 1, 8, 
"D - - 10 - x h - - 0 '0' icoord", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FdF",240,G__G__MathCore_129_0_3, 121, -1, -1, 0, 3, 1, 1, 8, 
"D - - 10 - x d - - 1 - f "
"D - - 0 - df", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("DoDerivative",1222,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 2, 1, 4, 8, 
"D - - 10 - x h - - 0 - icoord", (char*)NULL, (void*) NULL, 3);
   // automatic destructor
   G__memfunc_setup("~IGradientMultiDim", 1818, G__G__MathCore_129_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_129_0_6, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientMultiDim), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IGradientMultiDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIGradientOneDim(void) {
   /* ROOT::Math::IGradientOneDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientOneDim));
   G__memfunc_setup("Derivative",1043,G__G__MathCore_130_0_1, 100, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FdF",240,G__G__MathCore_130_0_2, 121, -1, -1, 0, 3, 1, 1, 8, 
"d - - 0 - x d - - 1 - f "
"d - - 1 - df", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Derivative",1043,G__G__MathCore_130_0_3, 100, -1, -1, 0, 1, 1, 1, 8, "D - - 10 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gradient",814,G__G__MathCore_130_0_4, 121, -1, -1, 0, 2, 1, 1, 8, 
"D - - 10 - x D - - 0 - g", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FdF",240,G__G__MathCore_130_0_5, 121, -1, -1, 0, 3, 1, 1, 8, 
"D - - 10 - x d - - 1 - f "
"D - - 0 - df", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DoDerivative",1222,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 4, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 3);
   // automatic destructor
   G__memfunc_setup("~IGradientOneDim", 1585, G__G__MathCore_130_0_7, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_130_0_8, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientOneDim), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IGradientOneDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIParametricFunctionOneDim(void) {
   /* ROOT::Math::IParametricFunctionOneDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim));
   G__memfunc_setup("operator()",957,G__G__MathCore_131_0_1, 100, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - x D - - 10 - p", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator()",957,G__G__MathCore_131_0_2, 100, -1, -1, 0, 2, 1, 1, 0, 
"D - - 10 - x D - - 10 - p", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DoEvalPar",862,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 2, 1, 4, 8, 
"d - - 0 - x D - - 10 - p", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("DoEval",571,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 4, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~IParametricFunctionOneDim", 2641, G__G__MathCore_131_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_131_0_6, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IParametricFunctionOneDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIParametricGradFunctionOneDim(void) {
   /* ROOT::Math::IParametricGradFunctionOneDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim));
   G__memfunc_setup("ParameterGradient",1743,G__G__MathCore_132_0_1, 121, -1, -1, 0, 3, 1, 1, 8, 
"d - - 0 - x D - - 10 - p "
"D - - 0 - grad", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ParameterGradient",1743,G__G__MathCore_132_0_2, 121, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - x D - - 0 - grad", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ParameterGradient",1743,G__G__MathCore_132_0_3, 121, -1, -1, 0, 3, 1, 1, 8, 
"D - - 10 - x D - - 10 - p "
"D - - 0 - grad", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ParameterGradient",1743,G__G__MathCore_132_0_4, 121, -1, -1, 0, 2, 1, 1, 8, 
"D - - 10 - x D - - 0 - grad", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ParameterDerivative",1972,G__G__MathCore_132_0_5, 100, -1, -1, 0, 3, 1, 1, 8, 
"d - - 0 - x D - - 10 - p "
"h - - 0 '0' ipar", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ParameterDerivative",1972,G__G__MathCore_132_0_6, 100, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - x h - - 0 '0' ipar", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ParameterDerivative",1972,G__G__MathCore_132_0_7, 100, -1, -1, 0, 3, 1, 1, 8, 
"D - - 10 - x D - - 10 - p "
"h - - 0 '0' ipar", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ParameterDerivative",1972,G__G__MathCore_132_0_8, 100, -1, -1, 0, 2, 1, 1, 8, 
"D - - 10 - x h - - 0 '0' ipar", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DoParameterDerivative",2151,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 3, 1, 4, 8, 
"d - - 0 - x D - - 10 - p "
"h - - 0 - ipar", (char*)NULL, (void*) NULL, 3);
   // automatic destructor
   G__memfunc_setup("~IParametricGradFunctionOneDim", 3023, G__G__MathCore_132_0_10, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_132_0_11, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IParametricGradFunctionOneDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIParametricFunctionMultiDim(void) {
   /* ROOT::Math::IParametricFunctionMultiDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim));
   G__memfunc_setup("operator()",957,G__G__MathCore_133_0_1, 100, -1, -1, 0, 2, 1, 1, 8, 
"D - - 10 - x D - - 10 - p", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DoEvalPar",862,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 2, 1, 4, 8, 
"D - - 10 - x D - - 10 - p", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("DoEval",571,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 4, 8, "D - - 10 - x", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~IParametricFunctionMultiDim", 2874, G__G__MathCore_133_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_133_0_5, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IParametricFunctionMultiDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIParametricGradFunctionMultiDim(void) {
   /* ROOT::Math::IParametricGradFunctionMultiDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim));
   G__memfunc_setup("ParameterGradient",1743,G__G__MathCore_134_0_1, 121, -1, -1, 0, 3, 1, 1, 8, 
"D - - 10 - x D - - 10 - p "
"D - - 0 - grad", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ParameterDerivative",1972,G__G__MathCore_134_0_2, 100, -1, -1, 0, 3, 1, 1, 8, 
"D - - 10 - x D - - 10 - p "
"h - - 0 '0' ipar", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ParameterGradient",1743,G__G__MathCore_134_0_3, 121, -1, -1, 0, 2, 1, 1, 8, 
"D - - 10 - x D - - 0 - grad", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ParameterDerivative",1972,G__G__MathCore_134_0_4, 100, -1, -1, 0, 2, 1, 1, 8, 
"D - - 10 - x h - - 0 '0' ipar", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DoParameterDerivative",2151,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 3, 1, 4, 8, 
"D - - 10 - x D - - 10 - p "
"h - - 0 - ipar", (char*)NULL, (void*) NULL, 3);
   // automatic destructor
   G__memfunc_setup("~IParametricGradFunctionMultiDim", 3256, G__G__MathCore_134_0_6, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_134_0_7, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IParametricGradFunctionMultiDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIBaseParam(void) {
   /* ROOT::Math::IBaseParam */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseParam));
   G__memfunc_setup("Parameters",1044,G__G__MathCore_136_0_1, 68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("SetParameters",1344,G__G__MathCore_136_0_2, 121, -1, -1, 0, 1, 1, 1, 0, "D - - 10 - p", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("NPar",369,G__G__MathCore_136_0_3, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("ParameterName",1314,G__G__MathCore_136_0_4, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 0, 1, 1, 1, 8, "h - - 0 - i", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~IBaseParam", 1075, G__G__MathCore_136_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_136_0_6, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseParam), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IBaseParam' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLParamFunctor(void) {
   /* ROOT::Math::ParamFunctor */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor));
   G__memfunc_setup("ParamFunctor",1234,G__G__MathCore_138_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ParamFunctor",1234,G__G__MathCore_138_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor), -1, 0, 1, 1, 1, 0, "Y - 'ROOT::Math::ParamFunctor::FreeFunc' 0 - f", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ParamFunctor",1234,G__G__MathCore_138_0_3, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::ParamFunctor' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__MathCore_138_0_4, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::ParamFunctor' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetImpl",690,G__G__MathCore_138_0_5, 89, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator()",957,G__G__MathCore_138_0_6, 100, -1, -1, 0, 2, 1, 1, 0, 
"D - - 0 - x D - - 0 - p", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Empty",527,G__G__MathCore_138_0_7, 103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_138_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "U 'ROOT::Math::ParamFunctionBase' 'ROOT::Math::ParamFunctor::Impl' 0 - f", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ParamFunctor", 1360, G__G__MathCore_138_0_9, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLFunctor(void) {
   /* ROOT::Math::Functor */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor));
   G__memfunc_setup("Functor",737,G__G__MathCore_139_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Functor",737,G__G__MathCore_139_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor), -1, 0, 4, 1, 1, 0, 
"Y - - 0 - p h - - 0 - dim "
"C - - 10 '0' className C - - 10 '0' methodName", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__MathCore_139_0_3, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::Functor' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim), G__defined_typename("ROOT::Math::Functor::ImplBase"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NDim",360,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoEval",571,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 4, 8, "D - - 10 - x", (char*)NULL, (void*) NULL, 1);
   // automatic copy constructor
   G__memfunc_setup("Functor", 737, G__G__MathCore_139_0_7, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::Functor' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Functor", 863, G__G__MathCore_139_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLFunctor1D(void) {
   /* ROOT::Math::Functor1D */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D));
   G__memfunc_setup("Functor1D",854,G__G__MathCore_141_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Functor1D",854,G__G__MathCore_141_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D), -1, 0, 3, 1, 1, 0, 
"Y - - 0 - p C - - 10 '0' className "
"C - - 10 '0' methodName", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__MathCore_141_0_3, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::Functor1D' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim), G__defined_typename("ROOT::Math::Functor1D::ImplBase"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoEval",571,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 4, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 1);
   // automatic copy constructor
   G__memfunc_setup("Functor1D", 854, G__G__MathCore_141_0_6, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::Functor1D' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Functor1D", 980, G__G__MathCore_141_0_7, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGradFunctor(void) {
   /* ROOT::Math::GradFunctor */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor));
   G__memfunc_setup("GradFunctor",1119,G__G__MathCore_143_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GradFunctor",1119,G__G__MathCore_143_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor), -1, 0, 5, 1, 1, 0, 
"Y - - 0 - p1 h - - 0 - dim "
"C - - 10 - className C - - 10 - methodName "
"C - - 10 - derivName", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GradFunctor",1119,G__G__MathCore_143_0_3, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor), -1, 0, 3, 1, 1, 0, 
"Y - - 0 - p1 Y - - 0 - p2 "
"h - - 0 - dim", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__MathCore_143_0_4, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::GradFunctor' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim), G__defined_typename("ROOT::Math::GradFunctor::ImplBase"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NDim",360,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoEval",571,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 4, 8, "D - - 10 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoDerivative",1222,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 2, 1, 4, 8, 
"D - - 10 - x h - - 0 - icoord", (char*)NULL, (void*) NULL, 1);
   // automatic copy constructor
   G__memfunc_setup("GradFunctor", 1119, G__G__MathCore_143_0_9, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::GradFunctor' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GradFunctor", 1245, G__G__MathCore_143_0_10, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGradFunctor1D(void) {
   /* ROOT::Math::GradFunctor1D */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D));
   G__memfunc_setup("GradFunctor1D",1236,G__G__MathCore_145_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GradFunctor1D",1236,G__G__MathCore_145_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D), -1, 0, 4, 1, 1, 0, 
"Y - - 0 - p1 C - - 10 - className "
"C - - 10 - methodName C - - 10 - derivName", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GradFunctor1D",1236,G__G__MathCore_145_0_3, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D), -1, 0, 2, 1, 1, 0, 
"Y - - 0 - p1 Y - - 0 - p2", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__MathCore_145_0_4, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::GradFunctor1D' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim), G__defined_typename("ROOT::Math::GradFunctor1D::ImplBase"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoEval",571,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 4, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DoDerivative",1222,(G__InterfaceMethod) NULL, 100, -1, -1, 0, 1, 1, 4, 8, "d - - 0 - x", (char*)NULL, (void*) NULL, 1);
   // automatic copy constructor
   G__memfunc_setup("GradFunctor1D", 1236, G__G__MathCore_145_0_8, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::GradFunctor1D' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GradFunctor1D", 1362, G__G__MathCore_145_0_9, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLMinimizer(void) {
   /* ROOT::Math::Minimizer */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizer));
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizer), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::Minimizer' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clear",487,G__G__MathCore_147_0_4, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_147_0_5, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - func", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_147_0_6, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IGradientFunctionMultiDim' 'ROOT::Math::IMultiGradFunction' 11 - func", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetVariable",1106,G__G__MathCore_147_0_7, 103, -1, -1, 0, 4, 1, 1, 0, 
"h - - 0 - ivar u 'string' - 11 - name "
"d - - 0 - val d - - 0 - step", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("SetLowerLimitedVariable",2339,G__G__MathCore_147_0_8, 103, -1, -1, 0, 5, 1, 1, 0, 
"h - - 0 - ivar u 'string' - 11 - name "
"d - - 0 - val d - - 0 - step "
"d - - 0 - lower", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetUpperLimitedVariable",2342,G__G__MathCore_147_0_9, 103, -1, -1, 0, 5, 1, 1, 0, 
"h - - 0 - ivar u 'string' - 11 - name "
"d - - 0 - val d - - 0 - step "
"d - - 0 - upper", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetLimitedVariable",1818,G__G__MathCore_147_0_10, 103, -1, -1, 0, 6, 1, 1, 0, 
"h - - 0 - - u 'string' - 11 - - "
"d - - 0 - - d - - 0 - - "
"d - - 0 - - d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFixedVariable",1602,G__G__MathCore_147_0_11, 103, -1, -1, 0, 3, 1, 1, 0, 
"h - - 0 - - u 'string' - 11 - - "
"d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetVariableValue",1615,G__G__MathCore_147_0_12, 103, -1, -1, 0, 2, 1, 1, 0, 
"h - - 0 - - d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetVariableValues",1730,G__G__MathCore_147_0_13, 103, -1, -1, 0, 1, 1, 1, 0, "D - - 10 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Minimize",834,G__G__MathCore_147_0_14, 103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("MinValue",801,G__G__MathCore_147_0_15, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Edm",278,G__G__MathCore_147_0_16, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("X",88,G__G__MathCore_147_0_17, 68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("MinGradient",1106,G__G__MathCore_147_0_18, 68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("NCalls",573,G__G__MathCore_147_0_19, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("NDim",360,G__G__MathCore_147_0_20, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("NFree",464,G__G__MathCore_147_0_21, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("ProvidesError",1366,G__G__MathCore_147_0_22, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Errors",637,G__G__MathCore_147_0_23, 68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("CovMatrix",925,G__G__MathCore_147_0_24, 100, -1, -1, 0, 2, 1, 1, 8, 
"h - - 0 - i h - - 0 - j", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("CovMatrixStatus",1569,G__G__MathCore_147_0_25, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Correlation",1154,G__G__MathCore_147_0_26, 100, -1, -1, 0, 2, 1, 1, 8, 
"h - - 0 - i h - - 0 - j", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GlobalCC",727,G__G__MathCore_147_0_27, 100, -1, -1, 0, 1, 1, 1, 8, "h - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetMinosError",1328,G__G__MathCore_147_0_28, 103, -1, -1, 0, 4, 1, 1, 0, 
"h - - 0 - - d - - 1 - errLow "
"d - - 1 - errUp i - - 0 '0' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Hesse",504,G__G__MathCore_147_0_29, 103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Scan",389,G__G__MathCore_147_0_30, 103, -1, -1, 0, 6, 1, 1, 0, 
"h - - 0 - - h - - 1 - - "
"D - - 0 - - D - - 0 - - "
"d - - 0 '0' - d - - 0 '0' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Contour",746,G__G__MathCore_147_0_31, 103, -1, -1, 0, 5, 1, 1, 0, 
"h - - 0 - - h - - 0 - - "
"h - - 1 - - D - - 0 - - "
"D - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("PrintResults",1279,G__G__MathCore_147_0_32, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("VariableName",1191,G__G__MathCore_147_0_33, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 0, 1, 1, 1, 8, "h - - 0 - -", "return empty string ", (void*) NULL, 1);
   G__memfunc_setup("VariableIndex",1310,G__G__MathCore_147_0_34, 105, -1, -1, 0, 1, 1, 1, 8, "u 'string' - 11 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("PrintLevel",1029,G__G__MathCore_147_0_35, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MaxFunctionCalls",1627,G__G__MathCore_147_0_36, 104, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MaxIterations",1352,G__G__MathCore_147_0_37, 104, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Tolerance",925,G__G__MathCore_147_0_38, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Precision",940,G__G__MathCore_147_0_39, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Strategy",851,G__G__MathCore_147_0_40, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Status",644,G__G__MathCore_147_0_41, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ErrorDef",793,G__G__MathCore_147_0_42, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsValidError",1206,G__G__MathCore_147_0_43, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPrintLevel",1329,G__G__MathCore_147_0_44, 121, -1, -1, 0, 1, 1, 1, 0, "i - - 0 - level", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetMaxFunctionCalls",1927,G__G__MathCore_147_0_45, 121, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - maxfcn", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetMaxIterations",1652,G__G__MathCore_147_0_46, 121, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - maxiter", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetTolerance",1225,G__G__MathCore_147_0_47, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - tol", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPrecision",1240,G__G__MathCore_147_0_48, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - prec", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetStrategy",1151,G__G__MathCore_147_0_49, 121, -1, -1, 0, 1, 1, 1, 0, "i - - 0 - strategyLevel", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetErrorDef",1093,G__G__MathCore_147_0_50, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - up", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetValidError",1318,G__G__MathCore_147_0_51, 121, -1, -1, 0, 1, 1, 1, 0, "g - - 0 - on", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Minimizer", 1074, G__G__MathCore_147_0_52, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLMinimizerOptions(void) {
   /* ROOT::Math::MinimizerOptions */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizerOptions));
   G__memfunc_setup("SetDefaultMinimizer",1957,G__G__MathCore_148_0_1, 121, -1, -1, 0, 2, 3, 1, 0, 
"C - - 10 - type C - - 10 '0' algo", (char*)NULL, (void*) G__func2void( (void (*)(const char*, const char*))(&ROOT::Math::MinimizerOptions::SetDefaultMinimizer) ), 0);
   G__memfunc_setup("SetDefaultErrorDef",1802,G__G__MathCore_148_0_2, 121, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - up", (char*)NULL, (void*) G__func2void( (void (*)(double))(&ROOT::Math::MinimizerOptions::SetDefaultErrorDef) ), 0);
   G__memfunc_setup("SetDefaultTolerance",1934,G__G__MathCore_148_0_3, 121, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - tol", (char*)NULL, (void*) G__func2void( (void (*)(double))(&ROOT::Math::MinimizerOptions::SetDefaultTolerance) ), 0);
   G__memfunc_setup("SetDefaultPrecision",1949,G__G__MathCore_148_0_4, 121, -1, -1, 0, 1, 3, 1, 0, "d - - 0 - prec", (char*)NULL, (void*) G__func2void( (void (*)(double))(&ROOT::Math::MinimizerOptions::SetDefaultPrecision) ), 0);
   G__memfunc_setup("SetDefaultMaxFunctionCalls",2636,G__G__MathCore_148_0_5, 121, -1, -1, 0, 1, 3, 1, 0, "i - - 0 - maxcall", (char*)NULL, (void*) G__func2void( (void (*)(int))(&ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls) ), 0);
   G__memfunc_setup("SetDefaultMaxIterations",2361,G__G__MathCore_148_0_6, 121, -1, -1, 0, 1, 3, 1, 0, "i - - 0 - maxiter", (char*)NULL, (void*) G__func2void( (void (*)(int))(&ROOT::Math::MinimizerOptions::SetDefaultMaxIterations) ), 0);
   G__memfunc_setup("SetDefaultStrategy",1860,G__G__MathCore_148_0_7, 121, -1, -1, 0, 1, 3, 1, 0, "i - - 0 - strat", (char*)NULL, (void*) G__func2void( (void (*)(int))(&ROOT::Math::MinimizerOptions::SetDefaultStrategy) ), 0);
   G__memfunc_setup("SetDefaultPrintLevel",2038,G__G__MathCore_148_0_8, 121, -1, -1, 0, 1, 3, 1, 0, "i - - 0 - level", (char*)NULL, (void*) G__func2void( (void (*)(int))(&ROOT::Math::MinimizerOptions::SetDefaultPrintLevel) ), 0);
   G__memfunc_setup("DefaultMinimizerType",2075,G__G__MathCore_148_0_9, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const string& (*)())(&ROOT::Math::MinimizerOptions::DefaultMinimizerType) ), 0);
   G__memfunc_setup("DefaultMinimizerAlgo",2044,G__G__MathCore_148_0_10, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const string& (*)())(&ROOT::Math::MinimizerOptions::DefaultMinimizerAlgo) ), 0);
   G__memfunc_setup("DefaultErrorDef",1502,G__G__MathCore_148_0_11, 100, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (double (*)())(&ROOT::Math::MinimizerOptions::DefaultErrorDef) ), 0);
   G__memfunc_setup("DefaultTolerance",1634,G__G__MathCore_148_0_12, 100, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (double (*)())(&ROOT::Math::MinimizerOptions::DefaultTolerance) ), 0);
   G__memfunc_setup("DefaultPrecision",1649,G__G__MathCore_148_0_13, 100, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (double (*)())(&ROOT::Math::MinimizerOptions::DefaultPrecision) ), 0);
   G__memfunc_setup("DefaultMaxFunctionCalls",2336,G__G__MathCore_148_0_14, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ROOT::Math::MinimizerOptions::DefaultMaxFunctionCalls) ), 0);
   G__memfunc_setup("DefaultMaxIterations",2061,G__G__MathCore_148_0_15, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ROOT::Math::MinimizerOptions::DefaultMaxIterations) ), 0);
   G__memfunc_setup("DefaultStrategy",1560,G__G__MathCore_148_0_16, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ROOT::Math::MinimizerOptions::DefaultStrategy) ), 0);
   G__memfunc_setup("DefaultPrintLevel",1738,G__G__MathCore_148_0_17, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&ROOT::Math::MinimizerOptions::DefaultPrintLevel) ), 0);
   G__memfunc_setup("MinimizerOptions",1696,G__G__MathCore_148_0_18, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizerOptions), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PrintLevel",1029,G__G__MathCore_148_0_19, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MaxFunctionCalls",1627,G__G__MathCore_148_0_20, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MaxIterations",1352,G__G__MathCore_148_0_21, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Strategy",851,G__G__MathCore_148_0_22, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Tolerance",925,G__G__MathCore_148_0_23, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Precision",940,G__G__MathCore_148_0_24, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ErrorDef",793,G__G__MathCore_148_0_25, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MinimizerType",1366,G__G__MathCore_148_0_26, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MinimizerAlgorithm",1883,G__G__MathCore_148_0_27, 117, G__get_linked_tagnum(&G__G__MathCoreLN_string), -1, 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPrintLevel",1329,G__G__MathCore_148_0_28, 121, -1, -1, 0, 1, 1, 1, 0, "i - - 0 - level", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetMaxFunctionCalls",1927,G__G__MathCore_148_0_29, 121, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - maxfcn", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetMaxIterations",1652,G__G__MathCore_148_0_30, 121, -1, -1, 0, 1, 1, 1, 0, "h - - 0 - maxiter", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetTolerance",1225,G__G__MathCore_148_0_31, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - tol", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPrecision",1240,G__G__MathCore_148_0_32, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - prec", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetStrategy",1151,G__G__MathCore_148_0_33, 121, -1, -1, 0, 1, 1, 1, 0, "i - - 0 - stra", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetErrorDef",1093,G__G__MathCore_148_0_34, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - err", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetMinimizerType",1666,G__G__MathCore_148_0_35, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetMinimizerAlgorithm",2183,G__G__MathCore_148_0_36, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - type", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("MinimizerOptions", 1696, G__G__MathCore_148_0_37, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizerOptions), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::MinimizerOptions' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~MinimizerOptions", 1822, G__G__MathCore_148_0_38, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_148_0_39, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizerOptions), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::MinimizerOptions' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIntegrationOneDim(void) {
   /* ROOT::Math::IntegrationOneDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDim));
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIntegrationMultiDim(void) {
   /* ROOT::Math::IntegrationMultiDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDim));
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLVirtualIntegrator(void) {
   /* ROOT::Math::VirtualIntegrator */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegrator));
   G__memfunc_setup("SetRelTolerance",1516,G__G__MathCore_153_0_1, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - -", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("SetAbsTolerance",1503,G__G__MathCore_153_0_2, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - -", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Result",639,G__G__MathCore_153_0_3, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Error",522,G__G__MathCore_153_0_4, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Status",644,G__G__MathCore_153_0_5, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   // automatic destructor
   G__memfunc_setup("~VirtualIntegrator", 1924, G__G__MathCore_153_0_6, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_153_0_7, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegrator), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::VirtualIntegrator' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLVirtualIntegratorOneDim(void) {
   /* ROOT::Math::VirtualIntegratorOneDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim));
   G__memfunc_setup("Integral",822,G__G__MathCore_154_0_1, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 - b", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_154_0_2, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - - g - - 0 'false' copy", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Integral",822,G__G__MathCore_154_0_3, 100, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("IntegralUp",1019,G__G__MathCore_154_0_4, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - a", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("IntegralLow",1128,G__G__MathCore_154_0_5, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - b", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Integral",822,G__G__MathCore_154_0_6, 100, -1, -1, 0, 1, 1, 1, 0, "u 'vector<double,allocator<double> >' 'vector<double>' 11 - pts", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("IntegralCauchy",1427,G__G__MathCore_154_0_7, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - a d - - 0 - b "
"d - - 0 - c", (char*)NULL, (void*) NULL, 3);
   // automatic destructor
   G__memfunc_setup("~VirtualIntegratorOneDim", 2496, G__G__MathCore_154_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_154_0_9, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::VirtualIntegratorOneDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlEdoublecOallocatorlEdoublegRsPgR(void) {
   /* vector<double,allocator<double> > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR));
   G__memfunc_setup("at",213,G__G__MathCore_156_0_1, 100, -1, -1, 1, 1, 1, 1, 0, "h - 'vector<double,allocator<double> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__G__MathCore_156_0_2, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__G__MathCore_156_0_3, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__G__MathCore_156_0_4, 117, G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), G__defined_typename("vector<double,allocator<double> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__G__MathCore_156_0_5, 117, G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), G__defined_typename("vector<double,allocator<double> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__G__MathCore_156_0_6, 104, -1, G__defined_typename("vector<double,allocator<double> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__G__MathCore_156_0_7, 104, -1, G__defined_typename("vector<double,allocator<double> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__G__MathCore_156_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'vector<double,allocator<double> >::size_type' 0 - sz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__G__MathCore_156_0_9, 121, -1, -1, 0, 2, 1, 1, 0, 
"h - 'vector<double,allocator<double> >::size_type' 0 - sz d - - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("capacity",846,G__G__MathCore_156_0_10, 104, -1, G__defined_typename("vector<double,allocator<double> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__G__MathCore_156_0_11, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__G__MathCore_156_0_12, 100, -1, -1, 1, 1, 1, 1, 0, "h - 'vector<double,allocator<double> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<double,allocator<double> >",3210,G__G__MathCore_156_0_13, 105, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<double,allocator<double> >",3210,G__G__MathCore_156_0_14, 105, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR), -1, 0, 2, 1, 1, 0, 
"h - 'vector<double,allocator<double> >::size_type' 0 - n d - - 11 'double()' value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<double,allocator<double> >",3210,G__G__MathCore_156_0_15, 105, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR), -1, 0, 1, 1, 1, 0, "u 'vector<double,allocator<double> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<double,allocator<double> >",3210,G__G__MathCore_156_0_16, 105, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'vector<double,allocator<double> >::iterator' 'vector<double,allocator<double> >::const_iterator' 10 - first u 'vector<double,allocator<double> >::iterator' 'vector<double,allocator<double> >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__MathCore_156_0_17, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR), -1, 1, 1, 1, 1, 0, "u 'vector<double,allocator<double> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reserve",764,G__G__MathCore_156_0_18, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'vector<double,allocator<double> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("front",553,G__G__MathCore_156_0_19, 100, -1, -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("back",401,G__G__MathCore_156_0_20, 100, -1, -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back",944,G__G__MathCore_156_0_21, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__G__MathCore_156_0_22, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<double,allocator<double> >' - 1 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__G__MathCore_156_0_23, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'vector<double,allocator<double> >::iterator' - 0 - position d - - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__G__MathCore_156_0_24, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<double,allocator<double> >::iterator' - 0 - position u 'vector<double,allocator<double> >::iterator' 'vector<double,allocator<double> >::const_iterator' 10 - first "
"u 'vector<double,allocator<double> >::iterator' 'vector<double,allocator<double> >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__G__MathCore_156_0_25, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<double,allocator<double> >::iterator' - 0 - position h - 'vector<double,allocator<double> >::size_type' 0 - n "
"d - - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pop_back",831,G__G__MathCore_156_0_26, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__G__MathCore_156_0_27, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<double,allocator<double> >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__G__MathCore_156_0_28, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<double,allocator<double> >::iterator' - 0 - first u 'vector<double,allocator<double> >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__G__MathCore_156_0_29, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~vector<double,allocator<double> >", 3336, G__G__MathCore_156_0_30, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator(void) {
   /* vector<double,allocator<double> >::iterator */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator));
   G__memfunc_setup("iterator",874,G__G__MathCore_157_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("iterator",874,G__G__MathCore_157_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 1, 5, 1, 0, "D - 'vector<double,allocator<double> >::iterator::pointer' 11 - __i", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator*",918,G__G__MathCore_157_0_3, 100, -1, G__defined_typename("vector<double,allocator<double> >::iterator::reference"), 1, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__G__MathCore_157_0_4, 68, -1, G__defined_typename("vector<double,allocator<double> >::iterator::pointer"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator++",962,G__G__MathCore_157_0_5, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator++",962,G__G__MathCore_157_0_6, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "i - - 0 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator--",966,G__G__MathCore_157_0_7, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator--",966,G__G__MathCore_157_0_8, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "i - - 0 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__G__MathCore_157_0_9, 100, -1, G__defined_typename("vector<double,allocator<double> >::iterator::reference"), 1, 1, 1, 1, 8, "l - 'vector<double,allocator<double> >::iterator::difference_type' 11 - __n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator+=",980,G__G__MathCore_157_0_10, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 1, 1, 1, 1, 0, "l - 'vector<double,allocator<double> >::iterator::difference_type' 11 - __n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator+",919,G__G__MathCore_157_0_11, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 1, 1, 1, 8, "l - 'vector<double,allocator<double> >::iterator::difference_type' 11 - __n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator-=",982,G__G__MathCore_157_0_12, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 1, 1, 1, 1, 0, "l - 'vector<double,allocator<double> >::iterator::difference_type' 11 - __n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator-",921,G__G__MathCore_157_0_13, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 1, 1, 1, 8, "l - 'vector<double,allocator<double> >::iterator::difference_type' 11 - __n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("base",411,G__G__MathCore_157_0_14, 68, -1, G__defined_typename("vector<double,allocator<double> >::iterator::pointer"), 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__MathCore_157_0_15, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "u 'vector<double,allocator<double> >::iterator' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("iterator", 874, G__G__MathCore_157_0_16, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "u 'vector<double,allocator<double> >::iterator' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~iterator", 1000, G__G__MathCore_157_0_17, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncreverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR(void) {
   /* reverse_iterator<vector<double,allocator<double> >::iterator> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR));
   G__memfunc_setup("reverse_iterator<vector<double,allocator<double> >::iterator>",6055,G__G__MathCore_158_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("base",411,G__G__MathCore_158_0_2, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 0, 1, 1, 8, "", "explicit", (void*) NULL, 0);
   G__memfunc_setup("operator*",918,G__G__MathCore_158_0_3, 100, -1, G__defined_typename("reverse_iterator<vector<double,allocator<double> >::iterator>::reference"), 1, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__G__MathCore_158_0_4, 68, -1, G__defined_typename("reverse_iterator<vector<double,allocator<double> >::iterator>::pointer"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator++",962,G__G__MathCore_158_0_5, 117, G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator++",962,G__G__MathCore_158_0_6, 117, G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), -1, 0, 1, 1, 1, 0, "i - - 0 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator--",966,G__G__MathCore_158_0_7, 117, G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator--",966,G__G__MathCore_158_0_8, 117, G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), -1, 0, 1, 1, 1, 0, "i - - 0 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator+",919,G__G__MathCore_158_0_9, 117, G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), -1, 0, 1, 1, 1, 8, "l - 'reverse_iterator<vector<double,allocator<double> >::iterator>::difference_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator+=",980,G__G__MathCore_158_0_10, 117, G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), -1, 1, 1, 1, 1, 0, "l - 'reverse_iterator<vector<double,allocator<double> >::iterator>::difference_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator-",921,G__G__MathCore_158_0_11, 117, G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), -1, 0, 1, 1, 1, 8, "l - 'reverse_iterator<vector<double,allocator<double> >::iterator>::difference_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator-=",982,G__G__MathCore_158_0_12, 117, G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), -1, 1, 1, 1, 1, 0, "l - 'reverse_iterator<vector<double,allocator<double> >::iterator>::difference_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__G__MathCore_158_0_13, 100, -1, G__defined_typename("reverse_iterator<vector<double,allocator<double> >::iterator>::reference"), 1, 1, 1, 1, 8, "l - 'reverse_iterator<vector<double,allocator<double> >::iterator>::difference_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("reverse_iterator<vector<double,allocator<double> >::iterator>", 6055, G__G__MathCore_158_0_14, (int) ('i'), 
G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), -1, 0, 1, 1, 1, 0, "u 'reverse_iterator<vector<double,allocator<double> >::iterator>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~reverse_iterator<vector<double,allocator<double> >::iterator>", 6181, G__G__MathCore_158_0_15, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_158_0_16, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR), -1, 1, 1, 1, 1, 0, "u 'reverse_iterator<vector<double,allocator<double> >::iterator>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLVirtualIntegratorMultiDim(void) {
   /* ROOT::Math::VirtualIntegratorMultiDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim));
   G__memfunc_setup("Integral",822,G__G__MathCore_159_0_1, 100, -1, -1, 0, 2, 1, 1, 0, 
"D - - 10 - - D - - 10 - -", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_159_0_2, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - -", (char*)NULL, (void*) NULL, 3);
   // automatic destructor
   G__memfunc_setup("~VirtualIntegratorMultiDim", 2729, G__G__MathCore_159_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_159_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::VirtualIntegratorMultiDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIntegratorOneDim(void) {
   /* ROOT::Math::IntegratorOneDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim));
   G__memfunc_setup("IntegratorOneDim",1627,G__G__MathCore_160_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim), -1, 0, 5, 5, 1, 0, 
"i 'ROOT::Math::IntegrationOneDim::Type' - 0 'IntegrationOneDim::kADAPTIVE' type d - - 0 '1.E-9' absTol "
"d - - 0 '1E-6' relTol h - - 0 '1000' size "
"h - - 0 '3' rule", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegratorOneDim",1627,G__G__MathCore_160_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim), -1, 0, 6, 5, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f i 'ROOT::Math::IntegrationOneDim::Type' - 0 'IntegrationOneDim::kADAPTIVE' type "
"d - - 0 '1.E-9' absTol d - - 0 '1E-6' relTol "
"h - - 0 '1000' size i - - 0 '3' rule", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegratorOneDim",1627,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::IntegratorOneDim' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::IntegratorOneDim' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_160_0_5, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f g - - 0 'false' copy", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_160_0_6, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - f h - - 0 '0' icoord "
"D - - 10 '0' x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,G__G__MathCore_160_0_7, 100, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - a "
"d - - 0 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,G__G__MathCore_160_0_8, 100, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegralUp",1019,G__G__MathCore_160_0_9, 100, -1, -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegralLow",1128,G__G__MathCore_160_0_10, 100, -1, -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,G__G__MathCore_160_0_11, 100, -1, -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f u 'vector<double,allocator<double> >' 'vector<double>' 11 - pts", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegralCauchy",1427,G__G__MathCore_160_0_12, 100, -1, -1, 0, 4, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - a "
"d - - 0 - b d - - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,G__G__MathCore_160_0_13, 100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,G__G__MathCore_160_0_14, 100, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegralUp",1019,G__G__MathCore_160_0_15, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegralLow",1128,G__G__MathCore_160_0_16, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator()",957,G__G__MathCore_160_0_17, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,G__G__MathCore_160_0_18, 100, -1, -1, 0, 1, 1, 1, 0, "u 'vector<double,allocator<double> >' 'vector<double>' 11 - pts", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegralCauchy",1427,G__G__MathCore_160_0_19, 100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - a d - - 0 - b "
"d - - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Result",639,G__G__MathCore_160_0_20, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Error",522,G__G__MathCore_160_0_21, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Status",644,G__G__MathCore_160_0_22, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetRelTolerance",1516,G__G__MathCore_160_0_23, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - relTolerance", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetAbsTolerance",1503,G__G__MathCore_160_0_24, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - absTolerance", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetIntegrator",1343,G__G__MathCore_160_0_25, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("CreateIntegrator",1651,(G__InterfaceMethod) NULL, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim), -1, 0, 5, 1, 2, 0, 
"i 'ROOT::Math::IntegrationOneDim::Type' - 0 - type d - - 0 - absTol "
"d - - 0 - relTol h - - 0 - size "
"i - - 0 - rule", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~IntegratorOneDim", 1753, G__G__MathCore_160_0_27, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLAdaptiveIntegratorMultiDim(void) {
   /* ROOT::Math::AdaptiveIntegratorMultiDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim));
   G__memfunc_setup("AdaptiveIntegratorMultiDim",2674,G__G__MathCore_161_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim), -1, 0, 3, 5, 1, 0, 
"d - - 0 '1.E-6' absTol d - - 0 '1E-6' relTol "
"h - - 0 '100000' size", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AdaptiveIntegratorMultiDim",2674,G__G__MathCore_161_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim), -1, 0, 4, 5, 1, 0, 
"u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - f d - - 0 '1.E-9' absTol "
"d - - 0 '1E-6' relTol h - - 0 '100000' size", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,(G__InterfaceMethod) NULL,100, -1, -1, 0, 2, 1, 1, 0, 
"D - - 10 - xmin D - - 10 - xmax", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Integral",822,G__G__MathCore_161_0_4, 100, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - f D - - 10 - xmin "
"D - - 10 - xmax", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - f", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Result",639,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Error",522,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("RelError",813,G__G__MathCore_161_0_8, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Status",644,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NEval",470,G__G__MathCore_161_0_10, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetRelTolerance",1516,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - relTol", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetAbsTolerance",1503,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - absTol", (char*)NULL, (void*) NULL, 1);
   // automatic copy constructor
   G__memfunc_setup("AdaptiveIntegratorMultiDim", 2674, G__G__MathCore_161_0_13, (int) ('i'), 
G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::AdaptiveIntegratorMultiDim' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AdaptiveIntegratorMultiDim", 2800, G__G__MathCore_161_0_14, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIntegratorMultiDim(void) {
   /* ROOT::Math::IntegratorMultiDim */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDim));
   G__memfunc_setup("IntegratorMultiDim",1860,G__G__MathCore_162_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDim), -1, 0, 4, 5, 1, 0, 
"i 'ROOT::Math::IntegrationMultiDim::Type' - 0 'IntegrationMultiDim::kADAPTIVE' type d - - 0 '1.E-9' absTol "
"d - - 0 '1E-6' relTol h - - 0 '100000' ncall", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegratorMultiDim",1860,G__G__MathCore_162_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDim), -1, 0, 5, 5, 1, 0, 
"u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - f i 'ROOT::Math::IntegrationMultiDim::Type' - 0 'IntegrationMultiDim::kADAPTIVE' type "
"d - - 0 '1.E-9' absTol d - - 0 '1E-6' relTol "
"h - - 0 '100000' ncall", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IntegratorMultiDim",1860,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDim), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::IntegratorMultiDim' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDim), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::IntegratorMultiDim' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,G__G__MathCore_162_0_5, 100, -1, -1, 0, 2, 1, 1, 0, 
"D - - 10 - xmin D - - 10 - xmax", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Integral",822,G__G__MathCore_162_0_6, 100, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - f D - - 10 - xmin "
"D - - 10 - xmax", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_162_0_7, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionMultiDim' 'ROOT::Math::IMultiGenFunction' 11 - f", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Result",639,G__G__MathCore_162_0_8, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Error",522,G__G__MathCore_162_0_9, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Status",644,G__G__MathCore_162_0_10, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetRelTolerance",1516,G__G__MathCore_162_0_11, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - relTol", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetAbsTolerance",1503,G__G__MathCore_162_0_12, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - absTol", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetIntegrator",1343,G__G__MathCore_162_0_13, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("CreateIntegrator",1651,(G__InterfaceMethod) NULL, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim), -1, 0, 4, 1, 2, 0, 
"i 'ROOT::Math::IntegrationMultiDim::Type' - 0 - type d - - 0 - absTol "
"d - - 0 - relTol h - - 0 - ncall", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~IntegratorMultiDim", 1986, G__G__MathCore_162_0_15, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLFactory(void) {
   /* ROOT::Math::Factory */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFactory));
   G__memfunc_setup("CreateMinimizer",1544,G__G__MathCore_163_0_1, 85, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizer), -1, 0, 2, 3, 1, 0, 
"u 'string' - 11 '\"Minuit2\"' minimizerType u 'string' - 11 '\"Migrad\"' algoType", (char*)NULL, (void*) G__func2void( (ROOT::Math::Minimizer* (*)(const string&, const string&))(&ROOT::Math::Factory::CreateMinimizer) ), 0);
   // automatic default constructor
   G__memfunc_setup("Factory", 728, G__G__MathCore_163_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFactory), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Factory", 728, G__G__MathCore_163_0_3, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFactory), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::Factory' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Factory", 854, G__G__MathCore_163_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_163_0_5, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFactory), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::Factory' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR(void) {
   /* ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR));
   G__memfunc_setup("NDim",360,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DataElement",1092,G__G__MathCore_164_0_3, 100, -1, -1, 0, 3, 1, 1, 8, 
"D - - 10 - x h - - 0 - i "
"D - - 0 '0' g", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("NPoints",715,G__G__MathCore_164_0_4, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Type",418,G__G__MathCore_164_0_5, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgRcLcLType_t), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NCalls",573,G__G__MathCore_164_0_6, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("UpdateNCalls",1184,G__G__MathCore_164_0_7, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ResetNCalls",1088,G__G__MathCore_164_0_8, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>", 5513, G__G__MathCore_164_0_9, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_164_0_10, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR(void) {
   /* ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR));
   G__memfunc_setup("NDim",360,(G__InterfaceMethod) NULL,104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DataElement",1092,G__G__MathCore_166_0_3, 100, -1, -1, 0, 3, 1, 1, 8, 
"D - - 10 - x h - - 0 - i "
"D - - 0 '0' g", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("NPoints",715,G__G__MathCore_166_0_4, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Type",418,G__G__MathCore_166_0_5, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgRcLcLType_t), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("NCalls",573,G__G__MathCore_166_0_6, 104, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("UpdateNCalls",1184,G__G__MathCore_166_0_7, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ResetNCalls",1088,G__G__MathCore_166_0_8, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>", 5948, G__G__MathCore_166_0_9, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_166_0_10, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGaussIntegrator(void) {
   /* ROOT::Math::GaussIntegrator */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator));
   G__memfunc_setup("GaussIntegrator",1570,G__G__MathCore_168_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AbsValue",787,G__G__MathCore_168_0_2, 121, -1, -1, 0, 1, 1, 1, 0, "g - - 0 - flag", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetRelTolerance",1516,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetAbsTolerance",1503,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Result",639,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Error",522,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Status",644,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Integral",822,(G__InterfaceMethod) NULL,100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFunction",1138,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - - g - - 0 'false' copy", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Integral",822,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("IntegralUp",1019,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - a", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("IntegralLow",1128,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Integral",822,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 0, "u 'vector<double,allocator<double> >' 'vector<double>' 11 - pts", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("IntegralCauchy",1427,(G__InterfaceMethod) NULL,100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - a d - - 0 - b "
"d - - 0 - c", (char*)NULL, (void*) NULL, 1);
   // automatic copy constructor
   G__memfunc_setup("GaussIntegrator", 1570, G__G__MathCore_168_0_15, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::GaussIntegrator' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GaussIntegrator", 1696, G__G__MathCore_168_0_16, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLGaussLegendreIntegrator(void) {
   /* ROOT::Math::GaussLegendreIntegrator */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator));
   G__memfunc_setup("GaussLegendreIntegrator",2376,G__G__MathCore_169_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator), -1, 0, 2, 1, 1, 0, 
"i - - 0 '10' num d - - 0 '1e-12' eps", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetNumberPoints",1554,G__G__MathCore_169_0_2, 121, -1, -1, 0, 1, 1, 1, 0, "i - - 0 - num", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetWeightVectors",1646,G__G__MathCore_169_0_3, 121, -1, -1, 0, 2, 1, 1, 0, 
"D - - 0 - x D - - 0 - w", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetRelTolerance",1516,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetAbsTolerance",1503,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Result",639,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Error",522,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Status",644,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Integral",822,(G__InterfaceMethod) NULL,100, -1, -1, 0, 2, 1, 1, 0, 
"d - - 0 - a d - - 0 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFunction",1138,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - - g - - 0 'false' copy", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Integral",822,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("IntegralUp",1019,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - a", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("IntegralLow",1128,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Integral",822,(G__InterfaceMethod) NULL,100, -1, -1, 0, 1, 1, 1, 0, "u 'vector<double,allocator<double> >' 'vector<double>' 11 - pts", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("IntegralCauchy",1427,(G__InterfaceMethod) NULL,100, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - a d - - 0 - b "
"d - - 0 - c", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("CalcGaussLegendreSamplingPoints",3156,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 0, 1, 4, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("GaussLegendreIntegrator", 2376, G__G__MathCore_169_0_17, (int) ('i'), 
G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::GaussLegendreIntegrator' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GaussLegendreIntegrator", 2502, G__G__MathCore_169_0_18, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLIRootFinderMethod(void) {
   /* ROOT::Math::IRootFinderMethod */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIRootFinderMethod));
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_170_0_2, 105, -1, -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::IGradientFunctionOneDim' 'ROOT::Math::IGradFunction' 11 - - d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_170_0_3, 105, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - - d - - 0 - - "
"d - - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Root",420,G__G__MathCore_170_0_4, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Solve",521,G__G__MathCore_170_0_5, 105, -1, -1, 0, 3, 1, 1, 0, 
"i - - 0 '100' maxIter d - - 0 '1E-3' absTol "
"d - - 0 '1E-6' relTol", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Name",385,G__G__MathCore_170_0_6, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Iterate",718,G__G__MathCore_170_0_7, 105, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Iterations",1058,G__G__MathCore_170_0_8, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~IRootFinderMethod", 1828, G__G__MathCore_170_0_9, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__MathCore_170_0_10, (int) ('u'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIRootFinderMethod), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::IRootFinderMethod' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLRootFinder(void) {
   /* ROOT::Math::RootFinder */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFinder));
   G__memfunc_setup("RootFinder",1020,G__G__MathCore_171_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFinder), -1, 0, 1, 1, 1, 0, "i 'ROOT::Math::RootFinder::EType' - 0 'RootFinder::kBRENT' type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RootFinder",1020,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFinder), -1, 0, 1, 1, 4, 0, "u 'ROOT::Math::RootFinder' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFinder), -1, 1, 1, 1, 4, 0, "u 'ROOT::Math::RootFinder' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetMethod",909,G__G__MathCore_171_0_4, 105, -1, -1, 0, 1, 1, 1, 0, "i 'ROOT::Math::RootFinder::EType' - 0 'RootFinder::kBRENT' type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_171_0_5, 105, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - xlow "
"d - - 0 - xup", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_171_0_6, 105, -1, -1, 0, 2, 1, 1, 0, 
"u 'ROOT::Math::IGradientFunctionOneDim' 'ROOT::Math::IGradFunction' 11 - f d - - 0 - xstart", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Solve",521,G__G__MathCore_171_0_7, 105, -1, -1, 0, 3, 1, 1, 0, 
"i - - 0 '100' maxIter d - - 0 '1E-3' absTol "
"d - - 0 '1E-6' relTol", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Iterations",1058,G__G__MathCore_171_0_8, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Iterate",718,G__G__MathCore_171_0_9, 105, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Root",420,G__G__MathCore_171_0_10, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Name",385,G__G__MathCore_171_0_11, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~RootFinder", 1146, G__G__MathCore_171_0_12, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLRichardsonDerivator(void) {
   /* ROOT::Math::RichardsonDerivator */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRichardsonDerivator));
   G__memfunc_setup("RichardsonDerivator",1981,G__G__MathCore_174_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRichardsonDerivator), -1, 0, 1, 1, 1, 0, "d - - 0 '0.001' h", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RichardsonDerivator",1981,G__G__MathCore_174_0_2, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRichardsonDerivator), -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 '0.001' h "
"g - - 0 'false' copyFunc", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RichardsonDerivator",1981,G__G__MathCore_174_0_3, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRichardsonDerivator), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::RichardsonDerivator' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__MathCore_174_0_4, 117, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRichardsonDerivator), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::RichardsonDerivator' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Error",522,G__G__MathCore_174_0_5, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Derivative1",1092,G__G__MathCore_174_0_6, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator()",957,G__G__MathCore_174_0_7, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Derivative1",1092,G__G__MathCore_174_0_8, 100, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - x "
"d - - 0 - h", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Derivative2",1093,G__G__MathCore_174_0_9, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Derivative2",1093,G__G__MathCore_174_0_10, 100, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - x "
"d - - 0 - h", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Derivative3",1094,G__G__MathCore_174_0_11, 100, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Derivative3",1094,G__G__MathCore_174_0_12, 100, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - x "
"d - - 0 - h", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_174_0_13, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetStepSize",1123,G__G__MathCore_174_0_14, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - h", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~RichardsonDerivator", 2107, G__G__MathCore_174_0_15, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLBrentMinimizer1D(void) {
   /* ROOT::Math::BrentMinimizer1D */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentMinimizer1D));
   G__memfunc_setup("BrentMinimizer1D",1572,G__G__MathCore_176_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentMinimizer1D), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("XMinimum",820,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("XLower",609,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("XUpper",612,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("FValMinimum",1093,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("FValLower",882,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("FValUpper",885,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Minimize",834,(G__InterfaceMethod) NULL,105, -1, -1, 0, 3, 1, 1, 0, 
"i - - 0 - maxIter d - - 0 - absTol "
"d - - 0 - relTol", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Iterations",1058,(G__InterfaceMethod) NULL,105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Name",385,(G__InterfaceMethod) NULL,67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetFunction",1138,G__G__MathCore_176_0_11, 105, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - xlow "
"d - - 0 - xup", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("BrentMinimizer1D", 1572, G__G__MathCore_176_0_12, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentMinimizer1D), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::BrentMinimizer1D' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~BrentMinimizer1D", 1698, G__G__MathCore_176_0_13, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLBrentRootFinder(void) {
   /* ROOT::Math::BrentRootFinder */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentRootFinder));
   G__memfunc_setup("BrentRootFinder",1527,G__G__MathCore_177_0_1, 105, G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentRootFinder), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFunction",1138,(G__InterfaceMethod) NULL,105, -1, -1, 0, 3, 1, 1, 0, 
"u 'ROOT::Math::IBaseFunctionOneDim' 'ROOT::Math::IGenFunction' 11 - f d - - 0 - xlow "
"d - - 0 - xup", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Solve",521,(G__InterfaceMethod) NULL,105, -1, -1, 0, 3, 1, 1, 0, 
"i - - 0 '100' maxIter d - - 0 '1E-3' absTol "
"d - - 0 '1E-6' relTol", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Root",420,(G__InterfaceMethod) NULL,100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Name",385,(G__InterfaceMethod) NULL,67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   // automatic copy constructor
   G__memfunc_setup("BrentRootFinder", 1527, G__G__MathCore_177_0_6, (int) ('i'), G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentRootFinder), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::BrentRootFinder' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~BrentRootFinder", 1653, G__G__MathCore_177_0_7, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfuncG__MathCore() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

}

static void G__cpp_setup_global1() {
   G__memvar_setup((void*)(&gRandom),85,0,0,G__get_linked_tagnum(&G__G__MathCoreLN_TRandom),-1,-1,1,"gRandom=",0,(char*)NULL);
}

static void G__cpp_setup_global2() {
}

static void G__cpp_setup_global3() {
   G__memvar_setup((void*)G__PVOID,112,0,0,-1,-1,-1,1,"ROOT_Math_SpecFuncMathCore=0",1,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,112,0,0,-1,-1,-1,1,"ROOT_Math_PdfFuncMathCore=0",1,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,112,0,0,-1,-1,-1,1,"ROOT_Math_ProbFuncMathCore=0",1,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,112,0,0,-1,-1,-1,1,"ROOT_Math_QuantFuncMathCore=0",1,(char*)NULL);

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_globalG__MathCore() {
  G__cpp_setup_global0();
  G__cpp_setup_global1();
  G__cpp_setup_global2();
  G__cpp_setup_global3();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();

}

static void G__cpp_setup_func1() {
}

static void G__cpp_setup_func2() {
}

static void G__cpp_setup_func3() {
   G__memfunc_setup("operator==", 998, G__G__MathCore__0_373, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'vector<double,allocator<double> >::iterator' - 11 - x u 'vector<double,allocator<double> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator!=", 970, G__G__MathCore__0_374, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'vector<double,allocator<double> >::iterator' - 11 - x u 'vector<double,allocator<double> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator<", 936, G__G__MathCore__0_375, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'vector<double,allocator<double> >::iterator' - 11 - x u 'vector<double,allocator<double> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator>", 938, G__G__MathCore__0_376, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'vector<double,allocator<double> >::iterator' - 11 - x u 'vector<double,allocator<double> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator<=", 997, G__G__MathCore__0_377, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'vector<double,allocator<double> >::iterator' - 11 - x u 'vector<double,allocator<double> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator>=", 999, G__G__MathCore__0_378, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'vector<double,allocator<double> >::iterator' - 11 - x u 'vector<double,allocator<double> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator-", 921, G__G__MathCore__0_379, 108, -1, G__defined_typename("difference_type"), 0, 2, 1, 1, 8, 
"u 'vector<double,allocator<double> >::iterator' - 11 - x u 'vector<double,allocator<double> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator+", 919, G__G__MathCore__0_380, 117, G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator), -1, 0, 2, 1, 1, 8, 
"l - 'difference_type' 10 - x u 'vector<double,allocator<double> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator==", 998, G__G__MathCore__0_381, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'reverse_iterator<vector<double,allocator<double> >::iterator>' 'reverse_iterator' 11 - x u 'reverse_iterator<vector<double,allocator<double> >::iterator>' 'reverse_iterator' 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator!=", 970, G__G__MathCore__0_382, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'reverse_iterator<vector<double,allocator<double> >::iterator>' 'reverse_iterator' 11 - x u 'reverse_iterator<vector<double,allocator<double> >::iterator>' 'reverse_iterator' 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator==", 998, G__G__MathCore__0_383, 103, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<double,allocator<double> >' - 11 - x u 'vector<double,allocator<double> >' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator<", 936, G__G__MathCore__0_384, 103, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<double,allocator<double> >' - 11 - x u 'vector<double,allocator<double> >' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator!=", 970, G__G__MathCore__0_385, 103, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<double,allocator<double> >' - 11 - x u 'vector<double,allocator<double> >' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator>", 938, G__G__MathCore__0_386, 103, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<double,allocator<double> >' - 11 - x u 'vector<double,allocator<double> >' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator>=", 999, G__G__MathCore__0_387, 103, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<double,allocator<double> >' - 11 - x u 'vector<double,allocator<double> >' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator<=", 997, G__G__MathCore__0_388, 103, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<double,allocator<double> >' - 11 - x u 'vector<double,allocator<double> >' - 11 - y", (char*) NULL
, (void*) NULL, 0);
}

static void G__cpp_setup_func4() {

   G__resetifuncposition();
}

extern "C" void G__cpp_setup_funcG__MathCore() {
  G__cpp_setup_func0();
  G__cpp_setup_func1();
  G__cpp_setup_func2();
  G__cpp_setup_func3();
  G__cpp_setup_func4();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__G__MathCoreLN_type_info = { "type_info" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TClass = { "TClass" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TBuffer = { "TBuffer" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TMemberInspector = { "TMemberInspector" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TObject = { "TObject" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TNamed = { "TNamed" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TVirtualIsAProxy = { "TVirtualIsAProxy" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOT = { "ROOT" , 110 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLTInitBehavior = { "ROOT::TInitBehavior" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_string = { "string" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR = { "vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TString = { "TString" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TRandom = { "TRandom" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TRandom1 = { "TRandom1" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TRandom2 = { "TRandom2" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TRandom3 = { "TRandom3" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TMethodCall = { "TMethodCall" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_Foption_t = { "Foption_t" , 115 , -1 };
G__linked_taginfo G__G__MathCoreLN_TVirtualFitter = { "TVirtualFitter" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TKDTreelEintcOdoublegR = { "TKDTree<int,double>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_vectorlEintcOallocatorlEintgRsPgR = { "vector<int,allocator<int> >" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<int,allocator<int> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_TKDTreelEintcOfloatgR = { "TKDTree<int,float>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMath = { "ROOT::Math" , 110 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim = { "ROOT::Math::IBaseFunctionOneDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim = { "ROOT::Math::IGradientFunctionOneDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim = { "ROOT::Math::IBaseFunctionMultiDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim = { "ROOT::Math::IGradientFunctionMultiDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientMultiDim = { "ROOT::Math::IGradientMultiDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientOneDim = { "ROOT::Math::IGradientOneDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim = { "ROOT::Math::IParametricFunctionOneDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim = { "ROOT::Math::IParametricGradFunctionOneDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim = { "ROOT::Math::IParametricFunctionMultiDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim = { "ROOT::Math::IParametricGradFunctionMultiDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseParam = { "ROOT::Math::IBaseParam" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctionBase = { "ROOT::Math::ParamFunctionBase" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor = { "ROOT::Math::ParamFunctor" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor = { "ROOT::Math::Functor" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR = { "auto_ptr<ROOT::Math::IBaseFunctionMultiDim>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D = { "ROOT::Math::Functor1D" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionOneDimgR = { "auto_ptr<ROOT::Math::IBaseFunctionOneDim>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor = { "ROOT::Math::GradFunctor" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR = { "auto_ptr<ROOT::Math::IGradientFunctionMultiDim>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D = { "ROOT::Math::GradFunctor1D" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIGradientFunctionOneDimgR = { "auto_ptr<ROOT::Math::IGradientFunctionOneDim>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizer = { "ROOT::Math::Minimizer" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizerOptions = { "ROOT::Math::MinimizerOptions" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDim = { "ROOT::Math::IntegrationOneDim" , 110 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType = { "ROOT::Math::IntegrationOneDim::Type" , 101 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDim = { "ROOT::Math::IntegrationMultiDim" , 110 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType = { "ROOT::Math::IntegrationMultiDim::Type" , 101 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegrator = { "ROOT::Math::VirtualIntegrator" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim = { "ROOT::Math::VirtualIntegratorOneDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR = { "vector<double,allocator<double> >" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator = { "vector<double,allocator<double> >::iterator" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR = { "reverse_iterator<vector<double,allocator<double> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim = { "ROOT::Math::VirtualIntegratorMultiDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim = { "ROOT::Math::IntegratorOneDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim = { "ROOT::Math::AdaptiveIntegratorMultiDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDim = { "ROOT::Math::IntegratorMultiDim" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLFactory = { "ROOT::Math::Factory" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR = { "ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgRcLcLType_t = { "ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_t" , 101 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR = { "ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgRcLcLType_t = { "ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_t" , 101 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator = { "ROOT::Math::GaussIntegrator" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator = { "ROOT::Math::GaussLegendreIntegrator" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIRootFinderMethod = { "ROOT::Math::IRootFinderMethod" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLRootFinder = { "ROOT::Math::RootFinder" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLRootFindercLcLEType = { "ROOT::Math::RootFinder::EType" , 101 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLRichardsonDerivator = { "ROOT::Math::RichardsonDerivator" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLIMinimizer1D = { "ROOT::Math::IMinimizer1D" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLBrentMinimizer1D = { "ROOT::Math::BrentMinimizer1D" , 99 , -1 };
G__linked_taginfo G__G__MathCoreLN_ROOTcLcLMathcLcLBrentRootFinder = { "ROOT::Math::BrentRootFinder" , 99 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtableG__MathCore() {
  G__G__MathCoreLN_type_info.tagnum = -1 ;
  G__G__MathCoreLN_TClass.tagnum = -1 ;
  G__G__MathCoreLN_TBuffer.tagnum = -1 ;
  G__G__MathCoreLN_TMemberInspector.tagnum = -1 ;
  G__G__MathCoreLN_TObject.tagnum = -1 ;
  G__G__MathCoreLN_TNamed.tagnum = -1 ;
  G__G__MathCoreLN_TVirtualIsAProxy.tagnum = -1 ;
  G__G__MathCoreLN_ROOT.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLTInitBehavior.tagnum = -1 ;
  G__G__MathCoreLN_string.tagnum = -1 ;
  G__G__MathCoreLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR.tagnum = -1 ;
  G__G__MathCoreLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__MathCoreLN_TString.tagnum = -1 ;
  G__G__MathCoreLN_TRandom.tagnum = -1 ;
  G__G__MathCoreLN_TRandom1.tagnum = -1 ;
  G__G__MathCoreLN_TRandom2.tagnum = -1 ;
  G__G__MathCoreLN_TRandom3.tagnum = -1 ;
  G__G__MathCoreLN_TMethodCall.tagnum = -1 ;
  G__G__MathCoreLN_Foption_t.tagnum = -1 ;
  G__G__MathCoreLN_TVirtualFitter.tagnum = -1 ;
  G__G__MathCoreLN_TKDTreelEintcOdoublegR.tagnum = -1 ;
  G__G__MathCoreLN_vectorlEintcOallocatorlEintgRsPgR.tagnum = -1 ;
  G__G__MathCoreLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__MathCoreLN_TKDTreelEintcOfloatgR.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMath.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientMultiDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientOneDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseParam.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctionBase.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor.tagnum = -1 ;
  G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D.tagnum = -1 ;
  G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionOneDimgR.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor.tagnum = -1 ;
  G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D.tagnum = -1 ;
  G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIGradientFunctionOneDimgR.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizer.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizerOptions.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegrator.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim.tagnum = -1 ;
  G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR.tagnum = -1 ;
  G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator.tagnum = -1 ;
  G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDim.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLFactory.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgRcLcLType_t.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgRcLcLType_t.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIRootFinderMethod.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLRootFinder.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLRootFindercLcLEType.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLRichardsonDerivator.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLIMinimizer1D.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLBrentMinimizer1D.tagnum = -1 ;
  G__G__MathCoreLN_ROOTcLcLMathcLcLBrentRootFinder.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtableG__MathCore() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_type_info);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TClass);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TBuffer);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TMemberInspector);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TObject);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TNamed);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TVirtualIsAProxy);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOT),0,-1,0,(char*)NULL,G__setup_memvarROOT,G__setup_memfuncROOT);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLTInitBehavior);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_string);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TString);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom),sizeof(TRandom),-1,324864,"Simple Random number generator (periodicity = 10**9)",G__setup_memvarTRandom,G__setup_memfuncTRandom);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom1),sizeof(TRandom1),-1,324864,"Ranlux Random number generators with periodicity > 10**14",G__setup_memvarTRandom1,G__setup_memfuncTRandom1);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom2),sizeof(TRandom2),-1,324864,"Random number generator with periodicity of 10**26",G__setup_memvarTRandom2,G__setup_memfuncTRandom2);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TRandom3),sizeof(TRandom3),-1,128256,"Random number generator: Mersenne Twistor",G__setup_memvarTRandom3,G__setup_memfuncTRandom3);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_TMethodCall);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_Foption_t);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TVirtualFitter),sizeof(TVirtualFitter),-1,327444,"Abstract interface for fitting",G__setup_memvarTVirtualFitter,G__setup_memfuncTVirtualFitter);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOdoublegR),sizeof(TKDTree<int,double>),-1,327424,"KD tree",G__setup_memvarTKDTreelEintcOdoublegR,G__setup_memfuncTKDTreelEintcOdoublegR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_vectorlEintcOallocatorlEintgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_TKDTreelEintcOfloatgR),sizeof(TKDTree<int,float>),-1,327424,"KD tree",G__setup_memvarTKDTreelEintcOfloatgR,G__setup_memfuncTKDTreelEintcOfloatgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMath),0,-1,0,(char*)NULL,G__setup_memvarROOTcLcLMath,G__setup_memfuncROOTcLcLMath);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionOneDim),sizeof(ROOT::Math::IBaseFunctionOneDim),-1,263426,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIBaseFunctionOneDim,G__setup_memfuncROOTcLcLMathcLcLIBaseFunctionOneDim);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionOneDim),sizeof(ROOT::Math::IGradientFunctionOneDim),-1,263171,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIGradientFunctionOneDim,G__setup_memfuncROOTcLcLMathcLcLIGradientFunctionOneDim);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseFunctionMultiDim),sizeof(ROOT::Math::IBaseFunctionMultiDim),-1,263427,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIBaseFunctionMultiDim,G__setup_memfuncROOTcLcLMathcLcLIBaseFunctionMultiDim);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientFunctionMultiDim),sizeof(ROOT::Math::IGradientFunctionMultiDim),-1,263172,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIGradientFunctionMultiDim,G__setup_memfuncROOTcLcLMathcLcLIGradientFunctionMultiDim);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientMultiDim),sizeof(ROOT::Math::IGradientMultiDim),-1,263171,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIGradientMultiDim,G__setup_memfuncROOTcLcLMathcLcLIGradientMultiDim);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIGradientOneDim),sizeof(ROOT::Math::IGradientOneDim),-1,263170,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIGradientOneDim,G__setup_memfuncROOTcLcLMathcLcLIGradientOneDim);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionOneDim),sizeof(ROOT::Math::IParametricFunctionOneDim),-1,262149,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIParametricFunctionOneDim,G__setup_memfuncROOTcLcLMathcLcLIParametricFunctionOneDim);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionOneDim),sizeof(ROOT::Math::IParametricGradFunctionOneDim),-1,263174,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIParametricGradFunctionOneDim,G__setup_memfuncROOTcLcLMathcLcLIParametricGradFunctionOneDim);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricFunctionMultiDim),sizeof(ROOT::Math::IParametricFunctionMultiDim),-1,262150,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIParametricFunctionMultiDim,G__setup_memfuncROOTcLcLMathcLcLIParametricFunctionMultiDim);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIParametricGradFunctionMultiDim),sizeof(ROOT::Math::IParametricGradFunctionMultiDim),-1,263175,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIParametricGradFunctionMultiDim,G__setup_memfuncROOTcLcLMathcLcLIParametricGradFunctionMultiDim);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIBaseParam),sizeof(ROOT::Math::IBaseParam),-1,263171,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIBaseParam,G__setup_memfuncROOTcLcLMathcLcLIBaseParam);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctionBase);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLParamFunctor),sizeof(ROOT::Math::ParamFunctor),-1,298752,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLParamFunctor,G__setup_memfuncROOTcLcLMathcLcLParamFunctor);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor),sizeof(ROOT::Math::Functor),-1,101632,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLFunctor,G__setup_memfuncROOTcLcLMathcLcLFunctor);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFunctor1D),sizeof(ROOT::Math::Functor1D),-1,101632,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLFunctor1D,G__setup_memfuncROOTcLcLMathcLcLFunctor1D);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIBaseFunctionOneDimgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor),sizeof(ROOT::Math::GradFunctor),-1,101632,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGradFunctor,G__setup_memfuncROOTcLcLMathcLcLGradFunctor);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGradFunctor1D),sizeof(ROOT::Math::GradFunctor1D),-1,101632,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGradFunctor1D,G__setup_memfuncROOTcLcLMathcLcLGradFunctor1D);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_auto_ptrlEROOTcLcLMathcLcLIGradientFunctionOneDimgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizer),sizeof(ROOT::Math::Minimizer),-1,265997,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLMinimizer,G__setup_memfuncROOTcLcLMathcLcLMinimizer);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLMinimizerOptions),sizeof(ROOT::Math::MinimizerOptions),-1,262400,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLMinimizerOptions,G__setup_memfuncROOTcLcLMathcLcLMinimizerOptions);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDim),0,-1,0,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIntegrationOneDim,G__setup_memfuncROOTcLcLMathcLcLIntegrationOneDim);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationOneDimcLcLType),sizeof(int),-1,0,(char*)NULL,NULL,NULL);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDim),0,-1,0,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIntegrationMultiDim,G__setup_memfuncROOTcLcLMathcLcLIntegrationMultiDim);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegrationMultiDimcLcLType),sizeof(int),-1,0,(char*)NULL,NULL,NULL);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegrator),sizeof(ROOT::Math::VirtualIntegrator),-1,263173,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLVirtualIntegrator,G__setup_memfuncROOTcLcLMathcLcLVirtualIntegrator);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorOneDim),sizeof(ROOT::Math::VirtualIntegratorOneDim),-1,263180,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLVirtualIntegratorOneDim,G__setup_memfuncROOTcLcLMathcLcLVirtualIntegratorOneDim);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgR),sizeof(vector<double,allocator<double> >),-1,298752,(char*)NULL,G__setup_memvarvectorlEdoublecOallocatorlEdoublegRsPgR,G__setup_memfuncvectorlEdoublecOallocatorlEdoublegRsPgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_vectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator),sizeof(vector<double,allocator<double> >::iterator),-1,35072,(char*)NULL,G__setup_memvarvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator,G__setup_memfuncvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiterator);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_reverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR),sizeof(reverse_iterator<vector<double,allocator<double> >::iterator>),-1,256,(char*)NULL,G__setup_memvarreverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR,G__setup_memfuncreverse_iteratorlEvectorlEdoublecOallocatorlEdoublegRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLVirtualIntegratorMultiDim),sizeof(ROOT::Math::VirtualIntegratorMultiDim),-1,263175,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLVirtualIntegratorMultiDim,G__setup_memfuncROOTcLcLMathcLcLVirtualIntegratorMultiDim);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorOneDim),sizeof(ROOT::Math::IntegratorOneDim),-1,298752,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIntegratorOneDim,G__setup_memfuncROOTcLcLMathcLcLIntegratorOneDim);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLAdaptiveIntegratorMultiDim),sizeof(ROOT::Math::AdaptiveIntegratorMultiDim),-1,296192,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLAdaptiveIntegratorMultiDim,G__setup_memfuncROOTcLcLMathcLcLAdaptiveIntegratorMultiDim);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIntegratorMultiDim),sizeof(ROOT::Math::IntegratorMultiDim),-1,298752,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIntegratorMultiDim,G__setup_memfuncROOTcLcLMathcLcLIntegratorMultiDim);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLFactory),sizeof(ROOT::Math::Factory),-1,262144,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLFactory,G__setup_memfuncROOTcLcLMathcLcLFactory);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR),sizeof(ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>),-1,295939,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR,G__setup_memfuncROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIBaseFunctionMultiDimgRcLcLType_t);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR),sizeof(ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>),-1,295940,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR,G__setup_memfuncROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgR);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLBasicFitMethodFunctionlEROOTcLcLMathcLcLIGradientFunctionMultiDimgRcLcLType_t);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussIntegrator),sizeof(ROOT::Math::GaussIntegrator),-1,263424,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGaussIntegrator,G__setup_memfuncROOTcLcLMathcLcLGaussIntegrator);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLGaussLegendreIntegrator),sizeof(ROOT::Math::GaussLegendreIntegrator),-1,263424,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLGaussLegendreIntegrator,G__setup_memfuncROOTcLcLMathcLcLGaussLegendreIntegrator);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLIRootFinderMethod),sizeof(ROOT::Math::IRootFinderMethod),-1,263427,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLIRootFinderMethod,G__setup_memfuncROOTcLcLMathcLcLIRootFinderMethod);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFinder),sizeof(ROOT::Math::RootFinder),-1,265984,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLRootFinder,G__setup_memfuncROOTcLcLMathcLcLRootFinder);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLRootFindercLcLEType);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLRichardsonDerivator),sizeof(ROOT::Math::RichardsonDerivator),-1,298752,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLRichardsonDerivator,G__setup_memfuncROOTcLcLMathcLcLRichardsonDerivator);
   G__get_linked_tagnum_fwd(&G__G__MathCoreLN_ROOTcLcLMathcLcLIMinimizer1D);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentMinimizer1D),sizeof(ROOT::Math::BrentMinimizer1D),-1,263424,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLBrentMinimizer1D,G__setup_memfuncROOTcLcLMathcLcLBrentMinimizer1D);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__MathCoreLN_ROOTcLcLMathcLcLBrentRootFinder),sizeof(ROOT::Math::BrentRootFinder),-1,263424,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLBrentRootFinder,G__setup_memfuncROOTcLcLMathcLcLBrentRootFinder);
}
extern "C" void G__cpp_setupG__MathCore(void) {
  G__check_setup_version(30051515,"G__cpp_setupG__MathCore()");
  G__set_cpp_environmentG__MathCore();
  G__cpp_setup_tagtableG__MathCore();

  G__cpp_setup_inheritanceG__MathCore();

  G__cpp_setup_typetableG__MathCore();

  G__cpp_setup_memvarG__MathCore();

  G__cpp_setup_memfuncG__MathCore();
  G__cpp_setup_globalG__MathCore();
  G__cpp_setup_funcG__MathCore();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfuncG__MathCore();
  return;
}
class G__cpp_setup_initG__MathCore {
  public:
    G__cpp_setup_initG__MathCore() { G__add_setup_func("G__MathCore",(G__incsetup)(&G__cpp_setupG__MathCore)); G__call_setup_funcs(); }
   ~G__cpp_setup_initG__MathCore() { G__remove_setup_func("G__MathCore"); }
};
G__cpp_setup_initG__MathCore G__cpp_setup_initializerG__MathCore;

