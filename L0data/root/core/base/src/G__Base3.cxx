//
// File generated by core/utils/src/rootcint_tmp at Mon Apr 13 13:38:16 2015

// Do NOT change. Changes will be lost next time file is generated
//

#include "RConfig.h" //rootcint 4834
#if !defined(R__ACCESS_IN_SYMBOL)
//Break the privacy of classes -- Disabled for the moment
#define private public
#define protected public
#endif

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;
#include "G__Base3.h"

#include "TCollectionProxyInfo.h"
#include "TClass.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"

// START OF SHADOWS

namespace ROOT {
   namespace Shadow {
      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< char*, int > pairlEcharmUcOintgR;
      #else
      class pairlEcharmUcOintgR  {
         public:
         //friend XX;
         char* first; //
         int second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< char*, long > pairlEcharmUcOlonggR;
      #else
      class pairlEcharmUcOlonggR  {
         public:
         //friend XX;
         char* first; //
         long second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< char*, float > pairlEcharmUcOfloatgR;
      #else
      class pairlEcharmUcOfloatgR  {
         public:
         //friend XX;
         char* first; //
         float second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< char*, double > pairlEcharmUcOdoublegR;
      #else
      class pairlEcharmUcOdoublegR  {
         public:
         //friend XX;
         char* first; //
         double second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< char*, void* > pairlEcharmUcOvoidmUgR;
      #else
      class pairlEcharmUcOvoidmUgR  {
         public:
         //friend XX;
         char* first; //
         void* second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< char*, char* > pairlEcharmUcOcharmUgR;
      #else
      class pairlEcharmUcOcharmUgR  {
         public:
         //friend XX;
         char* first; //
         char* second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< ::string, int > pairlEstringcOintgR;
      #else
      class pairlEstringcOintgR  {
         public:
         //friend XX;
         string first; //
         int second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< ::string, long > pairlEstringcOlonggR;
      #else
      class pairlEstringcOlonggR  {
         public:
         //friend XX;
         string first; //
         long second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< ::string, float > pairlEstringcOfloatgR;
      #else
      class pairlEstringcOfloatgR  {
         public:
         //friend XX;
         string first; //
         float second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< ::string, double > pairlEstringcOdoublegR;
      #else
      class pairlEstringcOdoublegR  {
         public:
         //friend XX;
         string first; //
         double second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< ::string, void* > pairlEstringcOvoidmUgR;
      #else
      class pairlEstringcOvoidmUgR  {
         public:
         //friend XX;
         string first; //
         void* second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< int, int > pairlEintcOintgR;
      #else
      class pairlEintcOintgR  {
         public:
         //friend XX;
         int first; //
         int second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< int, long > pairlEintcOlonggR;
      #else
      class pairlEintcOlonggR  {
         public:
         //friend XX;
         int first; //
         long second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< int, float > pairlEintcOfloatgR;
      #else
      class pairlEintcOfloatgR  {
         public:
         //friend XX;
         int first; //
         float second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< int, double > pairlEintcOdoublegR;
      #else
      class pairlEintcOdoublegR  {
         public:
         //friend XX;
         int first; //
         double second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< int, void* > pairlEintcOvoidmUgR;
      #else
      class pairlEintcOvoidmUgR  {
         public:
         //friend XX;
         int first; //
         void* second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< int, char* > pairlEintcOcharmUgR;
      #else
      class pairlEintcOcharmUgR  {
         public:
         //friend XX;
         int first; //
         char* second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< long, int > pairlElongcOintgR;
      #else
      class pairlElongcOintgR  {
         public:
         //friend XX;
         long first; //
         int second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< long, long > pairlElongcOlonggR;
      #else
      class pairlElongcOlonggR  {
         public:
         //friend XX;
         long first; //
         long second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< long, float > pairlElongcOfloatgR;
      #else
      class pairlElongcOfloatgR  {
         public:
         //friend XX;
         long first; //
         float second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< long, double > pairlElongcOdoublegR;
      #else
      class pairlElongcOdoublegR  {
         public:
         //friend XX;
         long first; //
         double second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< long, void* > pairlElongcOvoidmUgR;
      #else
      class pairlElongcOvoidmUgR  {
         public:
         //friend XX;
         long first; //
         void* second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< long, char* > pairlElongcOcharmUgR;
      #else
      class pairlElongcOcharmUgR  {
         public:
         //friend XX;
         long first; //
         char* second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< float, int > pairlEfloatcOintgR;
      #else
      class pairlEfloatcOintgR  {
         public:
         //friend XX;
         float first; //
         int second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< float, long > pairlEfloatcOlonggR;
      #else
      class pairlEfloatcOlonggR  {
         public:
         //friend XX;
         float first; //
         long second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< float, float > pairlEfloatcOfloatgR;
      #else
      class pairlEfloatcOfloatgR  {
         public:
         //friend XX;
         float first; //
         float second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< float, double > pairlEfloatcOdoublegR;
      #else
      class pairlEfloatcOdoublegR  {
         public:
         //friend XX;
         float first; //
         double second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< float, void* > pairlEfloatcOvoidmUgR;
      #else
      class pairlEfloatcOvoidmUgR  {
         public:
         //friend XX;
         float first; //
         void* second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< float, char* > pairlEfloatcOcharmUgR;
      #else
      class pairlEfloatcOcharmUgR  {
         public:
         //friend XX;
         float first; //
         char* second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< double, int > pairlEdoublecOintgR;
      #else
      class pairlEdoublecOintgR  {
         public:
         //friend XX;
         double first; //
         int second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< double, long > pairlEdoublecOlonggR;
      #else
      class pairlEdoublecOlonggR  {
         public:
         //friend XX;
         double first; //
         long second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< double, float > pairlEdoublecOfloatgR;
      #else
      class pairlEdoublecOfloatgR  {
         public:
         //friend XX;
         double first; //
         float second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< double, double > pairlEdoublecOdoublegR;
      #else
      class pairlEdoublecOdoublegR  {
         public:
         //friend XX;
         double first; //
         double second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< double, void* > pairlEdoublecOvoidmUgR;
      #else
      class pairlEdoublecOvoidmUgR  {
         public:
         //friend XX;
         double first; //
         void* second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< double, char* > pairlEdoublecOcharmUgR;
      #else
      class pairlEdoublecOcharmUgR  {
         public:
         //friend XX;
         double first; //
         char* second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const char*, int > pairlEconstsPcharmUcOintgR;
      #else
      class pairlEconstsPcharmUcOintgR  {
         public:
         //friend XX;
          char* first; //
         int second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const char*, long > pairlEconstsPcharmUcOlonggR;
      #else
      class pairlEconstsPcharmUcOlonggR  {
         public:
         //friend XX;
          char* first; //
         long second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const char*, float > pairlEconstsPcharmUcOfloatgR;
      #else
      class pairlEconstsPcharmUcOfloatgR  {
         public:
         //friend XX;
          char* first; //
         float second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const char*, double > pairlEconstsPcharmUcOdoublegR;
      #else
      class pairlEconstsPcharmUcOdoublegR  {
         public:
         //friend XX;
          char* first; //
         double second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const char*, void* > pairlEconstsPcharmUcOvoidmUgR;
      #else
      class pairlEconstsPcharmUcOvoidmUgR  {
         public:
         //friend XX;
          char* first; //
         void* second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const char*, char* > pairlEconstsPcharmUcOcharmUgR;
      #else
      class pairlEconstsPcharmUcOcharmUgR  {
         public:
         //friend XX;
          char* first; //
         char* second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const ::string, int > pairlEconstsPstringcOintgR;
      #else
      class pairlEconstsPstringcOintgR  {
         public:
         //friend XX;
          string first; //
         int second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const ::string, long > pairlEconstsPstringcOlonggR;
      #else
      class pairlEconstsPstringcOlonggR  {
         public:
         //friend XX;
          string first; //
         long second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const ::string, float > pairlEconstsPstringcOfloatgR;
      #else
      class pairlEconstsPstringcOfloatgR  {
         public:
         //friend XX;
          string first; //
         float second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const ::string, double > pairlEconstsPstringcOdoublegR;
      #else
      class pairlEconstsPstringcOdoublegR  {
         public:
         //friend XX;
          string first; //
         double second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const ::string, void* > pairlEconstsPstringcOvoidmUgR;
      #else
      class pairlEconstsPstringcOvoidmUgR  {
         public:
         //friend XX;
          string first; //
         void* second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const int, int > pairlEconstsPintcOintgR;
      #else
      class pairlEconstsPintcOintgR  {
         public:
         //friend XX;
          int first; //
         int second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const int, long > pairlEconstsPintcOlonggR;
      #else
      class pairlEconstsPintcOlonggR  {
         public:
         //friend XX;
          int first; //
         long second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const int, float > pairlEconstsPintcOfloatgR;
      #else
      class pairlEconstsPintcOfloatgR  {
         public:
         //friend XX;
          int first; //
         float second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const int, double > pairlEconstsPintcOdoublegR;
      #else
      class pairlEconstsPintcOdoublegR  {
         public:
         //friend XX;
          int first; //
         double second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const int, void* > pairlEconstsPintcOvoidmUgR;
      #else
      class pairlEconstsPintcOvoidmUgR  {
         public:
         //friend XX;
          int first; //
         void* second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const int, char* > pairlEconstsPintcOcharmUgR;
      #else
      class pairlEconstsPintcOcharmUgR  {
         public:
         //friend XX;
          int first; //
         char* second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const long, int > pairlEconstsPlongcOintgR;
      #else
      class pairlEconstsPlongcOintgR  {
         public:
         //friend XX;
          long first; //
         int second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const long, long > pairlEconstsPlongcOlonggR;
      #else
      class pairlEconstsPlongcOlonggR  {
         public:
         //friend XX;
          long first; //
         long second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const long, float > pairlEconstsPlongcOfloatgR;
      #else
      class pairlEconstsPlongcOfloatgR  {
         public:
         //friend XX;
          long first; //
         float second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const long, double > pairlEconstsPlongcOdoublegR;
      #else
      class pairlEconstsPlongcOdoublegR  {
         public:
         //friend XX;
          long first; //
         double second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const long, void* > pairlEconstsPlongcOvoidmUgR;
      #else
      class pairlEconstsPlongcOvoidmUgR  {
         public:
         //friend XX;
          long first; //
         void* second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const long, char* > pairlEconstsPlongcOcharmUgR;
      #else
      class pairlEconstsPlongcOcharmUgR  {
         public:
         //friend XX;
          long first; //
         char* second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const float, int > pairlEconstsPfloatcOintgR;
      #else
      class pairlEconstsPfloatcOintgR  {
         public:
         //friend XX;
          float first; //
         int second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const float, long > pairlEconstsPfloatcOlonggR;
      #else
      class pairlEconstsPfloatcOlonggR  {
         public:
         //friend XX;
          float first; //
         long second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const float, float > pairlEconstsPfloatcOfloatgR;
      #else
      class pairlEconstsPfloatcOfloatgR  {
         public:
         //friend XX;
          float first; //
         float second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const float, double > pairlEconstsPfloatcOdoublegR;
      #else
      class pairlEconstsPfloatcOdoublegR  {
         public:
         //friend XX;
          float first; //
         double second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const float, void* > pairlEconstsPfloatcOvoidmUgR;
      #else
      class pairlEconstsPfloatcOvoidmUgR  {
         public:
         //friend XX;
          float first; //
         void* second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const float, char* > pairlEconstsPfloatcOcharmUgR;
      #else
      class pairlEconstsPfloatcOcharmUgR  {
         public:
         //friend XX;
          float first; //
         char* second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const double, int > pairlEconstsPdoublecOintgR;
      #else
      class pairlEconstsPdoublecOintgR  {
         public:
         //friend XX;
          double first; //
         int second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const double, long > pairlEconstsPdoublecOlonggR;
      #else
      class pairlEconstsPdoublecOlonggR  {
         public:
         //friend XX;
          double first; //
         long second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const double, float > pairlEconstsPdoublecOfloatgR;
      #else
      class pairlEconstsPdoublecOfloatgR  {
         public:
         //friend XX;
          double first; //
         float second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const double, double > pairlEconstsPdoublecOdoublegR;
      #else
      class pairlEconstsPdoublecOdoublegR  {
         public:
         //friend XX;
          double first; //
         double second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const double, void* > pairlEconstsPdoublecOvoidmUgR;
      #else
      class pairlEconstsPdoublecOvoidmUgR  {
         public:
         //friend XX;
          double first; //
         void* second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< const double, char* > pairlEconstsPdoublecOcharmUgR;
      #else
      class pairlEconstsPdoublecOcharmUgR  {
         public:
         //friend XX;
          double first; //
         char* second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TParameter< float > TParameterlEfloatgR;
      #else
      class TParameterlEfloatgR  :  public ::TObject {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~TParameterlEfloatgR() throw() {};
         ::TString fName; //
         float fVal; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TParameter< double > TParameterlEdoublegR;
      #else
      class TParameterlEdoublegR  :  public ::TObject {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~TParameterlEdoublegR() throw() {};
         ::TString fName; //
         double fVal; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TParameter< int > TParameterlEintgR;
      #else
      class TParameterlEintgR  :  public ::TObject {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~TParameterlEintgR() throw() {};
         ::TString fName; //
         int fVal; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TParameter< long > TParameterlElonggR;
      #else
      class TParameterlElonggR  :  public ::TObject {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~TParameterlElonggR() throw() {};
         ::TString fName; //
         long fVal; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TParameter< long long > TParameterlElongsPlonggR;
      #else
      class TParameterlElongsPlonggR  :  public ::TObject {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~TParameterlElongsPlonggR() throw() {};
         ::TString fName; //
         G__int64 fVal; //
      };
      #endif

   } // of namespace Shadow
} // of namespace ROOT
// END OF SHADOWS

namespace ROOT {
   void SetWindowAttributes_t_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void SetWindowAttributes_t_Dictionary();
   static void *new_SetWindowAttributes_t(void *p = 0);
   static void *newArray_SetWindowAttributes_t(Long_t size, void *p);
   static void delete_SetWindowAttributes_t(void *p);
   static void deleteArray_SetWindowAttributes_t(void *p);
   static void destruct_SetWindowAttributes_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::SetWindowAttributes_t*)
   {
      ::SetWindowAttributes_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::SetWindowAttributes_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("SetWindowAttributes_t", "include/GuiTypes.h", 95,
                  typeid(::SetWindowAttributes_t), DefineBehavior(ptr, ptr),
                  0, &SetWindowAttributes_t_Dictionary, isa_proxy, 0,
                  sizeof(::SetWindowAttributes_t) );
      instance.SetNew(&new_SetWindowAttributes_t);
      instance.SetNewArray(&newArray_SetWindowAttributes_t);
      instance.SetDelete(&delete_SetWindowAttributes_t);
      instance.SetDeleteArray(&deleteArray_SetWindowAttributes_t);
      instance.SetDestructor(&destruct_SetWindowAttributes_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::SetWindowAttributes_t*)
   {
      return GenerateInitInstanceLocal((::SetWindowAttributes_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::SetWindowAttributes_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void SetWindowAttributes_t_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::SetWindowAttributes_t*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void WindowAttributes_t_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void WindowAttributes_t_Dictionary();
   static void *new_WindowAttributes_t(void *p = 0);
   static void *newArray_WindowAttributes_t(Long_t size, void *p);
   static void delete_WindowAttributes_t(void *p);
   static void deleteArray_WindowAttributes_t(void *p);
   static void destruct_WindowAttributes_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::WindowAttributes_t*)
   {
      ::WindowAttributes_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::WindowAttributes_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("WindowAttributes_t", "include/GuiTypes.h", 116,
                  typeid(::WindowAttributes_t), DefineBehavior(ptr, ptr),
                  0, &WindowAttributes_t_Dictionary, isa_proxy, 0,
                  sizeof(::WindowAttributes_t) );
      instance.SetNew(&new_WindowAttributes_t);
      instance.SetNewArray(&newArray_WindowAttributes_t);
      instance.SetDelete(&delete_WindowAttributes_t);
      instance.SetDeleteArray(&deleteArray_WindowAttributes_t);
      instance.SetDestructor(&destruct_WindowAttributes_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::WindowAttributes_t*)
   {
      return GenerateInitInstanceLocal((::WindowAttributes_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::WindowAttributes_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void WindowAttributes_t_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::WindowAttributes_t*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void Event_t_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void Event_t_Dictionary();
   static void *new_Event_t(void *p = 0);
   static void *newArray_Event_t(Long_t size, void *p);
   static void delete_Event_t(void *p);
   static void deleteArray_Event_t(void *p);
   static void destruct_Event_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Event_t*)
   {
      ::Event_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Event_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("Event_t", "include/GuiTypes.h", 176,
                  typeid(::Event_t), DefineBehavior(ptr, ptr),
                  0, &Event_t_Dictionary, isa_proxy, 0,
                  sizeof(::Event_t) );
      instance.SetNew(&new_Event_t);
      instance.SetNewArray(&newArray_Event_t);
      instance.SetDelete(&delete_Event_t);
      instance.SetDeleteArray(&deleteArray_Event_t);
      instance.SetDestructor(&destruct_Event_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Event_t*)
   {
      return GenerateInitInstanceLocal((::Event_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Event_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void Event_t_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Event_t*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void GCValues_t_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void GCValues_t_Dictionary();
   static void *new_GCValues_t(void *p = 0);
   static void *newArray_GCValues_t(Long_t size, void *p);
   static void delete_GCValues_t(void *p);
   static void deleteArray_GCValues_t(void *p);
   static void destruct_GCValues_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::GCValues_t*)
   {
      ::GCValues_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::GCValues_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("GCValues_t", "include/GuiTypes.h", 223,
                  typeid(::GCValues_t), DefineBehavior(ptr, ptr),
                  0, &GCValues_t_Dictionary, isa_proxy, 0,
                  sizeof(::GCValues_t) );
      instance.SetNew(&new_GCValues_t);
      instance.SetNewArray(&newArray_GCValues_t);
      instance.SetDelete(&delete_GCValues_t);
      instance.SetDeleteArray(&deleteArray_GCValues_t);
      instance.SetDestructor(&destruct_GCValues_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::GCValues_t*)
   {
      return GenerateInitInstanceLocal((::GCValues_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::GCValues_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void GCValues_t_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::GCValues_t*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ColorStruct_t_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void ColorStruct_t_Dictionary();
   static void *new_ColorStruct_t(void *p = 0);
   static void *newArray_ColorStruct_t(Long_t size, void *p);
   static void delete_ColorStruct_t(void *p);
   static void deleteArray_ColorStruct_t(void *p);
   static void destruct_ColorStruct_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ColorStruct_t*)
   {
      ::ColorStruct_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ColorStruct_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("ColorStruct_t", "include/GuiTypes.h", 309,
                  typeid(::ColorStruct_t), DefineBehavior(ptr, ptr),
                  0, &ColorStruct_t_Dictionary, isa_proxy, 0,
                  sizeof(::ColorStruct_t) );
      instance.SetNew(&new_ColorStruct_t);
      instance.SetNewArray(&newArray_ColorStruct_t);
      instance.SetDelete(&delete_ColorStruct_t);
      instance.SetDeleteArray(&deleteArray_ColorStruct_t);
      instance.SetDestructor(&destruct_ColorStruct_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ColorStruct_t*)
   {
      return GenerateInitInstanceLocal((::ColorStruct_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ColorStruct_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ColorStruct_t_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ColorStruct_t*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void PictureAttributes_t_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void PictureAttributes_t_Dictionary();
   static void *new_PictureAttributes_t(void *p = 0);
   static void *newArray_PictureAttributes_t(Long_t size, void *p);
   static void delete_PictureAttributes_t(void *p);
   static void deleteArray_PictureAttributes_t(void *p);
   static void destruct_PictureAttributes_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::PictureAttributes_t*)
   {
      ::PictureAttributes_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::PictureAttributes_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("PictureAttributes_t", "include/GuiTypes.h", 322,
                  typeid(::PictureAttributes_t), DefineBehavior(ptr, ptr),
                  0, &PictureAttributes_t_Dictionary, isa_proxy, 0,
                  sizeof(::PictureAttributes_t) );
      instance.SetNew(&new_PictureAttributes_t);
      instance.SetNewArray(&newArray_PictureAttributes_t);
      instance.SetDelete(&delete_PictureAttributes_t);
      instance.SetDeleteArray(&deleteArray_PictureAttributes_t);
      instance.SetDestructor(&destruct_PictureAttributes_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::PictureAttributes_t*)
   {
      return GenerateInitInstanceLocal((::PictureAttributes_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::PictureAttributes_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void PictureAttributes_t_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::PictureAttributes_t*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void Segment_t_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void Segment_t_Dictionary();
   static void *new_Segment_t(void *p = 0);
   static void *newArray_Segment_t(Long_t size, void *p);
   static void delete_Segment_t(void *p);
   static void deleteArray_Segment_t(void *p);
   static void destruct_Segment_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Segment_t*)
   {
      ::Segment_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Segment_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("Segment_t", "include/GuiTypes.h", 350,
                  typeid(::Segment_t), DefineBehavior(ptr, ptr),
                  0, &Segment_t_Dictionary, isa_proxy, 0,
                  sizeof(::Segment_t) );
      instance.SetNew(&new_Segment_t);
      instance.SetNewArray(&newArray_Segment_t);
      instance.SetDelete(&delete_Segment_t);
      instance.SetDeleteArray(&deleteArray_Segment_t);
      instance.SetDestructor(&destruct_Segment_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Segment_t*)
   {
      return GenerateInitInstanceLocal((::Segment_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Segment_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void Segment_t_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Segment_t*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void Point_t_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void Point_t_Dictionary();
   static void *new_Point_t(void *p = 0);
   static void *newArray_Point_t(Long_t size, void *p);
   static void delete_Point_t(void *p);
   static void deleteArray_Point_t(void *p);
   static void destruct_Point_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Point_t*)
   {
      ::Point_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Point_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("Point_t", "include/GuiTypes.h", 355,
                  typeid(::Point_t), DefineBehavior(ptr, ptr),
                  0, &Point_t_Dictionary, isa_proxy, 0,
                  sizeof(::Point_t) );
      instance.SetNew(&new_Point_t);
      instance.SetNewArray(&newArray_Point_t);
      instance.SetDelete(&delete_Point_t);
      instance.SetDeleteArray(&deleteArray_Point_t);
      instance.SetDestructor(&destruct_Point_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Point_t*)
   {
      return GenerateInitInstanceLocal((::Point_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Point_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void Point_t_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Point_t*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void Rectangle_t_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void Rectangle_t_Dictionary();
   static void *new_Rectangle_t(void *p = 0);
   static void *newArray_Rectangle_t(Long_t size, void *p);
   static void delete_Rectangle_t(void *p);
   static void deleteArray_Rectangle_t(void *p);
   static void destruct_Rectangle_t(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Rectangle_t*)
   {
      ::Rectangle_t *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Rectangle_t),0);
      static ::ROOT::TGenericClassInfo 
         instance("Rectangle_t", "include/GuiTypes.h", 360,
                  typeid(::Rectangle_t), DefineBehavior(ptr, ptr),
                  0, &Rectangle_t_Dictionary, isa_proxy, 0,
                  sizeof(::Rectangle_t) );
      instance.SetNew(&new_Rectangle_t);
      instance.SetNewArray(&newArray_Rectangle_t);
      instance.SetDelete(&delete_Rectangle_t);
      instance.SetDeleteArray(&deleteArray_Rectangle_t);
      instance.SetDestructor(&destruct_Rectangle_t);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Rectangle_t*)
   {
      return GenerateInitInstanceLocal((::Rectangle_t*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Rectangle_t*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void Rectangle_t_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Rectangle_t*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void timespec_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void timespec_Dictionary();
   static void *new_timespec(void *p = 0);
   static void *newArray_timespec(Long_t size, void *p);
   static void delete_timespec(void *p);
   static void deleteArray_timespec(void *p);
   static void destruct_timespec(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::timespec*)
   {
      ::timespec *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::timespec),0);
      static ::ROOT::TGenericClassInfo 
         instance("timespec", "include/TTimeStamp.h", 60,
                  typeid(::timespec), DefineBehavior(ptr, ptr),
                  0, &timespec_Dictionary, isa_proxy, 0,
                  sizeof(::timespec) );
      instance.SetNew(&new_timespec);
      instance.SetNewArray(&newArray_timespec);
      instance.SetDelete(&delete_timespec);
      instance.SetDeleteArray(&deleteArray_timespec);
      instance.SetDestructor(&destruct_timespec);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::timespec*)
   {
      return GenerateInitInstanceLocal((::timespec*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::timespec*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void timespec_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::timespec*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TVirtualMutex_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void delete_TVirtualMutex(void *p);
   static void deleteArray_TVirtualMutex(void *p);
   static void destruct_TVirtualMutex(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualMutex*)
   {
      ::TVirtualMutex *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TVirtualMutex >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualMutex", ::TVirtualMutex::Class_Version(), "include/TVirtualMutex.h", 34,
                  typeid(::TVirtualMutex), DefineBehavior(ptr, ptr),
                  &::TVirtualMutex::Dictionary, isa_proxy, 0,
                  sizeof(::TVirtualMutex) );
      instance.SetDelete(&delete_TVirtualMutex);
      instance.SetDeleteArray(&deleteArray_TVirtualMutex);
      instance.SetDestructor(&destruct_TVirtualMutex);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualMutex*)
   {
      return GenerateInitInstanceLocal((::TVirtualMutex*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TVirtualMutex*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TTimeStamp_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void *new_TTimeStamp(void *p = 0);
   static void *newArray_TTimeStamp(Long_t size, void *p);
   static void delete_TTimeStamp(void *p);
   static void deleteArray_TTimeStamp(void *p);
   static void destruct_TTimeStamp(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TTimeStamp*)
   {
      ::TTimeStamp *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TTimeStamp >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TTimeStamp", ::TTimeStamp::Class_Version(), "include/TTimeStamp.h", 99,
                  typeid(::TTimeStamp), DefineBehavior(ptr, ptr),
                  &::TTimeStamp::Dictionary, isa_proxy, 4,
                  sizeof(::TTimeStamp) );
      instance.SetNew(&new_TTimeStamp);
      instance.SetNewArray(&newArray_TTimeStamp);
      instance.SetDelete(&delete_TTimeStamp);
      instance.SetDeleteArray(&deleteArray_TTimeStamp);
      instance.SetDestructor(&destruct_TTimeStamp);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TTimeStamp*)
   {
      return GenerateInitInstanceLocal((::TTimeStamp*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TTimeStamp*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TLockGuard_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void delete_TLockGuard(void *p);
   static void deleteArray_TLockGuard(void *p);
   static void destruct_TLockGuard(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TLockGuard*)
   {
      ::TLockGuard *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TLockGuard >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TLockGuard", ::TLockGuard::Class_Version(), "include/TVirtualMutex.h", 69,
                  typeid(::TLockGuard), DefineBehavior(ptr, ptr),
                  &::TLockGuard::Dictionary, isa_proxy, 0,
                  sizeof(::TLockGuard) );
      instance.SetDelete(&delete_TLockGuard);
      instance.SetDeleteArray(&deleteArray_TLockGuard);
      instance.SetDestructor(&destruct_TLockGuard);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TLockGuard*)
   {
      return GenerateInitInstanceLocal((::TLockGuard*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TLockGuard*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TVirtualPerfStats_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void delete_TVirtualPerfStats(void *p);
   static void deleteArray_TVirtualPerfStats(void *p);
   static void destruct_TVirtualPerfStats(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualPerfStats*)
   {
      ::TVirtualPerfStats *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TVirtualPerfStats >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualPerfStats", ::TVirtualPerfStats::Class_Version(), "include/TVirtualPerfStats.h", 33,
                  typeid(::TVirtualPerfStats), DefineBehavior(ptr, ptr),
                  &::TVirtualPerfStats::Dictionary, isa_proxy, 0,
                  sizeof(::TVirtualPerfStats) );
      instance.SetDelete(&delete_TVirtualPerfStats);
      instance.SetDeleteArray(&deleteArray_TVirtualPerfStats);
      instance.SetDestructor(&destruct_TVirtualPerfStats);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualPerfStats*)
   {
      return GenerateInitInstanceLocal((::TVirtualPerfStats*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TVirtualPerfStats*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TVirtualAuth_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void delete_TVirtualAuth(void *p);
   static void deleteArray_TVirtualAuth(void *p);
   static void destruct_TVirtualAuth(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualAuth*)
   {
      ::TVirtualAuth *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TVirtualAuth >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualAuth", ::TVirtualAuth::Class_Version(), "include/TVirtualAuth.h", 29,
                  typeid(::TVirtualAuth), DefineBehavior(ptr, ptr),
                  &::TVirtualAuth::Dictionary, isa_proxy, 0,
                  sizeof(::TVirtualAuth) );
      instance.SetDelete(&delete_TVirtualAuth);
      instance.SetDeleteArray(&deleteArray_TVirtualAuth);
      instance.SetDestructor(&destruct_TVirtualAuth);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualAuth*)
   {
      return GenerateInitInstanceLocal((::TVirtualAuth*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TVirtualAuth*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TUrl_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void *new_TUrl(void *p = 0);
   static void *newArray_TUrl(Long_t size, void *p);
   static void delete_TUrl(void *p);
   static void deleteArray_TUrl(void *p);
   static void destruct_TUrl(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TUrl*)
   {
      ::TUrl *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TUrl >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TUrl", ::TUrl::Class_Version(), "include/TUrl.h", 41,
                  typeid(::TUrl), DefineBehavior(ptr, ptr),
                  &::TUrl::Dictionary, isa_proxy, 0,
                  sizeof(::TUrl) );
      instance.SetNew(&new_TUrl);
      instance.SetNewArray(&newArray_TUrl);
      instance.SetDelete(&delete_TUrl);
      instance.SetDeleteArray(&deleteArray_TUrl);
      instance.SetDestructor(&destruct_TUrl);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TUrl*)
   {
      return GenerateInitInstanceLocal((::TUrl*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TUrl*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TInetAddress_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void *new_TInetAddress(void *p = 0);
   static void *newArray_TInetAddress(Long_t size, void *p);
   static void delete_TInetAddress(void *p);
   static void deleteArray_TInetAddress(void *p);
   static void destruct_TInetAddress(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TInetAddress*)
   {
      ::TInetAddress *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TInetAddress >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TInetAddress", ::TInetAddress::Class_Version(), "include/TInetAddress.h", 40,
                  typeid(::TInetAddress), DefineBehavior(ptr, ptr),
                  &::TInetAddress::Dictionary, isa_proxy, 1,
                  sizeof(::TInetAddress) );
      instance.SetNew(&new_TInetAddress);
      instance.SetNewArray(&newArray_TInetAddress);
      instance.SetDelete(&delete_TInetAddress);
      instance.SetDeleteArray(&deleteArray_TInetAddress);
      instance.SetDestructor(&destruct_TInetAddress);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TInetAddress*)
   {
      return GenerateInitInstanceLocal((::TInetAddress*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TInetAddress*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TFileInfoMeta_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void *new_TFileInfoMeta(void *p = 0);
   static void *newArray_TFileInfoMeta(Long_t size, void *p);
   static void delete_TFileInfoMeta(void *p);
   static void deleteArray_TFileInfoMeta(void *p);
   static void destruct_TFileInfoMeta(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TFileInfoMeta*)
   {
      ::TFileInfoMeta *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TFileInfoMeta >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TFileInfoMeta", ::TFileInfoMeta::Class_Version(), "include/TFileInfo.h", 109,
                  typeid(::TFileInfoMeta), DefineBehavior(ptr, ptr),
                  &::TFileInfoMeta::Dictionary, isa_proxy, 4,
                  sizeof(::TFileInfoMeta) );
      instance.SetNew(&new_TFileInfoMeta);
      instance.SetNewArray(&newArray_TFileInfoMeta);
      instance.SetDelete(&delete_TFileInfoMeta);
      instance.SetDeleteArray(&deleteArray_TFileInfoMeta);
      instance.SetDestructor(&destruct_TFileInfoMeta);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TFileInfoMeta*)
   {
      return GenerateInitInstanceLocal((::TFileInfoMeta*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TFileInfoMeta*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TFileInfo_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void *new_TFileInfo(void *p = 0);
   static void *newArray_TFileInfo(Long_t size, void *p);
   static void delete_TFileInfo(void *p);
   static void deleteArray_TFileInfo(void *p);
   static void destruct_TFileInfo(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TFileInfo*)
   {
      ::TFileInfo *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TFileInfo >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TFileInfo", ::TFileInfo::Class_Version(), "include/TFileInfo.h", 50,
                  typeid(::TFileInfo), DefineBehavior(ptr, ptr),
                  &::TFileInfo::Dictionary, isa_proxy, 4,
                  sizeof(::TFileInfo) );
      instance.SetNew(&new_TFileInfo);
      instance.SetNewArray(&newArray_TFileInfo);
      instance.SetDelete(&delete_TFileInfo);
      instance.SetDeleteArray(&deleteArray_TFileInfo);
      instance.SetDestructor(&destruct_TFileInfo);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TFileInfo*)
   {
      return GenerateInitInstanceLocal((::TFileInfo*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TFileInfo*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TFileCollection_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void *new_TFileCollection(void *p = 0);
   static void *newArray_TFileCollection(Long_t size, void *p);
   static void delete_TFileCollection(void *p);
   static void deleteArray_TFileCollection(void *p);
   static void destruct_TFileCollection(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TFileCollection*)
   {
      ::TFileCollection *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TFileCollection >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TFileCollection", ::TFileCollection::Class_Version(), "include/TFileCollection.h", 42,
                  typeid(::TFileCollection), DefineBehavior(ptr, ptr),
                  &::TFileCollection::Dictionary, isa_proxy, 4,
                  sizeof(::TFileCollection) );
      instance.SetNew(&new_TFileCollection);
      instance.SetNewArray(&newArray_TFileCollection);
      instance.SetDelete(&delete_TFileCollection);
      instance.SetDeleteArray(&deleteArray_TFileCollection);
      instance.SetDestructor(&destruct_TFileCollection);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TFileCollection*)
   {
      return GenerateInitInstanceLocal((::TFileCollection*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TFileCollection*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TRedirectOutputGuard_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void delete_TRedirectOutputGuard(void *p);
   static void deleteArray_TRedirectOutputGuard(void *p);
   static void destruct_TRedirectOutputGuard(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TRedirectOutputGuard*)
   {
      ::TRedirectOutputGuard *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TRedirectOutputGuard >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TRedirectOutputGuard", ::TRedirectOutputGuard::Class_Version(), "include/TRedirectOutputGuard.h", 38,
                  typeid(::TRedirectOutputGuard), DefineBehavior(ptr, ptr),
                  &::TRedirectOutputGuard::Dictionary, isa_proxy, 0,
                  sizeof(::TRedirectOutputGuard) );
      instance.SetDelete(&delete_TRedirectOutputGuard);
      instance.SetDeleteArray(&deleteArray_TRedirectOutputGuard);
      instance.SetDestructor(&destruct_TRedirectOutputGuard);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TRedirectOutputGuard*)
   {
      return GenerateInitInstanceLocal((::TRedirectOutputGuard*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TRedirectOutputGuard*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TVirtualMonitoringWriter_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void *new_TVirtualMonitoringWriter(void *p = 0);
   static void *newArray_TVirtualMonitoringWriter(Long_t size, void *p);
   static void delete_TVirtualMonitoringWriter(void *p);
   static void deleteArray_TVirtualMonitoringWriter(void *p);
   static void destruct_TVirtualMonitoringWriter(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualMonitoringWriter*)
   {
      ::TVirtualMonitoringWriter *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TVirtualMonitoringWriter >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualMonitoringWriter", ::TVirtualMonitoringWriter::Class_Version(), "include/TVirtualMonitoring.h", 36,
                  typeid(::TVirtualMonitoringWriter), DefineBehavior(ptr, ptr),
                  &::TVirtualMonitoringWriter::Dictionary, isa_proxy, 0,
                  sizeof(::TVirtualMonitoringWriter) );
      instance.SetNew(&new_TVirtualMonitoringWriter);
      instance.SetNewArray(&newArray_TVirtualMonitoringWriter);
      instance.SetDelete(&delete_TVirtualMonitoringWriter);
      instance.SetDeleteArray(&deleteArray_TVirtualMonitoringWriter);
      instance.SetDestructor(&destruct_TVirtualMonitoringWriter);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualMonitoringWriter*)
   {
      return GenerateInitInstanceLocal((::TVirtualMonitoringWriter*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TVirtualMonitoringWriter*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TVirtualMonitoringReader_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void *new_TVirtualMonitoringReader(void *p = 0);
   static void *newArray_TVirtualMonitoringReader(Long_t size, void *p);
   static void delete_TVirtualMonitoringReader(void *p);
   static void deleteArray_TVirtualMonitoringReader(void *p);
   static void destruct_TVirtualMonitoringReader(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualMonitoringReader*)
   {
      ::TVirtualMonitoringReader *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TVirtualMonitoringReader >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualMonitoringReader", ::TVirtualMonitoringReader::Class_Version(), "include/TVirtualMonitoring.h", 90,
                  typeid(::TVirtualMonitoringReader), DefineBehavior(ptr, ptr),
                  &::TVirtualMonitoringReader::Dictionary, isa_proxy, 0,
                  sizeof(::TVirtualMonitoringReader) );
      instance.SetNew(&new_TVirtualMonitoringReader);
      instance.SetNewArray(&newArray_TVirtualMonitoringReader);
      instance.SetDelete(&delete_TVirtualMonitoringReader);
      instance.SetDeleteArray(&deleteArray_TVirtualMonitoringReader);
      instance.SetDestructor(&destruct_TVirtualMonitoringReader);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualMonitoringReader*)
   {
      return GenerateInitInstanceLocal((::TVirtualMonitoringReader*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TVirtualMonitoringReader*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TObjectSpy_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void *new_TObjectSpy(void *p = 0);
   static void *newArray_TObjectSpy(Long_t size, void *p);
   static void delete_TObjectSpy(void *p);
   static void deleteArray_TObjectSpy(void *p);
   static void destruct_TObjectSpy(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TObjectSpy*)
   {
      ::TObjectSpy *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TObjectSpy >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TObjectSpy", ::TObjectSpy::Class_Version(), "include/TObjectSpy.h", 32,
                  typeid(::TObjectSpy), DefineBehavior(ptr, ptr),
                  &::TObjectSpy::Dictionary, isa_proxy, 0,
                  sizeof(::TObjectSpy) );
      instance.SetNew(&new_TObjectSpy);
      instance.SetNewArray(&newArray_TObjectSpy);
      instance.SetDelete(&delete_TObjectSpy);
      instance.SetDeleteArray(&deleteArray_TObjectSpy);
      instance.SetDestructor(&destruct_TObjectSpy);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TObjectSpy*)
   {
      return GenerateInitInstanceLocal((::TObjectSpy*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TObjectSpy*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TObjectRefSpy_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void delete_TObjectRefSpy(void *p);
   static void deleteArray_TObjectRefSpy(void *p);
   static void destruct_TObjectRefSpy(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TObjectRefSpy*)
   {
      ::TObjectRefSpy *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TObjectRefSpy >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TObjectRefSpy", ::TObjectRefSpy::Class_Version(), "include/TObjectSpy.h", 54,
                  typeid(::TObjectRefSpy), DefineBehavior(ptr, ptr),
                  &::TObjectRefSpy::Dictionary, isa_proxy, 0,
                  sizeof(::TObjectRefSpy) );
      instance.SetDelete(&delete_TObjectRefSpy);
      instance.SetDeleteArray(&deleteArray_TObjectRefSpy);
      instance.SetDestructor(&destruct_TObjectRefSpy);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TObjectRefSpy*)
   {
      return GenerateInitInstanceLocal((::TObjectRefSpy*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TObjectRefSpy*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TUri_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void *new_TUri(void *p = 0);
   static void *newArray_TUri(Long_t size, void *p);
   static void delete_TUri(void *p);
   static void deleteArray_TUri(void *p);
   static void destruct_TUri(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TUri*)
   {
      ::TUri *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TUri >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TUri", ::TUri::Class_Version(), "include/TUri.h", 39,
                  typeid(::TUri), DefineBehavior(ptr, ptr),
                  &::TUri::Dictionary, isa_proxy, 0,
                  sizeof(::TUri) );
      instance.SetNew(&new_TUri);
      instance.SetNewArray(&newArray_TUri);
      instance.SetDelete(&delete_TUri);
      instance.SetDeleteArray(&deleteArray_TUri);
      instance.SetDestructor(&destruct_TUri);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TUri*)
   {
      return GenerateInitInstanceLocal((::TUri*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TUri*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TVirtualTableInterface_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void delete_TVirtualTableInterface(void *p);
   static void deleteArray_TVirtualTableInterface(void *p);
   static void destruct_TVirtualTableInterface(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TVirtualTableInterface*)
   {
      ::TVirtualTableInterface *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TVirtualTableInterface >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TVirtualTableInterface", ::TVirtualTableInterface::Class_Version(), "include/TVirtualTableInterface.h", 19,
                  typeid(::TVirtualTableInterface), DefineBehavior(ptr, ptr),
                  &::TVirtualTableInterface::Dictionary, isa_proxy, 4,
                  sizeof(::TVirtualTableInterface) );
      instance.SetDelete(&delete_TVirtualTableInterface);
      instance.SetDeleteArray(&deleteArray_TVirtualTableInterface);
      instance.SetDestructor(&destruct_TVirtualTableInterface);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TVirtualTableInterface*)
   {
      return GenerateInitInstanceLocal((::TVirtualTableInterface*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TVirtualTableInterface*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void TBase64_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void *new_TBase64(void *p = 0);
   static void *newArray_TBase64(Long_t size, void *p);
   static void delete_TBase64(void *p);
   static void deleteArray_TBase64(void *p);
   static void destruct_TBase64(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TBase64*)
   {
      ::TBase64 *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TBase64 >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TBase64", ::TBase64::Class_Version(), "include/TBase64.h", 33,
                  typeid(::TBase64), DefineBehavior(ptr, ptr),
                  &::TBase64::Dictionary, isa_proxy, 0,
                  sizeof(::TBase64) );
      instance.SetNew(&new_TBase64);
      instance.SetNewArray(&newArray_TBase64);
      instance.SetDelete(&delete_TBase64);
      instance.SetDeleteArray(&deleteArray_TBase64);
      instance.SetDestructor(&destruct_TBase64);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TBase64*)
   {
      return GenerateInitInstanceLocal((::TBase64*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TBase64*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void pairlEcharmUcOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEcharmUcOintgR_Dictionary();
   static void *new_pairlEcharmUcOintgR(void *p = 0);
   static void *newArray_pairlEcharmUcOintgR(Long_t size, void *p);
   static void delete_pairlEcharmUcOintgR(void *p);
   static void deleteArray_pairlEcharmUcOintgR(void *p);
   static void destruct_pairlEcharmUcOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<char*,int>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<char*,int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<char*,int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<char*,int>", "prec_stl/utility", 17,
                  typeid(pair<char*,int>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEcharmUcOintgR_ShowMembers, &pairlEcharmUcOintgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<char*,int>) );
      instance.SetNew(&new_pairlEcharmUcOintgR);
      instance.SetNewArray(&newArray_pairlEcharmUcOintgR);
      instance.SetDelete(&delete_pairlEcharmUcOintgR);
      instance.SetDeleteArray(&deleteArray_pairlEcharmUcOintgR);
      instance.SetDestructor(&destruct_pairlEcharmUcOintgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<char*,int>*)
   {
      return GenerateInitInstanceLocal((pair<char*,int>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<char*,int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEcharmUcOintgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<char*,int>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEcharmUcOlonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEcharmUcOlonggR_Dictionary();
   static void *new_pairlEcharmUcOlonggR(void *p = 0);
   static void *newArray_pairlEcharmUcOlonggR(Long_t size, void *p);
   static void delete_pairlEcharmUcOlonggR(void *p);
   static void deleteArray_pairlEcharmUcOlonggR(void *p);
   static void destruct_pairlEcharmUcOlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<char*,long>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<char*,long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<char*,long>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<char*,long>", "prec_stl/utility", 17,
                  typeid(pair<char*,long>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEcharmUcOlonggR_ShowMembers, &pairlEcharmUcOlonggR_Dictionary, isa_proxy, 4,
                  sizeof(pair<char*,long>) );
      instance.SetNew(&new_pairlEcharmUcOlonggR);
      instance.SetNewArray(&newArray_pairlEcharmUcOlonggR);
      instance.SetDelete(&delete_pairlEcharmUcOlonggR);
      instance.SetDeleteArray(&deleteArray_pairlEcharmUcOlonggR);
      instance.SetDestructor(&destruct_pairlEcharmUcOlonggR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<char*,long>*)
   {
      return GenerateInitInstanceLocal((pair<char*,long>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<char*,long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEcharmUcOlonggR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<char*,long>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEcharmUcOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEcharmUcOfloatgR_Dictionary();
   static void *new_pairlEcharmUcOfloatgR(void *p = 0);
   static void *newArray_pairlEcharmUcOfloatgR(Long_t size, void *p);
   static void delete_pairlEcharmUcOfloatgR(void *p);
   static void deleteArray_pairlEcharmUcOfloatgR(void *p);
   static void destruct_pairlEcharmUcOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<char*,float>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<char*,float> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<char*,float>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<char*,float>", "prec_stl/utility", 17,
                  typeid(pair<char*,float>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEcharmUcOfloatgR_ShowMembers, &pairlEcharmUcOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<char*,float>) );
      instance.SetNew(&new_pairlEcharmUcOfloatgR);
      instance.SetNewArray(&newArray_pairlEcharmUcOfloatgR);
      instance.SetDelete(&delete_pairlEcharmUcOfloatgR);
      instance.SetDeleteArray(&deleteArray_pairlEcharmUcOfloatgR);
      instance.SetDestructor(&destruct_pairlEcharmUcOfloatgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<char*,float>*)
   {
      return GenerateInitInstanceLocal((pair<char*,float>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<char*,float>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEcharmUcOfloatgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<char*,float>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEcharmUcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEcharmUcOdoublegR_Dictionary();
   static void *new_pairlEcharmUcOdoublegR(void *p = 0);
   static void *newArray_pairlEcharmUcOdoublegR(Long_t size, void *p);
   static void delete_pairlEcharmUcOdoublegR(void *p);
   static void deleteArray_pairlEcharmUcOdoublegR(void *p);
   static void destruct_pairlEcharmUcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<char*,double>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<char*,double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<char*,double>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<char*,double>", "prec_stl/utility", 17,
                  typeid(pair<char*,double>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEcharmUcOdoublegR_ShowMembers, &pairlEcharmUcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<char*,double>) );
      instance.SetNew(&new_pairlEcharmUcOdoublegR);
      instance.SetNewArray(&newArray_pairlEcharmUcOdoublegR);
      instance.SetDelete(&delete_pairlEcharmUcOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlEcharmUcOdoublegR);
      instance.SetDestructor(&destruct_pairlEcharmUcOdoublegR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<char*,double>*)
   {
      return GenerateInitInstanceLocal((pair<char*,double>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<char*,double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEcharmUcOdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<char*,double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEcharmUcOvoidmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEcharmUcOvoidmUgR_Dictionary();
   static void *new_pairlEcharmUcOvoidmUgR(void *p = 0);
   static void *newArray_pairlEcharmUcOvoidmUgR(Long_t size, void *p);
   static void delete_pairlEcharmUcOvoidmUgR(void *p);
   static void deleteArray_pairlEcharmUcOvoidmUgR(void *p);
   static void destruct_pairlEcharmUcOvoidmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<char*,void*>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<char*,void*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<char*,void*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<char*,void*>", "prec_stl/utility", 17,
                  typeid(pair<char*,void*>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEcharmUcOvoidmUgR_ShowMembers, &pairlEcharmUcOvoidmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<char*,void*>) );
      instance.SetNew(&new_pairlEcharmUcOvoidmUgR);
      instance.SetNewArray(&newArray_pairlEcharmUcOvoidmUgR);
      instance.SetDelete(&delete_pairlEcharmUcOvoidmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEcharmUcOvoidmUgR);
      instance.SetDestructor(&destruct_pairlEcharmUcOvoidmUgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<char*,void*>*)
   {
      return GenerateInitInstanceLocal((pair<char*,void*>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<char*,void*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEcharmUcOvoidmUgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<char*,void*>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEcharmUcOcharmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEcharmUcOcharmUgR_Dictionary();
   static void *new_pairlEcharmUcOcharmUgR(void *p = 0);
   static void *newArray_pairlEcharmUcOcharmUgR(Long_t size, void *p);
   static void delete_pairlEcharmUcOcharmUgR(void *p);
   static void deleteArray_pairlEcharmUcOcharmUgR(void *p);
   static void destruct_pairlEcharmUcOcharmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<char*,char*>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<char*,char*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<char*,char*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<char*,char*>", "prec_stl/utility", 17,
                  typeid(pair<char*,char*>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEcharmUcOcharmUgR_ShowMembers, &pairlEcharmUcOcharmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<char*,char*>) );
      instance.SetNew(&new_pairlEcharmUcOcharmUgR);
      instance.SetNewArray(&newArray_pairlEcharmUcOcharmUgR);
      instance.SetDelete(&delete_pairlEcharmUcOcharmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEcharmUcOcharmUgR);
      instance.SetDestructor(&destruct_pairlEcharmUcOcharmUgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<char*,char*>*)
   {
      return GenerateInitInstanceLocal((pair<char*,char*>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<char*,char*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEcharmUcOcharmUgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<char*,char*>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEstringcOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEstringcOintgR_Dictionary();
   static void *new_pairlEstringcOintgR(void *p = 0);
   static void *newArray_pairlEstringcOintgR(Long_t size, void *p);
   static void delete_pairlEstringcOintgR(void *p);
   static void deleteArray_pairlEstringcOintgR(void *p);
   static void destruct_pairlEstringcOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<string,int>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<string,int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<string,int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<string,int>", "prec_stl/utility", 17,
                  typeid(pair<string,int>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEstringcOintgR_ShowMembers, &pairlEstringcOintgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<string,int>) );
      instance.SetNew(&new_pairlEstringcOintgR);
      instance.SetNewArray(&newArray_pairlEstringcOintgR);
      instance.SetDelete(&delete_pairlEstringcOintgR);
      instance.SetDeleteArray(&deleteArray_pairlEstringcOintgR);
      instance.SetDestructor(&destruct_pairlEstringcOintgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<string,int>*)
   {
      return GenerateInitInstanceLocal((pair<string,int>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<string,int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEstringcOintgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<string,int>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEstringcOlonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEstringcOlonggR_Dictionary();
   static void *new_pairlEstringcOlonggR(void *p = 0);
   static void *newArray_pairlEstringcOlonggR(Long_t size, void *p);
   static void delete_pairlEstringcOlonggR(void *p);
   static void deleteArray_pairlEstringcOlonggR(void *p);
   static void destruct_pairlEstringcOlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<string,long>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<string,long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<string,long>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<string,long>", "prec_stl/utility", 17,
                  typeid(pair<string,long>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEstringcOlonggR_ShowMembers, &pairlEstringcOlonggR_Dictionary, isa_proxy, 4,
                  sizeof(pair<string,long>) );
      instance.SetNew(&new_pairlEstringcOlonggR);
      instance.SetNewArray(&newArray_pairlEstringcOlonggR);
      instance.SetDelete(&delete_pairlEstringcOlonggR);
      instance.SetDeleteArray(&deleteArray_pairlEstringcOlonggR);
      instance.SetDestructor(&destruct_pairlEstringcOlonggR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<string,long>*)
   {
      return GenerateInitInstanceLocal((pair<string,long>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<string,long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEstringcOlonggR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<string,long>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEstringcOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEstringcOfloatgR_Dictionary();
   static void *new_pairlEstringcOfloatgR(void *p = 0);
   static void *newArray_pairlEstringcOfloatgR(Long_t size, void *p);
   static void delete_pairlEstringcOfloatgR(void *p);
   static void deleteArray_pairlEstringcOfloatgR(void *p);
   static void destruct_pairlEstringcOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<string,float>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<string,float> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<string,float>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<string,float>", "prec_stl/utility", 17,
                  typeid(pair<string,float>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEstringcOfloatgR_ShowMembers, &pairlEstringcOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<string,float>) );
      instance.SetNew(&new_pairlEstringcOfloatgR);
      instance.SetNewArray(&newArray_pairlEstringcOfloatgR);
      instance.SetDelete(&delete_pairlEstringcOfloatgR);
      instance.SetDeleteArray(&deleteArray_pairlEstringcOfloatgR);
      instance.SetDestructor(&destruct_pairlEstringcOfloatgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<string,float>*)
   {
      return GenerateInitInstanceLocal((pair<string,float>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<string,float>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEstringcOfloatgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<string,float>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEstringcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEstringcOdoublegR_Dictionary();
   static void *new_pairlEstringcOdoublegR(void *p = 0);
   static void *newArray_pairlEstringcOdoublegR(Long_t size, void *p);
   static void delete_pairlEstringcOdoublegR(void *p);
   static void deleteArray_pairlEstringcOdoublegR(void *p);
   static void destruct_pairlEstringcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<string,double>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<string,double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<string,double>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<string,double>", "prec_stl/utility", 17,
                  typeid(pair<string,double>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEstringcOdoublegR_ShowMembers, &pairlEstringcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<string,double>) );
      instance.SetNew(&new_pairlEstringcOdoublegR);
      instance.SetNewArray(&newArray_pairlEstringcOdoublegR);
      instance.SetDelete(&delete_pairlEstringcOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlEstringcOdoublegR);
      instance.SetDestructor(&destruct_pairlEstringcOdoublegR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<string,double>*)
   {
      return GenerateInitInstanceLocal((pair<string,double>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<string,double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEstringcOdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<string,double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEstringcOvoidmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEstringcOvoidmUgR_Dictionary();
   static void *new_pairlEstringcOvoidmUgR(void *p = 0);
   static void *newArray_pairlEstringcOvoidmUgR(Long_t size, void *p);
   static void delete_pairlEstringcOvoidmUgR(void *p);
   static void deleteArray_pairlEstringcOvoidmUgR(void *p);
   static void destruct_pairlEstringcOvoidmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<string,void*>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<string,void*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<string,void*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<string,void*>", "prec_stl/utility", 17,
                  typeid(pair<string,void*>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEstringcOvoidmUgR_ShowMembers, &pairlEstringcOvoidmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<string,void*>) );
      instance.SetNew(&new_pairlEstringcOvoidmUgR);
      instance.SetNewArray(&newArray_pairlEstringcOvoidmUgR);
      instance.SetDelete(&delete_pairlEstringcOvoidmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEstringcOvoidmUgR);
      instance.SetDestructor(&destruct_pairlEstringcOvoidmUgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<string,void*>*)
   {
      return GenerateInitInstanceLocal((pair<string,void*>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<string,void*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEstringcOvoidmUgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<string,void*>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEintcOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEintcOintgR_Dictionary();
   static void *new_pairlEintcOintgR(void *p = 0);
   static void *newArray_pairlEintcOintgR(Long_t size, void *p);
   static void delete_pairlEintcOintgR(void *p);
   static void deleteArray_pairlEintcOintgR(void *p);
   static void destruct_pairlEintcOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<int,int>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<int,int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<int,int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<int,int>", "prec_stl/utility", 17,
                  typeid(pair<int,int>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEintcOintgR_ShowMembers, &pairlEintcOintgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<int,int>) );
      instance.SetNew(&new_pairlEintcOintgR);
      instance.SetNewArray(&newArray_pairlEintcOintgR);
      instance.SetDelete(&delete_pairlEintcOintgR);
      instance.SetDeleteArray(&deleteArray_pairlEintcOintgR);
      instance.SetDestructor(&destruct_pairlEintcOintgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<int,int>*)
   {
      return GenerateInitInstanceLocal((pair<int,int>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<int,int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEintcOintgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<int,int>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEintcOlonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEintcOlonggR_Dictionary();
   static void *new_pairlEintcOlonggR(void *p = 0);
   static void *newArray_pairlEintcOlonggR(Long_t size, void *p);
   static void delete_pairlEintcOlonggR(void *p);
   static void deleteArray_pairlEintcOlonggR(void *p);
   static void destruct_pairlEintcOlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<int,long>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<int,long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<int,long>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<int,long>", "prec_stl/utility", 17,
                  typeid(pair<int,long>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEintcOlonggR_ShowMembers, &pairlEintcOlonggR_Dictionary, isa_proxy, 4,
                  sizeof(pair<int,long>) );
      instance.SetNew(&new_pairlEintcOlonggR);
      instance.SetNewArray(&newArray_pairlEintcOlonggR);
      instance.SetDelete(&delete_pairlEintcOlonggR);
      instance.SetDeleteArray(&deleteArray_pairlEintcOlonggR);
      instance.SetDestructor(&destruct_pairlEintcOlonggR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<int,long>*)
   {
      return GenerateInitInstanceLocal((pair<int,long>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<int,long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEintcOlonggR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<int,long>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEintcOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEintcOfloatgR_Dictionary();
   static void *new_pairlEintcOfloatgR(void *p = 0);
   static void *newArray_pairlEintcOfloatgR(Long_t size, void *p);
   static void delete_pairlEintcOfloatgR(void *p);
   static void deleteArray_pairlEintcOfloatgR(void *p);
   static void destruct_pairlEintcOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<int,float>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<int,float> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<int,float>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<int,float>", "prec_stl/utility", 17,
                  typeid(pair<int,float>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEintcOfloatgR_ShowMembers, &pairlEintcOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<int,float>) );
      instance.SetNew(&new_pairlEintcOfloatgR);
      instance.SetNewArray(&newArray_pairlEintcOfloatgR);
      instance.SetDelete(&delete_pairlEintcOfloatgR);
      instance.SetDeleteArray(&deleteArray_pairlEintcOfloatgR);
      instance.SetDestructor(&destruct_pairlEintcOfloatgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<int,float>*)
   {
      return GenerateInitInstanceLocal((pair<int,float>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<int,float>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEintcOfloatgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<int,float>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEintcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEintcOdoublegR_Dictionary();
   static void *new_pairlEintcOdoublegR(void *p = 0);
   static void *newArray_pairlEintcOdoublegR(Long_t size, void *p);
   static void delete_pairlEintcOdoublegR(void *p);
   static void deleteArray_pairlEintcOdoublegR(void *p);
   static void destruct_pairlEintcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<int,double>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<int,double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<int,double>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<int,double>", "prec_stl/utility", 17,
                  typeid(pair<int,double>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEintcOdoublegR_ShowMembers, &pairlEintcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<int,double>) );
      instance.SetNew(&new_pairlEintcOdoublegR);
      instance.SetNewArray(&newArray_pairlEintcOdoublegR);
      instance.SetDelete(&delete_pairlEintcOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlEintcOdoublegR);
      instance.SetDestructor(&destruct_pairlEintcOdoublegR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<int,double>*)
   {
      return GenerateInitInstanceLocal((pair<int,double>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<int,double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEintcOdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<int,double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEintcOvoidmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEintcOvoidmUgR_Dictionary();
   static void *new_pairlEintcOvoidmUgR(void *p = 0);
   static void *newArray_pairlEintcOvoidmUgR(Long_t size, void *p);
   static void delete_pairlEintcOvoidmUgR(void *p);
   static void deleteArray_pairlEintcOvoidmUgR(void *p);
   static void destruct_pairlEintcOvoidmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<int,void*>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<int,void*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<int,void*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<int,void*>", "prec_stl/utility", 17,
                  typeid(pair<int,void*>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEintcOvoidmUgR_ShowMembers, &pairlEintcOvoidmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<int,void*>) );
      instance.SetNew(&new_pairlEintcOvoidmUgR);
      instance.SetNewArray(&newArray_pairlEintcOvoidmUgR);
      instance.SetDelete(&delete_pairlEintcOvoidmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEintcOvoidmUgR);
      instance.SetDestructor(&destruct_pairlEintcOvoidmUgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<int,void*>*)
   {
      return GenerateInitInstanceLocal((pair<int,void*>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<int,void*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEintcOvoidmUgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<int,void*>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEintcOcharmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEintcOcharmUgR_Dictionary();
   static void *new_pairlEintcOcharmUgR(void *p = 0);
   static void *newArray_pairlEintcOcharmUgR(Long_t size, void *p);
   static void delete_pairlEintcOcharmUgR(void *p);
   static void deleteArray_pairlEintcOcharmUgR(void *p);
   static void destruct_pairlEintcOcharmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<int,char*>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<int,char*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<int,char*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<int,char*>", "prec_stl/utility", 17,
                  typeid(pair<int,char*>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEintcOcharmUgR_ShowMembers, &pairlEintcOcharmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<int,char*>) );
      instance.SetNew(&new_pairlEintcOcharmUgR);
      instance.SetNewArray(&newArray_pairlEintcOcharmUgR);
      instance.SetDelete(&delete_pairlEintcOcharmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEintcOcharmUgR);
      instance.SetDestructor(&destruct_pairlEintcOcharmUgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<int,char*>*)
   {
      return GenerateInitInstanceLocal((pair<int,char*>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<int,char*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEintcOcharmUgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<int,char*>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlElongcOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlElongcOintgR_Dictionary();
   static void *new_pairlElongcOintgR(void *p = 0);
   static void *newArray_pairlElongcOintgR(Long_t size, void *p);
   static void delete_pairlElongcOintgR(void *p);
   static void deleteArray_pairlElongcOintgR(void *p);
   static void destruct_pairlElongcOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<long,int>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<long,int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<long,int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<long,int>", "prec_stl/utility", 17,
                  typeid(pair<long,int>), DefineBehavior(ptr, ptr),
                  (void*)&pairlElongcOintgR_ShowMembers, &pairlElongcOintgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<long,int>) );
      instance.SetNew(&new_pairlElongcOintgR);
      instance.SetNewArray(&newArray_pairlElongcOintgR);
      instance.SetDelete(&delete_pairlElongcOintgR);
      instance.SetDeleteArray(&deleteArray_pairlElongcOintgR);
      instance.SetDestructor(&destruct_pairlElongcOintgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<long,int>*)
   {
      return GenerateInitInstanceLocal((pair<long,int>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<long,int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlElongcOintgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<long,int>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlElongcOlonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlElongcOlonggR_Dictionary();
   static void *new_pairlElongcOlonggR(void *p = 0);
   static void *newArray_pairlElongcOlonggR(Long_t size, void *p);
   static void delete_pairlElongcOlonggR(void *p);
   static void deleteArray_pairlElongcOlonggR(void *p);
   static void destruct_pairlElongcOlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<long,long>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<long,long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<long,long>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<long,long>", "prec_stl/utility", 17,
                  typeid(pair<long,long>), DefineBehavior(ptr, ptr),
                  (void*)&pairlElongcOlonggR_ShowMembers, &pairlElongcOlonggR_Dictionary, isa_proxy, 4,
                  sizeof(pair<long,long>) );
      instance.SetNew(&new_pairlElongcOlonggR);
      instance.SetNewArray(&newArray_pairlElongcOlonggR);
      instance.SetDelete(&delete_pairlElongcOlonggR);
      instance.SetDeleteArray(&deleteArray_pairlElongcOlonggR);
      instance.SetDestructor(&destruct_pairlElongcOlonggR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<long,long>*)
   {
      return GenerateInitInstanceLocal((pair<long,long>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<long,long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlElongcOlonggR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<long,long>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlElongcOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlElongcOfloatgR_Dictionary();
   static void *new_pairlElongcOfloatgR(void *p = 0);
   static void *newArray_pairlElongcOfloatgR(Long_t size, void *p);
   static void delete_pairlElongcOfloatgR(void *p);
   static void deleteArray_pairlElongcOfloatgR(void *p);
   static void destruct_pairlElongcOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<long,float>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<long,float> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<long,float>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<long,float>", "prec_stl/utility", 17,
                  typeid(pair<long,float>), DefineBehavior(ptr, ptr),
                  (void*)&pairlElongcOfloatgR_ShowMembers, &pairlElongcOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<long,float>) );
      instance.SetNew(&new_pairlElongcOfloatgR);
      instance.SetNewArray(&newArray_pairlElongcOfloatgR);
      instance.SetDelete(&delete_pairlElongcOfloatgR);
      instance.SetDeleteArray(&deleteArray_pairlElongcOfloatgR);
      instance.SetDestructor(&destruct_pairlElongcOfloatgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<long,float>*)
   {
      return GenerateInitInstanceLocal((pair<long,float>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<long,float>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlElongcOfloatgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<long,float>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlElongcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlElongcOdoublegR_Dictionary();
   static void *new_pairlElongcOdoublegR(void *p = 0);
   static void *newArray_pairlElongcOdoublegR(Long_t size, void *p);
   static void delete_pairlElongcOdoublegR(void *p);
   static void deleteArray_pairlElongcOdoublegR(void *p);
   static void destruct_pairlElongcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<long,double>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<long,double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<long,double>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<long,double>", "prec_stl/utility", 17,
                  typeid(pair<long,double>), DefineBehavior(ptr, ptr),
                  (void*)&pairlElongcOdoublegR_ShowMembers, &pairlElongcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<long,double>) );
      instance.SetNew(&new_pairlElongcOdoublegR);
      instance.SetNewArray(&newArray_pairlElongcOdoublegR);
      instance.SetDelete(&delete_pairlElongcOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlElongcOdoublegR);
      instance.SetDestructor(&destruct_pairlElongcOdoublegR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<long,double>*)
   {
      return GenerateInitInstanceLocal((pair<long,double>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<long,double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlElongcOdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<long,double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlElongcOvoidmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlElongcOvoidmUgR_Dictionary();
   static void *new_pairlElongcOvoidmUgR(void *p = 0);
   static void *newArray_pairlElongcOvoidmUgR(Long_t size, void *p);
   static void delete_pairlElongcOvoidmUgR(void *p);
   static void deleteArray_pairlElongcOvoidmUgR(void *p);
   static void destruct_pairlElongcOvoidmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<long,void*>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<long,void*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<long,void*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<long,void*>", "prec_stl/utility", 17,
                  typeid(pair<long,void*>), DefineBehavior(ptr, ptr),
                  (void*)&pairlElongcOvoidmUgR_ShowMembers, &pairlElongcOvoidmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<long,void*>) );
      instance.SetNew(&new_pairlElongcOvoidmUgR);
      instance.SetNewArray(&newArray_pairlElongcOvoidmUgR);
      instance.SetDelete(&delete_pairlElongcOvoidmUgR);
      instance.SetDeleteArray(&deleteArray_pairlElongcOvoidmUgR);
      instance.SetDestructor(&destruct_pairlElongcOvoidmUgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<long,void*>*)
   {
      return GenerateInitInstanceLocal((pair<long,void*>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<long,void*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlElongcOvoidmUgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<long,void*>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlElongcOcharmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlElongcOcharmUgR_Dictionary();
   static void *new_pairlElongcOcharmUgR(void *p = 0);
   static void *newArray_pairlElongcOcharmUgR(Long_t size, void *p);
   static void delete_pairlElongcOcharmUgR(void *p);
   static void deleteArray_pairlElongcOcharmUgR(void *p);
   static void destruct_pairlElongcOcharmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<long,char*>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<long,char*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<long,char*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<long,char*>", "prec_stl/utility", 17,
                  typeid(pair<long,char*>), DefineBehavior(ptr, ptr),
                  (void*)&pairlElongcOcharmUgR_ShowMembers, &pairlElongcOcharmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<long,char*>) );
      instance.SetNew(&new_pairlElongcOcharmUgR);
      instance.SetNewArray(&newArray_pairlElongcOcharmUgR);
      instance.SetDelete(&delete_pairlElongcOcharmUgR);
      instance.SetDeleteArray(&deleteArray_pairlElongcOcharmUgR);
      instance.SetDestructor(&destruct_pairlElongcOcharmUgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<long,char*>*)
   {
      return GenerateInitInstanceLocal((pair<long,char*>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<long,char*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlElongcOcharmUgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<long,char*>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEfloatcOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEfloatcOintgR_Dictionary();
   static void *new_pairlEfloatcOintgR(void *p = 0);
   static void *newArray_pairlEfloatcOintgR(Long_t size, void *p);
   static void delete_pairlEfloatcOintgR(void *p);
   static void deleteArray_pairlEfloatcOintgR(void *p);
   static void destruct_pairlEfloatcOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<float,int>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<float,int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<float,int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<float,int>", "prec_stl/utility", 17,
                  typeid(pair<float,int>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEfloatcOintgR_ShowMembers, &pairlEfloatcOintgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<float,int>) );
      instance.SetNew(&new_pairlEfloatcOintgR);
      instance.SetNewArray(&newArray_pairlEfloatcOintgR);
      instance.SetDelete(&delete_pairlEfloatcOintgR);
      instance.SetDeleteArray(&deleteArray_pairlEfloatcOintgR);
      instance.SetDestructor(&destruct_pairlEfloatcOintgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<float,int>*)
   {
      return GenerateInitInstanceLocal((pair<float,int>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<float,int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEfloatcOintgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<float,int>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEfloatcOlonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEfloatcOlonggR_Dictionary();
   static void *new_pairlEfloatcOlonggR(void *p = 0);
   static void *newArray_pairlEfloatcOlonggR(Long_t size, void *p);
   static void delete_pairlEfloatcOlonggR(void *p);
   static void deleteArray_pairlEfloatcOlonggR(void *p);
   static void destruct_pairlEfloatcOlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<float,long>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<float,long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<float,long>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<float,long>", "prec_stl/utility", 17,
                  typeid(pair<float,long>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEfloatcOlonggR_ShowMembers, &pairlEfloatcOlonggR_Dictionary, isa_proxy, 4,
                  sizeof(pair<float,long>) );
      instance.SetNew(&new_pairlEfloatcOlonggR);
      instance.SetNewArray(&newArray_pairlEfloatcOlonggR);
      instance.SetDelete(&delete_pairlEfloatcOlonggR);
      instance.SetDeleteArray(&deleteArray_pairlEfloatcOlonggR);
      instance.SetDestructor(&destruct_pairlEfloatcOlonggR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<float,long>*)
   {
      return GenerateInitInstanceLocal((pair<float,long>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<float,long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEfloatcOlonggR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<float,long>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEfloatcOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEfloatcOfloatgR_Dictionary();
   static void *new_pairlEfloatcOfloatgR(void *p = 0);
   static void *newArray_pairlEfloatcOfloatgR(Long_t size, void *p);
   static void delete_pairlEfloatcOfloatgR(void *p);
   static void deleteArray_pairlEfloatcOfloatgR(void *p);
   static void destruct_pairlEfloatcOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<float,float>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<float,float> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<float,float>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<float,float>", "prec_stl/utility", 17,
                  typeid(pair<float,float>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEfloatcOfloatgR_ShowMembers, &pairlEfloatcOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<float,float>) );
      instance.SetNew(&new_pairlEfloatcOfloatgR);
      instance.SetNewArray(&newArray_pairlEfloatcOfloatgR);
      instance.SetDelete(&delete_pairlEfloatcOfloatgR);
      instance.SetDeleteArray(&deleteArray_pairlEfloatcOfloatgR);
      instance.SetDestructor(&destruct_pairlEfloatcOfloatgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<float,float>*)
   {
      return GenerateInitInstanceLocal((pair<float,float>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<float,float>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEfloatcOfloatgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<float,float>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEfloatcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEfloatcOdoublegR_Dictionary();
   static void *new_pairlEfloatcOdoublegR(void *p = 0);
   static void *newArray_pairlEfloatcOdoublegR(Long_t size, void *p);
   static void delete_pairlEfloatcOdoublegR(void *p);
   static void deleteArray_pairlEfloatcOdoublegR(void *p);
   static void destruct_pairlEfloatcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<float,double>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<float,double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<float,double>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<float,double>", "prec_stl/utility", 17,
                  typeid(pair<float,double>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEfloatcOdoublegR_ShowMembers, &pairlEfloatcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<float,double>) );
      instance.SetNew(&new_pairlEfloatcOdoublegR);
      instance.SetNewArray(&newArray_pairlEfloatcOdoublegR);
      instance.SetDelete(&delete_pairlEfloatcOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlEfloatcOdoublegR);
      instance.SetDestructor(&destruct_pairlEfloatcOdoublegR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<float,double>*)
   {
      return GenerateInitInstanceLocal((pair<float,double>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<float,double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEfloatcOdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<float,double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEfloatcOvoidmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEfloatcOvoidmUgR_Dictionary();
   static void *new_pairlEfloatcOvoidmUgR(void *p = 0);
   static void *newArray_pairlEfloatcOvoidmUgR(Long_t size, void *p);
   static void delete_pairlEfloatcOvoidmUgR(void *p);
   static void deleteArray_pairlEfloatcOvoidmUgR(void *p);
   static void destruct_pairlEfloatcOvoidmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<float,void*>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<float,void*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<float,void*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<float,void*>", "prec_stl/utility", 17,
                  typeid(pair<float,void*>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEfloatcOvoidmUgR_ShowMembers, &pairlEfloatcOvoidmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<float,void*>) );
      instance.SetNew(&new_pairlEfloatcOvoidmUgR);
      instance.SetNewArray(&newArray_pairlEfloatcOvoidmUgR);
      instance.SetDelete(&delete_pairlEfloatcOvoidmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEfloatcOvoidmUgR);
      instance.SetDestructor(&destruct_pairlEfloatcOvoidmUgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<float,void*>*)
   {
      return GenerateInitInstanceLocal((pair<float,void*>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<float,void*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEfloatcOvoidmUgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<float,void*>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEfloatcOcharmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEfloatcOcharmUgR_Dictionary();
   static void *new_pairlEfloatcOcharmUgR(void *p = 0);
   static void *newArray_pairlEfloatcOcharmUgR(Long_t size, void *p);
   static void delete_pairlEfloatcOcharmUgR(void *p);
   static void deleteArray_pairlEfloatcOcharmUgR(void *p);
   static void destruct_pairlEfloatcOcharmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<float,char*>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<float,char*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<float,char*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<float,char*>", "prec_stl/utility", 17,
                  typeid(pair<float,char*>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEfloatcOcharmUgR_ShowMembers, &pairlEfloatcOcharmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<float,char*>) );
      instance.SetNew(&new_pairlEfloatcOcharmUgR);
      instance.SetNewArray(&newArray_pairlEfloatcOcharmUgR);
      instance.SetDelete(&delete_pairlEfloatcOcharmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEfloatcOcharmUgR);
      instance.SetDestructor(&destruct_pairlEfloatcOcharmUgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<float,char*>*)
   {
      return GenerateInitInstanceLocal((pair<float,char*>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<float,char*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEfloatcOcharmUgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<float,char*>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEdoublecOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEdoublecOintgR_Dictionary();
   static void *new_pairlEdoublecOintgR(void *p = 0);
   static void *newArray_pairlEdoublecOintgR(Long_t size, void *p);
   static void delete_pairlEdoublecOintgR(void *p);
   static void deleteArray_pairlEdoublecOintgR(void *p);
   static void destruct_pairlEdoublecOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<double,int>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<double,int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<double,int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<double,int>", "prec_stl/utility", 17,
                  typeid(pair<double,int>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEdoublecOintgR_ShowMembers, &pairlEdoublecOintgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<double,int>) );
      instance.SetNew(&new_pairlEdoublecOintgR);
      instance.SetNewArray(&newArray_pairlEdoublecOintgR);
      instance.SetDelete(&delete_pairlEdoublecOintgR);
      instance.SetDeleteArray(&deleteArray_pairlEdoublecOintgR);
      instance.SetDestructor(&destruct_pairlEdoublecOintgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<double,int>*)
   {
      return GenerateInitInstanceLocal((pair<double,int>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<double,int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEdoublecOintgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<double,int>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEdoublecOlonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEdoublecOlonggR_Dictionary();
   static void *new_pairlEdoublecOlonggR(void *p = 0);
   static void *newArray_pairlEdoublecOlonggR(Long_t size, void *p);
   static void delete_pairlEdoublecOlonggR(void *p);
   static void deleteArray_pairlEdoublecOlonggR(void *p);
   static void destruct_pairlEdoublecOlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<double,long>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<double,long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<double,long>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<double,long>", "prec_stl/utility", 17,
                  typeid(pair<double,long>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEdoublecOlonggR_ShowMembers, &pairlEdoublecOlonggR_Dictionary, isa_proxy, 4,
                  sizeof(pair<double,long>) );
      instance.SetNew(&new_pairlEdoublecOlonggR);
      instance.SetNewArray(&newArray_pairlEdoublecOlonggR);
      instance.SetDelete(&delete_pairlEdoublecOlonggR);
      instance.SetDeleteArray(&deleteArray_pairlEdoublecOlonggR);
      instance.SetDestructor(&destruct_pairlEdoublecOlonggR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<double,long>*)
   {
      return GenerateInitInstanceLocal((pair<double,long>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<double,long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEdoublecOlonggR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<double,long>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEdoublecOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEdoublecOfloatgR_Dictionary();
   static void *new_pairlEdoublecOfloatgR(void *p = 0);
   static void *newArray_pairlEdoublecOfloatgR(Long_t size, void *p);
   static void delete_pairlEdoublecOfloatgR(void *p);
   static void deleteArray_pairlEdoublecOfloatgR(void *p);
   static void destruct_pairlEdoublecOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<double,float>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<double,float> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<double,float>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<double,float>", "prec_stl/utility", 17,
                  typeid(pair<double,float>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEdoublecOfloatgR_ShowMembers, &pairlEdoublecOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<double,float>) );
      instance.SetNew(&new_pairlEdoublecOfloatgR);
      instance.SetNewArray(&newArray_pairlEdoublecOfloatgR);
      instance.SetDelete(&delete_pairlEdoublecOfloatgR);
      instance.SetDeleteArray(&deleteArray_pairlEdoublecOfloatgR);
      instance.SetDestructor(&destruct_pairlEdoublecOfloatgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<double,float>*)
   {
      return GenerateInitInstanceLocal((pair<double,float>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<double,float>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEdoublecOfloatgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<double,float>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEdoublecOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEdoublecOdoublegR_Dictionary();
   static void *new_pairlEdoublecOdoublegR(void *p = 0);
   static void *newArray_pairlEdoublecOdoublegR(Long_t size, void *p);
   static void delete_pairlEdoublecOdoublegR(void *p);
   static void deleteArray_pairlEdoublecOdoublegR(void *p);
   static void destruct_pairlEdoublecOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<double,double>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<double,double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<double,double>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<double,double>", "prec_stl/utility", 17,
                  typeid(pair<double,double>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEdoublecOdoublegR_ShowMembers, &pairlEdoublecOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<double,double>) );
      instance.SetNew(&new_pairlEdoublecOdoublegR);
      instance.SetNewArray(&newArray_pairlEdoublecOdoublegR);
      instance.SetDelete(&delete_pairlEdoublecOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlEdoublecOdoublegR);
      instance.SetDestructor(&destruct_pairlEdoublecOdoublegR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<double,double>*)
   {
      return GenerateInitInstanceLocal((pair<double,double>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<double,double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEdoublecOdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<double,double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEdoublecOvoidmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEdoublecOvoidmUgR_Dictionary();
   static void *new_pairlEdoublecOvoidmUgR(void *p = 0);
   static void *newArray_pairlEdoublecOvoidmUgR(Long_t size, void *p);
   static void delete_pairlEdoublecOvoidmUgR(void *p);
   static void deleteArray_pairlEdoublecOvoidmUgR(void *p);
   static void destruct_pairlEdoublecOvoidmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<double,void*>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<double,void*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<double,void*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<double,void*>", "prec_stl/utility", 17,
                  typeid(pair<double,void*>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEdoublecOvoidmUgR_ShowMembers, &pairlEdoublecOvoidmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<double,void*>) );
      instance.SetNew(&new_pairlEdoublecOvoidmUgR);
      instance.SetNewArray(&newArray_pairlEdoublecOvoidmUgR);
      instance.SetDelete(&delete_pairlEdoublecOvoidmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEdoublecOvoidmUgR);
      instance.SetDestructor(&destruct_pairlEdoublecOvoidmUgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<double,void*>*)
   {
      return GenerateInitInstanceLocal((pair<double,void*>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<double,void*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEdoublecOvoidmUgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<double,void*>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEdoublecOcharmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEdoublecOcharmUgR_Dictionary();
   static void *new_pairlEdoublecOcharmUgR(void *p = 0);
   static void *newArray_pairlEdoublecOcharmUgR(Long_t size, void *p);
   static void delete_pairlEdoublecOcharmUgR(void *p);
   static void deleteArray_pairlEdoublecOcharmUgR(void *p);
   static void destruct_pairlEdoublecOcharmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<double,char*>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<double,char*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<double,char*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<double,char*>", "prec_stl/utility", 17,
                  typeid(pair<double,char*>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEdoublecOcharmUgR_ShowMembers, &pairlEdoublecOcharmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<double,char*>) );
      instance.SetNew(&new_pairlEdoublecOcharmUgR);
      instance.SetNewArray(&newArray_pairlEdoublecOcharmUgR);
      instance.SetDelete(&delete_pairlEdoublecOcharmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEdoublecOcharmUgR);
      instance.SetDestructor(&destruct_pairlEdoublecOcharmUgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<double,char*>*)
   {
      return GenerateInitInstanceLocal((pair<double,char*>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<double,char*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEdoublecOcharmUgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<double,char*>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPcharmUcOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPcharmUcOintgR_Dictionary();
   static void *new_pairlEconstsPcharmUcOintgR(void *p = 0);
   static void *newArray_pairlEconstsPcharmUcOintgR(Long_t size, void *p);
   static void delete_pairlEconstsPcharmUcOintgR(void *p);
   static void deleteArray_pairlEconstsPcharmUcOintgR(void *p);
   static void destruct_pairlEconstsPcharmUcOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const char*,int>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const char*,int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const char*,int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const char*,int>", "prec_stl/utility", 17,
                  typeid(pair<const char*,int>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPcharmUcOintgR_ShowMembers, &pairlEconstsPcharmUcOintgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const char*,int>) );
      instance.SetNew(&new_pairlEconstsPcharmUcOintgR);
      instance.SetNewArray(&newArray_pairlEconstsPcharmUcOintgR);
      instance.SetDelete(&delete_pairlEconstsPcharmUcOintgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPcharmUcOintgR);
      instance.SetDestructor(&destruct_pairlEconstsPcharmUcOintgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const char*,int>*)
   {
      return GenerateInitInstanceLocal((pair<const char*,int>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const char*,int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPcharmUcOintgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const char*,int>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPcharmUcOlonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPcharmUcOlonggR_Dictionary();
   static void *new_pairlEconstsPcharmUcOlonggR(void *p = 0);
   static void *newArray_pairlEconstsPcharmUcOlonggR(Long_t size, void *p);
   static void delete_pairlEconstsPcharmUcOlonggR(void *p);
   static void deleteArray_pairlEconstsPcharmUcOlonggR(void *p);
   static void destruct_pairlEconstsPcharmUcOlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const char*,long>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const char*,long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const char*,long>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const char*,long>", "prec_stl/utility", 17,
                  typeid(pair<const char*,long>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPcharmUcOlonggR_ShowMembers, &pairlEconstsPcharmUcOlonggR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const char*,long>) );
      instance.SetNew(&new_pairlEconstsPcharmUcOlonggR);
      instance.SetNewArray(&newArray_pairlEconstsPcharmUcOlonggR);
      instance.SetDelete(&delete_pairlEconstsPcharmUcOlonggR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPcharmUcOlonggR);
      instance.SetDestructor(&destruct_pairlEconstsPcharmUcOlonggR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const char*,long>*)
   {
      return GenerateInitInstanceLocal((pair<const char*,long>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const char*,long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPcharmUcOlonggR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const char*,long>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPcharmUcOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPcharmUcOfloatgR_Dictionary();
   static void *new_pairlEconstsPcharmUcOfloatgR(void *p = 0);
   static void *newArray_pairlEconstsPcharmUcOfloatgR(Long_t size, void *p);
   static void delete_pairlEconstsPcharmUcOfloatgR(void *p);
   static void deleteArray_pairlEconstsPcharmUcOfloatgR(void *p);
   static void destruct_pairlEconstsPcharmUcOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const char*,float>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const char*,float> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const char*,float>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const char*,float>", "prec_stl/utility", 17,
                  typeid(pair<const char*,float>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPcharmUcOfloatgR_ShowMembers, &pairlEconstsPcharmUcOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const char*,float>) );
      instance.SetNew(&new_pairlEconstsPcharmUcOfloatgR);
      instance.SetNewArray(&newArray_pairlEconstsPcharmUcOfloatgR);
      instance.SetDelete(&delete_pairlEconstsPcharmUcOfloatgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPcharmUcOfloatgR);
      instance.SetDestructor(&destruct_pairlEconstsPcharmUcOfloatgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const char*,float>*)
   {
      return GenerateInitInstanceLocal((pair<const char*,float>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const char*,float>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPcharmUcOfloatgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const char*,float>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPcharmUcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPcharmUcOdoublegR_Dictionary();
   static void *new_pairlEconstsPcharmUcOdoublegR(void *p = 0);
   static void *newArray_pairlEconstsPcharmUcOdoublegR(Long_t size, void *p);
   static void delete_pairlEconstsPcharmUcOdoublegR(void *p);
   static void deleteArray_pairlEconstsPcharmUcOdoublegR(void *p);
   static void destruct_pairlEconstsPcharmUcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const char*,double>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const char*,double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const char*,double>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const char*,double>", "prec_stl/utility", 17,
                  typeid(pair<const char*,double>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPcharmUcOdoublegR_ShowMembers, &pairlEconstsPcharmUcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const char*,double>) );
      instance.SetNew(&new_pairlEconstsPcharmUcOdoublegR);
      instance.SetNewArray(&newArray_pairlEconstsPcharmUcOdoublegR);
      instance.SetDelete(&delete_pairlEconstsPcharmUcOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPcharmUcOdoublegR);
      instance.SetDestructor(&destruct_pairlEconstsPcharmUcOdoublegR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const char*,double>*)
   {
      return GenerateInitInstanceLocal((pair<const char*,double>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const char*,double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPcharmUcOdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const char*,double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPcharmUcOvoidmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPcharmUcOvoidmUgR_Dictionary();
   static void *new_pairlEconstsPcharmUcOvoidmUgR(void *p = 0);
   static void *newArray_pairlEconstsPcharmUcOvoidmUgR(Long_t size, void *p);
   static void delete_pairlEconstsPcharmUcOvoidmUgR(void *p);
   static void deleteArray_pairlEconstsPcharmUcOvoidmUgR(void *p);
   static void destruct_pairlEconstsPcharmUcOvoidmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const char*,void*>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const char*,void*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const char*,void*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const char*,void*>", "prec_stl/utility", 17,
                  typeid(pair<const char*,void*>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPcharmUcOvoidmUgR_ShowMembers, &pairlEconstsPcharmUcOvoidmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const char*,void*>) );
      instance.SetNew(&new_pairlEconstsPcharmUcOvoidmUgR);
      instance.SetNewArray(&newArray_pairlEconstsPcharmUcOvoidmUgR);
      instance.SetDelete(&delete_pairlEconstsPcharmUcOvoidmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPcharmUcOvoidmUgR);
      instance.SetDestructor(&destruct_pairlEconstsPcharmUcOvoidmUgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const char*,void*>*)
   {
      return GenerateInitInstanceLocal((pair<const char*,void*>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const char*,void*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPcharmUcOvoidmUgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const char*,void*>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPcharmUcOcharmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPcharmUcOcharmUgR_Dictionary();
   static void *new_pairlEconstsPcharmUcOcharmUgR(void *p = 0);
   static void *newArray_pairlEconstsPcharmUcOcharmUgR(Long_t size, void *p);
   static void delete_pairlEconstsPcharmUcOcharmUgR(void *p);
   static void deleteArray_pairlEconstsPcharmUcOcharmUgR(void *p);
   static void destruct_pairlEconstsPcharmUcOcharmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const char*,char*>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const char*,char*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const char*,char*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const char*,char*>", "prec_stl/utility", 17,
                  typeid(pair<const char*,char*>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPcharmUcOcharmUgR_ShowMembers, &pairlEconstsPcharmUcOcharmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const char*,char*>) );
      instance.SetNew(&new_pairlEconstsPcharmUcOcharmUgR);
      instance.SetNewArray(&newArray_pairlEconstsPcharmUcOcharmUgR);
      instance.SetDelete(&delete_pairlEconstsPcharmUcOcharmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPcharmUcOcharmUgR);
      instance.SetDestructor(&destruct_pairlEconstsPcharmUcOcharmUgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const char*,char*>*)
   {
      return GenerateInitInstanceLocal((pair<const char*,char*>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const char*,char*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPcharmUcOcharmUgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const char*,char*>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPstringcOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPstringcOintgR_Dictionary();
   static void *new_pairlEconstsPstringcOintgR(void *p = 0);
   static void *newArray_pairlEconstsPstringcOintgR(Long_t size, void *p);
   static void delete_pairlEconstsPstringcOintgR(void *p);
   static void deleteArray_pairlEconstsPstringcOintgR(void *p);
   static void destruct_pairlEconstsPstringcOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const string,int>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const string,int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const string,int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const string,int>", "prec_stl/utility", 17,
                  typeid(pair<const string,int>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPstringcOintgR_ShowMembers, &pairlEconstsPstringcOintgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const string,int>) );
      instance.SetNew(&new_pairlEconstsPstringcOintgR);
      instance.SetNewArray(&newArray_pairlEconstsPstringcOintgR);
      instance.SetDelete(&delete_pairlEconstsPstringcOintgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPstringcOintgR);
      instance.SetDestructor(&destruct_pairlEconstsPstringcOintgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const string,int>*)
   {
      return GenerateInitInstanceLocal((pair<const string,int>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const string,int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPstringcOintgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const string,int>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPstringcOlonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPstringcOlonggR_Dictionary();
   static void *new_pairlEconstsPstringcOlonggR(void *p = 0);
   static void *newArray_pairlEconstsPstringcOlonggR(Long_t size, void *p);
   static void delete_pairlEconstsPstringcOlonggR(void *p);
   static void deleteArray_pairlEconstsPstringcOlonggR(void *p);
   static void destruct_pairlEconstsPstringcOlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const string,long>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const string,long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const string,long>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const string,long>", "prec_stl/utility", 17,
                  typeid(pair<const string,long>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPstringcOlonggR_ShowMembers, &pairlEconstsPstringcOlonggR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const string,long>) );
      instance.SetNew(&new_pairlEconstsPstringcOlonggR);
      instance.SetNewArray(&newArray_pairlEconstsPstringcOlonggR);
      instance.SetDelete(&delete_pairlEconstsPstringcOlonggR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPstringcOlonggR);
      instance.SetDestructor(&destruct_pairlEconstsPstringcOlonggR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const string,long>*)
   {
      return GenerateInitInstanceLocal((pair<const string,long>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const string,long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPstringcOlonggR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const string,long>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPstringcOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPstringcOfloatgR_Dictionary();
   static void *new_pairlEconstsPstringcOfloatgR(void *p = 0);
   static void *newArray_pairlEconstsPstringcOfloatgR(Long_t size, void *p);
   static void delete_pairlEconstsPstringcOfloatgR(void *p);
   static void deleteArray_pairlEconstsPstringcOfloatgR(void *p);
   static void destruct_pairlEconstsPstringcOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const string,float>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const string,float> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const string,float>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const string,float>", "prec_stl/utility", 17,
                  typeid(pair<const string,float>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPstringcOfloatgR_ShowMembers, &pairlEconstsPstringcOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const string,float>) );
      instance.SetNew(&new_pairlEconstsPstringcOfloatgR);
      instance.SetNewArray(&newArray_pairlEconstsPstringcOfloatgR);
      instance.SetDelete(&delete_pairlEconstsPstringcOfloatgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPstringcOfloatgR);
      instance.SetDestructor(&destruct_pairlEconstsPstringcOfloatgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const string,float>*)
   {
      return GenerateInitInstanceLocal((pair<const string,float>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const string,float>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPstringcOfloatgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const string,float>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPstringcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPstringcOdoublegR_Dictionary();
   static void *new_pairlEconstsPstringcOdoublegR(void *p = 0);
   static void *newArray_pairlEconstsPstringcOdoublegR(Long_t size, void *p);
   static void delete_pairlEconstsPstringcOdoublegR(void *p);
   static void deleteArray_pairlEconstsPstringcOdoublegR(void *p);
   static void destruct_pairlEconstsPstringcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const string,double>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const string,double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const string,double>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const string,double>", "prec_stl/utility", 17,
                  typeid(pair<const string,double>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPstringcOdoublegR_ShowMembers, &pairlEconstsPstringcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const string,double>) );
      instance.SetNew(&new_pairlEconstsPstringcOdoublegR);
      instance.SetNewArray(&newArray_pairlEconstsPstringcOdoublegR);
      instance.SetDelete(&delete_pairlEconstsPstringcOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPstringcOdoublegR);
      instance.SetDestructor(&destruct_pairlEconstsPstringcOdoublegR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const string,double>*)
   {
      return GenerateInitInstanceLocal((pair<const string,double>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const string,double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPstringcOdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const string,double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPstringcOvoidmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPstringcOvoidmUgR_Dictionary();
   static void *new_pairlEconstsPstringcOvoidmUgR(void *p = 0);
   static void *newArray_pairlEconstsPstringcOvoidmUgR(Long_t size, void *p);
   static void delete_pairlEconstsPstringcOvoidmUgR(void *p);
   static void deleteArray_pairlEconstsPstringcOvoidmUgR(void *p);
   static void destruct_pairlEconstsPstringcOvoidmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const string,void*>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const string,void*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const string,void*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const string,void*>", "prec_stl/utility", 17,
                  typeid(pair<const string,void*>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPstringcOvoidmUgR_ShowMembers, &pairlEconstsPstringcOvoidmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const string,void*>) );
      instance.SetNew(&new_pairlEconstsPstringcOvoidmUgR);
      instance.SetNewArray(&newArray_pairlEconstsPstringcOvoidmUgR);
      instance.SetDelete(&delete_pairlEconstsPstringcOvoidmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPstringcOvoidmUgR);
      instance.SetDestructor(&destruct_pairlEconstsPstringcOvoidmUgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const string,void*>*)
   {
      return GenerateInitInstanceLocal((pair<const string,void*>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const string,void*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPstringcOvoidmUgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const string,void*>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPintcOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPintcOintgR_Dictionary();
   static void *new_pairlEconstsPintcOintgR(void *p = 0);
   static void *newArray_pairlEconstsPintcOintgR(Long_t size, void *p);
   static void delete_pairlEconstsPintcOintgR(void *p);
   static void deleteArray_pairlEconstsPintcOintgR(void *p);
   static void destruct_pairlEconstsPintcOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const int,int>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const int,int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const int,int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const int,int>", "prec_stl/utility", 17,
                  typeid(pair<const int,int>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPintcOintgR_ShowMembers, &pairlEconstsPintcOintgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const int,int>) );
      instance.SetNew(&new_pairlEconstsPintcOintgR);
      instance.SetNewArray(&newArray_pairlEconstsPintcOintgR);
      instance.SetDelete(&delete_pairlEconstsPintcOintgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPintcOintgR);
      instance.SetDestructor(&destruct_pairlEconstsPintcOintgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const int,int>*)
   {
      return GenerateInitInstanceLocal((pair<const int,int>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const int,int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPintcOintgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const int,int>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPintcOlonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPintcOlonggR_Dictionary();
   static void *new_pairlEconstsPintcOlonggR(void *p = 0);
   static void *newArray_pairlEconstsPintcOlonggR(Long_t size, void *p);
   static void delete_pairlEconstsPintcOlonggR(void *p);
   static void deleteArray_pairlEconstsPintcOlonggR(void *p);
   static void destruct_pairlEconstsPintcOlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const int,long>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const int,long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const int,long>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const int,long>", "prec_stl/utility", 17,
                  typeid(pair<const int,long>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPintcOlonggR_ShowMembers, &pairlEconstsPintcOlonggR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const int,long>) );
      instance.SetNew(&new_pairlEconstsPintcOlonggR);
      instance.SetNewArray(&newArray_pairlEconstsPintcOlonggR);
      instance.SetDelete(&delete_pairlEconstsPintcOlonggR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPintcOlonggR);
      instance.SetDestructor(&destruct_pairlEconstsPintcOlonggR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const int,long>*)
   {
      return GenerateInitInstanceLocal((pair<const int,long>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const int,long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPintcOlonggR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const int,long>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPintcOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPintcOfloatgR_Dictionary();
   static void *new_pairlEconstsPintcOfloatgR(void *p = 0);
   static void *newArray_pairlEconstsPintcOfloatgR(Long_t size, void *p);
   static void delete_pairlEconstsPintcOfloatgR(void *p);
   static void deleteArray_pairlEconstsPintcOfloatgR(void *p);
   static void destruct_pairlEconstsPintcOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const int,float>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const int,float> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const int,float>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const int,float>", "prec_stl/utility", 17,
                  typeid(pair<const int,float>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPintcOfloatgR_ShowMembers, &pairlEconstsPintcOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const int,float>) );
      instance.SetNew(&new_pairlEconstsPintcOfloatgR);
      instance.SetNewArray(&newArray_pairlEconstsPintcOfloatgR);
      instance.SetDelete(&delete_pairlEconstsPintcOfloatgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPintcOfloatgR);
      instance.SetDestructor(&destruct_pairlEconstsPintcOfloatgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const int,float>*)
   {
      return GenerateInitInstanceLocal((pair<const int,float>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const int,float>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPintcOfloatgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const int,float>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPintcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPintcOdoublegR_Dictionary();
   static void *new_pairlEconstsPintcOdoublegR(void *p = 0);
   static void *newArray_pairlEconstsPintcOdoublegR(Long_t size, void *p);
   static void delete_pairlEconstsPintcOdoublegR(void *p);
   static void deleteArray_pairlEconstsPintcOdoublegR(void *p);
   static void destruct_pairlEconstsPintcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const int,double>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const int,double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const int,double>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const int,double>", "prec_stl/utility", 17,
                  typeid(pair<const int,double>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPintcOdoublegR_ShowMembers, &pairlEconstsPintcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const int,double>) );
      instance.SetNew(&new_pairlEconstsPintcOdoublegR);
      instance.SetNewArray(&newArray_pairlEconstsPintcOdoublegR);
      instance.SetDelete(&delete_pairlEconstsPintcOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPintcOdoublegR);
      instance.SetDestructor(&destruct_pairlEconstsPintcOdoublegR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const int,double>*)
   {
      return GenerateInitInstanceLocal((pair<const int,double>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const int,double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPintcOdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const int,double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPintcOvoidmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPintcOvoidmUgR_Dictionary();
   static void *new_pairlEconstsPintcOvoidmUgR(void *p = 0);
   static void *newArray_pairlEconstsPintcOvoidmUgR(Long_t size, void *p);
   static void delete_pairlEconstsPintcOvoidmUgR(void *p);
   static void deleteArray_pairlEconstsPintcOvoidmUgR(void *p);
   static void destruct_pairlEconstsPintcOvoidmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const int,void*>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const int,void*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const int,void*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const int,void*>", "prec_stl/utility", 17,
                  typeid(pair<const int,void*>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPintcOvoidmUgR_ShowMembers, &pairlEconstsPintcOvoidmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const int,void*>) );
      instance.SetNew(&new_pairlEconstsPintcOvoidmUgR);
      instance.SetNewArray(&newArray_pairlEconstsPintcOvoidmUgR);
      instance.SetDelete(&delete_pairlEconstsPintcOvoidmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPintcOvoidmUgR);
      instance.SetDestructor(&destruct_pairlEconstsPintcOvoidmUgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const int,void*>*)
   {
      return GenerateInitInstanceLocal((pair<const int,void*>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const int,void*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPintcOvoidmUgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const int,void*>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPintcOcharmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPintcOcharmUgR_Dictionary();
   static void *new_pairlEconstsPintcOcharmUgR(void *p = 0);
   static void *newArray_pairlEconstsPintcOcharmUgR(Long_t size, void *p);
   static void delete_pairlEconstsPintcOcharmUgR(void *p);
   static void deleteArray_pairlEconstsPintcOcharmUgR(void *p);
   static void destruct_pairlEconstsPintcOcharmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const int,char*>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const int,char*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const int,char*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const int,char*>", "prec_stl/utility", 17,
                  typeid(pair<const int,char*>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPintcOcharmUgR_ShowMembers, &pairlEconstsPintcOcharmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const int,char*>) );
      instance.SetNew(&new_pairlEconstsPintcOcharmUgR);
      instance.SetNewArray(&newArray_pairlEconstsPintcOcharmUgR);
      instance.SetDelete(&delete_pairlEconstsPintcOcharmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPintcOcharmUgR);
      instance.SetDestructor(&destruct_pairlEconstsPintcOcharmUgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const int,char*>*)
   {
      return GenerateInitInstanceLocal((pair<const int,char*>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const int,char*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPintcOcharmUgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const int,char*>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPlongcOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPlongcOintgR_Dictionary();
   static void *new_pairlEconstsPlongcOintgR(void *p = 0);
   static void *newArray_pairlEconstsPlongcOintgR(Long_t size, void *p);
   static void delete_pairlEconstsPlongcOintgR(void *p);
   static void deleteArray_pairlEconstsPlongcOintgR(void *p);
   static void destruct_pairlEconstsPlongcOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const long,int>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const long,int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const long,int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const long,int>", "prec_stl/utility", 17,
                  typeid(pair<const long,int>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPlongcOintgR_ShowMembers, &pairlEconstsPlongcOintgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const long,int>) );
      instance.SetNew(&new_pairlEconstsPlongcOintgR);
      instance.SetNewArray(&newArray_pairlEconstsPlongcOintgR);
      instance.SetDelete(&delete_pairlEconstsPlongcOintgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPlongcOintgR);
      instance.SetDestructor(&destruct_pairlEconstsPlongcOintgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const long,int>*)
   {
      return GenerateInitInstanceLocal((pair<const long,int>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const long,int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPlongcOintgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const long,int>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPlongcOlonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPlongcOlonggR_Dictionary();
   static void *new_pairlEconstsPlongcOlonggR(void *p = 0);
   static void *newArray_pairlEconstsPlongcOlonggR(Long_t size, void *p);
   static void delete_pairlEconstsPlongcOlonggR(void *p);
   static void deleteArray_pairlEconstsPlongcOlonggR(void *p);
   static void destruct_pairlEconstsPlongcOlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const long,long>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const long,long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const long,long>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const long,long>", "prec_stl/utility", 17,
                  typeid(pair<const long,long>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPlongcOlonggR_ShowMembers, &pairlEconstsPlongcOlonggR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const long,long>) );
      instance.SetNew(&new_pairlEconstsPlongcOlonggR);
      instance.SetNewArray(&newArray_pairlEconstsPlongcOlonggR);
      instance.SetDelete(&delete_pairlEconstsPlongcOlonggR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPlongcOlonggR);
      instance.SetDestructor(&destruct_pairlEconstsPlongcOlonggR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const long,long>*)
   {
      return GenerateInitInstanceLocal((pair<const long,long>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const long,long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPlongcOlonggR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const long,long>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPlongcOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPlongcOfloatgR_Dictionary();
   static void *new_pairlEconstsPlongcOfloatgR(void *p = 0);
   static void *newArray_pairlEconstsPlongcOfloatgR(Long_t size, void *p);
   static void delete_pairlEconstsPlongcOfloatgR(void *p);
   static void deleteArray_pairlEconstsPlongcOfloatgR(void *p);
   static void destruct_pairlEconstsPlongcOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const long,float>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const long,float> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const long,float>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const long,float>", "prec_stl/utility", 17,
                  typeid(pair<const long,float>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPlongcOfloatgR_ShowMembers, &pairlEconstsPlongcOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const long,float>) );
      instance.SetNew(&new_pairlEconstsPlongcOfloatgR);
      instance.SetNewArray(&newArray_pairlEconstsPlongcOfloatgR);
      instance.SetDelete(&delete_pairlEconstsPlongcOfloatgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPlongcOfloatgR);
      instance.SetDestructor(&destruct_pairlEconstsPlongcOfloatgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const long,float>*)
   {
      return GenerateInitInstanceLocal((pair<const long,float>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const long,float>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPlongcOfloatgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const long,float>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPlongcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPlongcOdoublegR_Dictionary();
   static void *new_pairlEconstsPlongcOdoublegR(void *p = 0);
   static void *newArray_pairlEconstsPlongcOdoublegR(Long_t size, void *p);
   static void delete_pairlEconstsPlongcOdoublegR(void *p);
   static void deleteArray_pairlEconstsPlongcOdoublegR(void *p);
   static void destruct_pairlEconstsPlongcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const long,double>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const long,double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const long,double>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const long,double>", "prec_stl/utility", 17,
                  typeid(pair<const long,double>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPlongcOdoublegR_ShowMembers, &pairlEconstsPlongcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const long,double>) );
      instance.SetNew(&new_pairlEconstsPlongcOdoublegR);
      instance.SetNewArray(&newArray_pairlEconstsPlongcOdoublegR);
      instance.SetDelete(&delete_pairlEconstsPlongcOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPlongcOdoublegR);
      instance.SetDestructor(&destruct_pairlEconstsPlongcOdoublegR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const long,double>*)
   {
      return GenerateInitInstanceLocal((pair<const long,double>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const long,double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPlongcOdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const long,double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPlongcOvoidmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPlongcOvoidmUgR_Dictionary();
   static void *new_pairlEconstsPlongcOvoidmUgR(void *p = 0);
   static void *newArray_pairlEconstsPlongcOvoidmUgR(Long_t size, void *p);
   static void delete_pairlEconstsPlongcOvoidmUgR(void *p);
   static void deleteArray_pairlEconstsPlongcOvoidmUgR(void *p);
   static void destruct_pairlEconstsPlongcOvoidmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const long,void*>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const long,void*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const long,void*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const long,void*>", "prec_stl/utility", 17,
                  typeid(pair<const long,void*>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPlongcOvoidmUgR_ShowMembers, &pairlEconstsPlongcOvoidmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const long,void*>) );
      instance.SetNew(&new_pairlEconstsPlongcOvoidmUgR);
      instance.SetNewArray(&newArray_pairlEconstsPlongcOvoidmUgR);
      instance.SetDelete(&delete_pairlEconstsPlongcOvoidmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPlongcOvoidmUgR);
      instance.SetDestructor(&destruct_pairlEconstsPlongcOvoidmUgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const long,void*>*)
   {
      return GenerateInitInstanceLocal((pair<const long,void*>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const long,void*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPlongcOvoidmUgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const long,void*>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPlongcOcharmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPlongcOcharmUgR_Dictionary();
   static void *new_pairlEconstsPlongcOcharmUgR(void *p = 0);
   static void *newArray_pairlEconstsPlongcOcharmUgR(Long_t size, void *p);
   static void delete_pairlEconstsPlongcOcharmUgR(void *p);
   static void deleteArray_pairlEconstsPlongcOcharmUgR(void *p);
   static void destruct_pairlEconstsPlongcOcharmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const long,char*>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const long,char*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const long,char*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const long,char*>", "prec_stl/utility", 17,
                  typeid(pair<const long,char*>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPlongcOcharmUgR_ShowMembers, &pairlEconstsPlongcOcharmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const long,char*>) );
      instance.SetNew(&new_pairlEconstsPlongcOcharmUgR);
      instance.SetNewArray(&newArray_pairlEconstsPlongcOcharmUgR);
      instance.SetDelete(&delete_pairlEconstsPlongcOcharmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPlongcOcharmUgR);
      instance.SetDestructor(&destruct_pairlEconstsPlongcOcharmUgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const long,char*>*)
   {
      return GenerateInitInstanceLocal((pair<const long,char*>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const long,char*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPlongcOcharmUgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const long,char*>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPfloatcOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPfloatcOintgR_Dictionary();
   static void *new_pairlEconstsPfloatcOintgR(void *p = 0);
   static void *newArray_pairlEconstsPfloatcOintgR(Long_t size, void *p);
   static void delete_pairlEconstsPfloatcOintgR(void *p);
   static void deleteArray_pairlEconstsPfloatcOintgR(void *p);
   static void destruct_pairlEconstsPfloatcOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const float,int>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const float,int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const float,int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const float,int>", "prec_stl/utility", 17,
                  typeid(pair<const float,int>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPfloatcOintgR_ShowMembers, &pairlEconstsPfloatcOintgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const float,int>) );
      instance.SetNew(&new_pairlEconstsPfloatcOintgR);
      instance.SetNewArray(&newArray_pairlEconstsPfloatcOintgR);
      instance.SetDelete(&delete_pairlEconstsPfloatcOintgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPfloatcOintgR);
      instance.SetDestructor(&destruct_pairlEconstsPfloatcOintgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const float,int>*)
   {
      return GenerateInitInstanceLocal((pair<const float,int>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const float,int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPfloatcOintgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const float,int>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPfloatcOlonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPfloatcOlonggR_Dictionary();
   static void *new_pairlEconstsPfloatcOlonggR(void *p = 0);
   static void *newArray_pairlEconstsPfloatcOlonggR(Long_t size, void *p);
   static void delete_pairlEconstsPfloatcOlonggR(void *p);
   static void deleteArray_pairlEconstsPfloatcOlonggR(void *p);
   static void destruct_pairlEconstsPfloatcOlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const float,long>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const float,long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const float,long>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const float,long>", "prec_stl/utility", 17,
                  typeid(pair<const float,long>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPfloatcOlonggR_ShowMembers, &pairlEconstsPfloatcOlonggR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const float,long>) );
      instance.SetNew(&new_pairlEconstsPfloatcOlonggR);
      instance.SetNewArray(&newArray_pairlEconstsPfloatcOlonggR);
      instance.SetDelete(&delete_pairlEconstsPfloatcOlonggR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPfloatcOlonggR);
      instance.SetDestructor(&destruct_pairlEconstsPfloatcOlonggR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const float,long>*)
   {
      return GenerateInitInstanceLocal((pair<const float,long>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const float,long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPfloatcOlonggR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const float,long>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPfloatcOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPfloatcOfloatgR_Dictionary();
   static void *new_pairlEconstsPfloatcOfloatgR(void *p = 0);
   static void *newArray_pairlEconstsPfloatcOfloatgR(Long_t size, void *p);
   static void delete_pairlEconstsPfloatcOfloatgR(void *p);
   static void deleteArray_pairlEconstsPfloatcOfloatgR(void *p);
   static void destruct_pairlEconstsPfloatcOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const float,float>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const float,float> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const float,float>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const float,float>", "prec_stl/utility", 17,
                  typeid(pair<const float,float>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPfloatcOfloatgR_ShowMembers, &pairlEconstsPfloatcOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const float,float>) );
      instance.SetNew(&new_pairlEconstsPfloatcOfloatgR);
      instance.SetNewArray(&newArray_pairlEconstsPfloatcOfloatgR);
      instance.SetDelete(&delete_pairlEconstsPfloatcOfloatgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPfloatcOfloatgR);
      instance.SetDestructor(&destruct_pairlEconstsPfloatcOfloatgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const float,float>*)
   {
      return GenerateInitInstanceLocal((pair<const float,float>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const float,float>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPfloatcOfloatgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const float,float>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPfloatcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPfloatcOdoublegR_Dictionary();
   static void *new_pairlEconstsPfloatcOdoublegR(void *p = 0);
   static void *newArray_pairlEconstsPfloatcOdoublegR(Long_t size, void *p);
   static void delete_pairlEconstsPfloatcOdoublegR(void *p);
   static void deleteArray_pairlEconstsPfloatcOdoublegR(void *p);
   static void destruct_pairlEconstsPfloatcOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const float,double>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const float,double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const float,double>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const float,double>", "prec_stl/utility", 17,
                  typeid(pair<const float,double>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPfloatcOdoublegR_ShowMembers, &pairlEconstsPfloatcOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const float,double>) );
      instance.SetNew(&new_pairlEconstsPfloatcOdoublegR);
      instance.SetNewArray(&newArray_pairlEconstsPfloatcOdoublegR);
      instance.SetDelete(&delete_pairlEconstsPfloatcOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPfloatcOdoublegR);
      instance.SetDestructor(&destruct_pairlEconstsPfloatcOdoublegR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const float,double>*)
   {
      return GenerateInitInstanceLocal((pair<const float,double>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const float,double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPfloatcOdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const float,double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPfloatcOvoidmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPfloatcOvoidmUgR_Dictionary();
   static void *new_pairlEconstsPfloatcOvoidmUgR(void *p = 0);
   static void *newArray_pairlEconstsPfloatcOvoidmUgR(Long_t size, void *p);
   static void delete_pairlEconstsPfloatcOvoidmUgR(void *p);
   static void deleteArray_pairlEconstsPfloatcOvoidmUgR(void *p);
   static void destruct_pairlEconstsPfloatcOvoidmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const float,void*>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const float,void*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const float,void*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const float,void*>", "prec_stl/utility", 17,
                  typeid(pair<const float,void*>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPfloatcOvoidmUgR_ShowMembers, &pairlEconstsPfloatcOvoidmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const float,void*>) );
      instance.SetNew(&new_pairlEconstsPfloatcOvoidmUgR);
      instance.SetNewArray(&newArray_pairlEconstsPfloatcOvoidmUgR);
      instance.SetDelete(&delete_pairlEconstsPfloatcOvoidmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPfloatcOvoidmUgR);
      instance.SetDestructor(&destruct_pairlEconstsPfloatcOvoidmUgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const float,void*>*)
   {
      return GenerateInitInstanceLocal((pair<const float,void*>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const float,void*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPfloatcOvoidmUgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const float,void*>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPfloatcOcharmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPfloatcOcharmUgR_Dictionary();
   static void *new_pairlEconstsPfloatcOcharmUgR(void *p = 0);
   static void *newArray_pairlEconstsPfloatcOcharmUgR(Long_t size, void *p);
   static void delete_pairlEconstsPfloatcOcharmUgR(void *p);
   static void deleteArray_pairlEconstsPfloatcOcharmUgR(void *p);
   static void destruct_pairlEconstsPfloatcOcharmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const float,char*>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const float,char*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const float,char*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const float,char*>", "prec_stl/utility", 17,
                  typeid(pair<const float,char*>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPfloatcOcharmUgR_ShowMembers, &pairlEconstsPfloatcOcharmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const float,char*>) );
      instance.SetNew(&new_pairlEconstsPfloatcOcharmUgR);
      instance.SetNewArray(&newArray_pairlEconstsPfloatcOcharmUgR);
      instance.SetDelete(&delete_pairlEconstsPfloatcOcharmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPfloatcOcharmUgR);
      instance.SetDestructor(&destruct_pairlEconstsPfloatcOcharmUgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const float,char*>*)
   {
      return GenerateInitInstanceLocal((pair<const float,char*>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const float,char*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPfloatcOcharmUgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const float,char*>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPdoublecOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPdoublecOintgR_Dictionary();
   static void *new_pairlEconstsPdoublecOintgR(void *p = 0);
   static void *newArray_pairlEconstsPdoublecOintgR(Long_t size, void *p);
   static void delete_pairlEconstsPdoublecOintgR(void *p);
   static void deleteArray_pairlEconstsPdoublecOintgR(void *p);
   static void destruct_pairlEconstsPdoublecOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const double,int>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const double,int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const double,int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const double,int>", "prec_stl/utility", 17,
                  typeid(pair<const double,int>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPdoublecOintgR_ShowMembers, &pairlEconstsPdoublecOintgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const double,int>) );
      instance.SetNew(&new_pairlEconstsPdoublecOintgR);
      instance.SetNewArray(&newArray_pairlEconstsPdoublecOintgR);
      instance.SetDelete(&delete_pairlEconstsPdoublecOintgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPdoublecOintgR);
      instance.SetDestructor(&destruct_pairlEconstsPdoublecOintgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const double,int>*)
   {
      return GenerateInitInstanceLocal((pair<const double,int>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const double,int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPdoublecOintgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const double,int>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPdoublecOlonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPdoublecOlonggR_Dictionary();
   static void *new_pairlEconstsPdoublecOlonggR(void *p = 0);
   static void *newArray_pairlEconstsPdoublecOlonggR(Long_t size, void *p);
   static void delete_pairlEconstsPdoublecOlonggR(void *p);
   static void deleteArray_pairlEconstsPdoublecOlonggR(void *p);
   static void destruct_pairlEconstsPdoublecOlonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const double,long>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const double,long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const double,long>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const double,long>", "prec_stl/utility", 17,
                  typeid(pair<const double,long>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPdoublecOlonggR_ShowMembers, &pairlEconstsPdoublecOlonggR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const double,long>) );
      instance.SetNew(&new_pairlEconstsPdoublecOlonggR);
      instance.SetNewArray(&newArray_pairlEconstsPdoublecOlonggR);
      instance.SetDelete(&delete_pairlEconstsPdoublecOlonggR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPdoublecOlonggR);
      instance.SetDestructor(&destruct_pairlEconstsPdoublecOlonggR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const double,long>*)
   {
      return GenerateInitInstanceLocal((pair<const double,long>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const double,long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPdoublecOlonggR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const double,long>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPdoublecOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPdoublecOfloatgR_Dictionary();
   static void *new_pairlEconstsPdoublecOfloatgR(void *p = 0);
   static void *newArray_pairlEconstsPdoublecOfloatgR(Long_t size, void *p);
   static void delete_pairlEconstsPdoublecOfloatgR(void *p);
   static void deleteArray_pairlEconstsPdoublecOfloatgR(void *p);
   static void destruct_pairlEconstsPdoublecOfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const double,float>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const double,float> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const double,float>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const double,float>", "prec_stl/utility", 17,
                  typeid(pair<const double,float>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPdoublecOfloatgR_ShowMembers, &pairlEconstsPdoublecOfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const double,float>) );
      instance.SetNew(&new_pairlEconstsPdoublecOfloatgR);
      instance.SetNewArray(&newArray_pairlEconstsPdoublecOfloatgR);
      instance.SetDelete(&delete_pairlEconstsPdoublecOfloatgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPdoublecOfloatgR);
      instance.SetDestructor(&destruct_pairlEconstsPdoublecOfloatgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const double,float>*)
   {
      return GenerateInitInstanceLocal((pair<const double,float>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const double,float>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPdoublecOfloatgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const double,float>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPdoublecOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPdoublecOdoublegR_Dictionary();
   static void *new_pairlEconstsPdoublecOdoublegR(void *p = 0);
   static void *newArray_pairlEconstsPdoublecOdoublegR(Long_t size, void *p);
   static void delete_pairlEconstsPdoublecOdoublegR(void *p);
   static void deleteArray_pairlEconstsPdoublecOdoublegR(void *p);
   static void destruct_pairlEconstsPdoublecOdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const double,double>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const double,double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const double,double>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const double,double>", "prec_stl/utility", 17,
                  typeid(pair<const double,double>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPdoublecOdoublegR_ShowMembers, &pairlEconstsPdoublecOdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const double,double>) );
      instance.SetNew(&new_pairlEconstsPdoublecOdoublegR);
      instance.SetNewArray(&newArray_pairlEconstsPdoublecOdoublegR);
      instance.SetDelete(&delete_pairlEconstsPdoublecOdoublegR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPdoublecOdoublegR);
      instance.SetDestructor(&destruct_pairlEconstsPdoublecOdoublegR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const double,double>*)
   {
      return GenerateInitInstanceLocal((pair<const double,double>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const double,double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPdoublecOdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const double,double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPdoublecOvoidmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPdoublecOvoidmUgR_Dictionary();
   static void *new_pairlEconstsPdoublecOvoidmUgR(void *p = 0);
   static void *newArray_pairlEconstsPdoublecOvoidmUgR(Long_t size, void *p);
   static void delete_pairlEconstsPdoublecOvoidmUgR(void *p);
   static void deleteArray_pairlEconstsPdoublecOvoidmUgR(void *p);
   static void destruct_pairlEconstsPdoublecOvoidmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const double,void*>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const double,void*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const double,void*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const double,void*>", "prec_stl/utility", 17,
                  typeid(pair<const double,void*>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPdoublecOvoidmUgR_ShowMembers, &pairlEconstsPdoublecOvoidmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const double,void*>) );
      instance.SetNew(&new_pairlEconstsPdoublecOvoidmUgR);
      instance.SetNewArray(&newArray_pairlEconstsPdoublecOvoidmUgR);
      instance.SetDelete(&delete_pairlEconstsPdoublecOvoidmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPdoublecOvoidmUgR);
      instance.SetDestructor(&destruct_pairlEconstsPdoublecOvoidmUgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const double,void*>*)
   {
      return GenerateInitInstanceLocal((pair<const double,void*>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const double,void*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPdoublecOvoidmUgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const double,void*>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEconstsPdoublecOcharmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void pairlEconstsPdoublecOcharmUgR_Dictionary();
   static void *new_pairlEconstsPdoublecOcharmUgR(void *p = 0);
   static void *newArray_pairlEconstsPdoublecOcharmUgR(Long_t size, void *p);
   static void delete_pairlEconstsPdoublecOcharmUgR(void *p);
   static void deleteArray_pairlEconstsPdoublecOcharmUgR(void *p);
   static void destruct_pairlEconstsPdoublecOcharmUgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<const double,char*>*)
   {
      // Make sure the shadow class has the right sizeof
      pair<const double,char*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<const double,char*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<const double,char*>", "prec_stl/utility", 17,
                  typeid(pair<const double,char*>), DefineBehavior(ptr, ptr),
                  (void*)&pairlEconstsPdoublecOcharmUgR_ShowMembers, &pairlEconstsPdoublecOcharmUgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<const double,char*>) );
      instance.SetNew(&new_pairlEconstsPdoublecOcharmUgR);
      instance.SetNewArray(&newArray_pairlEconstsPdoublecOcharmUgR);
      instance.SetDelete(&delete_pairlEconstsPdoublecOcharmUgR);
      instance.SetDeleteArray(&deleteArray_pairlEconstsPdoublecOcharmUgR);
      instance.SetDestructor(&destruct_pairlEconstsPdoublecOcharmUgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<const double,char*>*)
   {
      return GenerateInitInstanceLocal((pair<const double,char*>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<const double,char*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEconstsPdoublecOcharmUgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<const double,char*>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TParameterlEfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void TParameterlEfloatgR_Dictionary();
   static void *new_TParameterlEfloatgR(void *p = 0);
   static void *newArray_TParameterlEfloatgR(Long_t size, void *p);
   static void delete_TParameterlEfloatgR(void *p);
   static void deleteArray_TParameterlEfloatgR(void *p);
   static void destruct_TParameterlEfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TParameter<float>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TParameter<float>) == sizeof(::ROOT::Shadow::TParameterlEfloatgR));
      ::TParameter<float> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TParameter<float> >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TParameter<float>", ::TParameter<float>::Class_Version(), "include/TParameter.h", 35,
                  typeid(::TParameter<float>), DefineBehavior(ptr, ptr),
                  &TParameterlEfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(::TParameter<float>) );
      instance.SetNew(&new_TParameterlEfloatgR);
      instance.SetNewArray(&newArray_TParameterlEfloatgR);
      instance.SetDelete(&delete_TParameterlEfloatgR);
      instance.SetDeleteArray(&deleteArray_TParameterlEfloatgR);
      instance.SetDestructor(&destruct_TParameterlEfloatgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TParameter<float>*)
   {
      return GenerateInitInstanceLocal((::TParameter<float>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TParameter<float>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TParameterlEfloatgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TParameter<float>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TParameterlEdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void TParameterlEdoublegR_Dictionary();
   static void *new_TParameterlEdoublegR(void *p = 0);
   static void *newArray_TParameterlEdoublegR(Long_t size, void *p);
   static void delete_TParameterlEdoublegR(void *p);
   static void deleteArray_TParameterlEdoublegR(void *p);
   static void destruct_TParameterlEdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TParameter<double>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TParameter<double>) == sizeof(::ROOT::Shadow::TParameterlEdoublegR));
      ::TParameter<double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TParameter<double> >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TParameter<double>", ::TParameter<double>::Class_Version(), "include/TParameter.h", 35,
                  typeid(::TParameter<double>), DefineBehavior(ptr, ptr),
                  &TParameterlEdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(::TParameter<double>) );
      instance.SetNew(&new_TParameterlEdoublegR);
      instance.SetNewArray(&newArray_TParameterlEdoublegR);
      instance.SetDelete(&delete_TParameterlEdoublegR);
      instance.SetDeleteArray(&deleteArray_TParameterlEdoublegR);
      instance.SetDestructor(&destruct_TParameterlEdoublegR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TParameter<double>*)
   {
      return GenerateInitInstanceLocal((::TParameter<double>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TParameter<double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TParameterlEdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TParameter<double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TParameterlEintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void TParameterlEintgR_Dictionary();
   static void *new_TParameterlEintgR(void *p = 0);
   static void *newArray_TParameterlEintgR(Long_t size, void *p);
   static void delete_TParameterlEintgR(void *p);
   static void deleteArray_TParameterlEintgR(void *p);
   static void destruct_TParameterlEintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TParameter<int>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TParameter<int>) == sizeof(::ROOT::Shadow::TParameterlEintgR));
      ::TParameter<int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TParameter<int> >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TParameter<int>", ::TParameter<int>::Class_Version(), "include/TParameter.h", 35,
                  typeid(::TParameter<int>), DefineBehavior(ptr, ptr),
                  &TParameterlEintgR_Dictionary, isa_proxy, 4,
                  sizeof(::TParameter<int>) );
      instance.SetNew(&new_TParameterlEintgR);
      instance.SetNewArray(&newArray_TParameterlEintgR);
      instance.SetDelete(&delete_TParameterlEintgR);
      instance.SetDeleteArray(&deleteArray_TParameterlEintgR);
      instance.SetDestructor(&destruct_TParameterlEintgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TParameter<int>*)
   {
      return GenerateInitInstanceLocal((::TParameter<int>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TParameter<int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TParameterlEintgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TParameter<int>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TParameterlElonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void TParameterlElonggR_Dictionary();
   static void *new_TParameterlElonggR(void *p = 0);
   static void *newArray_TParameterlElonggR(Long_t size, void *p);
   static void delete_TParameterlElonggR(void *p);
   static void deleteArray_TParameterlElonggR(void *p);
   static void destruct_TParameterlElonggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TParameter<long>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TParameter<long>) == sizeof(::ROOT::Shadow::TParameterlElonggR));
      ::TParameter<long> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TParameter<long> >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TParameter<long>", ::TParameter<long>::Class_Version(), "include/TParameter.h", 35,
                  typeid(::TParameter<long>), DefineBehavior(ptr, ptr),
                  &TParameterlElonggR_Dictionary, isa_proxy, 4,
                  sizeof(::TParameter<long>) );
      instance.SetNew(&new_TParameterlElonggR);
      instance.SetNewArray(&newArray_TParameterlElonggR);
      instance.SetDelete(&delete_TParameterlElonggR);
      instance.SetDeleteArray(&deleteArray_TParameterlElonggR);
      instance.SetDestructor(&destruct_TParameterlElonggR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TParameter<long>*)
   {
      return GenerateInitInstanceLocal((::TParameter<long>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TParameter<long>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TParameterlElonggR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TParameter<long>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TParameterlELong64_tgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void TParameterlELong64_tgR_Dictionary();
   static void *new_TParameterlELong64_tgR(void *p = 0);
   static void *newArray_TParameterlELong64_tgR(Long_t size, void *p);
   static void delete_TParameterlELong64_tgR(void *p);
   static void deleteArray_TParameterlELong64_tgR(void *p);
   static void destruct_TParameterlELong64_tgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TParameter<Long64_t>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TParameter<Long64_t>) == sizeof(::ROOT::Shadow::TParameterlElongsPlonggR));
      ::TParameter<Long64_t> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::TParameter<Long64_t> >(0);
      static ::ROOT::TGenericClassInfo 
         instance("TParameter<Long64_t>", ::TParameter<Long64_t>::Class_Version(), "include/TParameter.h", 35,
                  typeid(::TParameter<Long64_t>), DefineBehavior(ptr, ptr),
                  &TParameterlELong64_tgR_Dictionary, isa_proxy, 4,
                  sizeof(::TParameter<Long64_t>) );
      instance.SetNew(&new_TParameterlELong64_tgR);
      instance.SetNewArray(&newArray_TParameterlELong64_tgR);
      instance.SetDelete(&delete_TParameterlELong64_tgR);
      instance.SetDeleteArray(&deleteArray_TParameterlELong64_tgR);
      instance.SetDestructor(&destruct_TParameterlELong64_tgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TParameter<Long64_t>*)
   {
      return GenerateInitInstanceLocal((::TParameter<Long64_t>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TParameter<Long64_t>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TParameterlELong64_tgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TParameter<Long64_t>*)0x0)->GetClass();
   }

} // end of namespace ROOT

//______________________________________________________________________________
TClass *TVirtualMutex::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualMutex::Class_Name()
{
   return "TVirtualMutex";
}

//______________________________________________________________________________
const char *TVirtualMutex::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualMutex*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualMutex::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualMutex*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TVirtualMutex::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualMutex*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TVirtualMutex::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualMutex*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TTimeStamp::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TTimeStamp::Class_Name()
{
   return "TTimeStamp";
}

//______________________________________________________________________________
const char *TTimeStamp::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TTimeStamp*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TTimeStamp::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TTimeStamp*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TTimeStamp::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TTimeStamp*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TTimeStamp::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TTimeStamp*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TLockGuard::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TLockGuard::Class_Name()
{
   return "TLockGuard";
}

//______________________________________________________________________________
const char *TLockGuard::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TLockGuard*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TLockGuard::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TLockGuard*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TLockGuard::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TLockGuard*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TLockGuard::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TLockGuard*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TVirtualPerfStats::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualPerfStats::Class_Name()
{
   return "TVirtualPerfStats";
}

//______________________________________________________________________________
const char *TVirtualPerfStats::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualPerfStats*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualPerfStats::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualPerfStats*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TVirtualPerfStats::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualPerfStats*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TVirtualPerfStats::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualPerfStats*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TVirtualAuth::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualAuth::Class_Name()
{
   return "TVirtualAuth";
}

//______________________________________________________________________________
const char *TVirtualAuth::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualAuth*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualAuth::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualAuth*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TVirtualAuth::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualAuth*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TVirtualAuth::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualAuth*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TUrl::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TUrl::Class_Name()
{
   return "TUrl";
}

//______________________________________________________________________________
const char *TUrl::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TUrl*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TUrl::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TUrl*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TUrl::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TUrl*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TUrl::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TUrl*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TInetAddress::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TInetAddress::Class_Name()
{
   return "TInetAddress";
}

//______________________________________________________________________________
const char *TInetAddress::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TInetAddress*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TInetAddress::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TInetAddress*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TInetAddress::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TInetAddress*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TInetAddress::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TInetAddress*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TFileInfoMeta::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TFileInfoMeta::Class_Name()
{
   return "TFileInfoMeta";
}

//______________________________________________________________________________
const char *TFileInfoMeta::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TFileInfoMeta*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TFileInfoMeta::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TFileInfoMeta*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TFileInfoMeta::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TFileInfoMeta*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TFileInfoMeta::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TFileInfoMeta*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TFileInfo::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TFileInfo::Class_Name()
{
   return "TFileInfo";
}

//______________________________________________________________________________
const char *TFileInfo::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TFileInfo*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TFileInfo::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TFileInfo*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TFileInfo::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TFileInfo*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TFileInfo::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TFileInfo*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TFileCollection::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TFileCollection::Class_Name()
{
   return "TFileCollection";
}

//______________________________________________________________________________
const char *TFileCollection::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TFileCollection*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TFileCollection::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TFileCollection*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TFileCollection::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TFileCollection*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TFileCollection::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TFileCollection*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TRedirectOutputGuard::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TRedirectOutputGuard::Class_Name()
{
   return "TRedirectOutputGuard";
}

//______________________________________________________________________________
const char *TRedirectOutputGuard::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRedirectOutputGuard*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TRedirectOutputGuard::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TRedirectOutputGuard*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TRedirectOutputGuard::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRedirectOutputGuard*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TRedirectOutputGuard::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TRedirectOutputGuard*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TVirtualMonitoringWriter::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualMonitoringWriter::Class_Name()
{
   return "TVirtualMonitoringWriter";
}

//______________________________________________________________________________
const char *TVirtualMonitoringWriter::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualMonitoringWriter*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualMonitoringWriter::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualMonitoringWriter*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TVirtualMonitoringWriter::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualMonitoringWriter*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TVirtualMonitoringWriter::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualMonitoringWriter*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TVirtualMonitoringReader::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualMonitoringReader::Class_Name()
{
   return "TVirtualMonitoringReader";
}

//______________________________________________________________________________
const char *TVirtualMonitoringReader::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualMonitoringReader*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualMonitoringReader::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualMonitoringReader*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TVirtualMonitoringReader::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualMonitoringReader*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TVirtualMonitoringReader::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualMonitoringReader*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TObjectSpy::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TObjectSpy::Class_Name()
{
   return "TObjectSpy";
}

//______________________________________________________________________________
const char *TObjectSpy::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TObjectSpy*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TObjectSpy::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TObjectSpy*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TObjectSpy::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TObjectSpy*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TObjectSpy::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TObjectSpy*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TObjectRefSpy::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TObjectRefSpy::Class_Name()
{
   return "TObjectRefSpy";
}

//______________________________________________________________________________
const char *TObjectRefSpy::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TObjectRefSpy*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TObjectRefSpy::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TObjectRefSpy*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TObjectRefSpy::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TObjectRefSpy*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TObjectRefSpy::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TObjectRefSpy*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TUri::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TUri::Class_Name()
{
   return "TUri";
}

//______________________________________________________________________________
const char *TUri::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TUri*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TUri::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TUri*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TUri::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TUri*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TUri::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TUri*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TVirtualTableInterface::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TVirtualTableInterface::Class_Name()
{
   return "TVirtualTableInterface";
}

//______________________________________________________________________________
const char *TVirtualTableInterface::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualTableInterface*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TVirtualTableInterface::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TVirtualTableInterface*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TVirtualTableInterface::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualTableInterface*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TVirtualTableInterface::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TVirtualTableInterface*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *TBase64::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *TBase64::Class_Name()
{
   return "TBase64";
}

//______________________________________________________________________________
const char *TBase64::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TBase64*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int TBase64::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TBase64*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void TBase64::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TBase64*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *TBase64::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TBase64*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *TParameter<float>::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
template <> const char *TParameter<float>::Class_Name()
{
   return "TParameter<float>";
}

//______________________________________________________________________________
template <> const char *TParameter<float>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TParameter<float>*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
template <> int TParameter<float>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TParameter<float>*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
template <> void TParameter<float>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<float>*)0x0)->GetClass();
}

//______________________________________________________________________________
template <> TClass *TParameter<float>::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<float>*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *TParameter<double>::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
template <> const char *TParameter<double>::Class_Name()
{
   return "TParameter<double>";
}

//______________________________________________________________________________
template <> const char *TParameter<double>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TParameter<double>*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
template <> int TParameter<double>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TParameter<double>*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
template <> void TParameter<double>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<double>*)0x0)->GetClass();
}

//______________________________________________________________________________
template <> TClass *TParameter<double>::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<double>*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *TParameter<int>::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
template <> const char *TParameter<int>::Class_Name()
{
   return "TParameter<int>";
}

//______________________________________________________________________________
template <> const char *TParameter<int>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TParameter<int>*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
template <> int TParameter<int>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TParameter<int>*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
template <> void TParameter<int>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<int>*)0x0)->GetClass();
}

//______________________________________________________________________________
template <> TClass *TParameter<int>::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<int>*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *TParameter<long>::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
template <> const char *TParameter<long>::Class_Name()
{
   return "TParameter<long>";
}

//______________________________________________________________________________
template <> const char *TParameter<long>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TParameter<long>*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
template <> int TParameter<long>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TParameter<long>*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
template <> void TParameter<long>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<long>*)0x0)->GetClass();
}

//______________________________________________________________________________
template <> TClass *TParameter<long>::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<long>*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
template <> TClass *TParameter<long long>::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
template <> const char *TParameter<long long>::Class_Name()
{
   return "TParameter<long long>";
}

//______________________________________________________________________________
template <> const char *TParameter<long long>::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TParameter<long long>*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
template <> int TParameter<long long>::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::TParameter<long long>*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
template <> void TParameter<long long>::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<long long>*)0x0)->GetClass();
}

//______________________________________________________________________________
template <> TClass *TParameter<long long>::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<long long>*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
void TTimeStamp::Streamer(TBuffer &R__b)
{
   // Stream an object of class TTimeStamp.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TTimeStamp::Class(),this);
   } else {
      R__b.WriteClassBuffer(TTimeStamp::Class(),this);
   }
}

//______________________________________________________________________________
void TTimeStamp::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class TTimeStamp.
      TClass *R__cl = ::TTimeStamp::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fSec", &fSec);
      R__insp.Inspect(R__cl, R__parent, "fNanoSec", &fNanoSec);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TTimeStamp(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TTimeStamp : new ::TTimeStamp;
   }
   static void *newArray_TTimeStamp(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TTimeStamp[nElements] : new ::TTimeStamp[nElements];
   }
   // Wrapper around operator delete
   static void delete_TTimeStamp(void *p) {
      delete ((::TTimeStamp*)p);
   }
   static void deleteArray_TTimeStamp(void *p) {
      delete [] ((::TTimeStamp*)p);
   }
   static void destruct_TTimeStamp(void *p) {
      typedef ::TTimeStamp current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TTimeStamp

//______________________________________________________________________________
void TFileInfo::Streamer(TBuffer &R__b)
{
   // Stream an object of class TFileInfo.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TFileInfo::Class(),this);
   } else {
      R__b.WriteClassBuffer(TFileInfo::Class(),this);
   }
}

//______________________________________________________________________________
void TFileInfo::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class TFileInfo.
      TClass *R__cl = ::TFileInfo::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "*fCurrentUrl", &fCurrentUrl);
      R__insp.Inspect(R__cl, R__parent, "*fUrlList", &fUrlList);
      R__insp.Inspect(R__cl, R__parent, "fSize", &fSize);
      R__insp.Inspect(R__cl, R__parent, "*fUUID", &fUUID);
      R__insp.Inspect(R__cl, R__parent, "*fMD5", &fMD5);
      R__insp.Inspect(R__cl, R__parent, "*fMetaDataList", &fMetaDataList);
      TNamed::ShowMembers(R__insp, R__parent);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TFileInfo(void *p) {
      return  p ? new(p) ::TFileInfo : new ::TFileInfo;
   }
   static void *newArray_TFileInfo(Long_t nElements, void *p) {
      return p ? new(p) ::TFileInfo[nElements] : new ::TFileInfo[nElements];
   }
   // Wrapper around operator delete
   static void delete_TFileInfo(void *p) {
      delete ((::TFileInfo*)p);
   }
   static void deleteArray_TFileInfo(void *p) {
      delete [] ((::TFileInfo*)p);
   }
   static void destruct_TFileInfo(void *p) {
      typedef ::TFileInfo current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TFileInfo

//______________________________________________________________________________
void TFileInfoMeta::Streamer(TBuffer &R__b)
{
   // Stream an object of class TFileInfoMeta.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TFileInfoMeta::Class(),this);
   } else {
      R__b.WriteClassBuffer(TFileInfoMeta::Class(),this);
   }
}

//______________________________________________________________________________
void TFileInfoMeta::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class TFileInfoMeta.
      TClass *R__cl = ::TFileInfoMeta::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fEntries", &fEntries);
      R__insp.Inspect(R__cl, R__parent, "fFirst", &fFirst);
      R__insp.Inspect(R__cl, R__parent, "fLast", &fLast);
      R__insp.Inspect(R__cl, R__parent, "fIsTree", &fIsTree);
      R__insp.Inspect(R__cl, R__parent, "fTotBytes", &fTotBytes);
      R__insp.Inspect(R__cl, R__parent, "fZipBytes", &fZipBytes);
      TNamed::ShowMembers(R__insp, R__parent);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TFileInfoMeta(void *p) {
      return  p ? new(p) ::TFileInfoMeta : new ::TFileInfoMeta;
   }
   static void *newArray_TFileInfoMeta(Long_t nElements, void *p) {
      return p ? new(p) ::TFileInfoMeta[nElements] : new ::TFileInfoMeta[nElements];
   }
   // Wrapper around operator delete
   static void delete_TFileInfoMeta(void *p) {
      delete ((::TFileInfoMeta*)p);
   }
   static void deleteArray_TFileInfoMeta(void *p) {
      delete [] ((::TFileInfoMeta*)p);
   }
   static void destruct_TFileInfoMeta(void *p) {
      typedef ::TFileInfoMeta current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TFileInfoMeta

//______________________________________________________________________________
void TFileCollection::Streamer(TBuffer &R__b)
{
   // Stream an object of class TFileCollection.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TFileCollection::Class(),this);
   } else {
      R__b.WriteClassBuffer(TFileCollection::Class(),this);
   }
}

//______________________________________________________________________________
void TFileCollection::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class TFileCollection.
      TClass *R__cl = ::TFileCollection::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "*fList", &fList);
      R__insp.Inspect(R__cl, R__parent, "*fMetaDataList", &fMetaDataList);
      R__insp.Inspect(R__cl, R__parent, "fDefaultTree", &fDefaultTree);
      fDefaultTree.ShowMembers(R__insp, strcat(R__parent,"fDefaultTree.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fTotalSize", &fTotalSize);
      R__insp.Inspect(R__cl, R__parent, "fNFiles", &fNFiles);
      R__insp.Inspect(R__cl, R__parent, "fNStagedFiles", &fNStagedFiles);
      R__insp.Inspect(R__cl, R__parent, "fNCorruptFiles", &fNCorruptFiles);
      TNamed::ShowMembers(R__insp, R__parent);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TFileCollection(void *p) {
      return  p ? new(p) ::TFileCollection : new ::TFileCollection;
   }
   static void *newArray_TFileCollection(Long_t nElements, void *p) {
      return p ? new(p) ::TFileCollection[nElements] : new ::TFileCollection[nElements];
   }
   // Wrapper around operator delete
   static void delete_TFileCollection(void *p) {
      delete ((::TFileCollection*)p);
   }
   static void deleteArray_TFileCollection(void *p) {
      delete [] ((::TFileCollection*)p);
   }
   static void destruct_TFileCollection(void *p) {
      typedef ::TFileCollection current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TFileCollection

//______________________________________________________________________________
void TVirtualAuth::Streamer(TBuffer &R__b)
{
   // Stream an object of class TVirtualAuth.

   ::Error("TVirtualAuth::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

//______________________________________________________________________________
void TVirtualAuth::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class TVirtualAuth.
      TClass *R__cl = ::TVirtualAuth::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TVirtualAuth(void *p) {
      delete ((::TVirtualAuth*)p);
   }
   static void deleteArray_TVirtualAuth(void *p) {
      delete [] ((::TVirtualAuth*)p);
   }
   static void destruct_TVirtualAuth(void *p) {
      typedef ::TVirtualAuth current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TVirtualAuth

//______________________________________________________________________________
void TVirtualMutex::Streamer(TBuffer &R__b)
{
   // Stream an object of class TVirtualMutex.

   TObject::Streamer(R__b);
}

//______________________________________________________________________________
void TVirtualMutex::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class TVirtualMutex.
      TClass *R__cl = ::TVirtualMutex::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      TObject::ShowMembers(R__insp, R__parent);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TVirtualMutex(void *p) {
      delete ((::TVirtualMutex*)p);
   }
   static void deleteArray_TVirtualMutex(void *p) {
      delete [] ((::TVirtualMutex*)p);
   }
   static void destruct_TVirtualMutex(void *p) {
      typedef ::TVirtualMutex current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TVirtualMutex

//______________________________________________________________________________
void TLockGuard::Streamer(TBuffer &R__b)
{
   // Stream an object of class TLockGuard.

   ::Error("TLockGuard::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

//______________________________________________________________________________
void TLockGuard::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class TLockGuard.
      TClass *R__cl = ::TLockGuard::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "*fMutex", &fMutex);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TLockGuard(void *p) {
      delete ((::TLockGuard*)p);
   }
   static void deleteArray_TLockGuard(void *p) {
      delete [] ((::TLockGuard*)p);
   }
   static void destruct_TLockGuard(void *p) {
      typedef ::TLockGuard current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TLockGuard

//______________________________________________________________________________
void TRedirectOutputGuard::Streamer(TBuffer &R__b)
{
   // Stream an object of class TRedirectOutputGuard.

   ::Error("TRedirectOutputGuard::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

//______________________________________________________________________________
void TRedirectOutputGuard::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class TRedirectOutputGuard.
      TClass *R__cl = ::TRedirectOutputGuard::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TRedirectOutputGuard(void *p) {
      delete ((::TRedirectOutputGuard*)p);
   }
   static void deleteArray_TRedirectOutputGuard(void *p) {
      delete [] ((::TRedirectOutputGuard*)p);
   }
   static void destruct_TRedirectOutputGuard(void *p) {
      typedef ::TRedirectOutputGuard current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TRedirectOutputGuard

//______________________________________________________________________________
void TVirtualPerfStats::Streamer(TBuffer &R__b)
{
   // Stream an object of class TVirtualPerfStats.

   TObject::Streamer(R__b);
}

//______________________________________________________________________________
void TVirtualPerfStats::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class TVirtualPerfStats.
      TClass *R__cl = ::TVirtualPerfStats::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      TObject::ShowMembers(R__insp, R__parent);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TVirtualPerfStats(void *p) {
      delete ((::TVirtualPerfStats*)p);
   }
   static void deleteArray_TVirtualPerfStats(void *p) {
      delete [] ((::TVirtualPerfStats*)p);
   }
   static void destruct_TVirtualPerfStats(void *p) {
      typedef ::TVirtualPerfStats current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TVirtualPerfStats

//______________________________________________________________________________
void TVirtualMonitoringWriter::Streamer(TBuffer &R__b)
{
   // Stream an object of class TVirtualMonitoringWriter.

   TNamed::Streamer(R__b);
}

//______________________________________________________________________________
void TVirtualMonitoringWriter::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class TVirtualMonitoringWriter.
      TClass *R__cl = ::TVirtualMonitoringWriter::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fValue", &fValue);
      R__insp.Inspect(R__cl, R__parent, "*fTmpOpenPhases", &fTmpOpenPhases);
      TNamed::ShowMembers(R__insp, R__parent);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TVirtualMonitoringWriter(void *p) {
      return  p ? new(p) ::TVirtualMonitoringWriter : new ::TVirtualMonitoringWriter;
   }
   static void *newArray_TVirtualMonitoringWriter(Long_t nElements, void *p) {
      return p ? new(p) ::TVirtualMonitoringWriter[nElements] : new ::TVirtualMonitoringWriter[nElements];
   }
   // Wrapper around operator delete
   static void delete_TVirtualMonitoringWriter(void *p) {
      delete ((::TVirtualMonitoringWriter*)p);
   }
   static void deleteArray_TVirtualMonitoringWriter(void *p) {
      delete [] ((::TVirtualMonitoringWriter*)p);
   }
   static void destruct_TVirtualMonitoringWriter(void *p) {
      typedef ::TVirtualMonitoringWriter current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TVirtualMonitoringWriter

//______________________________________________________________________________
void TVirtualMonitoringReader::Streamer(TBuffer &R__b)
{
   // Stream an object of class TVirtualMonitoringReader.

   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      TNamed::Streamer(R__b);
      R__b.CheckByteCount(R__s, R__c, TVirtualMonitoringReader::IsA());
   } else {
      R__c = R__b.WriteVersion(TVirtualMonitoringReader::IsA(), kTRUE);
      TNamed::Streamer(R__b);
      R__b.SetByteCount(R__c, kTRUE);
   }
}

//______________________________________________________________________________
void TVirtualMonitoringReader::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class TVirtualMonitoringReader.
      TClass *R__cl = ::TVirtualMonitoringReader::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      TNamed::ShowMembers(R__insp, R__parent);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TVirtualMonitoringReader(void *p) {
      return  p ? new(p) ::TVirtualMonitoringReader : new ::TVirtualMonitoringReader;
   }
   static void *newArray_TVirtualMonitoringReader(Long_t nElements, void *p) {
      return p ? new(p) ::TVirtualMonitoringReader[nElements] : new ::TVirtualMonitoringReader[nElements];
   }
   // Wrapper around operator delete
   static void delete_TVirtualMonitoringReader(void *p) {
      delete ((::TVirtualMonitoringReader*)p);
   }
   static void deleteArray_TVirtualMonitoringReader(void *p) {
      delete [] ((::TVirtualMonitoringReader*)p);
   }
   static void destruct_TVirtualMonitoringReader(void *p) {
      typedef ::TVirtualMonitoringReader current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TVirtualMonitoringReader

//______________________________________________________________________________
void TObjectSpy::Streamer(TBuffer &R__b)
{
   // Stream an object of class TObjectSpy.

   TObject::Streamer(R__b);
}

//______________________________________________________________________________
void TObjectSpy::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class TObjectSpy.
      TClass *R__cl = ::TObjectSpy::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "*fObj", &fObj);
      R__insp.Inspect(R__cl, R__parent, "fResetMustCleanupBit", &fResetMustCleanupBit);
      TObject::ShowMembers(R__insp, R__parent);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TObjectSpy(void *p) {
      return  p ? new(p) ::TObjectSpy : new ::TObjectSpy;
   }
   static void *newArray_TObjectSpy(Long_t nElements, void *p) {
      return p ? new(p) ::TObjectSpy[nElements] : new ::TObjectSpy[nElements];
   }
   // Wrapper around operator delete
   static void delete_TObjectSpy(void *p) {
      delete ((::TObjectSpy*)p);
   }
   static void deleteArray_TObjectSpy(void *p) {
      delete [] ((::TObjectSpy*)p);
   }
   static void destruct_TObjectSpy(void *p) {
      typedef ::TObjectSpy current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TObjectSpy

//______________________________________________________________________________
void TObjectRefSpy::Streamer(TBuffer &R__b)
{
   // Stream an object of class TObjectRefSpy.

   TObject::Streamer(R__b);
}

//______________________________________________________________________________
void TObjectRefSpy::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class TObjectRefSpy.
      TClass *R__cl = ::TObjectRefSpy::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "*fObj", &fObj);
      R__insp.Inspect(R__cl, R__parent, "fResetMustCleanupBit", &fResetMustCleanupBit);
      TObject::ShowMembers(R__insp, R__parent);
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TObjectRefSpy(void *p) {
      delete ((::TObjectRefSpy*)p);
   }
   static void deleteArray_TObjectRefSpy(void *p) {
      delete [] ((::TObjectRefSpy*)p);
   }
   static void destruct_TObjectRefSpy(void *p) {
      typedef ::TObjectRefSpy current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TObjectRefSpy

//______________________________________________________________________________
void TUri::Streamer(TBuffer &R__b)
{
   // Stream an object of class TUri.

   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      TObject::Streamer(R__b);
      fScheme.Streamer(R__b);
      fUserinfo.Streamer(R__b);
      fHost.Streamer(R__b);
      fPort.Streamer(R__b);
      fPath.Streamer(R__b);
      fQuery.Streamer(R__b);
      fFragment.Streamer(R__b);
      R__b >> fHasScheme;
      R__b >> fHasUserinfo;
      R__b >> fHasHost;
      R__b >> fHasPort;
      R__b >> fHasPath;
      R__b >> fHasQuery;
      R__b >> fHasFragment;
      R__b.CheckByteCount(R__s, R__c, TUri::IsA());
   } else {
      R__c = R__b.WriteVersion(TUri::IsA(), kTRUE);
      TObject::Streamer(R__b);
      fScheme.Streamer(R__b);
      fUserinfo.Streamer(R__b);
      fHost.Streamer(R__b);
      fPort.Streamer(R__b);
      fPath.Streamer(R__b);
      fQuery.Streamer(R__b);
      fFragment.Streamer(R__b);
      R__b << fHasScheme;
      R__b << fHasUserinfo;
      R__b << fHasHost;
      R__b << fHasPort;
      R__b << fHasPath;
      R__b << fHasQuery;
      R__b << fHasFragment;
      R__b.SetByteCount(R__c, kTRUE);
   }
}

//______________________________________________________________________________
void TUri::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class TUri.
      TClass *R__cl = ::TUri::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fScheme", &fScheme);
      fScheme.ShowMembers(R__insp, strcat(R__parent,"fScheme.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fUserinfo", &fUserinfo);
      fUserinfo.ShowMembers(R__insp, strcat(R__parent,"fUserinfo.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fHost", &fHost);
      fHost.ShowMembers(R__insp, strcat(R__parent,"fHost.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fPort", &fPort);
      fPort.ShowMembers(R__insp, strcat(R__parent,"fPort.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fPath", &fPath);
      fPath.ShowMembers(R__insp, strcat(R__parent,"fPath.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fQuery", &fQuery);
      fQuery.ShowMembers(R__insp, strcat(R__parent,"fQuery.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fFragment", &fFragment);
      fFragment.ShowMembers(R__insp, strcat(R__parent,"fFragment.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fHasScheme", &fHasScheme);
      R__insp.Inspect(R__cl, R__parent, "fHasUserinfo", &fHasUserinfo);
      R__insp.Inspect(R__cl, R__parent, "fHasHost", &fHasHost);
      R__insp.Inspect(R__cl, R__parent, "fHasPort", &fHasPort);
      R__insp.Inspect(R__cl, R__parent, "fHasPath", &fHasPath);
      R__insp.Inspect(R__cl, R__parent, "fHasQuery", &fHasQuery);
      R__insp.Inspect(R__cl, R__parent, "fHasFragment", &fHasFragment);
      TObject::ShowMembers(R__insp, R__parent);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TUri(void *p) {
      return  p ? new(p) ::TUri : new ::TUri;
   }
   static void *newArray_TUri(Long_t nElements, void *p) {
      return p ? new(p) ::TUri[nElements] : new ::TUri[nElements];
   }
   // Wrapper around operator delete
   static void delete_TUri(void *p) {
      delete ((::TUri*)p);
   }
   static void deleteArray_TUri(void *p) {
      delete [] ((::TUri*)p);
   }
   static void destruct_TUri(void *p) {
      typedef ::TUri current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TUri

//______________________________________________________________________________
void TUrl::Streamer(TBuffer &R__b)
{
   // Stream an object of class TUrl.

   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      TObject::Streamer(R__b);
      fUrl.Streamer(R__b);
      fProtocol.Streamer(R__b);
      fUser.Streamer(R__b);
      fPasswd.Streamer(R__b);
      fHost.Streamer(R__b);
      fFile.Streamer(R__b);
      fAnchor.Streamer(R__b);
      fOptions.Streamer(R__b);
      R__b >> fPort;
      R__b.CheckByteCount(R__s, R__c, TUrl::IsA());
   } else {
      R__c = R__b.WriteVersion(TUrl::IsA(), kTRUE);
      TObject::Streamer(R__b);
      fUrl.Streamer(R__b);
      fProtocol.Streamer(R__b);
      fUser.Streamer(R__b);
      fPasswd.Streamer(R__b);
      fHost.Streamer(R__b);
      fFile.Streamer(R__b);
      fAnchor.Streamer(R__b);
      fOptions.Streamer(R__b);
      R__b << fPort;
      R__b.SetByteCount(R__c, kTRUE);
   }
}

//______________________________________________________________________________
void TUrl::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class TUrl.
      TClass *R__cl = ::TUrl::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fUrl", &fUrl);
      fUrl.ShowMembers(R__insp, strcat(R__parent,"fUrl.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fProtocol", &fProtocol);
      fProtocol.ShowMembers(R__insp, strcat(R__parent,"fProtocol.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fUser", &fUser);
      fUser.ShowMembers(R__insp, strcat(R__parent,"fUser.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fPasswd", &fPasswd);
      fPasswd.ShowMembers(R__insp, strcat(R__parent,"fPasswd.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fHost", &fHost);
      fHost.ShowMembers(R__insp, strcat(R__parent,"fHost.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fFile", &fFile);
      fFile.ShowMembers(R__insp, strcat(R__parent,"fFile.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fAnchor", &fAnchor);
      fAnchor.ShowMembers(R__insp, strcat(R__parent,"fAnchor.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fOptions", &fOptions);
      fOptions.ShowMembers(R__insp, strcat(R__parent,"fOptions.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fFileOA", &fFileOA);
      fFileOA.ShowMembers(R__insp, strcat(R__parent,"fFileOA.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fHostFQ", &fHostFQ);
      fHostFQ.ShowMembers(R__insp, strcat(R__parent,"fHostFQ.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fPort", &fPort);
      R__insp.Inspect(R__cl, R__parent, "*fOptionsMap", &fOptionsMap);
      TObject::ShowMembers(R__insp, R__parent);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TUrl(void *p) {
      return  p ? new(p) ::TUrl : new ::TUrl;
   }
   static void *newArray_TUrl(Long_t nElements, void *p) {
      return p ? new(p) ::TUrl[nElements] : new ::TUrl[nElements];
   }
   // Wrapper around operator delete
   static void delete_TUrl(void *p) {
      delete ((::TUrl*)p);
   }
   static void deleteArray_TUrl(void *p) {
      delete [] ((::TUrl*)p);
   }
   static void destruct_TUrl(void *p) {
      typedef ::TUrl current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TUrl

//______________________________________________________________________________
void TInetAddress::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class TInetAddress.
      TClass *R__cl = ::TInetAddress::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fHostname", &fHostname);
      fHostname.ShowMembers(R__insp, strcat(R__parent,"fHostname.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fFamily", &fFamily);
      R__insp.Inspect(R__cl, R__parent, "fPort", &fPort);
      R__insp.Inspect(R__cl, R__parent, "fAddresses", (void*)&fAddresses);
      ::ROOT::GenericShowMembers("TInetAddress::AddressList_t", (void*)&fAddresses, R__insp, strcat(R__parent,"fAddresses."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fAliases", (void*)&fAliases);
      ::ROOT::GenericShowMembers("TInetAddress::AliasList_t", (void*)&fAliases, R__insp, strcat(R__parent,"fAliases."),false);
      R__parent[R__ncp] = 0;
      TObject::ShowMembers(R__insp, R__parent);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TInetAddress(void *p) {
      return  p ? new(p) ::TInetAddress : new ::TInetAddress;
   }
   static void *newArray_TInetAddress(Long_t nElements, void *p) {
      return p ? new(p) ::TInetAddress[nElements] : new ::TInetAddress[nElements];
   }
   // Wrapper around operator delete
   static void delete_TInetAddress(void *p) {
      delete ((::TInetAddress*)p);
   }
   static void deleteArray_TInetAddress(void *p) {
      delete [] ((::TInetAddress*)p);
   }
   static void destruct_TInetAddress(void *p) {
      typedef ::TInetAddress current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TInetAddress

//______________________________________________________________________________
void TVirtualTableInterface::Streamer(TBuffer &R__b)
{
   // Stream an object of class TVirtualTableInterface.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TVirtualTableInterface::Class(),this);
   } else {
      R__b.WriteClassBuffer(TVirtualTableInterface::Class(),this);
   }
}

//______________________________________________________________________________
void TVirtualTableInterface::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class TVirtualTableInterface.
      TClass *R__cl = ::TVirtualTableInterface::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
}

namespace ROOT {
   // Wrapper around operator delete
   static void delete_TVirtualTableInterface(void *p) {
      delete ((::TVirtualTableInterface*)p);
   }
   static void deleteArray_TVirtualTableInterface(void *p) {
      delete [] ((::TVirtualTableInterface*)p);
   }
   static void destruct_TVirtualTableInterface(void *p) {
      typedef ::TVirtualTableInterface current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TVirtualTableInterface

//______________________________________________________________________________
void TBase64::Streamer(TBuffer &R__b)
{
   // Stream an object of class TBase64.

   ::Error("TBase64::Streamer", "version id <=0 in ClassDef, dummy Streamer() called"); if (R__b.IsReading()) { }
}

//______________________________________________________________________________
void TBase64::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class TBase64.
      TClass *R__cl = ::TBase64::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TBase64(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TBase64 : new ::TBase64;
   }
   static void *newArray_TBase64(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TBase64[nElements] : new ::TBase64[nElements];
   }
   // Wrapper around operator delete
   static void delete_TBase64(void *p) {
      delete ((::TBase64*)p);
   }
   static void deleteArray_TBase64(void *p) {
      delete [] ((::TBase64*)p);
   }
   static void destruct_TBase64(void *p) {
      typedef ::TBase64 current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TBase64

//______________________________________________________________________________
namespace ROOT {
   void pairlEcharmUcOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<char*,int>.
      typedef ::ROOT::Shadow::pairlEcharmUcOintgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<char*,int>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "*first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEcharmUcOintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<char*,int> : new pair<char*,int>;
   }
   static void *newArray_pairlEcharmUcOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<char*,int>[nElements] : new pair<char*,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEcharmUcOintgR(void *p) {
      delete ((pair<char*,int>*)p);
   }
   static void deleteArray_pairlEcharmUcOintgR(void *p) {
      delete [] ((pair<char*,int>*)p);
   }
   static void destruct_pairlEcharmUcOintgR(void *p) {
      typedef pair<char*,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<char*,int>

//______________________________________________________________________________
namespace ROOT {
   void pairlEcharmUcOlonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<char*,long>.
      typedef ::ROOT::Shadow::pairlEcharmUcOlonggR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<char*,long>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "*first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEcharmUcOlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<char*,long> : new pair<char*,long>;
   }
   static void *newArray_pairlEcharmUcOlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<char*,long>[nElements] : new pair<char*,long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEcharmUcOlonggR(void *p) {
      delete ((pair<char*,long>*)p);
   }
   static void deleteArray_pairlEcharmUcOlonggR(void *p) {
      delete [] ((pair<char*,long>*)p);
   }
   static void destruct_pairlEcharmUcOlonggR(void *p) {
      typedef pair<char*,long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<char*,long>

//______________________________________________________________________________
namespace ROOT {
   void pairlEcharmUcOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<char*,float>.
      typedef ::ROOT::Shadow::pairlEcharmUcOfloatgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<char*,float>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "*first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEcharmUcOfloatgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<char*,float> : new pair<char*,float>;
   }
   static void *newArray_pairlEcharmUcOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<char*,float>[nElements] : new pair<char*,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEcharmUcOfloatgR(void *p) {
      delete ((pair<char*,float>*)p);
   }
   static void deleteArray_pairlEcharmUcOfloatgR(void *p) {
      delete [] ((pair<char*,float>*)p);
   }
   static void destruct_pairlEcharmUcOfloatgR(void *p) {
      typedef pair<char*,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<char*,float>

//______________________________________________________________________________
namespace ROOT {
   void pairlEcharmUcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<char*,double>.
      typedef ::ROOT::Shadow::pairlEcharmUcOdoublegR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<char*,double>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "*first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEcharmUcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<char*,double> : new pair<char*,double>;
   }
   static void *newArray_pairlEcharmUcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<char*,double>[nElements] : new pair<char*,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEcharmUcOdoublegR(void *p) {
      delete ((pair<char*,double>*)p);
   }
   static void deleteArray_pairlEcharmUcOdoublegR(void *p) {
      delete [] ((pair<char*,double>*)p);
   }
   static void destruct_pairlEcharmUcOdoublegR(void *p) {
      typedef pair<char*,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<char*,double>

//______________________________________________________________________________
namespace ROOT {
   void pairlEcharmUcOvoidmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<char*,void*>.
      typedef ::ROOT::Shadow::pairlEcharmUcOvoidmUgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<char*,void*>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "*first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "*second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEcharmUcOvoidmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<char*,void*> : new pair<char*,void*>;
   }
   static void *newArray_pairlEcharmUcOvoidmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<char*,void*>[nElements] : new pair<char*,void*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEcharmUcOvoidmUgR(void *p) {
      delete ((pair<char*,void*>*)p);
   }
   static void deleteArray_pairlEcharmUcOvoidmUgR(void *p) {
      delete [] ((pair<char*,void*>*)p);
   }
   static void destruct_pairlEcharmUcOvoidmUgR(void *p) {
      typedef pair<char*,void*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<char*,void*>

//______________________________________________________________________________
namespace ROOT {
   void pairlEcharmUcOcharmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<char*,char*>.
      typedef ::ROOT::Shadow::pairlEcharmUcOcharmUgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<char*,char*>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "*first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "*second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEcharmUcOcharmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<char*,char*> : new pair<char*,char*>;
   }
   static void *newArray_pairlEcharmUcOcharmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<char*,char*>[nElements] : new pair<char*,char*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEcharmUcOcharmUgR(void *p) {
      delete ((pair<char*,char*>*)p);
   }
   static void deleteArray_pairlEcharmUcOcharmUgR(void *p) {
      delete [] ((pair<char*,char*>*)p);
   }
   static void destruct_pairlEcharmUcOcharmUgR(void *p) {
      typedef pair<char*,char*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<char*,char*>

//______________________________________________________________________________
namespace ROOT {
   void pairlEstringcOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<string,int>.
      typedef ::ROOT::Shadow::pairlEstringcOintgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<string,int>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", (void*)&sobj->first);
      ::ROOT::GenericShowMembers("string", (void*)&sobj->first, R__insp, strcat(R__parent,"first."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEstringcOintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<string,int> : new pair<string,int>;
   }
   static void *newArray_pairlEstringcOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<string,int>[nElements] : new pair<string,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEstringcOintgR(void *p) {
      delete ((pair<string,int>*)p);
   }
   static void deleteArray_pairlEstringcOintgR(void *p) {
      delete [] ((pair<string,int>*)p);
   }
   static void destruct_pairlEstringcOintgR(void *p) {
      typedef pair<string,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<string,int>

//______________________________________________________________________________
namespace ROOT {
   void pairlEstringcOlonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<string,long>.
      typedef ::ROOT::Shadow::pairlEstringcOlonggR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<string,long>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", (void*)&sobj->first);
      ::ROOT::GenericShowMembers("string", (void*)&sobj->first, R__insp, strcat(R__parent,"first."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEstringcOlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<string,long> : new pair<string,long>;
   }
   static void *newArray_pairlEstringcOlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<string,long>[nElements] : new pair<string,long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEstringcOlonggR(void *p) {
      delete ((pair<string,long>*)p);
   }
   static void deleteArray_pairlEstringcOlonggR(void *p) {
      delete [] ((pair<string,long>*)p);
   }
   static void destruct_pairlEstringcOlonggR(void *p) {
      typedef pair<string,long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<string,long>

//______________________________________________________________________________
namespace ROOT {
   void pairlEstringcOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<string,float>.
      typedef ::ROOT::Shadow::pairlEstringcOfloatgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<string,float>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", (void*)&sobj->first);
      ::ROOT::GenericShowMembers("string", (void*)&sobj->first, R__insp, strcat(R__parent,"first."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEstringcOfloatgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<string,float> : new pair<string,float>;
   }
   static void *newArray_pairlEstringcOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<string,float>[nElements] : new pair<string,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEstringcOfloatgR(void *p) {
      delete ((pair<string,float>*)p);
   }
   static void deleteArray_pairlEstringcOfloatgR(void *p) {
      delete [] ((pair<string,float>*)p);
   }
   static void destruct_pairlEstringcOfloatgR(void *p) {
      typedef pair<string,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<string,float>

//______________________________________________________________________________
namespace ROOT {
   void pairlEstringcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<string,double>.
      typedef ::ROOT::Shadow::pairlEstringcOdoublegR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<string,double>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", (void*)&sobj->first);
      ::ROOT::GenericShowMembers("string", (void*)&sobj->first, R__insp, strcat(R__parent,"first."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEstringcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<string,double> : new pair<string,double>;
   }
   static void *newArray_pairlEstringcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<string,double>[nElements] : new pair<string,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEstringcOdoublegR(void *p) {
      delete ((pair<string,double>*)p);
   }
   static void deleteArray_pairlEstringcOdoublegR(void *p) {
      delete [] ((pair<string,double>*)p);
   }
   static void destruct_pairlEstringcOdoublegR(void *p) {
      typedef pair<string,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<string,double>

//______________________________________________________________________________
namespace ROOT {
   void pairlEstringcOvoidmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<string,void*>.
      typedef ::ROOT::Shadow::pairlEstringcOvoidmUgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<string,void*>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", (void*)&sobj->first);
      ::ROOT::GenericShowMembers("string", (void*)&sobj->first, R__insp, strcat(R__parent,"first."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "*second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEstringcOvoidmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<string,void*> : new pair<string,void*>;
   }
   static void *newArray_pairlEstringcOvoidmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<string,void*>[nElements] : new pair<string,void*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEstringcOvoidmUgR(void *p) {
      delete ((pair<string,void*>*)p);
   }
   static void deleteArray_pairlEstringcOvoidmUgR(void *p) {
      delete [] ((pair<string,void*>*)p);
   }
   static void destruct_pairlEstringcOvoidmUgR(void *p) {
      typedef pair<string,void*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<string,void*>

//______________________________________________________________________________
namespace ROOT {
   void pairlEintcOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<int,int>.
      typedef ::ROOT::Shadow::pairlEintcOintgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<int,int>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEintcOintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<int,int> : new pair<int,int>;
   }
   static void *newArray_pairlEintcOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<int,int>[nElements] : new pair<int,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEintcOintgR(void *p) {
      delete ((pair<int,int>*)p);
   }
   static void deleteArray_pairlEintcOintgR(void *p) {
      delete [] ((pair<int,int>*)p);
   }
   static void destruct_pairlEintcOintgR(void *p) {
      typedef pair<int,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<int,int>

//______________________________________________________________________________
namespace ROOT {
   void pairlEintcOlonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<int,long>.
      typedef ::ROOT::Shadow::pairlEintcOlonggR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<int,long>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEintcOlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<int,long> : new pair<int,long>;
   }
   static void *newArray_pairlEintcOlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<int,long>[nElements] : new pair<int,long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEintcOlonggR(void *p) {
      delete ((pair<int,long>*)p);
   }
   static void deleteArray_pairlEintcOlonggR(void *p) {
      delete [] ((pair<int,long>*)p);
   }
   static void destruct_pairlEintcOlonggR(void *p) {
      typedef pair<int,long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<int,long>

//______________________________________________________________________________
namespace ROOT {
   void pairlEintcOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<int,float>.
      typedef ::ROOT::Shadow::pairlEintcOfloatgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<int,float>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEintcOfloatgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<int,float> : new pair<int,float>;
   }
   static void *newArray_pairlEintcOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<int,float>[nElements] : new pair<int,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEintcOfloatgR(void *p) {
      delete ((pair<int,float>*)p);
   }
   static void deleteArray_pairlEintcOfloatgR(void *p) {
      delete [] ((pair<int,float>*)p);
   }
   static void destruct_pairlEintcOfloatgR(void *p) {
      typedef pair<int,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<int,float>

//______________________________________________________________________________
namespace ROOT {
   void pairlEintcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<int,double>.
      typedef ::ROOT::Shadow::pairlEintcOdoublegR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<int,double>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEintcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<int,double> : new pair<int,double>;
   }
   static void *newArray_pairlEintcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<int,double>[nElements] : new pair<int,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEintcOdoublegR(void *p) {
      delete ((pair<int,double>*)p);
   }
   static void deleteArray_pairlEintcOdoublegR(void *p) {
      delete [] ((pair<int,double>*)p);
   }
   static void destruct_pairlEintcOdoublegR(void *p) {
      typedef pair<int,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<int,double>

//______________________________________________________________________________
namespace ROOT {
   void pairlEintcOvoidmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<int,void*>.
      typedef ::ROOT::Shadow::pairlEintcOvoidmUgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<int,void*>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "*second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEintcOvoidmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<int,void*> : new pair<int,void*>;
   }
   static void *newArray_pairlEintcOvoidmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<int,void*>[nElements] : new pair<int,void*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEintcOvoidmUgR(void *p) {
      delete ((pair<int,void*>*)p);
   }
   static void deleteArray_pairlEintcOvoidmUgR(void *p) {
      delete [] ((pair<int,void*>*)p);
   }
   static void destruct_pairlEintcOvoidmUgR(void *p) {
      typedef pair<int,void*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<int,void*>

//______________________________________________________________________________
namespace ROOT {
   void pairlEintcOcharmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<int,char*>.
      typedef ::ROOT::Shadow::pairlEintcOcharmUgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<int,char*>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "*second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEintcOcharmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<int,char*> : new pair<int,char*>;
   }
   static void *newArray_pairlEintcOcharmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<int,char*>[nElements] : new pair<int,char*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEintcOcharmUgR(void *p) {
      delete ((pair<int,char*>*)p);
   }
   static void deleteArray_pairlEintcOcharmUgR(void *p) {
      delete [] ((pair<int,char*>*)p);
   }
   static void destruct_pairlEintcOcharmUgR(void *p) {
      typedef pair<int,char*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<int,char*>

//______________________________________________________________________________
namespace ROOT {
   void pairlElongcOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<long,int>.
      typedef ::ROOT::Shadow::pairlElongcOintgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<long,int>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlElongcOintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<long,int> : new pair<long,int>;
   }
   static void *newArray_pairlElongcOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<long,int>[nElements] : new pair<long,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlElongcOintgR(void *p) {
      delete ((pair<long,int>*)p);
   }
   static void deleteArray_pairlElongcOintgR(void *p) {
      delete [] ((pair<long,int>*)p);
   }
   static void destruct_pairlElongcOintgR(void *p) {
      typedef pair<long,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<long,int>

//______________________________________________________________________________
namespace ROOT {
   void pairlElongcOlonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<long,long>.
      typedef ::ROOT::Shadow::pairlElongcOlonggR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<long,long>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlElongcOlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<long,long> : new pair<long,long>;
   }
   static void *newArray_pairlElongcOlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<long,long>[nElements] : new pair<long,long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlElongcOlonggR(void *p) {
      delete ((pair<long,long>*)p);
   }
   static void deleteArray_pairlElongcOlonggR(void *p) {
      delete [] ((pair<long,long>*)p);
   }
   static void destruct_pairlElongcOlonggR(void *p) {
      typedef pair<long,long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<long,long>

//______________________________________________________________________________
namespace ROOT {
   void pairlElongcOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<long,float>.
      typedef ::ROOT::Shadow::pairlElongcOfloatgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<long,float>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlElongcOfloatgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<long,float> : new pair<long,float>;
   }
   static void *newArray_pairlElongcOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<long,float>[nElements] : new pair<long,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlElongcOfloatgR(void *p) {
      delete ((pair<long,float>*)p);
   }
   static void deleteArray_pairlElongcOfloatgR(void *p) {
      delete [] ((pair<long,float>*)p);
   }
   static void destruct_pairlElongcOfloatgR(void *p) {
      typedef pair<long,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<long,float>

//______________________________________________________________________________
namespace ROOT {
   void pairlElongcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<long,double>.
      typedef ::ROOT::Shadow::pairlElongcOdoublegR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<long,double>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlElongcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<long,double> : new pair<long,double>;
   }
   static void *newArray_pairlElongcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<long,double>[nElements] : new pair<long,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlElongcOdoublegR(void *p) {
      delete ((pair<long,double>*)p);
   }
   static void deleteArray_pairlElongcOdoublegR(void *p) {
      delete [] ((pair<long,double>*)p);
   }
   static void destruct_pairlElongcOdoublegR(void *p) {
      typedef pair<long,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<long,double>

//______________________________________________________________________________
namespace ROOT {
   void pairlElongcOvoidmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<long,void*>.
      typedef ::ROOT::Shadow::pairlElongcOvoidmUgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<long,void*>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "*second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlElongcOvoidmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<long,void*> : new pair<long,void*>;
   }
   static void *newArray_pairlElongcOvoidmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<long,void*>[nElements] : new pair<long,void*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlElongcOvoidmUgR(void *p) {
      delete ((pair<long,void*>*)p);
   }
   static void deleteArray_pairlElongcOvoidmUgR(void *p) {
      delete [] ((pair<long,void*>*)p);
   }
   static void destruct_pairlElongcOvoidmUgR(void *p) {
      typedef pair<long,void*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<long,void*>

//______________________________________________________________________________
namespace ROOT {
   void pairlElongcOcharmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<long,char*>.
      typedef ::ROOT::Shadow::pairlElongcOcharmUgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<long,char*>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "*second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlElongcOcharmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<long,char*> : new pair<long,char*>;
   }
   static void *newArray_pairlElongcOcharmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<long,char*>[nElements] : new pair<long,char*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlElongcOcharmUgR(void *p) {
      delete ((pair<long,char*>*)p);
   }
   static void deleteArray_pairlElongcOcharmUgR(void *p) {
      delete [] ((pair<long,char*>*)p);
   }
   static void destruct_pairlElongcOcharmUgR(void *p) {
      typedef pair<long,char*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<long,char*>

//______________________________________________________________________________
namespace ROOT {
   void pairlEfloatcOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<float,int>.
      typedef ::ROOT::Shadow::pairlEfloatcOintgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<float,int>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEfloatcOintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<float,int> : new pair<float,int>;
   }
   static void *newArray_pairlEfloatcOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<float,int>[nElements] : new pair<float,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEfloatcOintgR(void *p) {
      delete ((pair<float,int>*)p);
   }
   static void deleteArray_pairlEfloatcOintgR(void *p) {
      delete [] ((pair<float,int>*)p);
   }
   static void destruct_pairlEfloatcOintgR(void *p) {
      typedef pair<float,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<float,int>

//______________________________________________________________________________
namespace ROOT {
   void pairlEfloatcOlonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<float,long>.
      typedef ::ROOT::Shadow::pairlEfloatcOlonggR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<float,long>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEfloatcOlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<float,long> : new pair<float,long>;
   }
   static void *newArray_pairlEfloatcOlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<float,long>[nElements] : new pair<float,long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEfloatcOlonggR(void *p) {
      delete ((pair<float,long>*)p);
   }
   static void deleteArray_pairlEfloatcOlonggR(void *p) {
      delete [] ((pair<float,long>*)p);
   }
   static void destruct_pairlEfloatcOlonggR(void *p) {
      typedef pair<float,long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<float,long>

//______________________________________________________________________________
namespace ROOT {
   void pairlEfloatcOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<float,float>.
      typedef ::ROOT::Shadow::pairlEfloatcOfloatgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<float,float>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEfloatcOfloatgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<float,float> : new pair<float,float>;
   }
   static void *newArray_pairlEfloatcOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<float,float>[nElements] : new pair<float,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEfloatcOfloatgR(void *p) {
      delete ((pair<float,float>*)p);
   }
   static void deleteArray_pairlEfloatcOfloatgR(void *p) {
      delete [] ((pair<float,float>*)p);
   }
   static void destruct_pairlEfloatcOfloatgR(void *p) {
      typedef pair<float,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<float,float>

//______________________________________________________________________________
namespace ROOT {
   void pairlEfloatcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<float,double>.
      typedef ::ROOT::Shadow::pairlEfloatcOdoublegR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<float,double>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEfloatcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<float,double> : new pair<float,double>;
   }
   static void *newArray_pairlEfloatcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<float,double>[nElements] : new pair<float,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEfloatcOdoublegR(void *p) {
      delete ((pair<float,double>*)p);
   }
   static void deleteArray_pairlEfloatcOdoublegR(void *p) {
      delete [] ((pair<float,double>*)p);
   }
   static void destruct_pairlEfloatcOdoublegR(void *p) {
      typedef pair<float,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<float,double>

//______________________________________________________________________________
namespace ROOT {
   void pairlEfloatcOvoidmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<float,void*>.
      typedef ::ROOT::Shadow::pairlEfloatcOvoidmUgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<float,void*>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "*second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEfloatcOvoidmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<float,void*> : new pair<float,void*>;
   }
   static void *newArray_pairlEfloatcOvoidmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<float,void*>[nElements] : new pair<float,void*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEfloatcOvoidmUgR(void *p) {
      delete ((pair<float,void*>*)p);
   }
   static void deleteArray_pairlEfloatcOvoidmUgR(void *p) {
      delete [] ((pair<float,void*>*)p);
   }
   static void destruct_pairlEfloatcOvoidmUgR(void *p) {
      typedef pair<float,void*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<float,void*>

//______________________________________________________________________________
namespace ROOT {
   void pairlEfloatcOcharmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<float,char*>.
      typedef ::ROOT::Shadow::pairlEfloatcOcharmUgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<float,char*>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "*second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEfloatcOcharmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<float,char*> : new pair<float,char*>;
   }
   static void *newArray_pairlEfloatcOcharmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<float,char*>[nElements] : new pair<float,char*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEfloatcOcharmUgR(void *p) {
      delete ((pair<float,char*>*)p);
   }
   static void deleteArray_pairlEfloatcOcharmUgR(void *p) {
      delete [] ((pair<float,char*>*)p);
   }
   static void destruct_pairlEfloatcOcharmUgR(void *p) {
      typedef pair<float,char*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<float,char*>

//______________________________________________________________________________
namespace ROOT {
   void pairlEdoublecOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<double,int>.
      typedef ::ROOT::Shadow::pairlEdoublecOintgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<double,int>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEdoublecOintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<double,int> : new pair<double,int>;
   }
   static void *newArray_pairlEdoublecOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<double,int>[nElements] : new pair<double,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEdoublecOintgR(void *p) {
      delete ((pair<double,int>*)p);
   }
   static void deleteArray_pairlEdoublecOintgR(void *p) {
      delete [] ((pair<double,int>*)p);
   }
   static void destruct_pairlEdoublecOintgR(void *p) {
      typedef pair<double,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<double,int>

//______________________________________________________________________________
namespace ROOT {
   void pairlEdoublecOlonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<double,long>.
      typedef ::ROOT::Shadow::pairlEdoublecOlonggR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<double,long>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEdoublecOlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<double,long> : new pair<double,long>;
   }
   static void *newArray_pairlEdoublecOlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<double,long>[nElements] : new pair<double,long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEdoublecOlonggR(void *p) {
      delete ((pair<double,long>*)p);
   }
   static void deleteArray_pairlEdoublecOlonggR(void *p) {
      delete [] ((pair<double,long>*)p);
   }
   static void destruct_pairlEdoublecOlonggR(void *p) {
      typedef pair<double,long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<double,long>

//______________________________________________________________________________
namespace ROOT {
   void pairlEdoublecOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<double,float>.
      typedef ::ROOT::Shadow::pairlEdoublecOfloatgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<double,float>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEdoublecOfloatgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<double,float> : new pair<double,float>;
   }
   static void *newArray_pairlEdoublecOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<double,float>[nElements] : new pair<double,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEdoublecOfloatgR(void *p) {
      delete ((pair<double,float>*)p);
   }
   static void deleteArray_pairlEdoublecOfloatgR(void *p) {
      delete [] ((pair<double,float>*)p);
   }
   static void destruct_pairlEdoublecOfloatgR(void *p) {
      typedef pair<double,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<double,float>

//______________________________________________________________________________
namespace ROOT {
   void pairlEdoublecOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<double,double>.
      typedef ::ROOT::Shadow::pairlEdoublecOdoublegR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<double,double>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEdoublecOdoublegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<double,double> : new pair<double,double>;
   }
   static void *newArray_pairlEdoublecOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<double,double>[nElements] : new pair<double,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEdoublecOdoublegR(void *p) {
      delete ((pair<double,double>*)p);
   }
   static void deleteArray_pairlEdoublecOdoublegR(void *p) {
      delete [] ((pair<double,double>*)p);
   }
   static void destruct_pairlEdoublecOdoublegR(void *p) {
      typedef pair<double,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<double,double>

//______________________________________________________________________________
namespace ROOT {
   void pairlEdoublecOvoidmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<double,void*>.
      typedef ::ROOT::Shadow::pairlEdoublecOvoidmUgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<double,void*>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "*second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEdoublecOvoidmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<double,void*> : new pair<double,void*>;
   }
   static void *newArray_pairlEdoublecOvoidmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<double,void*>[nElements] : new pair<double,void*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEdoublecOvoidmUgR(void *p) {
      delete ((pair<double,void*>*)p);
   }
   static void deleteArray_pairlEdoublecOvoidmUgR(void *p) {
      delete [] ((pair<double,void*>*)p);
   }
   static void destruct_pairlEdoublecOvoidmUgR(void *p) {
      typedef pair<double,void*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<double,void*>

//______________________________________________________________________________
namespace ROOT {
   void pairlEdoublecOcharmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<double,char*>.
      typedef ::ROOT::Shadow::pairlEdoublecOcharmUgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<double,char*>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "*second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEdoublecOcharmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<double,char*> : new pair<double,char*>;
   }
   static void *newArray_pairlEdoublecOcharmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<double,char*>[nElements] : new pair<double,char*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEdoublecOcharmUgR(void *p) {
      delete ((pair<double,char*>*)p);
   }
   static void deleteArray_pairlEdoublecOcharmUgR(void *p) {
      delete [] ((pair<double,char*>*)p);
   }
   static void destruct_pairlEdoublecOcharmUgR(void *p) {
      typedef pair<double,char*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<double,char*>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPcharmUcOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const char*,int>.
      typedef ::ROOT::Shadow::pairlEconstsPcharmUcOintgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const char*,int>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "*first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPcharmUcOintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const char*,int> : new pair<const char*,int>;
   }
   static void *newArray_pairlEconstsPcharmUcOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const char*,int>[nElements] : new pair<const char*,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPcharmUcOintgR(void *p) {
      delete ((pair<const char*,int>*)p);
   }
   static void deleteArray_pairlEconstsPcharmUcOintgR(void *p) {
      delete [] ((pair<const char*,int>*)p);
   }
   static void destruct_pairlEconstsPcharmUcOintgR(void *p) {
      typedef pair<const char*,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const char*,int>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPcharmUcOlonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const char*,long>.
      typedef ::ROOT::Shadow::pairlEconstsPcharmUcOlonggR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const char*,long>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "*first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPcharmUcOlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const char*,long> : new pair<const char*,long>;
   }
   static void *newArray_pairlEconstsPcharmUcOlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const char*,long>[nElements] : new pair<const char*,long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPcharmUcOlonggR(void *p) {
      delete ((pair<const char*,long>*)p);
   }
   static void deleteArray_pairlEconstsPcharmUcOlonggR(void *p) {
      delete [] ((pair<const char*,long>*)p);
   }
   static void destruct_pairlEconstsPcharmUcOlonggR(void *p) {
      typedef pair<const char*,long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const char*,long>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPcharmUcOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const char*,float>.
      typedef ::ROOT::Shadow::pairlEconstsPcharmUcOfloatgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const char*,float>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "*first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPcharmUcOfloatgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const char*,float> : new pair<const char*,float>;
   }
   static void *newArray_pairlEconstsPcharmUcOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const char*,float>[nElements] : new pair<const char*,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPcharmUcOfloatgR(void *p) {
      delete ((pair<const char*,float>*)p);
   }
   static void deleteArray_pairlEconstsPcharmUcOfloatgR(void *p) {
      delete [] ((pair<const char*,float>*)p);
   }
   static void destruct_pairlEconstsPcharmUcOfloatgR(void *p) {
      typedef pair<const char*,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const char*,float>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPcharmUcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const char*,double>.
      typedef ::ROOT::Shadow::pairlEconstsPcharmUcOdoublegR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const char*,double>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "*first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPcharmUcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const char*,double> : new pair<const char*,double>;
   }
   static void *newArray_pairlEconstsPcharmUcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const char*,double>[nElements] : new pair<const char*,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPcharmUcOdoublegR(void *p) {
      delete ((pair<const char*,double>*)p);
   }
   static void deleteArray_pairlEconstsPcharmUcOdoublegR(void *p) {
      delete [] ((pair<const char*,double>*)p);
   }
   static void destruct_pairlEconstsPcharmUcOdoublegR(void *p) {
      typedef pair<const char*,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const char*,double>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPcharmUcOvoidmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const char*,void*>.
      typedef ::ROOT::Shadow::pairlEconstsPcharmUcOvoidmUgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const char*,void*>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "*first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "*second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPcharmUcOvoidmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const char*,void*> : new pair<const char*,void*>;
   }
   static void *newArray_pairlEconstsPcharmUcOvoidmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const char*,void*>[nElements] : new pair<const char*,void*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPcharmUcOvoidmUgR(void *p) {
      delete ((pair<const char*,void*>*)p);
   }
   static void deleteArray_pairlEconstsPcharmUcOvoidmUgR(void *p) {
      delete [] ((pair<const char*,void*>*)p);
   }
   static void destruct_pairlEconstsPcharmUcOvoidmUgR(void *p) {
      typedef pair<const char*,void*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const char*,void*>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPcharmUcOcharmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const char*,char*>.
      typedef ::ROOT::Shadow::pairlEconstsPcharmUcOcharmUgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const char*,char*>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "*first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "*second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPcharmUcOcharmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const char*,char*> : new pair<const char*,char*>;
   }
   static void *newArray_pairlEconstsPcharmUcOcharmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const char*,char*>[nElements] : new pair<const char*,char*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPcharmUcOcharmUgR(void *p) {
      delete ((pair<const char*,char*>*)p);
   }
   static void deleteArray_pairlEconstsPcharmUcOcharmUgR(void *p) {
      delete [] ((pair<const char*,char*>*)p);
   }
   static void destruct_pairlEconstsPcharmUcOcharmUgR(void *p) {
      typedef pair<const char*,char*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const char*,char*>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPstringcOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const string,int>.
      typedef ::ROOT::Shadow::pairlEconstsPstringcOintgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const string,int>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", (void*)&sobj->first);
      ::ROOT::GenericShowMembers("const string", (void*)&sobj->first, R__insp, strcat(R__parent,"first."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPstringcOintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const string,int> : new pair<const string,int>;
   }
   static void *newArray_pairlEconstsPstringcOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const string,int>[nElements] : new pair<const string,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPstringcOintgR(void *p) {
      delete ((pair<const string,int>*)p);
   }
   static void deleteArray_pairlEconstsPstringcOintgR(void *p) {
      delete [] ((pair<const string,int>*)p);
   }
   static void destruct_pairlEconstsPstringcOintgR(void *p) {
      typedef pair<const string,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const string,int>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPstringcOlonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const string,long>.
      typedef ::ROOT::Shadow::pairlEconstsPstringcOlonggR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const string,long>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", (void*)&sobj->first);
      ::ROOT::GenericShowMembers("const string", (void*)&sobj->first, R__insp, strcat(R__parent,"first."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPstringcOlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const string,long> : new pair<const string,long>;
   }
   static void *newArray_pairlEconstsPstringcOlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const string,long>[nElements] : new pair<const string,long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPstringcOlonggR(void *p) {
      delete ((pair<const string,long>*)p);
   }
   static void deleteArray_pairlEconstsPstringcOlonggR(void *p) {
      delete [] ((pair<const string,long>*)p);
   }
   static void destruct_pairlEconstsPstringcOlonggR(void *p) {
      typedef pair<const string,long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const string,long>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPstringcOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const string,float>.
      typedef ::ROOT::Shadow::pairlEconstsPstringcOfloatgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const string,float>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", (void*)&sobj->first);
      ::ROOT::GenericShowMembers("const string", (void*)&sobj->first, R__insp, strcat(R__parent,"first."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPstringcOfloatgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const string,float> : new pair<const string,float>;
   }
   static void *newArray_pairlEconstsPstringcOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const string,float>[nElements] : new pair<const string,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPstringcOfloatgR(void *p) {
      delete ((pair<const string,float>*)p);
   }
   static void deleteArray_pairlEconstsPstringcOfloatgR(void *p) {
      delete [] ((pair<const string,float>*)p);
   }
   static void destruct_pairlEconstsPstringcOfloatgR(void *p) {
      typedef pair<const string,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const string,float>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPstringcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const string,double>.
      typedef ::ROOT::Shadow::pairlEconstsPstringcOdoublegR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const string,double>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", (void*)&sobj->first);
      ::ROOT::GenericShowMembers("const string", (void*)&sobj->first, R__insp, strcat(R__parent,"first."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPstringcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const string,double> : new pair<const string,double>;
   }
   static void *newArray_pairlEconstsPstringcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const string,double>[nElements] : new pair<const string,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPstringcOdoublegR(void *p) {
      delete ((pair<const string,double>*)p);
   }
   static void deleteArray_pairlEconstsPstringcOdoublegR(void *p) {
      delete [] ((pair<const string,double>*)p);
   }
   static void destruct_pairlEconstsPstringcOdoublegR(void *p) {
      typedef pair<const string,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const string,double>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPstringcOvoidmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const string,void*>.
      typedef ::ROOT::Shadow::pairlEconstsPstringcOvoidmUgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const string,void*>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", (void*)&sobj->first);
      ::ROOT::GenericShowMembers("const string", (void*)&sobj->first, R__insp, strcat(R__parent,"first."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "*second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPstringcOvoidmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const string,void*> : new pair<const string,void*>;
   }
   static void *newArray_pairlEconstsPstringcOvoidmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const string,void*>[nElements] : new pair<const string,void*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPstringcOvoidmUgR(void *p) {
      delete ((pair<const string,void*>*)p);
   }
   static void deleteArray_pairlEconstsPstringcOvoidmUgR(void *p) {
      delete [] ((pair<const string,void*>*)p);
   }
   static void destruct_pairlEconstsPstringcOvoidmUgR(void *p) {
      typedef pair<const string,void*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const string,void*>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPintcOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const int,int>.
      typedef ::ROOT::Shadow::pairlEconstsPintcOintgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const int,int>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPintcOintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const int,int> : new pair<const int,int>;
   }
   static void *newArray_pairlEconstsPintcOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const int,int>[nElements] : new pair<const int,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPintcOintgR(void *p) {
      delete ((pair<const int,int>*)p);
   }
   static void deleteArray_pairlEconstsPintcOintgR(void *p) {
      delete [] ((pair<const int,int>*)p);
   }
   static void destruct_pairlEconstsPintcOintgR(void *p) {
      typedef pair<const int,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const int,int>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPintcOlonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const int,long>.
      typedef ::ROOT::Shadow::pairlEconstsPintcOlonggR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const int,long>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPintcOlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const int,long> : new pair<const int,long>;
   }
   static void *newArray_pairlEconstsPintcOlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const int,long>[nElements] : new pair<const int,long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPintcOlonggR(void *p) {
      delete ((pair<const int,long>*)p);
   }
   static void deleteArray_pairlEconstsPintcOlonggR(void *p) {
      delete [] ((pair<const int,long>*)p);
   }
   static void destruct_pairlEconstsPintcOlonggR(void *p) {
      typedef pair<const int,long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const int,long>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPintcOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const int,float>.
      typedef ::ROOT::Shadow::pairlEconstsPintcOfloatgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const int,float>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPintcOfloatgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const int,float> : new pair<const int,float>;
   }
   static void *newArray_pairlEconstsPintcOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const int,float>[nElements] : new pair<const int,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPintcOfloatgR(void *p) {
      delete ((pair<const int,float>*)p);
   }
   static void deleteArray_pairlEconstsPintcOfloatgR(void *p) {
      delete [] ((pair<const int,float>*)p);
   }
   static void destruct_pairlEconstsPintcOfloatgR(void *p) {
      typedef pair<const int,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const int,float>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPintcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const int,double>.
      typedef ::ROOT::Shadow::pairlEconstsPintcOdoublegR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const int,double>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPintcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const int,double> : new pair<const int,double>;
   }
   static void *newArray_pairlEconstsPintcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const int,double>[nElements] : new pair<const int,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPintcOdoublegR(void *p) {
      delete ((pair<const int,double>*)p);
   }
   static void deleteArray_pairlEconstsPintcOdoublegR(void *p) {
      delete [] ((pair<const int,double>*)p);
   }
   static void destruct_pairlEconstsPintcOdoublegR(void *p) {
      typedef pair<const int,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const int,double>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPintcOvoidmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const int,void*>.
      typedef ::ROOT::Shadow::pairlEconstsPintcOvoidmUgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const int,void*>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "*second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPintcOvoidmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const int,void*> : new pair<const int,void*>;
   }
   static void *newArray_pairlEconstsPintcOvoidmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const int,void*>[nElements] : new pair<const int,void*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPintcOvoidmUgR(void *p) {
      delete ((pair<const int,void*>*)p);
   }
   static void deleteArray_pairlEconstsPintcOvoidmUgR(void *p) {
      delete [] ((pair<const int,void*>*)p);
   }
   static void destruct_pairlEconstsPintcOvoidmUgR(void *p) {
      typedef pair<const int,void*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const int,void*>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPintcOcharmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const int,char*>.
      typedef ::ROOT::Shadow::pairlEconstsPintcOcharmUgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const int,char*>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "*second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPintcOcharmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const int,char*> : new pair<const int,char*>;
   }
   static void *newArray_pairlEconstsPintcOcharmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const int,char*>[nElements] : new pair<const int,char*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPintcOcharmUgR(void *p) {
      delete ((pair<const int,char*>*)p);
   }
   static void deleteArray_pairlEconstsPintcOcharmUgR(void *p) {
      delete [] ((pair<const int,char*>*)p);
   }
   static void destruct_pairlEconstsPintcOcharmUgR(void *p) {
      typedef pair<const int,char*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const int,char*>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPlongcOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const long,int>.
      typedef ::ROOT::Shadow::pairlEconstsPlongcOintgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const long,int>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPlongcOintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const long,int> : new pair<const long,int>;
   }
   static void *newArray_pairlEconstsPlongcOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const long,int>[nElements] : new pair<const long,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPlongcOintgR(void *p) {
      delete ((pair<const long,int>*)p);
   }
   static void deleteArray_pairlEconstsPlongcOintgR(void *p) {
      delete [] ((pair<const long,int>*)p);
   }
   static void destruct_pairlEconstsPlongcOintgR(void *p) {
      typedef pair<const long,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const long,int>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPlongcOlonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const long,long>.
      typedef ::ROOT::Shadow::pairlEconstsPlongcOlonggR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const long,long>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPlongcOlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const long,long> : new pair<const long,long>;
   }
   static void *newArray_pairlEconstsPlongcOlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const long,long>[nElements] : new pair<const long,long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPlongcOlonggR(void *p) {
      delete ((pair<const long,long>*)p);
   }
   static void deleteArray_pairlEconstsPlongcOlonggR(void *p) {
      delete [] ((pair<const long,long>*)p);
   }
   static void destruct_pairlEconstsPlongcOlonggR(void *p) {
      typedef pair<const long,long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const long,long>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPlongcOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const long,float>.
      typedef ::ROOT::Shadow::pairlEconstsPlongcOfloatgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const long,float>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPlongcOfloatgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const long,float> : new pair<const long,float>;
   }
   static void *newArray_pairlEconstsPlongcOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const long,float>[nElements] : new pair<const long,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPlongcOfloatgR(void *p) {
      delete ((pair<const long,float>*)p);
   }
   static void deleteArray_pairlEconstsPlongcOfloatgR(void *p) {
      delete [] ((pair<const long,float>*)p);
   }
   static void destruct_pairlEconstsPlongcOfloatgR(void *p) {
      typedef pair<const long,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const long,float>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPlongcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const long,double>.
      typedef ::ROOT::Shadow::pairlEconstsPlongcOdoublegR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const long,double>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPlongcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const long,double> : new pair<const long,double>;
   }
   static void *newArray_pairlEconstsPlongcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const long,double>[nElements] : new pair<const long,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPlongcOdoublegR(void *p) {
      delete ((pair<const long,double>*)p);
   }
   static void deleteArray_pairlEconstsPlongcOdoublegR(void *p) {
      delete [] ((pair<const long,double>*)p);
   }
   static void destruct_pairlEconstsPlongcOdoublegR(void *p) {
      typedef pair<const long,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const long,double>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPlongcOvoidmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const long,void*>.
      typedef ::ROOT::Shadow::pairlEconstsPlongcOvoidmUgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const long,void*>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "*second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPlongcOvoidmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const long,void*> : new pair<const long,void*>;
   }
   static void *newArray_pairlEconstsPlongcOvoidmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const long,void*>[nElements] : new pair<const long,void*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPlongcOvoidmUgR(void *p) {
      delete ((pair<const long,void*>*)p);
   }
   static void deleteArray_pairlEconstsPlongcOvoidmUgR(void *p) {
      delete [] ((pair<const long,void*>*)p);
   }
   static void destruct_pairlEconstsPlongcOvoidmUgR(void *p) {
      typedef pair<const long,void*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const long,void*>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPlongcOcharmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const long,char*>.
      typedef ::ROOT::Shadow::pairlEconstsPlongcOcharmUgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const long,char*>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "*second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPlongcOcharmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const long,char*> : new pair<const long,char*>;
   }
   static void *newArray_pairlEconstsPlongcOcharmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const long,char*>[nElements] : new pair<const long,char*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPlongcOcharmUgR(void *p) {
      delete ((pair<const long,char*>*)p);
   }
   static void deleteArray_pairlEconstsPlongcOcharmUgR(void *p) {
      delete [] ((pair<const long,char*>*)p);
   }
   static void destruct_pairlEconstsPlongcOcharmUgR(void *p) {
      typedef pair<const long,char*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const long,char*>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPfloatcOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const float,int>.
      typedef ::ROOT::Shadow::pairlEconstsPfloatcOintgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const float,int>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPfloatcOintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const float,int> : new pair<const float,int>;
   }
   static void *newArray_pairlEconstsPfloatcOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const float,int>[nElements] : new pair<const float,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPfloatcOintgR(void *p) {
      delete ((pair<const float,int>*)p);
   }
   static void deleteArray_pairlEconstsPfloatcOintgR(void *p) {
      delete [] ((pair<const float,int>*)p);
   }
   static void destruct_pairlEconstsPfloatcOintgR(void *p) {
      typedef pair<const float,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const float,int>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPfloatcOlonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const float,long>.
      typedef ::ROOT::Shadow::pairlEconstsPfloatcOlonggR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const float,long>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPfloatcOlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const float,long> : new pair<const float,long>;
   }
   static void *newArray_pairlEconstsPfloatcOlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const float,long>[nElements] : new pair<const float,long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPfloatcOlonggR(void *p) {
      delete ((pair<const float,long>*)p);
   }
   static void deleteArray_pairlEconstsPfloatcOlonggR(void *p) {
      delete [] ((pair<const float,long>*)p);
   }
   static void destruct_pairlEconstsPfloatcOlonggR(void *p) {
      typedef pair<const float,long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const float,long>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPfloatcOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const float,float>.
      typedef ::ROOT::Shadow::pairlEconstsPfloatcOfloatgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const float,float>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPfloatcOfloatgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const float,float> : new pair<const float,float>;
   }
   static void *newArray_pairlEconstsPfloatcOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const float,float>[nElements] : new pair<const float,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPfloatcOfloatgR(void *p) {
      delete ((pair<const float,float>*)p);
   }
   static void deleteArray_pairlEconstsPfloatcOfloatgR(void *p) {
      delete [] ((pair<const float,float>*)p);
   }
   static void destruct_pairlEconstsPfloatcOfloatgR(void *p) {
      typedef pair<const float,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const float,float>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPfloatcOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const float,double>.
      typedef ::ROOT::Shadow::pairlEconstsPfloatcOdoublegR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const float,double>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPfloatcOdoublegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const float,double> : new pair<const float,double>;
   }
   static void *newArray_pairlEconstsPfloatcOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const float,double>[nElements] : new pair<const float,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPfloatcOdoublegR(void *p) {
      delete ((pair<const float,double>*)p);
   }
   static void deleteArray_pairlEconstsPfloatcOdoublegR(void *p) {
      delete [] ((pair<const float,double>*)p);
   }
   static void destruct_pairlEconstsPfloatcOdoublegR(void *p) {
      typedef pair<const float,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const float,double>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPfloatcOvoidmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const float,void*>.
      typedef ::ROOT::Shadow::pairlEconstsPfloatcOvoidmUgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const float,void*>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "*second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPfloatcOvoidmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const float,void*> : new pair<const float,void*>;
   }
   static void *newArray_pairlEconstsPfloatcOvoidmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const float,void*>[nElements] : new pair<const float,void*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPfloatcOvoidmUgR(void *p) {
      delete ((pair<const float,void*>*)p);
   }
   static void deleteArray_pairlEconstsPfloatcOvoidmUgR(void *p) {
      delete [] ((pair<const float,void*>*)p);
   }
   static void destruct_pairlEconstsPfloatcOvoidmUgR(void *p) {
      typedef pair<const float,void*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const float,void*>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPfloatcOcharmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const float,char*>.
      typedef ::ROOT::Shadow::pairlEconstsPfloatcOcharmUgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const float,char*>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "*second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPfloatcOcharmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const float,char*> : new pair<const float,char*>;
   }
   static void *newArray_pairlEconstsPfloatcOcharmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const float,char*>[nElements] : new pair<const float,char*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPfloatcOcharmUgR(void *p) {
      delete ((pair<const float,char*>*)p);
   }
   static void deleteArray_pairlEconstsPfloatcOcharmUgR(void *p) {
      delete [] ((pair<const float,char*>*)p);
   }
   static void destruct_pairlEconstsPfloatcOcharmUgR(void *p) {
      typedef pair<const float,char*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const float,char*>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPdoublecOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const double,int>.
      typedef ::ROOT::Shadow::pairlEconstsPdoublecOintgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const double,int>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPdoublecOintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const double,int> : new pair<const double,int>;
   }
   static void *newArray_pairlEconstsPdoublecOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const double,int>[nElements] : new pair<const double,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPdoublecOintgR(void *p) {
      delete ((pair<const double,int>*)p);
   }
   static void deleteArray_pairlEconstsPdoublecOintgR(void *p) {
      delete [] ((pair<const double,int>*)p);
   }
   static void destruct_pairlEconstsPdoublecOintgR(void *p) {
      typedef pair<const double,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const double,int>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPdoublecOlonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const double,long>.
      typedef ::ROOT::Shadow::pairlEconstsPdoublecOlonggR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const double,long>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPdoublecOlonggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const double,long> : new pair<const double,long>;
   }
   static void *newArray_pairlEconstsPdoublecOlonggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const double,long>[nElements] : new pair<const double,long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPdoublecOlonggR(void *p) {
      delete ((pair<const double,long>*)p);
   }
   static void deleteArray_pairlEconstsPdoublecOlonggR(void *p) {
      delete [] ((pair<const double,long>*)p);
   }
   static void destruct_pairlEconstsPdoublecOlonggR(void *p) {
      typedef pair<const double,long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const double,long>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPdoublecOfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const double,float>.
      typedef ::ROOT::Shadow::pairlEconstsPdoublecOfloatgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const double,float>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPdoublecOfloatgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const double,float> : new pair<const double,float>;
   }
   static void *newArray_pairlEconstsPdoublecOfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const double,float>[nElements] : new pair<const double,float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPdoublecOfloatgR(void *p) {
      delete ((pair<const double,float>*)p);
   }
   static void deleteArray_pairlEconstsPdoublecOfloatgR(void *p) {
      delete [] ((pair<const double,float>*)p);
   }
   static void destruct_pairlEconstsPdoublecOfloatgR(void *p) {
      typedef pair<const double,float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const double,float>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPdoublecOdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const double,double>.
      typedef ::ROOT::Shadow::pairlEconstsPdoublecOdoublegR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const double,double>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPdoublecOdoublegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const double,double> : new pair<const double,double>;
   }
   static void *newArray_pairlEconstsPdoublecOdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const double,double>[nElements] : new pair<const double,double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPdoublecOdoublegR(void *p) {
      delete ((pair<const double,double>*)p);
   }
   static void deleteArray_pairlEconstsPdoublecOdoublegR(void *p) {
      delete [] ((pair<const double,double>*)p);
   }
   static void destruct_pairlEconstsPdoublecOdoublegR(void *p) {
      typedef pair<const double,double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const double,double>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPdoublecOvoidmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const double,void*>.
      typedef ::ROOT::Shadow::pairlEconstsPdoublecOvoidmUgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const double,void*>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "*second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPdoublecOvoidmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const double,void*> : new pair<const double,void*>;
   }
   static void *newArray_pairlEconstsPdoublecOvoidmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const double,void*>[nElements] : new pair<const double,void*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPdoublecOvoidmUgR(void *p) {
      delete ((pair<const double,void*>*)p);
   }
   static void deleteArray_pairlEconstsPdoublecOvoidmUgR(void *p) {
      delete [] ((pair<const double,void*>*)p);
   }
   static void destruct_pairlEconstsPdoublecOvoidmUgR(void *p) {
      typedef pair<const double,void*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const double,void*>

//______________________________________________________________________________
namespace ROOT {
   void pairlEconstsPdoublecOcharmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class pair<const double,char*>.
      typedef ::ROOT::Shadow::pairlEconstsPdoublecOcharmUgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<const double,char*>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "first", &sobj->first);
      R__insp.Inspect(R__cl, R__parent, "*second", &sobj->second);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEconstsPdoublecOcharmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const double,char*> : new pair<const double,char*>;
   }
   static void *newArray_pairlEconstsPdoublecOcharmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<const double,char*>[nElements] : new pair<const double,char*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEconstsPdoublecOcharmUgR(void *p) {
      delete ((pair<const double,char*>*)p);
   }
   static void deleteArray_pairlEconstsPdoublecOcharmUgR(void *p) {
      delete [] ((pair<const double,char*>*)p);
   }
   static void destruct_pairlEconstsPdoublecOcharmUgR(void *p) {
      typedef pair<const double,char*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<const double,char*>

//______________________________________________________________________________
template <> void TParameter<float>::Streamer(TBuffer &R__b)
{
   // Stream an object of class TParameter<float>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TParameter<float>::Class(),this);
   } else {
      R__b.WriteClassBuffer(TParameter<float>::Class(),this);
   }
}

//______________________________________________________________________________
namespace ROOT {
   void TParameterlEfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class TParameter<float>.
      typedef ::ROOT::Shadow::TParameterlEfloatgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<float>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fName", &sobj->fName);
      sobj->fName.ShowMembers(R__insp, strcat(R__parent,"fName.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fVal", &sobj->fVal);
      sobj->TObject::ShowMembers(R__insp, R__parent);
   }

}

template <> void TParameter<float>::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
   ::ROOT::TParameterlEfloatgR_ShowMembers(this, R__insp, R__parent);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TParameterlEfloatgR(void *p) {
      return  p ? new(p) ::TParameter<float> : new ::TParameter<float>;
   }
   static void *newArray_TParameterlEfloatgR(Long_t nElements, void *p) {
      return p ? new(p) ::TParameter<float>[nElements] : new ::TParameter<float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_TParameterlEfloatgR(void *p) {
      delete ((::TParameter<float>*)p);
   }
   static void deleteArray_TParameterlEfloatgR(void *p) {
      delete [] ((::TParameter<float>*)p);
   }
   static void destruct_TParameterlEfloatgR(void *p) {
      typedef ::TParameter<float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TParameter<float>

//______________________________________________________________________________
template <> void TParameter<double>::Streamer(TBuffer &R__b)
{
   // Stream an object of class TParameter<double>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TParameter<double>::Class(),this);
   } else {
      R__b.WriteClassBuffer(TParameter<double>::Class(),this);
   }
}

//______________________________________________________________________________
namespace ROOT {
   void TParameterlEdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class TParameter<double>.
      typedef ::ROOT::Shadow::TParameterlEdoublegR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<double>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fName", &sobj->fName);
      sobj->fName.ShowMembers(R__insp, strcat(R__parent,"fName.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fVal", &sobj->fVal);
      sobj->TObject::ShowMembers(R__insp, R__parent);
   }

}

template <> void TParameter<double>::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
   ::ROOT::TParameterlEdoublegR_ShowMembers(this, R__insp, R__parent);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TParameterlEdoublegR(void *p) {
      return  p ? new(p) ::TParameter<double> : new ::TParameter<double>;
   }
   static void *newArray_TParameterlEdoublegR(Long_t nElements, void *p) {
      return p ? new(p) ::TParameter<double>[nElements] : new ::TParameter<double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_TParameterlEdoublegR(void *p) {
      delete ((::TParameter<double>*)p);
   }
   static void deleteArray_TParameterlEdoublegR(void *p) {
      delete [] ((::TParameter<double>*)p);
   }
   static void destruct_TParameterlEdoublegR(void *p) {
      typedef ::TParameter<double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TParameter<double>

//______________________________________________________________________________
template <> void TParameter<int>::Streamer(TBuffer &R__b)
{
   // Stream an object of class TParameter<int>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TParameter<int>::Class(),this);
   } else {
      R__b.WriteClassBuffer(TParameter<int>::Class(),this);
   }
}

//______________________________________________________________________________
namespace ROOT {
   void TParameterlEintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class TParameter<int>.
      typedef ::ROOT::Shadow::TParameterlEintgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<int>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fName", &sobj->fName);
      sobj->fName.ShowMembers(R__insp, strcat(R__parent,"fName.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fVal", &sobj->fVal);
      sobj->TObject::ShowMembers(R__insp, R__parent);
   }

}

template <> void TParameter<int>::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
   ::ROOT::TParameterlEintgR_ShowMembers(this, R__insp, R__parent);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TParameterlEintgR(void *p) {
      return  p ? new(p) ::TParameter<int> : new ::TParameter<int>;
   }
   static void *newArray_TParameterlEintgR(Long_t nElements, void *p) {
      return p ? new(p) ::TParameter<int>[nElements] : new ::TParameter<int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_TParameterlEintgR(void *p) {
      delete ((::TParameter<int>*)p);
   }
   static void deleteArray_TParameterlEintgR(void *p) {
      delete [] ((::TParameter<int>*)p);
   }
   static void destruct_TParameterlEintgR(void *p) {
      typedef ::TParameter<int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TParameter<int>

//______________________________________________________________________________
template <> void TParameter<long>::Streamer(TBuffer &R__b)
{
   // Stream an object of class TParameter<long>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TParameter<long>::Class(),this);
   } else {
      R__b.WriteClassBuffer(TParameter<long>::Class(),this);
   }
}

//______________________________________________________________________________
namespace ROOT {
   void TParameterlElonggR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class TParameter<long>.
      typedef ::ROOT::Shadow::TParameterlElonggR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<long>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fName", &sobj->fName);
      sobj->fName.ShowMembers(R__insp, strcat(R__parent,"fName.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fVal", &sobj->fVal);
      sobj->TObject::ShowMembers(R__insp, R__parent);
   }

}

template <> void TParameter<long>::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
   ::ROOT::TParameterlElonggR_ShowMembers(this, R__insp, R__parent);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TParameterlElonggR(void *p) {
      return  p ? new(p) ::TParameter<long> : new ::TParameter<long>;
   }
   static void *newArray_TParameterlElonggR(Long_t nElements, void *p) {
      return p ? new(p) ::TParameter<long>[nElements] : new ::TParameter<long>[nElements];
   }
   // Wrapper around operator delete
   static void delete_TParameterlElonggR(void *p) {
      delete ((::TParameter<long>*)p);
   }
   static void deleteArray_TParameterlElonggR(void *p) {
      delete [] ((::TParameter<long>*)p);
   }
   static void destruct_TParameterlElonggR(void *p) {
      typedef ::TParameter<long> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TParameter<long>

//______________________________________________________________________________
template <> void TParameter<long long>::Streamer(TBuffer &R__b)
{
   // Stream an object of class TParameter<long long>.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(TParameter<long long>::Class(),this);
   } else {
      R__b.WriteClassBuffer(TParameter<long long>::Class(),this);
   }
}

//______________________________________________________________________________
namespace ROOT {
   void TParameterlELong64_tgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class TParameter<long long>.
      typedef ::ROOT::Shadow::TParameterlElongsPlonggR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TParameter<long long>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fName", &sobj->fName);
      sobj->fName.ShowMembers(R__insp, strcat(R__parent,"fName.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fVal", &sobj->fVal);
      sobj->TObject::ShowMembers(R__insp, R__parent);
   }

}

template <> void TParameter<long long>::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
   ::ROOT::TParameterlELong64_tgR_ShowMembers(this, R__insp, R__parent);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TParameterlELong64_tgR(void *p) {
      return  p ? new(p) ::TParameter<Long64_t> : new ::TParameter<Long64_t>;
   }
   static void *newArray_TParameterlELong64_tgR(Long_t nElements, void *p) {
      return p ? new(p) ::TParameter<Long64_t>[nElements] : new ::TParameter<Long64_t>[nElements];
   }
   // Wrapper around operator delete
   static void delete_TParameterlELong64_tgR(void *p) {
      delete ((::TParameter<Long64_t>*)p);
   }
   static void deleteArray_TParameterlELong64_tgR(void *p) {
      delete [] ((::TParameter<Long64_t>*)p);
   }
   static void destruct_TParameterlELong64_tgR(void *p) {
      typedef ::TParameter<Long64_t> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TParameter<Long64_t>

namespace ROOT {
   // Wrappers around operator new
   static void *new_SetWindowAttributes_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SetWindowAttributes_t : new ::SetWindowAttributes_t;
   }
   static void *newArray_SetWindowAttributes_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::SetWindowAttributes_t[nElements] : new ::SetWindowAttributes_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_SetWindowAttributes_t(void *p) {
      delete ((::SetWindowAttributes_t*)p);
   }
   static void deleteArray_SetWindowAttributes_t(void *p) {
      delete [] ((::SetWindowAttributes_t*)p);
   }
   static void destruct_SetWindowAttributes_t(void *p) {
      typedef ::SetWindowAttributes_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::SetWindowAttributes_t

namespace ROOT {
   // Wrappers around operator new
   static void *new_WindowAttributes_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::WindowAttributes_t : new ::WindowAttributes_t;
   }
   static void *newArray_WindowAttributes_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::WindowAttributes_t[nElements] : new ::WindowAttributes_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_WindowAttributes_t(void *p) {
      delete ((::WindowAttributes_t*)p);
   }
   static void deleteArray_WindowAttributes_t(void *p) {
      delete [] ((::WindowAttributes_t*)p);
   }
   static void destruct_WindowAttributes_t(void *p) {
      typedef ::WindowAttributes_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::WindowAttributes_t

namespace ROOT {
   // Wrappers around operator new
   static void *new_Event_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Event_t : new ::Event_t;
   }
   static void *newArray_Event_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Event_t[nElements] : new ::Event_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_Event_t(void *p) {
      delete ((::Event_t*)p);
   }
   static void deleteArray_Event_t(void *p) {
      delete [] ((::Event_t*)p);
   }
   static void destruct_Event_t(void *p) {
      typedef ::Event_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Event_t

namespace ROOT {
   // Wrappers around operator new
   static void *new_GCValues_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GCValues_t : new ::GCValues_t;
   }
   static void *newArray_GCValues_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::GCValues_t[nElements] : new ::GCValues_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_GCValues_t(void *p) {
      delete ((::GCValues_t*)p);
   }
   static void deleteArray_GCValues_t(void *p) {
      delete [] ((::GCValues_t*)p);
   }
   static void destruct_GCValues_t(void *p) {
      typedef ::GCValues_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::GCValues_t

namespace ROOT {
   // Wrappers around operator new
   static void *new_ColorStruct_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ColorStruct_t : new ::ColorStruct_t;
   }
   static void *newArray_ColorStruct_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ColorStruct_t[nElements] : new ::ColorStruct_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_ColorStruct_t(void *p) {
      delete ((::ColorStruct_t*)p);
   }
   static void deleteArray_ColorStruct_t(void *p) {
      delete [] ((::ColorStruct_t*)p);
   }
   static void destruct_ColorStruct_t(void *p) {
      typedef ::ColorStruct_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ColorStruct_t

namespace ROOT {
   // Wrappers around operator new
   static void *new_PictureAttributes_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PictureAttributes_t : new ::PictureAttributes_t;
   }
   static void *newArray_PictureAttributes_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::PictureAttributes_t[nElements] : new ::PictureAttributes_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_PictureAttributes_t(void *p) {
      delete ((::PictureAttributes_t*)p);
   }
   static void deleteArray_PictureAttributes_t(void *p) {
      delete [] ((::PictureAttributes_t*)p);
   }
   static void destruct_PictureAttributes_t(void *p) {
      typedef ::PictureAttributes_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::PictureAttributes_t

namespace ROOT {
   // Wrappers around operator new
   static void *new_Segment_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Segment_t : new ::Segment_t;
   }
   static void *newArray_Segment_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Segment_t[nElements] : new ::Segment_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_Segment_t(void *p) {
      delete ((::Segment_t*)p);
   }
   static void deleteArray_Segment_t(void *p) {
      delete [] ((::Segment_t*)p);
   }
   static void destruct_Segment_t(void *p) {
      typedef ::Segment_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Segment_t

namespace ROOT {
   // Wrappers around operator new
   static void *new_Point_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Point_t : new ::Point_t;
   }
   static void *newArray_Point_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Point_t[nElements] : new ::Point_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_Point_t(void *p) {
      delete ((::Point_t*)p);
   }
   static void deleteArray_Point_t(void *p) {
      delete [] ((::Point_t*)p);
   }
   static void destruct_Point_t(void *p) {
      typedef ::Point_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Point_t

namespace ROOT {
   // Wrappers around operator new
   static void *new_Rectangle_t(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Rectangle_t : new ::Rectangle_t;
   }
   static void *newArray_Rectangle_t(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Rectangle_t[nElements] : new ::Rectangle_t[nElements];
   }
   // Wrapper around operator delete
   static void delete_Rectangle_t(void *p) {
      delete ((::Rectangle_t*)p);
   }
   static void deleteArray_Rectangle_t(void *p) {
      delete [] ((::Rectangle_t*)p);
   }
   static void destruct_Rectangle_t(void *p) {
      typedef ::Rectangle_t current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Rectangle_t

namespace ROOT {
   // Wrappers around operator new
   static void *new_timespec(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::timespec : new ::timespec;
   }
   static void *newArray_timespec(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::timespec[nElements] : new ::timespec[nElements];
   }
   // Wrapper around operator delete
   static void delete_timespec(void *p) {
      delete ((::timespec*)p);
   }
   static void deleteArray_timespec(void *p) {
      delete [] ((::timespec*)p);
   }
   static void destruct_timespec(void *p) {
      typedef ::timespec current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::timespec

namespace ROOT {
   void vectorlETStringgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void vectorlETStringgR_Dictionary();
   static void *new_vectorlETStringgR(void *p = 0);
   static void *newArray_vectorlETStringgR(Long_t size, void *p);
   static void delete_vectorlETStringgR(void *p);
   static void deleteArray_vectorlETStringgR(void *p);
   static void destruct_vectorlETStringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<TString>*)
   {
      vector<TString> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<TString>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<TString>", -2, "prec_stl/vector", 49,
                  typeid(vector<TString>), DefineBehavior(ptr, ptr),
                  0, &vectorlETStringgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<TString>) );
      instance.SetNew(&new_vectorlETStringgR);
      instance.SetNewArray(&newArray_vectorlETStringgR);
      instance.SetDelete(&delete_vectorlETStringgR);
      instance.SetDeleteArray(&deleteArray_vectorlETStringgR);
      instance.SetDestructor(&destruct_vectorlETStringgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<TString> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<TString>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETStringgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<TString>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETStringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TString> : new vector<TString>;
   }
   static void *newArray_vectorlETStringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TString>[nElements] : new vector<TString>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETStringgR(void *p) {
      delete ((vector<TString>*)p);
   }
   static void deleteArray_vectorlETStringgR(void *p) {
      delete [] ((vector<TString>*)p);
   }
   static void destruct_vectorlETStringgR(void *p) {
      typedef vector<TString> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TString>

namespace ROOT {
   void vectorlEunsignedsPintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void vectorlEunsignedsPintgR_Dictionary();
   static void *new_vectorlEunsignedsPintgR(void *p = 0);
   static void *newArray_vectorlEunsignedsPintgR(Long_t size, void *p);
   static void delete_vectorlEunsignedsPintgR(void *p);
   static void deleteArray_vectorlEunsignedsPintgR(void *p);
   static void destruct_vectorlEunsignedsPintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<unsigned int>*)
   {
      vector<unsigned int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<unsigned int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<unsigned int>", -2, "prec_stl/vector", 49,
                  typeid(vector<unsigned int>), DefineBehavior(ptr, ptr),
                  0, &vectorlEunsignedsPintgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<unsigned int>) );
      instance.SetNew(&new_vectorlEunsignedsPintgR);
      instance.SetNewArray(&newArray_vectorlEunsignedsPintgR);
      instance.SetDelete(&delete_vectorlEunsignedsPintgR);
      instance.SetDeleteArray(&deleteArray_vectorlEunsignedsPintgR);
      instance.SetDestructor(&destruct_vectorlEunsignedsPintgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<unsigned int> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<unsigned int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEunsignedsPintgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<unsigned int>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEunsignedsPintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<unsigned int> : new vector<unsigned int>;
   }
   static void *newArray_vectorlEunsignedsPintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<unsigned int>[nElements] : new vector<unsigned int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEunsignedsPintgR(void *p) {
      delete ((vector<unsigned int>*)p);
   }
   static void deleteArray_vectorlEunsignedsPintgR(void *p) {
      delete [] ((vector<unsigned int>*)p);
   }
   static void destruct_vectorlEunsignedsPintgR(void *p) {
      typedef vector<unsigned int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<unsigned int>

/********************************************************
* core/base/src/G__Base3.cxx
* CAUTION: DON'T CHANGE THIS FILE. THIS FILE IS AUTOMATICALLY GENERATED
*          FROM HEADER FILES LISTED IN G__setup_cpp_environmentXXX().
*          CHANGE THOSE HEADER FILES AND REGENERATE THIS FILE.
********************************************************/

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

#if defined(__GNUC__) && __GNUC__ >= 4 && ((__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ >= 1) || (__GNUC_MINOR__ >= 3))
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif

extern "C" void G__cpp_reset_tagtableG__Base3();

extern "C" void G__set_cpp_environmentG__Base3() {
  G__add_compiledheader("TObject.h");
  G__add_compiledheader("TMemberInspector.h");
  G__add_compiledheader("GuiTypes.h");
  G__add_compiledheader("KeySymbols.h");
  G__add_compiledheader("Buttons.h");
  G__add_compiledheader("TTimeStamp.h");
  G__add_compiledheader("TVirtualMutex.h");
  G__add_compiledheader("TVirtualPerfStats.h");
  G__add_compiledheader("TVirtualX.h");
  G__add_compiledheader("TParameter.h");
  G__add_compiledheader("TVirtualAuth.h");
  G__add_compiledheader("TFileInfo.h");
  G__add_compiledheader("TFileCollection.h");
  G__add_compiledheader("TRedirectOutputGuard.h");
  G__add_compiledheader("TVirtualMonitoring.h");
  G__add_compiledheader("TObjectSpy.h");
  G__add_compiledheader("TUri.h");
  G__add_compiledheader("TUrl.h");
  G__add_compiledheader("TInetAddress.h");
  G__add_compiledheader("TVirtualTableInterface.h");
  G__add_compiledheader("TBase64.h");
  G__cpp_reset_tagtableG__Base3();
}
#include <new>
extern "C" int G__cpp_dllrevG__Base3() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* SetWindowAttributes_t */
// automatic default constructor
static int G__G__Base3_99_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SetWindowAttributes_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SetWindowAttributes_t[n];
     } else {
       p = new((void*) gvp) SetWindowAttributes_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new SetWindowAttributes_t;
     } else {
       p = new((void*) gvp) SetWindowAttributes_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_SetWindowAttributes_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_99_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   SetWindowAttributes_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new SetWindowAttributes_t(*(SetWindowAttributes_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_SetWindowAttributes_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef SetWindowAttributes_t G__TSetWindowAttributes_t;
static int G__G__Base3_99_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (SetWindowAttributes_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((SetWindowAttributes_t*) (soff+(sizeof(SetWindowAttributes_t)*i)))->~G__TSetWindowAttributes_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (SetWindowAttributes_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((SetWindowAttributes_t*) (soff))->~G__TSetWindowAttributes_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Base3_99_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   SetWindowAttributes_t* dest = (SetWindowAttributes_t*) G__getstructoffset();
   *dest = *(SetWindowAttributes_t*) libp->para[0].ref;
   const SetWindowAttributes_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* WindowAttributes_t */
// automatic default constructor
static int G__G__Base3_100_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   WindowAttributes_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new WindowAttributes_t[n];
     } else {
       p = new((void*) gvp) WindowAttributes_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new WindowAttributes_t;
     } else {
       p = new((void*) gvp) WindowAttributes_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_WindowAttributes_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_100_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   WindowAttributes_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new WindowAttributes_t(*(WindowAttributes_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_WindowAttributes_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef WindowAttributes_t G__TWindowAttributes_t;
static int G__G__Base3_100_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (WindowAttributes_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((WindowAttributes_t*) (soff+(sizeof(WindowAttributes_t)*i)))->~G__TWindowAttributes_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (WindowAttributes_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((WindowAttributes_t*) (soff))->~G__TWindowAttributes_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Base3_100_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   WindowAttributes_t* dest = (WindowAttributes_t*) G__getstructoffset();
   *dest = *(WindowAttributes_t*) libp->para[0].ref;
   const WindowAttributes_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Event_t */
// automatic default constructor
static int G__G__Base3_101_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Event_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Event_t[n];
     } else {
       p = new((void*) gvp) Event_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Event_t;
     } else {
       p = new((void*) gvp) Event_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_Event_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_101_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Event_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Event_t(*(Event_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_Event_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Event_t G__TEvent_t;
static int G__G__Base3_101_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Event_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Event_t*) (soff+(sizeof(Event_t)*i)))->~G__TEvent_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Event_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Event_t*) (soff))->~G__TEvent_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Base3_101_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Event_t* dest = (Event_t*) G__getstructoffset();
   *dest = *(Event_t*) libp->para[0].ref;
   const Event_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* GCValues_t */
static int G__G__Base3_104_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   GCValues_t* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new GCValues_t[n];
     } else {
       p = new((void*) gvp) GCValues_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new GCValues_t;
     } else {
       p = new((void*) gvp) GCValues_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_GCValues_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_104_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   GCValues_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new GCValues_t(*(GCValues_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_GCValues_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef GCValues_t G__TGCValues_t;
static int G__G__Base3_104_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (GCValues_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((GCValues_t*) (soff+(sizeof(GCValues_t)*i)))->~G__TGCValues_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (GCValues_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((GCValues_t*) (soff))->~G__TGCValues_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Base3_104_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   GCValues_t* dest = (GCValues_t*) G__getstructoffset();
   *dest = *(GCValues_t*) libp->para[0].ref;
   const GCValues_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ColorStruct_t */
// automatic default constructor
static int G__G__Base3_105_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ColorStruct_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ColorStruct_t[n];
     } else {
       p = new((void*) gvp) ColorStruct_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ColorStruct_t;
     } else {
       p = new((void*) gvp) ColorStruct_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_ColorStruct_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_105_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ColorStruct_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ColorStruct_t(*(ColorStruct_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_ColorStruct_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ColorStruct_t G__TColorStruct_t;
static int G__G__Base3_105_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ColorStruct_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ColorStruct_t*) (soff+(sizeof(ColorStruct_t)*i)))->~G__TColorStruct_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ColorStruct_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ColorStruct_t*) (soff))->~G__TColorStruct_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Base3_105_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ColorStruct_t* dest = (ColorStruct_t*) G__getstructoffset();
   *dest = *(ColorStruct_t*) libp->para[0].ref;
   const ColorStruct_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* PictureAttributes_t */
// automatic default constructor
static int G__G__Base3_106_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PictureAttributes_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PictureAttributes_t[n];
     } else {
       p = new((void*) gvp) PictureAttributes_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new PictureAttributes_t;
     } else {
       p = new((void*) gvp) PictureAttributes_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_PictureAttributes_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_106_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   PictureAttributes_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new PictureAttributes_t(*(PictureAttributes_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_PictureAttributes_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef PictureAttributes_t G__TPictureAttributes_t;
static int G__G__Base3_106_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (PictureAttributes_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((PictureAttributes_t*) (soff+(sizeof(PictureAttributes_t)*i)))->~G__TPictureAttributes_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (PictureAttributes_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((PictureAttributes_t*) (soff))->~G__TPictureAttributes_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Base3_106_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   PictureAttributes_t* dest = (PictureAttributes_t*) G__getstructoffset();
   *dest = *(PictureAttributes_t*) libp->para[0].ref;
   const PictureAttributes_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Segment_t */
// automatic default constructor
static int G__G__Base3_108_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Segment_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Segment_t[n];
     } else {
       p = new((void*) gvp) Segment_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Segment_t;
     } else {
       p = new((void*) gvp) Segment_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_Segment_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_108_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Segment_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Segment_t(*(Segment_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_Segment_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Segment_t G__TSegment_t;
static int G__G__Base3_108_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Segment_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Segment_t*) (soff+(sizeof(Segment_t)*i)))->~G__TSegment_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Segment_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Segment_t*) (soff))->~G__TSegment_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Base3_108_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Segment_t* dest = (Segment_t*) G__getstructoffset();
   *dest = *(Segment_t*) libp->para[0].ref;
   const Segment_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Point_t */
// automatic default constructor
static int G__G__Base3_109_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Point_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Point_t[n];
     } else {
       p = new((void*) gvp) Point_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Point_t;
     } else {
       p = new((void*) gvp) Point_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_Point_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_109_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Point_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Point_t(*(Point_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_Point_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Point_t G__TPoint_t;
static int G__G__Base3_109_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Point_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Point_t*) (soff+(sizeof(Point_t)*i)))->~G__TPoint_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Point_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Point_t*) (soff))->~G__TPoint_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Base3_109_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Point_t* dest = (Point_t*) G__getstructoffset();
   *dest = *(Point_t*) libp->para[0].ref;
   const Point_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Rectangle_t */
// automatic default constructor
static int G__G__Base3_110_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Rectangle_t *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Rectangle_t[n];
     } else {
       p = new((void*) gvp) Rectangle_t[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Rectangle_t;
     } else {
       p = new((void*) gvp) Rectangle_t;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_Rectangle_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_110_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Rectangle_t* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Rectangle_t(*(Rectangle_t*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_Rectangle_t));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Rectangle_t G__TRectangle_t;
static int G__G__Base3_110_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Rectangle_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Rectangle_t*) (soff+(sizeof(Rectangle_t)*i)))->~G__TRectangle_t();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Rectangle_t*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Rectangle_t*) (soff))->~G__TRectangle_t();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Base3_110_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Rectangle_t* dest = (Rectangle_t*) G__getstructoffset();
   *dest = *(Rectangle_t*) libp->para[0].ref;
   const Rectangle_t& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* timespec */
// automatic default constructor
static int G__G__Base3_118_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   timespec *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new timespec[n];
     } else {
       p = new((void*) gvp) timespec[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new timespec;
     } else {
       p = new((void*) gvp) timespec;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_timespec));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_118_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   timespec* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new timespec(*(timespec*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_timespec));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef timespec G__Ttimespec;
static int G__G__Base3_118_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (timespec*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((timespec*) (soff+(sizeof(timespec)*i)))->~G__Ttimespec();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (timespec*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((timespec*) (soff))->~G__Ttimespec();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Base3_118_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   timespec* dest = (timespec*) G__getstructoffset();
   *dest = *(timespec*) libp->para[0].ref;
   const timespec& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TVirtualMutex */
static int G__G__Base3_119_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TVirtualMutex*) G__getstructoffset())->Lock());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_119_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TVirtualMutex*) G__getstructoffset())->TryLock());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_119_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TVirtualMutex*) G__getstructoffset())->UnLock());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_119_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TVirtualMutex*) G__getstructoffset())->CleanUp());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_119_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TVirtualMutex*) G__getstructoffset())->Acquire());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_119_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TVirtualMutex*) G__getstructoffset())->Release());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_119_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 85, (long) ((TVirtualMutex*) G__getstructoffset())->Factory((Bool_t) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 85, (long) ((TVirtualMutex*) G__getstructoffset())->Factory());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_119_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TVirtualMutex::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_119_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualMutex::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_119_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TVirtualMutex::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_119_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TVirtualMutex::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_119_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualMutex*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_119_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualMutex::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_119_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TVirtualMutex::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_119_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualMutex::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_119_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TVirtualMutex::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TVirtualMutex G__TTVirtualMutex;
static int G__G__Base3_119_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TVirtualMutex*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TVirtualMutex*) (soff+(sizeof(TVirtualMutex)*i)))->~G__TTVirtualMutex();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TVirtualMutex*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TVirtualMutex*) (soff))->~G__TTVirtualMutex();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Base3_119_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TVirtualMutex* dest = (TVirtualMutex*) G__getstructoffset();
   *dest = *(TVirtualMutex*) libp->para[0].ref;
   const TVirtualMutex& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TTimeStamp */
static int G__G__Base3_120_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TTimeStamp* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TTimeStamp[n];
     } else {
       p = new((void*) gvp) TTimeStamp[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TTimeStamp;
     } else {
       p = new((void*) gvp) TTimeStamp;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TTimeStamp));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TTimeStamp* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TTimeStamp(*(timespec_t*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) TTimeStamp(*(timespec_t*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TTimeStamp));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TTimeStamp* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TTimeStamp((time_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1]));
   } else {
     p = new((void*) gvp) TTimeStamp((time_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TTimeStamp));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TTimeStamp* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 9:
     //m: 9
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TTimeStamp(
(UInt_t) G__int(libp->para[0]), (UInt_t) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (UInt_t) G__int(libp->para[3])
, (UInt_t) G__int(libp->para[4]), (UInt_t) G__int(libp->para[5])
, (UInt_t) G__int(libp->para[6]), (Bool_t) G__int(libp->para[7])
, (Int_t) G__int(libp->para[8]));
     } else {
       p = new((void*) gvp) TTimeStamp(
(UInt_t) G__int(libp->para[0]), (UInt_t) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (UInt_t) G__int(libp->para[3])
, (UInt_t) G__int(libp->para[4]), (UInt_t) G__int(libp->para[5])
, (UInt_t) G__int(libp->para[6]), (Bool_t) G__int(libp->para[7])
, (Int_t) G__int(libp->para[8]));
     }
     break;
   case 8:
     //m: 8
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TTimeStamp(
(UInt_t) G__int(libp->para[0]), (UInt_t) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (UInt_t) G__int(libp->para[3])
, (UInt_t) G__int(libp->para[4]), (UInt_t) G__int(libp->para[5])
, (UInt_t) G__int(libp->para[6]), (Bool_t) G__int(libp->para[7]));
     } else {
       p = new((void*) gvp) TTimeStamp(
(UInt_t) G__int(libp->para[0]), (UInt_t) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (UInt_t) G__int(libp->para[3])
, (UInt_t) G__int(libp->para[4]), (UInt_t) G__int(libp->para[5])
, (UInt_t) G__int(libp->para[6]), (Bool_t) G__int(libp->para[7]));
     }
     break;
   case 7:
     //m: 7
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TTimeStamp(
(UInt_t) G__int(libp->para[0]), (UInt_t) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (UInt_t) G__int(libp->para[3])
, (UInt_t) G__int(libp->para[4]), (UInt_t) G__int(libp->para[5])
, (UInt_t) G__int(libp->para[6]));
     } else {
       p = new((void*) gvp) TTimeStamp(
(UInt_t) G__int(libp->para[0]), (UInt_t) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (UInt_t) G__int(libp->para[3])
, (UInt_t) G__int(libp->para[4]), (UInt_t) G__int(libp->para[5])
, (UInt_t) G__int(libp->para[6]));
     }
     break;
   case 6:
     //m: 6
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TTimeStamp(
(UInt_t) G__int(libp->para[0]), (UInt_t) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (UInt_t) G__int(libp->para[3])
, (UInt_t) G__int(libp->para[4]), (UInt_t) G__int(libp->para[5]));
     } else {
       p = new((void*) gvp) TTimeStamp(
(UInt_t) G__int(libp->para[0]), (UInt_t) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (UInt_t) G__int(libp->para[3])
, (UInt_t) G__int(libp->para[4]), (UInt_t) G__int(libp->para[5]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TTimeStamp));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TTimeStamp* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 5:
     //m: 5
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TTimeStamp(
(UInt_t) G__int(libp->para[0]), (UInt_t) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (Bool_t) G__int(libp->para[3])
, (Int_t) G__int(libp->para[4]));
     } else {
       p = new((void*) gvp) TTimeStamp(
(UInt_t) G__int(libp->para[0]), (UInt_t) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (Bool_t) G__int(libp->para[3])
, (Int_t) G__int(libp->para[4]));
     }
     break;
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TTimeStamp(
(UInt_t) G__int(libp->para[0]), (UInt_t) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (Bool_t) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) TTimeStamp(
(UInt_t) G__int(libp->para[0]), (UInt_t) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]), (Bool_t) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TTimeStamp(
(UInt_t) G__int(libp->para[0]), (UInt_t) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) TTimeStamp(
(UInt_t) G__int(libp->para[0]), (UInt_t) G__int(libp->para[1])
, (UInt_t) G__int(libp->para[2]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TTimeStamp));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TTimeStamp* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TTimeStamp(
(UInt_t) G__int(libp->para[0]), (Bool_t) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2]), (Bool_t) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) TTimeStamp(
(UInt_t) G__int(libp->para[0]), (Bool_t) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2]), (Bool_t) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TTimeStamp(
(UInt_t) G__int(libp->para[0]), (Bool_t) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) TTimeStamp(
(UInt_t) G__int(libp->para[0]), (Bool_t) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TTimeStamp((UInt_t) G__int(libp->para[0]), (Bool_t) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) TTimeStamp((UInt_t) G__int(libp->para[0]), (Bool_t) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TTimeStamp((UInt_t) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) TTimeStamp((UInt_t) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TTimeStamp));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TTimeStamp*) G__getstructoffset())->Set();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TTimeStamp*) G__getstructoffset())->Set(
(Int_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2]), (Int_t) G__int(libp->para[3])
, (Int_t) G__int(libp->para[4]), (Int_t) G__int(libp->para[5])
, (Int_t) G__int(libp->para[6]), (Bool_t) G__int(libp->para[7])
, (Int_t) G__int(libp->para[8]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TTimeStamp*) G__getstructoffset())->Set((Int_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2]), (Bool_t) G__int(libp->para[3])
, (Int_t) G__int(libp->para[4]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TTimeStamp*) G__getstructoffset())->Set((UInt_t) G__int(libp->para[0]), (Bool_t) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2]), (Bool_t) G__int(libp->para[3]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TTimeStamp*) G__getstructoffset())->SetSec((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TTimeStamp*) G__getstructoffset())->SetNanoSec((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const timespec_t* pobj;
         const timespec_t xobj = ((const TTimeStamp*) G__getstructoffset())->GetTimeSpec();
         pobj = new timespec_t(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 108, (long) ((const TTimeStamp*) G__getstructoffset())->GetSec());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TTimeStamp*) G__getstructoffset())->GetNanoSec());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const TTimeStamp*) G__getstructoffset())->AsDouble());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const TTimeStamp*) G__getstructoffset())->AsJulianDate());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 67, (long) ((const TTimeStamp*) G__getstructoffset())->AsString((Option_t*) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 67, (long) ((const TTimeStamp*) G__getstructoffset())->AsString());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const TTimeStamp*) G__getstructoffset())->Copy(*(TTimeStamp*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      G__letint(result7, 104, (long) ((const TTimeStamp*) G__getstructoffset())->GetDate((Bool_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])
, (UInt_t*) G__int(libp->para[2]), (UInt_t*) G__int(libp->para[3])
, (UInt_t*) G__int(libp->para[4])));
      break;
   case 4:
      G__letint(result7, 104, (long) ((const TTimeStamp*) G__getstructoffset())->GetDate((Bool_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])
, (UInt_t*) G__int(libp->para[2]), (UInt_t*) G__int(libp->para[3])));
      break;
   case 3:
      G__letint(result7, 104, (long) ((const TTimeStamp*) G__getstructoffset())->GetDate((Bool_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])
, (UInt_t*) G__int(libp->para[2])));
      break;
   case 2:
      G__letint(result7, 104, (long) ((const TTimeStamp*) G__getstructoffset())->GetDate((Bool_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 104, (long) ((const TTimeStamp*) G__getstructoffset())->GetDate((Bool_t) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 104, (long) ((const TTimeStamp*) G__getstructoffset())->GetDate());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      G__letint(result7, 104, (long) ((const TTimeStamp*) G__getstructoffset())->GetTime((Bool_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])
, (UInt_t*) G__int(libp->para[2]), (UInt_t*) G__int(libp->para[3])
, (UInt_t*) G__int(libp->para[4])));
      break;
   case 4:
      G__letint(result7, 104, (long) ((const TTimeStamp*) G__getstructoffset())->GetTime((Bool_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])
, (UInt_t*) G__int(libp->para[2]), (UInt_t*) G__int(libp->para[3])));
      break;
   case 3:
      G__letint(result7, 104, (long) ((const TTimeStamp*) G__getstructoffset())->GetTime((Bool_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])
, (UInt_t*) G__int(libp->para[2])));
      break;
   case 2:
      G__letint(result7, 104, (long) ((const TTimeStamp*) G__getstructoffset())->GetTime((Bool_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 104, (long) ((const TTimeStamp*) G__getstructoffset())->GetTime((Bool_t) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 104, (long) ((const TTimeStamp*) G__getstructoffset())->GetTime());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 105, (long) ((const TTimeStamp*) G__getstructoffset())->GetDayOfYear((Bool_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 105, (long) ((const TTimeStamp*) G__getstructoffset())->GetDayOfYear((Bool_t) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 105, (long) ((const TTimeStamp*) G__getstructoffset())->GetDayOfYear());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 105, (long) ((const TTimeStamp*) G__getstructoffset())->GetDayOfWeek((Bool_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 105, (long) ((const TTimeStamp*) G__getstructoffset())->GetDayOfWeek((Bool_t) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 105, (long) ((const TTimeStamp*) G__getstructoffset())->GetDayOfWeek());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 105, (long) ((const TTimeStamp*) G__getstructoffset())->GetMonth((Bool_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 105, (long) ((const TTimeStamp*) G__getstructoffset())->GetMonth((Bool_t) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 105, (long) ((const TTimeStamp*) G__getstructoffset())->GetMonth());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 105, (long) ((const TTimeStamp*) G__getstructoffset())->GetWeek((Bool_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 105, (long) ((const TTimeStamp*) G__getstructoffset())->GetWeek((Bool_t) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 105, (long) ((const TTimeStamp*) G__getstructoffset())->GetWeek());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 103, (long) ((const TTimeStamp*) G__getstructoffset())->IsLeapYear((Bool_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 103, (long) ((const TTimeStamp*) G__getstructoffset())->IsLeapYear((Bool_t) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 103, (long) ((const TTimeStamp*) G__getstructoffset())->IsLeapYear());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TTimeStamp*) G__getstructoffset())->Add(*(TTimeStamp*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((const TTimeStamp*) G__getstructoffset())->Print((Option_t*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      ((const TTimeStamp*) G__getstructoffset())->Print();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const TTimeStamp*) G__getstructoffset())->operator double());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TTimeStamp::GetZoneOffset());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 108, (long) TTimeStamp::MktimeFromUTC((tm_t*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TTimeStamp::DumpTMStruct(*(tm_t*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TTimeStamp::GetDayOfYear((Int_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TTimeStamp::GetDayOfWeek((Int_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TTimeStamp::GetWeek((Int_t) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) TTimeStamp::IsLeapYear((Int_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TTimeStamp::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TTimeStamp::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TTimeStamp::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TTimeStamp::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_42(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const TTimeStamp*) G__getstructoffset())->IsA());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_43(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TTimeStamp*) G__getstructoffset())->ShowMembers(*(TMemberInspector*) libp->para[0].ref, (char*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_44(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TTimeStamp*) G__getstructoffset())->Streamer(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_45(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TTimeStamp*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_46(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TTimeStamp::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_47(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TTimeStamp::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_48(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TTimeStamp::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_120_0_49(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TTimeStamp::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_120_0_50(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TTimeStamp* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TTimeStamp(*(TTimeStamp*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TTimeStamp));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TTimeStamp G__TTTimeStamp;
static int G__G__Base3_120_0_51(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TTimeStamp*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TTimeStamp*) (soff+(sizeof(TTimeStamp)*i)))->~G__TTTimeStamp();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TTimeStamp*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TTimeStamp*) (soff))->~G__TTTimeStamp();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Base3_120_0_52(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TTimeStamp* dest = (TTimeStamp*) G__getstructoffset();
   *dest = *(TTimeStamp*) libp->para[0].ref;
   const TTimeStamp& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TLockGuard */
static int G__G__Base3_121_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TLockGuard* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TLockGuard((TVirtualMutex*) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) TLockGuard((TVirtualMutex*) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TLockGuard));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_121_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TLockGuard::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_121_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TLockGuard::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_121_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TLockGuard::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_121_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TLockGuard::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_121_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const TLockGuard*) G__getstructoffset())->IsA());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_121_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TLockGuard*) G__getstructoffset())->ShowMembers(*(TMemberInspector*) libp->para[0].ref, (char*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_121_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TLockGuard*) G__getstructoffset())->Streamer(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_121_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TLockGuard*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_121_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TLockGuard::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_121_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TLockGuard::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_121_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TLockGuard::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_121_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TLockGuard::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TLockGuard G__TTLockGuard;
static int G__G__Base3_121_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TLockGuard*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TLockGuard*) (soff+(sizeof(TLockGuard)*i)))->~G__TTLockGuard();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TLockGuard*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TLockGuard*) (soff))->~G__TTLockGuard();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TVirtualPerfStats */
static int G__G__Base3_123_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualPerfStats*) G__getstructoffset())->SimpleEvent((TVirtualPerfStats::EEventType) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_123_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualPerfStats*) G__getstructoffset())->PacketEvent(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (Long64_t) G__Longlong(libp->para[3])
, (Double_t) G__double(libp->para[4]), (Double_t) G__double(libp->para[5])
, (Double_t) G__double(libp->para[6]), (Long64_t) G__Longlong(libp->para[7]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_123_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualPerfStats*) G__getstructoffset())->FileEvent((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (const char*) G__int(libp->para[3])
, (Bool_t) G__int(libp->para[4]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_123_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualPerfStats*) G__getstructoffset())->FileOpenEvent((TFile*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (Double_t) G__double(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_123_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualPerfStats*) G__getstructoffset())->FileReadEvent((TFile*) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])
, (Double_t) G__double(libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_123_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualPerfStats*) G__getstructoffset())->RateEvent((Double_t) G__double(libp->para[0]), (Double_t) G__double(libp->para[1])
, (Long64_t) G__Longlong(libp->para[2]), (Long64_t) G__Longlong(libp->para[3]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_123_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualPerfStats*) G__getstructoffset())->SetBytesRead((Long64_t) G__Longlong(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_123_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letLonglong(result7, 110, (G__int64) ((const TVirtualPerfStats*) G__getstructoffset())->GetBytesRead());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_123_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualPerfStats*) G__getstructoffset())->SetNumEvents((Long64_t) G__Longlong(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_123_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letLonglong(result7, 110, (G__int64) ((const TVirtualPerfStats*) G__getstructoffset())->GetNumEvents());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_123_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualPerfStats::EventType((TVirtualPerfStats::EEventType) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_123_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TVirtualPerfStats::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_123_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualPerfStats::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_123_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TVirtualPerfStats::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_123_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TVirtualPerfStats::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_123_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualPerfStats*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_123_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualPerfStats::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_123_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TVirtualPerfStats::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_123_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualPerfStats::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_123_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TVirtualPerfStats::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TVirtualPerfStats G__TTVirtualPerfStats;
static int G__G__Base3_123_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TVirtualPerfStats*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TVirtualPerfStats*) (soff+(sizeof(TVirtualPerfStats)*i)))->~G__TTVirtualPerfStats();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TVirtualPerfStats*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TVirtualPerfStats*) (soff))->~G__TTVirtualPerfStats();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Base3_123_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TVirtualPerfStats* dest = (TVirtualPerfStats*) G__getstructoffset();
   *dest = *(TVirtualPerfStats*) libp->para[0].ref;
   const TVirtualPerfStats& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TVirtualAuth */
static int G__G__Base3_152_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((TVirtualAuth*) G__getstructoffset())->Authenticate((TSocket*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (Option_t*) G__int(libp->para[3])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_152_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TVirtualAuth*) G__getstructoffset())->ClientVersion());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_152_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualAuth*) G__getstructoffset())->ErrorMsg((const char*) G__int(libp->para[0]), (Int_t) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_152_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((TVirtualAuth*) G__getstructoffset())->Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_152_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TVirtualAuth::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_152_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualAuth::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_152_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TVirtualAuth::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_152_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TVirtualAuth::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_152_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const TVirtualAuth*) G__getstructoffset())->IsA());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_152_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualAuth*) G__getstructoffset())->ShowMembers(*(TMemberInspector*) libp->para[0].ref, (char*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_152_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualAuth*) G__getstructoffset())->Streamer(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_152_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualAuth*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_152_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualAuth::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_152_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TVirtualAuth::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_152_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualAuth::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_152_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TVirtualAuth::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TVirtualAuth G__TTVirtualAuth;
static int G__G__Base3_152_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TVirtualAuth*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TVirtualAuth*) (soff+(sizeof(TVirtualAuth)*i)))->~G__TTVirtualAuth();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TVirtualAuth*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TVirtualAuth*) (soff))->~G__TTVirtualAuth();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Base3_152_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TVirtualAuth* dest = (TVirtualAuth*) G__getstructoffset();
   *dest = *(TVirtualAuth*) libp->para[0].ref;
   const TVirtualAuth& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TUrl */
static int G__G__Base3_167_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TUrl* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TUrl[n];
     } else {
       p = new((void*) gvp) TUrl[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TUrl;
     } else {
       p = new((void*) gvp) TUrl;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TUrl));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TUrl* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TUrl((const char*) G__int(libp->para[0]), (Bool_t) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) TUrl((const char*) G__int(libp->para[0]), (Bool_t) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TUrl((const char*) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) TUrl((const char*) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TUrl));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TUrl* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TUrl(*(TUrl*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) TUrl(*(TUrl*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TUrl));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TUrl& obj = ((TUrl*) G__getstructoffset())->operator=(*(TUrl*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 67, (long) ((TUrl*) G__getstructoffset())->GetUrl((Bool_t) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 67, (long) ((TUrl*) G__getstructoffset())->GetUrl());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const TUrl*) G__getstructoffset())->GetProtocol());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const TUrl*) G__getstructoffset())->GetUser());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const TUrl*) G__getstructoffset())->GetPasswd());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const TUrl*) G__getstructoffset())->GetHost());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const TUrl*) G__getstructoffset())->GetHostFQDN());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const TUrl*) G__getstructoffset())->GetFile());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const TUrl*) G__getstructoffset())->GetAnchor());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const TUrl*) G__getstructoffset())->GetOptions());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const TUrl*) G__getstructoffset())->GetValueFromOptions((const char*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TUrl*) G__getstructoffset())->GetIntValueFromOptions((const char*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const TUrl*) G__getstructoffset())->ParseOptions();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TUrl*) G__getstructoffset())->CleanRelativePath();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const TUrl*) G__getstructoffset())->GetFileAndOptions());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TUrl*) G__getstructoffset())->GetPort());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TUrl*) G__getstructoffset())->IsValid());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((TUrl*) G__getstructoffset())->SetProtocol((const char*) G__int(libp->para[0]), (Bool_t) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((TUrl*) G__getstructoffset())->SetProtocol((const char*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TUrl*) G__getstructoffset())->SetUser((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TUrl*) G__getstructoffset())->SetPasswd((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TUrl*) G__getstructoffset())->SetHost((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TUrl*) G__getstructoffset())->SetFile((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TUrl*) G__getstructoffset())->SetAnchor((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TUrl*) G__getstructoffset())->SetOptions((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TUrl*) G__getstructoffset())->SetPort((Int_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((TUrl*) G__getstructoffset())->SetUrl((const char*) G__int(libp->para[0]), (Bool_t) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((TUrl*) G__getstructoffset())->SetUrl((const char*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TUrl::GetSpecialProtocols());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TUrl::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TUrl::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TUrl::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TUrl::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_42(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TUrl*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_43(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TUrl::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_44(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TUrl::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_45(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TUrl::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_167_0_46(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TUrl::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TUrl G__TTUrl;
static int G__G__Base3_167_0_47(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TUrl*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TUrl*) (soff+(sizeof(TUrl)*i)))->~G__TTUrl();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TUrl*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TUrl*) (soff))->~G__TTUrl();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TInetAddress */
static int G__G__Base3_168_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TInetAddress* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TInetAddress[n];
     } else {
       p = new((void*) gvp) TInetAddress[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TInetAddress;
     } else {
       p = new((void*) gvp) TInetAddress;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TInetAddress));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_168_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TInetAddress* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TInetAddress(*(TInetAddress*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) TInetAddress(*(TInetAddress*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TInetAddress));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_168_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TInetAddress& obj = ((TInetAddress*) G__getstructoffset())->operator=(*(TInetAddress*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_168_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const TInetAddress*) G__getstructoffset())->GetAddress());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_168_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 66, (long) ((const TInetAddress*) G__getstructoffset())->GetAddressBytes());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_168_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const TInetAddress*) G__getstructoffset())->GetHostAddress());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_168_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const TInetAddress*) G__getstructoffset())->GetHostName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_168_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TInetAddress*) G__getstructoffset())->GetFamily());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_168_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TInetAddress*) G__getstructoffset())->GetPort());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_168_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TInetAddress::AddressList_t& obj = ((const TInetAddress*) G__getstructoffset())->GetAddresses();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_168_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TInetAddress::AliasList_t& obj = ((const TInetAddress*) G__getstructoffset())->GetAliases();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_168_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TInetAddress*) G__getstructoffset())->IsValid());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_168_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TInetAddress::GetHostAddress((UInt_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_168_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TInetAddress::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_168_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TInetAddress::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_168_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TInetAddress::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_168_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TInetAddress::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_168_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TInetAddress*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_168_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TInetAddress::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_168_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TInetAddress::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_168_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TInetAddress::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_168_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TInetAddress::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TInetAddress G__TTInetAddress;
static int G__G__Base3_168_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TInetAddress*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TInetAddress*) (soff+(sizeof(TInetAddress)*i)))->~G__TTInetAddress();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TInetAddress*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TInetAddress*) (soff))->~G__TTInetAddress();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TFileInfoMeta */
static int G__G__Base3_177_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TFileInfoMeta* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileInfoMeta[n];
     } else {
       p = new((void*) gvp) TFileInfoMeta[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileInfoMeta;
     } else {
       p = new((void*) gvp) TFileInfoMeta;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TFileInfoMeta));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TFileInfoMeta* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 7:
     //m: 7
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileInfoMeta(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (Long64_t) G__Longlong(libp->para[2]), (Long64_t) G__Longlong(libp->para[3])
, (Long64_t) G__Longlong(libp->para[4]), (Long64_t) G__Longlong(libp->para[5])
, (Long64_t) G__Longlong(libp->para[6]));
     } else {
       p = new((void*) gvp) TFileInfoMeta(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (Long64_t) G__Longlong(libp->para[2]), (Long64_t) G__Longlong(libp->para[3])
, (Long64_t) G__Longlong(libp->para[4]), (Long64_t) G__Longlong(libp->para[5])
, (Long64_t) G__Longlong(libp->para[6]));
     }
     break;
   case 6:
     //m: 6
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileInfoMeta(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (Long64_t) G__Longlong(libp->para[2]), (Long64_t) G__Longlong(libp->para[3])
, (Long64_t) G__Longlong(libp->para[4]), (Long64_t) G__Longlong(libp->para[5]));
     } else {
       p = new((void*) gvp) TFileInfoMeta(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (Long64_t) G__Longlong(libp->para[2]), (Long64_t) G__Longlong(libp->para[3])
, (Long64_t) G__Longlong(libp->para[4]), (Long64_t) G__Longlong(libp->para[5]));
     }
     break;
   case 5:
     //m: 5
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileInfoMeta(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (Long64_t) G__Longlong(libp->para[2]), (Long64_t) G__Longlong(libp->para[3])
, (Long64_t) G__Longlong(libp->para[4]));
     } else {
       p = new((void*) gvp) TFileInfoMeta(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (Long64_t) G__Longlong(libp->para[2]), (Long64_t) G__Longlong(libp->para[3])
, (Long64_t) G__Longlong(libp->para[4]));
     }
     break;
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileInfoMeta(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (Long64_t) G__Longlong(libp->para[2]), (Long64_t) G__Longlong(libp->para[3]));
     } else {
       p = new((void*) gvp) TFileInfoMeta(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (Long64_t) G__Longlong(libp->para[2]), (Long64_t) G__Longlong(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileInfoMeta(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (Long64_t) G__Longlong(libp->para[2]));
     } else {
       p = new((void*) gvp) TFileInfoMeta(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (Long64_t) G__Longlong(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileInfoMeta((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) TFileInfoMeta((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileInfoMeta((const char*) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) TFileInfoMeta((const char*) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TFileInfoMeta));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TFileInfoMeta* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 8:
     //m: 8
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileInfoMeta(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (Long64_t) G__Longlong(libp->para[3])
, (Long64_t) G__Longlong(libp->para[4]), (Long64_t) G__Longlong(libp->para[5])
, (Long64_t) G__Longlong(libp->para[6]), (Long64_t) G__Longlong(libp->para[7]));
     } else {
       p = new((void*) gvp) TFileInfoMeta(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (Long64_t) G__Longlong(libp->para[3])
, (Long64_t) G__Longlong(libp->para[4]), (Long64_t) G__Longlong(libp->para[5])
, (Long64_t) G__Longlong(libp->para[6]), (Long64_t) G__Longlong(libp->para[7]));
     }
     break;
   case 7:
     //m: 7
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileInfoMeta(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (Long64_t) G__Longlong(libp->para[3])
, (Long64_t) G__Longlong(libp->para[4]), (Long64_t) G__Longlong(libp->para[5])
, (Long64_t) G__Longlong(libp->para[6]));
     } else {
       p = new((void*) gvp) TFileInfoMeta(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (Long64_t) G__Longlong(libp->para[3])
, (Long64_t) G__Longlong(libp->para[4]), (Long64_t) G__Longlong(libp->para[5])
, (Long64_t) G__Longlong(libp->para[6]));
     }
     break;
   case 6:
     //m: 6
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileInfoMeta(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (Long64_t) G__Longlong(libp->para[3])
, (Long64_t) G__Longlong(libp->para[4]), (Long64_t) G__Longlong(libp->para[5]));
     } else {
       p = new((void*) gvp) TFileInfoMeta(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (Long64_t) G__Longlong(libp->para[3])
, (Long64_t) G__Longlong(libp->para[4]), (Long64_t) G__Longlong(libp->para[5]));
     }
     break;
   case 5:
     //m: 5
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileInfoMeta(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (Long64_t) G__Longlong(libp->para[3])
, (Long64_t) G__Longlong(libp->para[4]));
     } else {
       p = new((void*) gvp) TFileInfoMeta(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (Long64_t) G__Longlong(libp->para[3])
, (Long64_t) G__Longlong(libp->para[4]));
     }
     break;
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileInfoMeta(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (Long64_t) G__Longlong(libp->para[3]));
     } else {
       p = new((void*) gvp) TFileInfoMeta(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (Long64_t) G__Longlong(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileInfoMeta(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) TFileInfoMeta(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TFileInfoMeta));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TFileInfoMeta* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TFileInfoMeta(*(TFileInfoMeta*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) TFileInfoMeta(*(TFileInfoMeta*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TFileInfoMeta));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const TFileInfoMeta*) G__getstructoffset())->GetObject());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const TFileInfoMeta*) G__getstructoffset())->GetClass());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const TFileInfoMeta*) G__getstructoffset())->GetDirectory());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letLonglong(result7, 110, (G__int64) ((const TFileInfoMeta*) G__getstructoffset())->GetEntries());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letLonglong(result7, 110, (G__int64) ((const TFileInfoMeta*) G__getstructoffset())->GetFirst());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letLonglong(result7, 110, (G__int64) ((const TFileInfoMeta*) G__getstructoffset())->GetLast());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TFileInfoMeta*) G__getstructoffset())->IsTree());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letLonglong(result7, 110, (G__int64) ((const TFileInfoMeta*) G__getstructoffset())->GetTotBytes());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letLonglong(result7, 110, (G__int64) ((const TFileInfoMeta*) G__getstructoffset())->GetZipBytes());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TFileInfoMeta*) G__getstructoffset())->SetEntries((Long64_t) G__Longlong(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TFileInfoMeta*) G__getstructoffset())->SetFirst((Long64_t) G__Longlong(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TFileInfoMeta*) G__getstructoffset())->SetLast((Long64_t) G__Longlong(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TFileInfoMeta*) G__getstructoffset())->SetTotBytes((Long64_t) G__Longlong(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TFileInfoMeta*) G__getstructoffset())->SetZipBytes((Long64_t) G__Longlong(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TFileInfoMeta::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TFileInfoMeta::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TFileInfoMeta::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TFileInfoMeta::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TFileInfoMeta*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TFileInfoMeta::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TFileInfoMeta::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TFileInfoMeta::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_177_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TFileInfoMeta::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TFileInfoMeta G__TTFileInfoMeta;
static int G__G__Base3_177_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TFileInfoMeta*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TFileInfoMeta*) (soff+(sizeof(TFileInfoMeta)*i)))->~G__TTFileInfoMeta();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TFileInfoMeta*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TFileInfoMeta*) (soff))->~G__TTFileInfoMeta();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TFileInfo */
static int G__G__Base3_178_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TFileInfo* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 5:
     //m: 5
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileInfo(
(const char*) G__int(libp->para[0]), (Long64_t) G__Longlong(libp->para[1])
, (const char*) G__int(libp->para[2]), (const char*) G__int(libp->para[3])
, (TObject*) G__int(libp->para[4]));
     } else {
       p = new((void*) gvp) TFileInfo(
(const char*) G__int(libp->para[0]), (Long64_t) G__Longlong(libp->para[1])
, (const char*) G__int(libp->para[2]), (const char*) G__int(libp->para[3])
, (TObject*) G__int(libp->para[4]));
     }
     break;
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileInfo(
(const char*) G__int(libp->para[0]), (Long64_t) G__Longlong(libp->para[1])
, (const char*) G__int(libp->para[2]), (const char*) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) TFileInfo(
(const char*) G__int(libp->para[0]), (Long64_t) G__Longlong(libp->para[1])
, (const char*) G__int(libp->para[2]), (const char*) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileInfo(
(const char*) G__int(libp->para[0]), (Long64_t) G__Longlong(libp->para[1])
, (const char*) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) TFileInfo(
(const char*) G__int(libp->para[0]), (Long64_t) G__Longlong(libp->para[1])
, (const char*) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileInfo((const char*) G__int(libp->para[0]), (Long64_t) G__Longlong(libp->para[1]));
     } else {
       p = new((void*) gvp) TFileInfo((const char*) G__int(libp->para[0]), (Long64_t) G__Longlong(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileInfo((const char*) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) TFileInfo((const char*) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new TFileInfo[n];
       } else {
         p = new((void*) gvp) TFileInfo[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new TFileInfo;
       } else {
         p = new((void*) gvp) TFileInfo;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TFileInfo));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TFileInfo* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TFileInfo(*(TFileInfo*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) TFileInfo(*(TFileInfo*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TFileInfo));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TFileInfo*) G__getstructoffset())->ResetUrl();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((TFileInfo*) G__getstructoffset())->NextUrl());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const TFileInfo*) G__getstructoffset())->GetCurrentUrl());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const TFileInfo*) G__getstructoffset())->GetFirstUrl());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const TFileInfo*) G__getstructoffset())->GetNUrls());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((TFileInfo*) G__getstructoffset())->SetCurrentUrl((const char*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((TFileInfo*) G__getstructoffset())->SetCurrentUrl((TUrl*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letLonglong(result7, 110, (G__int64) ((const TFileInfo*) G__getstructoffset())->GetSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const TFileInfo*) G__getstructoffset())->GetUUID());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const TFileInfo*) G__getstructoffset())->GetMD5());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const TFileInfo*) G__getstructoffset())->GetMetaDataList());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 85, (long) ((const TFileInfo*) G__getstructoffset())->GetMetaData((const char*) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 85, (long) ((const TFileInfo*) G__getstructoffset())->GetMetaData());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TFileInfo*) G__getstructoffset())->SetSize((Long64_t) G__Longlong(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TFileInfo*) G__getstructoffset())->SetUUID((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 85, (long) ((TFileInfo*) G__getstructoffset())->FindByUrl((const char*) G__int(libp->para[0]), (Bool_t) G__int(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 85, (long) ((TFileInfo*) G__getstructoffset())->FindByUrl((const char*) G__int(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 103, (long) ((TFileInfo*) G__getstructoffset())->AddUrl((const char*) G__int(libp->para[0]), (Bool_t) G__int(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 103, (long) ((TFileInfo*) G__getstructoffset())->AddUrl((const char*) G__int(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((TFileInfo*) G__getstructoffset())->RemoveUrl((const char*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((TFileInfo*) G__getstructoffset())->AddMetaData((TObject*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 103, (long) ((TFileInfo*) G__getstructoffset())->RemoveMetaData((const char*) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 103, (long) ((TFileInfo*) G__getstructoffset())->RemoveMetaData());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TFileInfo::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TFileInfo::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TFileInfo::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TFileInfo::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TFileInfo*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TFileInfo::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TFileInfo::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TFileInfo::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_178_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TFileInfo::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TFileInfo G__TTFileInfo;
static int G__G__Base3_178_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TFileInfo*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TFileInfo*) (soff+(sizeof(TFileInfo)*i)))->~G__TTFileInfo();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TFileInfo*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TFileInfo*) (soff))->~G__TTFileInfo();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TFileCollection */
static int G__G__Base3_181_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TFileCollection* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 5:
     //m: 5
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileCollection(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (Int_t) G__int(libp->para[3])
, (Int_t) G__int(libp->para[4]));
     } else {
       p = new((void*) gvp) TFileCollection(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (Int_t) G__int(libp->para[3])
, (Int_t) G__int(libp->para[4]));
     }
     break;
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileCollection(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (Int_t) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) TFileCollection(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (Int_t) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileCollection(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) TFileCollection(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileCollection((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) TFileCollection((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TFileCollection((const char*) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) TFileCollection((const char*) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new TFileCollection[n];
       } else {
         p = new((void*) gvp) TFileCollection[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new TFileCollection;
       } else {
         p = new((void*) gvp) TFileCollection;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TFileCollection));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TFileCollection*) G__getstructoffset())->Add((TFileInfo*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TFileCollection*) G__getstructoffset())->Add((TFileCollection*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letint(result7, 105, (long) ((TFileCollection*) G__getstructoffset())->AddFromFile((const char*) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])
, (Int_t) G__int(libp->para[2])));
      break;
   case 2:
      G__letint(result7, 105, (long) ((TFileCollection*) G__getstructoffset())->AddFromFile((const char*) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 105, (long) ((TFileCollection*) G__getstructoffset())->AddFromFile((const char*) G__int(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TFileCollection*) G__getstructoffset())->Add((const char*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((TFileCollection*) G__getstructoffset())->GetList());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TFileCollection*) G__getstructoffset())->SetList((THashList*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 85, (long) ((TFileCollection*) G__getstructoffset())->ExportInfo((const char*) G__int(libp->para[0]), (Int_t) G__int(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 85, (long) ((TFileCollection*) G__getstructoffset())->ExportInfo((const char*) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 85, (long) ((TFileCollection*) G__getstructoffset())->ExportInfo());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((TFileCollection*) G__getstructoffset())->RemoveDuplicates());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 105, (long) ((TFileCollection*) G__getstructoffset())->Update((Long64_t) G__Longlong(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 105, (long) ((TFileCollection*) G__getstructoffset())->Update());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TFileCollection*) G__getstructoffset())->Sort();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TFileCollection*) G__getstructoffset())->SetAnchor((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TFileCollection*) G__getstructoffset())->SetBitAll((UInt_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TFileCollection*) G__getstructoffset())->ResetBitAll((UInt_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letLonglong(result7, 110, (G__int64) ((const TFileCollection*) G__getstructoffset())->GetTotalSize());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letLonglong(result7, 110, (G__int64) ((const TFileCollection*) G__getstructoffset())->GetNFiles());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letLonglong(result7, 110, (G__int64) ((const TFileCollection*) G__getstructoffset())->GetNStagedFiles());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letLonglong(result7, 110, (G__int64) ((const TFileCollection*) G__getstructoffset())->GetNCorruptFiles());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const TFileCollection*) G__getstructoffset())->GetStagedPercentage());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const TFileCollection*) G__getstructoffset())->GetCorruptedPercentage());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const TFileCollection*) G__getstructoffset())->GetDefaultTreeName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TFileCollection*) G__getstructoffset())->SetDefaultTreeName((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letLonglong(result7, 110, (G__int64) ((const TFileCollection*) G__getstructoffset())->GetTotalEntries((const char*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 85, (long) ((const TFileCollection*) G__getstructoffset())->GetMetaData((const char*) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 85, (long) ((const TFileCollection*) G__getstructoffset())->GetMetaData());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TFileCollection*) G__getstructoffset())->SetDefaultMetaData((const char*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((TFileCollection*) G__getstructoffset())->AddMetaData((TObject*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TFileCollection*) G__getstructoffset())->RemoveMetaData((const char*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      ((TFileCollection*) G__getstructoffset())->RemoveMetaData();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((TFileCollection*) G__getstructoffset())->GetStagedSubset());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((TFileCollection*) G__getstructoffset())->GetFilesOnServer((const char*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 85, (long) ((TFileCollection*) G__getstructoffset())->GetFilesPerServer((const char*) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 85, (long) ((TFileCollection*) G__getstructoffset())->GetFilesPerServer());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TFileCollection::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TFileCollection::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TFileCollection::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TFileCollection::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TFileCollection*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_42(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TFileCollection::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_43(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TFileCollection::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_44(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TFileCollection::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_181_0_45(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TFileCollection::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TFileCollection G__TTFileCollection;
static int G__G__Base3_181_0_46(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TFileCollection*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TFileCollection*) (soff+(sizeof(TFileCollection)*i)))->~G__TTFileCollection();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TFileCollection*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TFileCollection*) (soff))->~G__TTFileCollection();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TRedirectOutputGuard */
static int G__G__Base3_225_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRedirectOutputGuard* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRedirectOutputGuard((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) TRedirectOutputGuard((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TRedirectOutputGuard((const char*) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) TRedirectOutputGuard((const char*) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TRedirectOutputGuard));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_225_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TRedirectOutputGuard::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_225_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRedirectOutputGuard::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_225_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TRedirectOutputGuard::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_225_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TRedirectOutputGuard::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_225_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const TRedirectOutputGuard*) G__getstructoffset())->IsA());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_225_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRedirectOutputGuard*) G__getstructoffset())->ShowMembers(*(TMemberInspector*) libp->para[0].ref, (char*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_225_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRedirectOutputGuard*) G__getstructoffset())->Streamer(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_225_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TRedirectOutputGuard*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_225_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRedirectOutputGuard::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_225_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TRedirectOutputGuard::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_225_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TRedirectOutputGuard::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_225_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TRedirectOutputGuard::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_225_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TRedirectOutputGuard* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TRedirectOutputGuard(*(TRedirectOutputGuard*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TRedirectOutputGuard));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TRedirectOutputGuard G__TTRedirectOutputGuard;
static int G__G__Base3_225_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TRedirectOutputGuard*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TRedirectOutputGuard*) (soff+(sizeof(TRedirectOutputGuard)*i)))->~G__TTRedirectOutputGuard();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TRedirectOutputGuard*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TRedirectOutputGuard*) (soff))->~G__TTRedirectOutputGuard();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Base3_225_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TRedirectOutputGuard* dest = (TRedirectOutputGuard*) G__getstructoffset();
   *dest = *(TRedirectOutputGuard*) libp->para[0].ref;
   const TRedirectOutputGuard& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TVirtualMonitoringWriter */
static int G__G__Base3_226_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TVirtualMonitoringWriter* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TVirtualMonitoringWriter[n];
     } else {
       p = new((void*) gvp) TVirtualMonitoringWriter[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TVirtualMonitoringWriter;
     } else {
       p = new((void*) gvp) TVirtualMonitoringWriter;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringWriter));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_226_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TVirtualMonitoringWriter* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TVirtualMonitoringWriter((const char*) G__int(libp->para[0]), (Double_t) G__double(libp->para[1]));
   } else {
     p = new((void*) gvp) TVirtualMonitoringWriter((const char*) G__int(libp->para[0]), (Double_t) G__double(libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringWriter));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_226_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((TVirtualMonitoringWriter*) G__getstructoffset())->SendFileCloseEvent((TFile*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_226_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((TVirtualMonitoringWriter*) G__getstructoffset())->SendFileReadProgress((TFile*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_226_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((TVirtualMonitoringWriter*) G__getstructoffset())->SendFileWriteProgress((TFile*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_226_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 103, (long) ((TVirtualMonitoringWriter*) G__getstructoffset())->SendParameters((TList*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 103, (long) ((TVirtualMonitoringWriter*) G__getstructoffset())->SendParameters((TList*) G__int(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_226_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((TVirtualMonitoringWriter*) G__getstructoffset())->SendInfoTime());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_226_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 103, (long) ((TVirtualMonitoringWriter*) G__getstructoffset())->SendInfoUser((const char*) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 103, (long) ((TVirtualMonitoringWriter*) G__getstructoffset())->SendInfoUser());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_226_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((TVirtualMonitoringWriter*) G__getstructoffset())->SendInfoDescription((const char*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_226_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((TVirtualMonitoringWriter*) G__getstructoffset())->SendInfoStatus((const char*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_226_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 4:
      G__letint(result7, 103, (long) ((TVirtualMonitoringWriter*) G__getstructoffset())->SendFileOpenProgress((TFile*) G__int(libp->para[0]), (TList*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (Bool_t) G__int(libp->para[3])));
      break;
   case 3:
      G__letint(result7, 103, (long) ((TVirtualMonitoringWriter*) G__getstructoffset())->SendFileOpenProgress((TFile*) G__int(libp->para[0]), (TList*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_226_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 103, (long) ((TVirtualMonitoringWriter*) G__getstructoffset())->SendProcessingStatus((const char*) G__int(libp->para[0]), (Bool_t) G__int(libp->para[1])));
      break;
   case 1:
      G__letint(result7, 103, (long) ((TVirtualMonitoringWriter*) G__getstructoffset())->SendProcessingStatus((const char*) G__int(libp->para[0])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_226_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      G__letint(result7, 103, (long) ((TVirtualMonitoringWriter*) G__getstructoffset())->SendProcessingProgress((Double_t) G__double(libp->para[0]), (Double_t) G__double(libp->para[1])
, (Bool_t) G__int(libp->para[2])));
      break;
   case 2:
      G__letint(result7, 103, (long) ((TVirtualMonitoringWriter*) G__getstructoffset())->SendProcessingProgress((Double_t) G__double(libp->para[0]), (Double_t) G__double(libp->para[1])));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_226_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      ((TVirtualMonitoringWriter*) G__getstructoffset())->SetLogLevel((const char*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   case 0:
      ((TVirtualMonitoringWriter*) G__getstructoffset())->SetLogLevel();
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_226_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualMonitoringWriter*) G__getstructoffset())->Verbose((Bool_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_226_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TVirtualMonitoringWriter::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_226_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualMonitoringWriter::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_226_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TVirtualMonitoringWriter::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_226_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TVirtualMonitoringWriter::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_226_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualMonitoringWriter*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_226_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualMonitoringWriter::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_226_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TVirtualMonitoringWriter::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_226_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualMonitoringWriter::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_226_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TVirtualMonitoringWriter::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TVirtualMonitoringWriter G__TTVirtualMonitoringWriter;
static int G__G__Base3_226_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TVirtualMonitoringWriter*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TVirtualMonitoringWriter*) (soff+(sizeof(TVirtualMonitoringWriter)*i)))->~G__TTVirtualMonitoringWriter();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TVirtualMonitoringWriter*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TVirtualMonitoringWriter*) (soff))->~G__TTVirtualMonitoringWriter();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TVirtualMonitoringReader */
static int G__G__Base3_227_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TVirtualMonitoringReader* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TVirtualMonitoringReader((const char*) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) TVirtualMonitoringReader((const char*) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new TVirtualMonitoringReader[n];
       } else {
         p = new((void*) gvp) TVirtualMonitoringReader[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new TVirtualMonitoringReader;
       } else {
         p = new((void*) gvp) TVirtualMonitoringReader;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringReader));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_227_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualMonitoringReader*) G__getstructoffset())->DumpResult();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_227_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 7:
      ((TVirtualMonitoringReader*) G__getstructoffset())->GetValues(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (const char*) G__int(libp->para[3])
, (Long_t) G__int(libp->para[4]), (Long_t) G__int(libp->para[5])
, (Bool_t) G__int(libp->para[6]));
      G__setnull(result7);
      break;
   case 6:
      ((TVirtualMonitoringReader*) G__getstructoffset())->GetValues((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (const char*) G__int(libp->para[3])
, (Long_t) G__int(libp->para[4]), (Long_t) G__int(libp->para[5]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_227_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 5:
      ((TVirtualMonitoringReader*) G__getstructoffset())->GetLastValues((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (const char*) G__int(libp->para[3])
, (Bool_t) G__int(libp->para[4]));
      G__setnull(result7);
      break;
   case 4:
      ((TVirtualMonitoringReader*) G__getstructoffset())->GetLastValues((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (const char*) G__int(libp->para[3]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_227_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualMonitoringReader*) G__getstructoffset())->ProxyValues(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]), (const char*) G__int(libp->para[3])
, (Long_t) G__int(libp->para[4]), (Long_t) G__int(libp->para[5])
, (Long_t) G__int(libp->para[6]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_227_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((TVirtualMonitoringReader*) G__getstructoffset())->GetMap());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_227_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualMonitoringReader*) G__getstructoffset())->DeleteMap((TMap*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_227_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TVirtualMonitoringReader::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_227_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualMonitoringReader::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_227_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TVirtualMonitoringReader::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_227_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TVirtualMonitoringReader::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_227_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualMonitoringReader*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_227_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualMonitoringReader::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_227_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TVirtualMonitoringReader::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_227_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualMonitoringReader::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_227_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TVirtualMonitoringReader::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_227_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TVirtualMonitoringReader* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TVirtualMonitoringReader(*(TVirtualMonitoringReader*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringReader));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TVirtualMonitoringReader G__TTVirtualMonitoringReader;
static int G__G__Base3_227_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TVirtualMonitoringReader*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TVirtualMonitoringReader*) (soff+(sizeof(TVirtualMonitoringReader)*i)))->~G__TTVirtualMonitoringReader();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TVirtualMonitoringReader*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TVirtualMonitoringReader*) (soff))->~G__TTVirtualMonitoringReader();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Base3_227_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TVirtualMonitoringReader* dest = (TVirtualMonitoringReader*) G__getstructoffset();
   *dest = *(TVirtualMonitoringReader*) libp->para[0].ref;
   const TVirtualMonitoringReader& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TObjectSpy */
static int G__G__Base3_228_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TObjectSpy* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TObjectSpy((TObject*) G__int(libp->para[0]), (Bool_t) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) TObjectSpy((TObject*) G__int(libp->para[0]), (Bool_t) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TObjectSpy((TObject*) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) TObjectSpy((TObject*) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new TObjectSpy[n];
       } else {
         p = new((void*) gvp) TObjectSpy[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new TObjectSpy;
       } else {
         p = new((void*) gvp) TObjectSpy;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TObjectSpy));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_228_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const TObjectSpy*) G__getstructoffset())->GetObject());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_228_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      ((TObjectSpy*) G__getstructoffset())->SetObject((TObject*) G__int(libp->para[0]), (Bool_t) G__int(libp->para[1]));
      G__setnull(result7);
      break;
   case 1:
      ((TObjectSpy*) G__getstructoffset())->SetObject((TObject*) G__int(libp->para[0]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_228_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TObjectSpy::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_228_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TObjectSpy::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_228_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TObjectSpy::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_228_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TObjectSpy::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_228_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TObjectSpy*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_228_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TObjectSpy::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_228_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TObjectSpy::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_228_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TObjectSpy::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_228_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TObjectSpy::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TObjectSpy G__TTObjectSpy;
static int G__G__Base3_228_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TObjectSpy*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TObjectSpy*) (soff+(sizeof(TObjectSpy)*i)))->~G__TTObjectSpy();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TObjectSpy*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TObjectSpy*) (soff))->~G__TTObjectSpy();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TObjectRefSpy */
static int G__G__Base3_229_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TObjectRefSpy* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TObjectRefSpy(libp->para[0].ref ? *(TObject**) libp->para[0].ref : *(TObject**) (&G__Mlong(libp->para[0])), (Bool_t) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) TObjectRefSpy(libp->para[0].ref ? *(TObject**) libp->para[0].ref : *(TObject**) (&G__Mlong(libp->para[0])), (Bool_t) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TObjectRefSpy(libp->para[0].ref ? *(TObject**) libp->para[0].ref : *(TObject**) (&G__Mlong(libp->para[0])));
     } else {
       p = new((void*) gvp) TObjectRefSpy(libp->para[0].ref ? *(TObject**) libp->para[0].ref : *(TObject**) (&G__Mlong(libp->para[0])));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TObjectRefSpy));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_229_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const TObjectRefSpy*) G__getstructoffset())->GetObject());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_229_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TObjectRefSpy::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_229_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TObjectRefSpy::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_229_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TObjectRefSpy::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_229_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TObjectRefSpy::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_229_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TObjectRefSpy*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_229_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TObjectRefSpy::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_229_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TObjectRefSpy::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_229_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TObjectRefSpy::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_229_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TObjectRefSpy::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TObjectRefSpy G__TTObjectRefSpy;
static int G__G__Base3_229_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TObjectRefSpy*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TObjectRefSpy*) (soff+(sizeof(TObjectRefSpy)*i)))->~G__TTObjectRefSpy();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TObjectRefSpy*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TObjectRefSpy*) (soff))->~G__TTObjectRefSpy();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TUri */
static int G__G__Base3_230_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TUri* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TUri(*(TUri*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) TUri(*(TUri*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TUri));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TUri* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TUri[n];
     } else {
       p = new((void*) gvp) TUri[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TUri;
     } else {
       p = new((void*) gvp) TUri;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TUri));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TUri* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TUri(*(TString*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) TUri(*(TString*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TUri));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TUri* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TUri((const char*) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) TUri((const char*) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TUri));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TUri& obj = ((TUri*) G__getstructoffset())->operator=(*(TUri*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TString* pobj;
         const TString xobj = ((const TUri*) G__getstructoffset())->GetUri();
         pobj = new TString(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TString* pobj;
         const TString xobj = ((const TUri*) G__getstructoffset())->GetScheme();
         pobj = new TString(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TString* pobj;
         const TString xobj = ((const TUri*) G__getstructoffset())->GetHierPart();
         pobj = new TString(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TString* pobj;
         const TString xobj = ((const TUri*) G__getstructoffset())->GetRelativePart();
         pobj = new TString(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TString* pobj;
         const TString xobj = ((const TUri*) G__getstructoffset())->GetAuthority();
         pobj = new TString(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TString* pobj;
         const TString xobj = ((const TUri*) G__getstructoffset())->GetUserInfo();
         pobj = new TString(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TString* pobj;
         const TString xobj = ((const TUri*) G__getstructoffset())->GetHost();
         pobj = new TString(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TString* pobj;
         const TString xobj = ((const TUri*) G__getstructoffset())->GetPort();
         pobj = new TString(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TString* pobj;
         const TString xobj = ((const TUri*) G__getstructoffset())->GetPath();
         pobj = new TString(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TString* pobj;
         const TString xobj = ((const TUri*) G__getstructoffset())->GetQuery();
         pobj = new TString(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TString* pobj;
         const TString xobj = ((const TUri*) G__getstructoffset())->GetFragment();
         pobj = new TString(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TUri*) G__getstructoffset())->HasScheme());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TUri*) G__getstructoffset())->HasHierPart());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TUri*) G__getstructoffset())->HasAuthority());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TUri*) G__getstructoffset())->HasUserInfo());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TUri*) G__getstructoffset())->HasHost());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TUri*) G__getstructoffset())->HasPort());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TUri*) G__getstructoffset())->HasPath());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TUri*) G__getstructoffset())->HasQuery());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TUri*) G__getstructoffset())->HasFragment());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TUri*) G__getstructoffset())->HasRelativePart());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((TUri*) G__getstructoffset())->SetUri(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((TUri*) G__getstructoffset())->SetScheme(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((TUri*) G__getstructoffset())->SetHierPart(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((TUri*) G__getstructoffset())->SetAuthority(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((TUri*) G__getstructoffset())->SetUserInfo(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((TUri*) G__getstructoffset())->SetHost(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((TUri*) G__getstructoffset())->SetPort(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((TUri*) G__getstructoffset())->SetPath(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((TUri*) G__getstructoffset())->SetQuery(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((TUri*) G__getstructoffset())->SetFragment(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((TUri*) G__getstructoffset())->SetRelativePart(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TUri*) G__getstructoffset())->Normalise();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TUri*) G__getstructoffset())->Reset();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_42(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TUri*) G__getstructoffset())->IsAbsolute());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_43(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TUri*) G__getstructoffset())->IsRelative());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_44(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TUri*) G__getstructoffset())->IsUri());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_45(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const TUri*) G__getstructoffset())->IsReference());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_46(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) TUri::IsUnreserved(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_47(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         TString* pobj;
         TString xobj = TUri::PctEncode(*(TString*) libp->para[0].ref);
         pobj = new TString(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_48(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         TString* pobj;
         TString xobj = TUri::PctDecode(*(TString*) libp->para[0].ref);
         pobj = new TString(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_49(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         TString* pobj;
         TString xobj = TUri::PctDecodeUnreserved(*(TString*) libp->para[0].ref);
         pobj = new TString(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_50(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         TString* pobj;
         TString xobj = TUri::PctNormalise(*(TString*) libp->para[0].ref);
         pobj = new TString(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_51(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) TUri::IsScheme(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_52(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) TUri::IsHierPart(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_53(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) TUri::IsAuthority(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_54(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) TUri::IsUserInfo(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_55(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) TUri::IsHost(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_56(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) TUri::IsIpv4(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_57(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) TUri::IsRegName(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_58(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) TUri::IsPort(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_59(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) TUri::IsPath(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_60(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) TUri::IsPathAbsolute(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_61(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) TUri::IsPathAbempty(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_62(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) TUri::IsPathNoscheme(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_63(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) TUri::IsPathRootless(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_64(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) TUri::IsPathEmpty(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_65(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) TUri::IsQuery(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_66(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) TUri::IsFragment(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_67(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) TUri::IsRelativePart(*(TString*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_68(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         TString* pobj;
         TString xobj = TUri::RemoveDotSegments(*(TString*) libp->para[0].ref);
         pobj = new TString(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_69(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         TUri* pobj;
         TUri xobj = TUri::Transform(*(TUri*) libp->para[0].ref, *(TUri*) libp->para[1].ref);
         pobj = new TUri(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_70(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         TString* pobj;
         TString xobj = TUri::MergePaths(*(TUri*) libp->para[0].ref, *(TUri*) libp->para[1].ref);
         pobj = new TString(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_71(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TUri::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_72(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TUri::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_73(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TUri::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_74(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TUri::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_78(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TUri*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_79(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TUri::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_80(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TUri::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_81(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TUri::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_230_0_82(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TUri::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TUri G__TTUri;
static int G__G__Base3_230_0_83(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TUri*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TUri*) (soff+(sizeof(TUri)*i)))->~G__TTUri();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TUri*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TUri*) (soff))->~G__TTUri();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TVirtualTableInterface */
static int G__G__Base3_231_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((TVirtualTableInterface*) G__getstructoffset())->GetValue((UInt_t) G__int(libp->para[0]), (UInt_t) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_231_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((TVirtualTableInterface*) G__getstructoffset())->GetValueAsString((UInt_t) G__int(libp->para[0]), (UInt_t) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_231_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((TVirtualTableInterface*) G__getstructoffset())->GetRowHeader((UInt_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_231_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((TVirtualTableInterface*) G__getstructoffset())->GetColumnHeader((UInt_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_231_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((TVirtualTableInterface*) G__getstructoffset())->GetNRows());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_231_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((TVirtualTableInterface*) G__getstructoffset())->GetNColumns());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_231_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TVirtualTableInterface::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_231_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualTableInterface::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_231_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TVirtualTableInterface::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_231_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TVirtualTableInterface::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_231_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const TVirtualTableInterface*) G__getstructoffset())->IsA());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_231_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualTableInterface*) G__getstructoffset())->ShowMembers(*(TMemberInspector*) libp->para[0].ref, (char*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_231_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualTableInterface*) G__getstructoffset())->Streamer(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_231_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TVirtualTableInterface*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_231_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualTableInterface::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_231_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TVirtualTableInterface::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_231_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TVirtualTableInterface::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_231_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TVirtualTableInterface::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TVirtualTableInterface G__TTVirtualTableInterface;
static int G__G__Base3_231_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TVirtualTableInterface*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TVirtualTableInterface*) (soff+(sizeof(TVirtualTableInterface)*i)))->~G__TTVirtualTableInterface();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TVirtualTableInterface*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TVirtualTableInterface*) (soff))->~G__TTVirtualTableInterface();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Base3_231_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TVirtualTableInterface* dest = (TVirtualTableInterface*) G__getstructoffset();
   *dest = *(TVirtualTableInterface*) libp->para[0].ref;
   const TVirtualTableInterface& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TBase64 */
static int G__G__Base3_232_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         TString* pobj;
         TString xobj = TBase64::Encode((const char*) G__int(libp->para[0]));
         pobj = new TString(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_232_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         TString* pobj;
         TString xobj = TBase64::Encode((const char*) G__int(libp->para[0]), (Int_t) G__int(libp->para[1]));
         pobj = new TString(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_232_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         TString* pobj;
         TString xobj = TBase64::Decode((const char*) G__int(libp->para[0]));
         pobj = new TString(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_232_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TBase64::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_232_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TBase64::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_232_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TBase64::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_232_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TBase64::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_232_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const TBase64*) G__getstructoffset())->IsA());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_232_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TBase64*) G__getstructoffset())->ShowMembers(*(TMemberInspector*) libp->para[0].ref, (char*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_232_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TBase64*) G__getstructoffset())->Streamer(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_232_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TBase64*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_232_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TBase64::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_232_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TBase64::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_232_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TBase64::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_232_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TBase64::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic default constructor
static int G__G__Base3_232_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TBase64 *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TBase64[n];
     } else {
       p = new((void*) gvp) TBase64[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TBase64;
     } else {
       p = new((void*) gvp) TBase64;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TBase64));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_232_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TBase64* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TBase64(*(TBase64*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TBase64));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TBase64 G__TTBase64;
static int G__G__Base3_232_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TBase64*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TBase64*) (soff+(sizeof(TBase64)*i)))->~G__TTBase64();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TBase64*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TBase64*) (soff))->~G__TTBase64();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Base3_232_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TBase64* dest = (TBase64*) G__getstructoffset();
   *dest = *(TBase64*) libp->para[0].ref;
   const TBase64& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<char*,int> */
static int G__G__Base3_233_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<char*,int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<char*,int>[n];
     } else {
       p = new((void*) gvp) pair<char*,int>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<char*,int>;
     } else {
       p = new((void*) gvp) pair<char*,int>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_233_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<char*,int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<char*,int>(libp->para[0].ref ? *(char**) libp->para[0].ref : *(char**) (&G__Mlong(libp->para[0])), *(int*) G__Intref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<char*,int>(libp->para[0].ref ? *(char**) libp->para[0].ref : *(char**) (&G__Mlong(libp->para[0])), *(int*) G__Intref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_233_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<char*,int>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<char*,int>(*(pair<char*,int>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<char*,int> G__TpairlEcharmUcOintgR;
static int G__G__Base3_233_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<char*,int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<char*,int>*) (soff+(sizeof(pair<char*,int>)*i)))->~G__TpairlEcharmUcOintgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<char*,int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<char*,int>*) (soff))->~G__TpairlEcharmUcOintgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<char*,long> */
static int G__G__Base3_234_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<char*,long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<char*,long>[n];
     } else {
       p = new((void*) gvp) pair<char*,long>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<char*,long>;
     } else {
       p = new((void*) gvp) pair<char*,long>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_234_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<char*,long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<char*,long>(libp->para[0].ref ? *(char**) libp->para[0].ref : *(char**) (&G__Mlong(libp->para[0])), *(long*) G__Longref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<char*,long>(libp->para[0].ref ? *(char**) libp->para[0].ref : *(char**) (&G__Mlong(libp->para[0])), *(long*) G__Longref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_234_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<char*,long>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<char*,long>(*(pair<char*,long>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<char*,long> G__TpairlEcharmUcOlonggR;
static int G__G__Base3_234_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<char*,long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<char*,long>*) (soff+(sizeof(pair<char*,long>)*i)))->~G__TpairlEcharmUcOlonggR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<char*,long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<char*,long>*) (soff))->~G__TpairlEcharmUcOlonggR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<char*,float> */
static int G__G__Base3_235_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<char*,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<char*,float>[n];
     } else {
       p = new((void*) gvp) pair<char*,float>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<char*,float>;
     } else {
       p = new((void*) gvp) pair<char*,float>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_235_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<char*,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<char*,float>(libp->para[0].ref ? *(char**) libp->para[0].ref : *(char**) (&G__Mlong(libp->para[0])), *(float*) G__Floatref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<char*,float>(libp->para[0].ref ? *(char**) libp->para[0].ref : *(char**) (&G__Mlong(libp->para[0])), *(float*) G__Floatref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_235_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<char*,float>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<char*,float>(*(pair<char*,float>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<char*,float> G__TpairlEcharmUcOfloatgR;
static int G__G__Base3_235_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<char*,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<char*,float>*) (soff+(sizeof(pair<char*,float>)*i)))->~G__TpairlEcharmUcOfloatgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<char*,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<char*,float>*) (soff))->~G__TpairlEcharmUcOfloatgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<char*,double> */
static int G__G__Base3_236_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<char*,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<char*,double>[n];
     } else {
       p = new((void*) gvp) pair<char*,double>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<char*,double>;
     } else {
       p = new((void*) gvp) pair<char*,double>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_236_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<char*,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<char*,double>(libp->para[0].ref ? *(char**) libp->para[0].ref : *(char**) (&G__Mlong(libp->para[0])), *(double*) G__Doubleref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<char*,double>(libp->para[0].ref ? *(char**) libp->para[0].ref : *(char**) (&G__Mlong(libp->para[0])), *(double*) G__Doubleref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_236_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<char*,double>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<char*,double>(*(pair<char*,double>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<char*,double> G__TpairlEcharmUcOdoublegR;
static int G__G__Base3_236_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<char*,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<char*,double>*) (soff+(sizeof(pair<char*,double>)*i)))->~G__TpairlEcharmUcOdoublegR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<char*,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<char*,double>*) (soff))->~G__TpairlEcharmUcOdoublegR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<char*,void*> */
static int G__G__Base3_237_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<char*,void*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<char*,void*>[n];
     } else {
       p = new((void*) gvp) pair<char*,void*>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<char*,void*>;
     } else {
       p = new((void*) gvp) pair<char*,void*>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_237_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<char*,void*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<char*,void*>(libp->para[0].ref ? *(char**) libp->para[0].ref : *(char**) (&G__Mlong(libp->para[0])), libp->para[1].ref ? *(void**) libp->para[1].ref : *(void**) (&G__Mlong(libp->para[1])));
   } else {
     p = new((void*) gvp) pair<char*,void*>(libp->para[0].ref ? *(char**) libp->para[0].ref : *(char**) (&G__Mlong(libp->para[0])), libp->para[1].ref ? *(void**) libp->para[1].ref : *(void**) (&G__Mlong(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_237_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<char*,void*>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<char*,void*>(*(pair<char*,void*>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<char*,void*> G__TpairlEcharmUcOvoidmUgR;
static int G__G__Base3_237_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<char*,void*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<char*,void*>*) (soff+(sizeof(pair<char*,void*>)*i)))->~G__TpairlEcharmUcOvoidmUgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<char*,void*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<char*,void*>*) (soff))->~G__TpairlEcharmUcOvoidmUgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<char*,char*> */
static int G__G__Base3_238_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<char*,char*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<char*,char*>[n];
     } else {
       p = new((void*) gvp) pair<char*,char*>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<char*,char*>;
     } else {
       p = new((void*) gvp) pair<char*,char*>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_238_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<char*,char*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<char*,char*>(libp->para[0].ref ? *(char**) libp->para[0].ref : *(char**) (&G__Mlong(libp->para[0])), libp->para[1].ref ? *(char**) libp->para[1].ref : *(char**) (&G__Mlong(libp->para[1])));
   } else {
     p = new((void*) gvp) pair<char*,char*>(libp->para[0].ref ? *(char**) libp->para[0].ref : *(char**) (&G__Mlong(libp->para[0])), libp->para[1].ref ? *(char**) libp->para[1].ref : *(char**) (&G__Mlong(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_238_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<char*,char*>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<char*,char*>(*(pair<char*,char*>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<char*,char*> G__TpairlEcharmUcOcharmUgR;
static int G__G__Base3_238_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<char*,char*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<char*,char*>*) (soff+(sizeof(pair<char*,char*>)*i)))->~G__TpairlEcharmUcOcharmUgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<char*,char*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<char*,char*>*) (soff))->~G__TpairlEcharmUcOcharmUgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<string,int> */
static int G__G__Base3_239_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<string,int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<string,int>[n];
     } else {
       p = new((void*) gvp) pair<string,int>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<string,int>;
     } else {
       p = new((void*) gvp) pair<string,int>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_239_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<string,int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<string,int>(*(string*) libp->para[0].ref, *(int*) G__Intref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<string,int>(*(string*) libp->para[0].ref, *(int*) G__Intref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_239_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<string,int>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<string,int>(*(pair<string,int>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<string,int> G__TpairlEstringcOintgR;
static int G__G__Base3_239_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<string,int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<string,int>*) (soff+(sizeof(pair<string,int>)*i)))->~G__TpairlEstringcOintgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<string,int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<string,int>*) (soff))->~G__TpairlEstringcOintgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<string,long> */
static int G__G__Base3_240_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<string,long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<string,long>[n];
     } else {
       p = new((void*) gvp) pair<string,long>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<string,long>;
     } else {
       p = new((void*) gvp) pair<string,long>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_240_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<string,long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<string,long>(*(string*) libp->para[0].ref, *(long*) G__Longref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<string,long>(*(string*) libp->para[0].ref, *(long*) G__Longref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_240_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<string,long>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<string,long>(*(pair<string,long>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<string,long> G__TpairlEstringcOlonggR;
static int G__G__Base3_240_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<string,long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<string,long>*) (soff+(sizeof(pair<string,long>)*i)))->~G__TpairlEstringcOlonggR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<string,long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<string,long>*) (soff))->~G__TpairlEstringcOlonggR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<string,float> */
static int G__G__Base3_241_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<string,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<string,float>[n];
     } else {
       p = new((void*) gvp) pair<string,float>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<string,float>;
     } else {
       p = new((void*) gvp) pair<string,float>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_241_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<string,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<string,float>(*(string*) libp->para[0].ref, *(float*) G__Floatref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<string,float>(*(string*) libp->para[0].ref, *(float*) G__Floatref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_241_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<string,float>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<string,float>(*(pair<string,float>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<string,float> G__TpairlEstringcOfloatgR;
static int G__G__Base3_241_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<string,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<string,float>*) (soff+(sizeof(pair<string,float>)*i)))->~G__TpairlEstringcOfloatgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<string,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<string,float>*) (soff))->~G__TpairlEstringcOfloatgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<string,double> */
static int G__G__Base3_242_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<string,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<string,double>[n];
     } else {
       p = new((void*) gvp) pair<string,double>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<string,double>;
     } else {
       p = new((void*) gvp) pair<string,double>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_242_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<string,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<string,double>(*(string*) libp->para[0].ref, *(double*) G__Doubleref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<string,double>(*(string*) libp->para[0].ref, *(double*) G__Doubleref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_242_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<string,double>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<string,double>(*(pair<string,double>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<string,double> G__TpairlEstringcOdoublegR;
static int G__G__Base3_242_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<string,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<string,double>*) (soff+(sizeof(pair<string,double>)*i)))->~G__TpairlEstringcOdoublegR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<string,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<string,double>*) (soff))->~G__TpairlEstringcOdoublegR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<string,void*> */
static int G__G__Base3_243_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<string,void*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<string,void*>[n];
     } else {
       p = new((void*) gvp) pair<string,void*>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<string,void*>;
     } else {
       p = new((void*) gvp) pair<string,void*>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_243_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<string,void*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<string,void*>(*(string*) libp->para[0].ref, libp->para[1].ref ? *(void**) libp->para[1].ref : *(void**) (&G__Mlong(libp->para[1])));
   } else {
     p = new((void*) gvp) pair<string,void*>(*(string*) libp->para[0].ref, libp->para[1].ref ? *(void**) libp->para[1].ref : *(void**) (&G__Mlong(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_243_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<string,void*>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<string,void*>(*(pair<string,void*>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<string,void*> G__TpairlEstringcOvoidmUgR;
static int G__G__Base3_243_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<string,void*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<string,void*>*) (soff+(sizeof(pair<string,void*>)*i)))->~G__TpairlEstringcOvoidmUgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<string,void*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<string,void*>*) (soff))->~G__TpairlEstringcOvoidmUgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<int,int> */
static int G__G__Base3_244_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<int,int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<int,int>[n];
     } else {
       p = new((void*) gvp) pair<int,int>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<int,int>;
     } else {
       p = new((void*) gvp) pair<int,int>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_244_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<int,int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<int,int>(*(int*) G__Intref(&libp->para[0]), *(int*) G__Intref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<int,int>(*(int*) G__Intref(&libp->para[0]), *(int*) G__Intref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_244_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<int,int>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<int,int>(*(pair<int,int>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<int,int> G__TpairlEintcOintgR;
static int G__G__Base3_244_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<int,int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<int,int>*) (soff+(sizeof(pair<int,int>)*i)))->~G__TpairlEintcOintgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<int,int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<int,int>*) (soff))->~G__TpairlEintcOintgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<int,long> */
static int G__G__Base3_245_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<int,long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<int,long>[n];
     } else {
       p = new((void*) gvp) pair<int,long>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<int,long>;
     } else {
       p = new((void*) gvp) pair<int,long>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_245_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<int,long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<int,long>(*(int*) G__Intref(&libp->para[0]), *(long*) G__Longref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<int,long>(*(int*) G__Intref(&libp->para[0]), *(long*) G__Longref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_245_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<int,long>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<int,long>(*(pair<int,long>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<int,long> G__TpairlEintcOlonggR;
static int G__G__Base3_245_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<int,long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<int,long>*) (soff+(sizeof(pair<int,long>)*i)))->~G__TpairlEintcOlonggR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<int,long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<int,long>*) (soff))->~G__TpairlEintcOlonggR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<int,float> */
static int G__G__Base3_246_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<int,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<int,float>[n];
     } else {
       p = new((void*) gvp) pair<int,float>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<int,float>;
     } else {
       p = new((void*) gvp) pair<int,float>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_246_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<int,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<int,float>(*(int*) G__Intref(&libp->para[0]), *(float*) G__Floatref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<int,float>(*(int*) G__Intref(&libp->para[0]), *(float*) G__Floatref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_246_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<int,float>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<int,float>(*(pair<int,float>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<int,float> G__TpairlEintcOfloatgR;
static int G__G__Base3_246_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<int,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<int,float>*) (soff+(sizeof(pair<int,float>)*i)))->~G__TpairlEintcOfloatgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<int,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<int,float>*) (soff))->~G__TpairlEintcOfloatgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<int,double> */
static int G__G__Base3_247_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<int,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<int,double>[n];
     } else {
       p = new((void*) gvp) pair<int,double>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<int,double>;
     } else {
       p = new((void*) gvp) pair<int,double>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_247_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<int,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<int,double>(*(int*) G__Intref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<int,double>(*(int*) G__Intref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_247_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<int,double>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<int,double>(*(pair<int,double>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<int,double> G__TpairlEintcOdoublegR;
static int G__G__Base3_247_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<int,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<int,double>*) (soff+(sizeof(pair<int,double>)*i)))->~G__TpairlEintcOdoublegR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<int,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<int,double>*) (soff))->~G__TpairlEintcOdoublegR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<int,void*> */
static int G__G__Base3_248_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<int,void*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<int,void*>[n];
     } else {
       p = new((void*) gvp) pair<int,void*>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<int,void*>;
     } else {
       p = new((void*) gvp) pair<int,void*>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_248_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<int,void*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<int,void*>(*(int*) G__Intref(&libp->para[0]), libp->para[1].ref ? *(void**) libp->para[1].ref : *(void**) (&G__Mlong(libp->para[1])));
   } else {
     p = new((void*) gvp) pair<int,void*>(*(int*) G__Intref(&libp->para[0]), libp->para[1].ref ? *(void**) libp->para[1].ref : *(void**) (&G__Mlong(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_248_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<int,void*>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<int,void*>(*(pair<int,void*>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<int,void*> G__TpairlEintcOvoidmUgR;
static int G__G__Base3_248_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<int,void*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<int,void*>*) (soff+(sizeof(pair<int,void*>)*i)))->~G__TpairlEintcOvoidmUgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<int,void*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<int,void*>*) (soff))->~G__TpairlEintcOvoidmUgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<int,char*> */
static int G__G__Base3_249_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<int,char*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<int,char*>[n];
     } else {
       p = new((void*) gvp) pair<int,char*>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<int,char*>;
     } else {
       p = new((void*) gvp) pair<int,char*>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_249_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<int,char*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<int,char*>(*(int*) G__Intref(&libp->para[0]), libp->para[1].ref ? *(char**) libp->para[1].ref : *(char**) (&G__Mlong(libp->para[1])));
   } else {
     p = new((void*) gvp) pair<int,char*>(*(int*) G__Intref(&libp->para[0]), libp->para[1].ref ? *(char**) libp->para[1].ref : *(char**) (&G__Mlong(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_249_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<int,char*>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<int,char*>(*(pair<int,char*>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<int,char*> G__TpairlEintcOcharmUgR;
static int G__G__Base3_249_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<int,char*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<int,char*>*) (soff+(sizeof(pair<int,char*>)*i)))->~G__TpairlEintcOcharmUgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<int,char*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<int,char*>*) (soff))->~G__TpairlEintcOcharmUgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<long,int> */
static int G__G__Base3_250_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<long,int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<long,int>[n];
     } else {
       p = new((void*) gvp) pair<long,int>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<long,int>;
     } else {
       p = new((void*) gvp) pair<long,int>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_250_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<long,int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<long,int>(*(long*) G__Longref(&libp->para[0]), *(int*) G__Intref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<long,int>(*(long*) G__Longref(&libp->para[0]), *(int*) G__Intref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_250_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<long,int>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<long,int>(*(pair<long,int>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<long,int> G__TpairlElongcOintgR;
static int G__G__Base3_250_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<long,int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<long,int>*) (soff+(sizeof(pair<long,int>)*i)))->~G__TpairlElongcOintgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<long,int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<long,int>*) (soff))->~G__TpairlElongcOintgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<long,long> */
static int G__G__Base3_251_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<long,long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<long,long>[n];
     } else {
       p = new((void*) gvp) pair<long,long>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<long,long>;
     } else {
       p = new((void*) gvp) pair<long,long>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_251_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<long,long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<long,long>(*(long*) G__Longref(&libp->para[0]), *(long*) G__Longref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<long,long>(*(long*) G__Longref(&libp->para[0]), *(long*) G__Longref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_251_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<long,long>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<long,long>(*(pair<long,long>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<long,long> G__TpairlElongcOlonggR;
static int G__G__Base3_251_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<long,long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<long,long>*) (soff+(sizeof(pair<long,long>)*i)))->~G__TpairlElongcOlonggR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<long,long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<long,long>*) (soff))->~G__TpairlElongcOlonggR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<long,float> */
static int G__G__Base3_252_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<long,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<long,float>[n];
     } else {
       p = new((void*) gvp) pair<long,float>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<long,float>;
     } else {
       p = new((void*) gvp) pair<long,float>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_252_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<long,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<long,float>(*(long*) G__Longref(&libp->para[0]), *(float*) G__Floatref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<long,float>(*(long*) G__Longref(&libp->para[0]), *(float*) G__Floatref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_252_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<long,float>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<long,float>(*(pair<long,float>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<long,float> G__TpairlElongcOfloatgR;
static int G__G__Base3_252_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<long,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<long,float>*) (soff+(sizeof(pair<long,float>)*i)))->~G__TpairlElongcOfloatgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<long,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<long,float>*) (soff))->~G__TpairlElongcOfloatgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<long,double> */
static int G__G__Base3_253_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<long,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<long,double>[n];
     } else {
       p = new((void*) gvp) pair<long,double>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<long,double>;
     } else {
       p = new((void*) gvp) pair<long,double>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_253_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<long,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<long,double>(*(long*) G__Longref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<long,double>(*(long*) G__Longref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_253_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<long,double>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<long,double>(*(pair<long,double>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<long,double> G__TpairlElongcOdoublegR;
static int G__G__Base3_253_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<long,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<long,double>*) (soff+(sizeof(pair<long,double>)*i)))->~G__TpairlElongcOdoublegR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<long,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<long,double>*) (soff))->~G__TpairlElongcOdoublegR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<long,void*> */
static int G__G__Base3_254_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<long,void*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<long,void*>[n];
     } else {
       p = new((void*) gvp) pair<long,void*>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<long,void*>;
     } else {
       p = new((void*) gvp) pair<long,void*>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_254_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<long,void*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<long,void*>(*(long*) G__Longref(&libp->para[0]), libp->para[1].ref ? *(void**) libp->para[1].ref : *(void**) (&G__Mlong(libp->para[1])));
   } else {
     p = new((void*) gvp) pair<long,void*>(*(long*) G__Longref(&libp->para[0]), libp->para[1].ref ? *(void**) libp->para[1].ref : *(void**) (&G__Mlong(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_254_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<long,void*>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<long,void*>(*(pair<long,void*>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<long,void*> G__TpairlElongcOvoidmUgR;
static int G__G__Base3_254_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<long,void*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<long,void*>*) (soff+(sizeof(pair<long,void*>)*i)))->~G__TpairlElongcOvoidmUgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<long,void*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<long,void*>*) (soff))->~G__TpairlElongcOvoidmUgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<long,char*> */
static int G__G__Base3_255_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<long,char*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<long,char*>[n];
     } else {
       p = new((void*) gvp) pair<long,char*>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<long,char*>;
     } else {
       p = new((void*) gvp) pair<long,char*>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_255_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<long,char*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<long,char*>(*(long*) G__Longref(&libp->para[0]), libp->para[1].ref ? *(char**) libp->para[1].ref : *(char**) (&G__Mlong(libp->para[1])));
   } else {
     p = new((void*) gvp) pair<long,char*>(*(long*) G__Longref(&libp->para[0]), libp->para[1].ref ? *(char**) libp->para[1].ref : *(char**) (&G__Mlong(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_255_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<long,char*>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<long,char*>(*(pair<long,char*>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<long,char*> G__TpairlElongcOcharmUgR;
static int G__G__Base3_255_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<long,char*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<long,char*>*) (soff+(sizeof(pair<long,char*>)*i)))->~G__TpairlElongcOcharmUgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<long,char*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<long,char*>*) (soff))->~G__TpairlElongcOcharmUgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<float,int> */
static int G__G__Base3_256_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<float,int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<float,int>[n];
     } else {
       p = new((void*) gvp) pair<float,int>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<float,int>;
     } else {
       p = new((void*) gvp) pair<float,int>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_256_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<float,int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<float,int>(*(float*) G__Floatref(&libp->para[0]), *(int*) G__Intref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<float,int>(*(float*) G__Floatref(&libp->para[0]), *(int*) G__Intref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_256_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<float,int>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<float,int>(*(pair<float,int>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<float,int> G__TpairlEfloatcOintgR;
static int G__G__Base3_256_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<float,int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<float,int>*) (soff+(sizeof(pair<float,int>)*i)))->~G__TpairlEfloatcOintgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<float,int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<float,int>*) (soff))->~G__TpairlEfloatcOintgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<float,long> */
static int G__G__Base3_257_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<float,long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<float,long>[n];
     } else {
       p = new((void*) gvp) pair<float,long>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<float,long>;
     } else {
       p = new((void*) gvp) pair<float,long>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_257_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<float,long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<float,long>(*(float*) G__Floatref(&libp->para[0]), *(long*) G__Longref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<float,long>(*(float*) G__Floatref(&libp->para[0]), *(long*) G__Longref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_257_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<float,long>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<float,long>(*(pair<float,long>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<float,long> G__TpairlEfloatcOlonggR;
static int G__G__Base3_257_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<float,long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<float,long>*) (soff+(sizeof(pair<float,long>)*i)))->~G__TpairlEfloatcOlonggR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<float,long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<float,long>*) (soff))->~G__TpairlEfloatcOlonggR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<float,float> */
static int G__G__Base3_258_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<float,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<float,float>[n];
     } else {
       p = new((void*) gvp) pair<float,float>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<float,float>;
     } else {
       p = new((void*) gvp) pair<float,float>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_258_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<float,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<float,float>(*(float*) G__Floatref(&libp->para[0]), *(float*) G__Floatref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<float,float>(*(float*) G__Floatref(&libp->para[0]), *(float*) G__Floatref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_258_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<float,float>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<float,float>(*(pair<float,float>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<float,float> G__TpairlEfloatcOfloatgR;
static int G__G__Base3_258_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<float,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<float,float>*) (soff+(sizeof(pair<float,float>)*i)))->~G__TpairlEfloatcOfloatgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<float,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<float,float>*) (soff))->~G__TpairlEfloatcOfloatgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<float,double> */
static int G__G__Base3_259_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<float,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<float,double>[n];
     } else {
       p = new((void*) gvp) pair<float,double>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<float,double>;
     } else {
       p = new((void*) gvp) pair<float,double>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_259_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<float,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<float,double>(*(float*) G__Floatref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<float,double>(*(float*) G__Floatref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_259_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<float,double>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<float,double>(*(pair<float,double>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<float,double> G__TpairlEfloatcOdoublegR;
static int G__G__Base3_259_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<float,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<float,double>*) (soff+(sizeof(pair<float,double>)*i)))->~G__TpairlEfloatcOdoublegR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<float,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<float,double>*) (soff))->~G__TpairlEfloatcOdoublegR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<float,void*> */
static int G__G__Base3_260_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<float,void*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<float,void*>[n];
     } else {
       p = new((void*) gvp) pair<float,void*>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<float,void*>;
     } else {
       p = new((void*) gvp) pair<float,void*>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_260_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<float,void*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<float,void*>(*(float*) G__Floatref(&libp->para[0]), libp->para[1].ref ? *(void**) libp->para[1].ref : *(void**) (&G__Mlong(libp->para[1])));
   } else {
     p = new((void*) gvp) pair<float,void*>(*(float*) G__Floatref(&libp->para[0]), libp->para[1].ref ? *(void**) libp->para[1].ref : *(void**) (&G__Mlong(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_260_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<float,void*>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<float,void*>(*(pair<float,void*>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<float,void*> G__TpairlEfloatcOvoidmUgR;
static int G__G__Base3_260_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<float,void*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<float,void*>*) (soff+(sizeof(pair<float,void*>)*i)))->~G__TpairlEfloatcOvoidmUgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<float,void*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<float,void*>*) (soff))->~G__TpairlEfloatcOvoidmUgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<float,char*> */
static int G__G__Base3_261_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<float,char*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<float,char*>[n];
     } else {
       p = new((void*) gvp) pair<float,char*>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<float,char*>;
     } else {
       p = new((void*) gvp) pair<float,char*>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_261_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<float,char*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<float,char*>(*(float*) G__Floatref(&libp->para[0]), libp->para[1].ref ? *(char**) libp->para[1].ref : *(char**) (&G__Mlong(libp->para[1])));
   } else {
     p = new((void*) gvp) pair<float,char*>(*(float*) G__Floatref(&libp->para[0]), libp->para[1].ref ? *(char**) libp->para[1].ref : *(char**) (&G__Mlong(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_261_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<float,char*>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<float,char*>(*(pair<float,char*>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<float,char*> G__TpairlEfloatcOcharmUgR;
static int G__G__Base3_261_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<float,char*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<float,char*>*) (soff+(sizeof(pair<float,char*>)*i)))->~G__TpairlEfloatcOcharmUgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<float,char*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<float,char*>*) (soff))->~G__TpairlEfloatcOcharmUgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<double,int> */
static int G__G__Base3_262_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<double,int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<double,int>[n];
     } else {
       p = new((void*) gvp) pair<double,int>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<double,int>;
     } else {
       p = new((void*) gvp) pair<double,int>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_262_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<double,int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<double,int>(*(double*) G__Doubleref(&libp->para[0]), *(int*) G__Intref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<double,int>(*(double*) G__Doubleref(&libp->para[0]), *(int*) G__Intref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_262_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<double,int>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<double,int>(*(pair<double,int>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<double,int> G__TpairlEdoublecOintgR;
static int G__G__Base3_262_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<double,int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<double,int>*) (soff+(sizeof(pair<double,int>)*i)))->~G__TpairlEdoublecOintgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<double,int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<double,int>*) (soff))->~G__TpairlEdoublecOintgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<double,long> */
static int G__G__Base3_263_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<double,long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<double,long>[n];
     } else {
       p = new((void*) gvp) pair<double,long>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<double,long>;
     } else {
       p = new((void*) gvp) pair<double,long>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_263_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<double,long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<double,long>(*(double*) G__Doubleref(&libp->para[0]), *(long*) G__Longref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<double,long>(*(double*) G__Doubleref(&libp->para[0]), *(long*) G__Longref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_263_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<double,long>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<double,long>(*(pair<double,long>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<double,long> G__TpairlEdoublecOlonggR;
static int G__G__Base3_263_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<double,long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<double,long>*) (soff+(sizeof(pair<double,long>)*i)))->~G__TpairlEdoublecOlonggR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<double,long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<double,long>*) (soff))->~G__TpairlEdoublecOlonggR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<double,float> */
static int G__G__Base3_264_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<double,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<double,float>[n];
     } else {
       p = new((void*) gvp) pair<double,float>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<double,float>;
     } else {
       p = new((void*) gvp) pair<double,float>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_264_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<double,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<double,float>(*(double*) G__Doubleref(&libp->para[0]), *(float*) G__Floatref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<double,float>(*(double*) G__Doubleref(&libp->para[0]), *(float*) G__Floatref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_264_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<double,float>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<double,float>(*(pair<double,float>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<double,float> G__TpairlEdoublecOfloatgR;
static int G__G__Base3_264_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<double,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<double,float>*) (soff+(sizeof(pair<double,float>)*i)))->~G__TpairlEdoublecOfloatgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<double,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<double,float>*) (soff))->~G__TpairlEdoublecOfloatgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<double,double> */
static int G__G__Base3_265_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<double,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<double,double>[n];
     } else {
       p = new((void*) gvp) pair<double,double>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<double,double>;
     } else {
       p = new((void*) gvp) pair<double,double>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_265_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<double,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<double,double>(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<double,double>(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_265_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<double,double>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<double,double>(*(pair<double,double>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<double,double> G__TpairlEdoublecOdoublegR;
static int G__G__Base3_265_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<double,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<double,double>*) (soff+(sizeof(pair<double,double>)*i)))->~G__TpairlEdoublecOdoublegR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<double,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<double,double>*) (soff))->~G__TpairlEdoublecOdoublegR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<double,void*> */
static int G__G__Base3_266_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<double,void*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<double,void*>[n];
     } else {
       p = new((void*) gvp) pair<double,void*>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<double,void*>;
     } else {
       p = new((void*) gvp) pair<double,void*>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_266_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<double,void*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<double,void*>(*(double*) G__Doubleref(&libp->para[0]), libp->para[1].ref ? *(void**) libp->para[1].ref : *(void**) (&G__Mlong(libp->para[1])));
   } else {
     p = new((void*) gvp) pair<double,void*>(*(double*) G__Doubleref(&libp->para[0]), libp->para[1].ref ? *(void**) libp->para[1].ref : *(void**) (&G__Mlong(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_266_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<double,void*>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<double,void*>(*(pair<double,void*>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<double,void*> G__TpairlEdoublecOvoidmUgR;
static int G__G__Base3_266_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<double,void*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<double,void*>*) (soff+(sizeof(pair<double,void*>)*i)))->~G__TpairlEdoublecOvoidmUgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<double,void*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<double,void*>*) (soff))->~G__TpairlEdoublecOvoidmUgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<double,char*> */
static int G__G__Base3_267_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<double,char*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<double,char*>[n];
     } else {
       p = new((void*) gvp) pair<double,char*>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<double,char*>;
     } else {
       p = new((void*) gvp) pair<double,char*>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_267_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<double,char*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<double,char*>(*(double*) G__Doubleref(&libp->para[0]), libp->para[1].ref ? *(char**) libp->para[1].ref : *(char**) (&G__Mlong(libp->para[1])));
   } else {
     p = new((void*) gvp) pair<double,char*>(*(double*) G__Doubleref(&libp->para[0]), libp->para[1].ref ? *(char**) libp->para[1].ref : *(char**) (&G__Mlong(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_267_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<double,char*>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<double,char*>(*(pair<double,char*>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<double,char*> G__TpairlEdoublecOcharmUgR;
static int G__G__Base3_267_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<double,char*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<double,char*>*) (soff+(sizeof(pair<double,char*>)*i)))->~G__TpairlEdoublecOcharmUgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<double,char*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<double,char*>*) (soff))->~G__TpairlEdoublecOcharmUgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const char*,int> */
static int G__G__Base3_268_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const char*,int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const char*,int>[n];
     } else {
       p = new((void*) gvp) pair<const char*,int>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const char*,int>;
     } else {
       p = new((void*) gvp) pair<const char*,int>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_268_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const char*,int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const char*,int>(libp->para[0].ref ? *(const char**) libp->para[0].ref : *(const char**) (&G__Mlong(libp->para[0])), *(int*) G__Intref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<const char*,int>(libp->para[0].ref ? *(const char**) libp->para[0].ref : *(const char**) (&G__Mlong(libp->para[0])), *(int*) G__Intref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_268_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const char*,int>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const char*,int>(*(pair<const char*,int>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const char*,int> G__TpairlEconstsPcharmUcOintgR;
static int G__G__Base3_268_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const char*,int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const char*,int>*) (soff+(sizeof(pair<const char*,int>)*i)))->~G__TpairlEconstsPcharmUcOintgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const char*,int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const char*,int>*) (soff))->~G__TpairlEconstsPcharmUcOintgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const char*,long> */
static int G__G__Base3_269_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const char*,long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const char*,long>[n];
     } else {
       p = new((void*) gvp) pair<const char*,long>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const char*,long>;
     } else {
       p = new((void*) gvp) pair<const char*,long>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_269_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const char*,long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const char*,long>(libp->para[0].ref ? *(const char**) libp->para[0].ref : *(const char**) (&G__Mlong(libp->para[0])), *(long*) G__Longref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<const char*,long>(libp->para[0].ref ? *(const char**) libp->para[0].ref : *(const char**) (&G__Mlong(libp->para[0])), *(long*) G__Longref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_269_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const char*,long>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const char*,long>(*(pair<const char*,long>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const char*,long> G__TpairlEconstsPcharmUcOlonggR;
static int G__G__Base3_269_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const char*,long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const char*,long>*) (soff+(sizeof(pair<const char*,long>)*i)))->~G__TpairlEconstsPcharmUcOlonggR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const char*,long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const char*,long>*) (soff))->~G__TpairlEconstsPcharmUcOlonggR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const char*,float> */
static int G__G__Base3_270_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const char*,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const char*,float>[n];
     } else {
       p = new((void*) gvp) pair<const char*,float>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const char*,float>;
     } else {
       p = new((void*) gvp) pair<const char*,float>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_270_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const char*,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const char*,float>(libp->para[0].ref ? *(const char**) libp->para[0].ref : *(const char**) (&G__Mlong(libp->para[0])), *(float*) G__Floatref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<const char*,float>(libp->para[0].ref ? *(const char**) libp->para[0].ref : *(const char**) (&G__Mlong(libp->para[0])), *(float*) G__Floatref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_270_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const char*,float>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const char*,float>(*(pair<const char*,float>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const char*,float> G__TpairlEconstsPcharmUcOfloatgR;
static int G__G__Base3_270_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const char*,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const char*,float>*) (soff+(sizeof(pair<const char*,float>)*i)))->~G__TpairlEconstsPcharmUcOfloatgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const char*,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const char*,float>*) (soff))->~G__TpairlEconstsPcharmUcOfloatgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const char*,double> */
static int G__G__Base3_271_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const char*,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const char*,double>[n];
     } else {
       p = new((void*) gvp) pair<const char*,double>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const char*,double>;
     } else {
       p = new((void*) gvp) pair<const char*,double>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_271_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const char*,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const char*,double>(libp->para[0].ref ? *(const char**) libp->para[0].ref : *(const char**) (&G__Mlong(libp->para[0])), *(double*) G__Doubleref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<const char*,double>(libp->para[0].ref ? *(const char**) libp->para[0].ref : *(const char**) (&G__Mlong(libp->para[0])), *(double*) G__Doubleref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_271_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const char*,double>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const char*,double>(*(pair<const char*,double>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const char*,double> G__TpairlEconstsPcharmUcOdoublegR;
static int G__G__Base3_271_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const char*,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const char*,double>*) (soff+(sizeof(pair<const char*,double>)*i)))->~G__TpairlEconstsPcharmUcOdoublegR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const char*,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const char*,double>*) (soff))->~G__TpairlEconstsPcharmUcOdoublegR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const char*,void*> */
static int G__G__Base3_272_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const char*,void*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const char*,void*>[n];
     } else {
       p = new((void*) gvp) pair<const char*,void*>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const char*,void*>;
     } else {
       p = new((void*) gvp) pair<const char*,void*>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_272_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const char*,void*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const char*,void*>(libp->para[0].ref ? *(const char**) libp->para[0].ref : *(const char**) (&G__Mlong(libp->para[0])), libp->para[1].ref ? *(void**) libp->para[1].ref : *(void**) (&G__Mlong(libp->para[1])));
   } else {
     p = new((void*) gvp) pair<const char*,void*>(libp->para[0].ref ? *(const char**) libp->para[0].ref : *(const char**) (&G__Mlong(libp->para[0])), libp->para[1].ref ? *(void**) libp->para[1].ref : *(void**) (&G__Mlong(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_272_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const char*,void*>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const char*,void*>(*(pair<const char*,void*>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const char*,void*> G__TpairlEconstsPcharmUcOvoidmUgR;
static int G__G__Base3_272_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const char*,void*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const char*,void*>*) (soff+(sizeof(pair<const char*,void*>)*i)))->~G__TpairlEconstsPcharmUcOvoidmUgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const char*,void*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const char*,void*>*) (soff))->~G__TpairlEconstsPcharmUcOvoidmUgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const char*,char*> */
static int G__G__Base3_273_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const char*,char*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const char*,char*>[n];
     } else {
       p = new((void*) gvp) pair<const char*,char*>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const char*,char*>;
     } else {
       p = new((void*) gvp) pair<const char*,char*>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_273_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const char*,char*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const char*,char*>(libp->para[0].ref ? *(const char**) libp->para[0].ref : *(const char**) (&G__Mlong(libp->para[0])), libp->para[1].ref ? *(char**) libp->para[1].ref : *(char**) (&G__Mlong(libp->para[1])));
   } else {
     p = new((void*) gvp) pair<const char*,char*>(libp->para[0].ref ? *(const char**) libp->para[0].ref : *(const char**) (&G__Mlong(libp->para[0])), libp->para[1].ref ? *(char**) libp->para[1].ref : *(char**) (&G__Mlong(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_273_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const char*,char*>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const char*,char*>(*(pair<const char*,char*>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const char*,char*> G__TpairlEconstsPcharmUcOcharmUgR;
static int G__G__Base3_273_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const char*,char*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const char*,char*>*) (soff+(sizeof(pair<const char*,char*>)*i)))->~G__TpairlEconstsPcharmUcOcharmUgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const char*,char*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const char*,char*>*) (soff))->~G__TpairlEconstsPcharmUcOcharmUgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const string,int> */
static int G__G__Base3_274_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const string,int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const string,int>[n];
     } else {
       p = new((void*) gvp) pair<const string,int>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const string,int>;
     } else {
       p = new((void*) gvp) pair<const string,int>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_274_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const string,int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const string,int>(*(string*) libp->para[0].ref, *(int*) G__Intref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<const string,int>(*(string*) libp->para[0].ref, *(int*) G__Intref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_274_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const string,int>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const string,int>(*(pair<const string,int>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const string,int> G__TpairlEconstsPstringcOintgR;
static int G__G__Base3_274_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const string,int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const string,int>*) (soff+(sizeof(pair<const string,int>)*i)))->~G__TpairlEconstsPstringcOintgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const string,int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const string,int>*) (soff))->~G__TpairlEconstsPstringcOintgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const string,long> */
static int G__G__Base3_275_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const string,long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const string,long>[n];
     } else {
       p = new((void*) gvp) pair<const string,long>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const string,long>;
     } else {
       p = new((void*) gvp) pair<const string,long>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_275_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const string,long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const string,long>(*(string*) libp->para[0].ref, *(long*) G__Longref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<const string,long>(*(string*) libp->para[0].ref, *(long*) G__Longref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_275_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const string,long>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const string,long>(*(pair<const string,long>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const string,long> G__TpairlEconstsPstringcOlonggR;
static int G__G__Base3_275_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const string,long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const string,long>*) (soff+(sizeof(pair<const string,long>)*i)))->~G__TpairlEconstsPstringcOlonggR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const string,long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const string,long>*) (soff))->~G__TpairlEconstsPstringcOlonggR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const string,float> */
static int G__G__Base3_276_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const string,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const string,float>[n];
     } else {
       p = new((void*) gvp) pair<const string,float>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const string,float>;
     } else {
       p = new((void*) gvp) pair<const string,float>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_276_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const string,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const string,float>(*(string*) libp->para[0].ref, *(float*) G__Floatref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<const string,float>(*(string*) libp->para[0].ref, *(float*) G__Floatref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_276_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const string,float>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const string,float>(*(pair<const string,float>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const string,float> G__TpairlEconstsPstringcOfloatgR;
static int G__G__Base3_276_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const string,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const string,float>*) (soff+(sizeof(pair<const string,float>)*i)))->~G__TpairlEconstsPstringcOfloatgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const string,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const string,float>*) (soff))->~G__TpairlEconstsPstringcOfloatgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const string,double> */
static int G__G__Base3_277_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const string,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const string,double>[n];
     } else {
       p = new((void*) gvp) pair<const string,double>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const string,double>;
     } else {
       p = new((void*) gvp) pair<const string,double>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_277_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const string,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const string,double>(*(string*) libp->para[0].ref, *(double*) G__Doubleref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<const string,double>(*(string*) libp->para[0].ref, *(double*) G__Doubleref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_277_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const string,double>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const string,double>(*(pair<const string,double>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const string,double> G__TpairlEconstsPstringcOdoublegR;
static int G__G__Base3_277_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const string,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const string,double>*) (soff+(sizeof(pair<const string,double>)*i)))->~G__TpairlEconstsPstringcOdoublegR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const string,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const string,double>*) (soff))->~G__TpairlEconstsPstringcOdoublegR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const string,void*> */
static int G__G__Base3_278_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const string,void*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const string,void*>[n];
     } else {
       p = new((void*) gvp) pair<const string,void*>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const string,void*>;
     } else {
       p = new((void*) gvp) pair<const string,void*>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_278_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const string,void*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const string,void*>(*(string*) libp->para[0].ref, libp->para[1].ref ? *(void**) libp->para[1].ref : *(void**) (&G__Mlong(libp->para[1])));
   } else {
     p = new((void*) gvp) pair<const string,void*>(*(string*) libp->para[0].ref, libp->para[1].ref ? *(void**) libp->para[1].ref : *(void**) (&G__Mlong(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_278_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const string,void*>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const string,void*>(*(pair<const string,void*>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const string,void*> G__TpairlEconstsPstringcOvoidmUgR;
static int G__G__Base3_278_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const string,void*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const string,void*>*) (soff+(sizeof(pair<const string,void*>)*i)))->~G__TpairlEconstsPstringcOvoidmUgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const string,void*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const string,void*>*) (soff))->~G__TpairlEconstsPstringcOvoidmUgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const int,int> */
static int G__G__Base3_279_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const int,int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const int,int>[n];
     } else {
       p = new((void*) gvp) pair<const int,int>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const int,int>;
     } else {
       p = new((void*) gvp) pair<const int,int>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_279_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const int,int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const int,int>(*(int*) G__Intref(&libp->para[0]), *(int*) G__Intref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<const int,int>(*(int*) G__Intref(&libp->para[0]), *(int*) G__Intref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_279_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const int,int>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const int,int>(*(pair<const int,int>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const int,int> G__TpairlEconstsPintcOintgR;
static int G__G__Base3_279_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const int,int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const int,int>*) (soff+(sizeof(pair<const int,int>)*i)))->~G__TpairlEconstsPintcOintgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const int,int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const int,int>*) (soff))->~G__TpairlEconstsPintcOintgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const int,long> */
static int G__G__Base3_280_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const int,long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const int,long>[n];
     } else {
       p = new((void*) gvp) pair<const int,long>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const int,long>;
     } else {
       p = new((void*) gvp) pair<const int,long>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_280_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const int,long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const int,long>(*(int*) G__Intref(&libp->para[0]), *(long*) G__Longref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<const int,long>(*(int*) G__Intref(&libp->para[0]), *(long*) G__Longref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_280_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const int,long>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const int,long>(*(pair<const int,long>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const int,long> G__TpairlEconstsPintcOlonggR;
static int G__G__Base3_280_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const int,long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const int,long>*) (soff+(sizeof(pair<const int,long>)*i)))->~G__TpairlEconstsPintcOlonggR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const int,long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const int,long>*) (soff))->~G__TpairlEconstsPintcOlonggR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const int,float> */
static int G__G__Base3_281_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const int,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const int,float>[n];
     } else {
       p = new((void*) gvp) pair<const int,float>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const int,float>;
     } else {
       p = new((void*) gvp) pair<const int,float>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_281_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const int,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const int,float>(*(int*) G__Intref(&libp->para[0]), *(float*) G__Floatref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<const int,float>(*(int*) G__Intref(&libp->para[0]), *(float*) G__Floatref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_281_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const int,float>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const int,float>(*(pair<const int,float>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const int,float> G__TpairlEconstsPintcOfloatgR;
static int G__G__Base3_281_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const int,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const int,float>*) (soff+(sizeof(pair<const int,float>)*i)))->~G__TpairlEconstsPintcOfloatgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const int,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const int,float>*) (soff))->~G__TpairlEconstsPintcOfloatgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const int,double> */
static int G__G__Base3_282_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const int,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const int,double>[n];
     } else {
       p = new((void*) gvp) pair<const int,double>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const int,double>;
     } else {
       p = new((void*) gvp) pair<const int,double>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_282_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const int,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const int,double>(*(int*) G__Intref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<const int,double>(*(int*) G__Intref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_282_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const int,double>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const int,double>(*(pair<const int,double>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const int,double> G__TpairlEconstsPintcOdoublegR;
static int G__G__Base3_282_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const int,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const int,double>*) (soff+(sizeof(pair<const int,double>)*i)))->~G__TpairlEconstsPintcOdoublegR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const int,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const int,double>*) (soff))->~G__TpairlEconstsPintcOdoublegR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const int,void*> */
static int G__G__Base3_283_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const int,void*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const int,void*>[n];
     } else {
       p = new((void*) gvp) pair<const int,void*>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const int,void*>;
     } else {
       p = new((void*) gvp) pair<const int,void*>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_283_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const int,void*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const int,void*>(*(int*) G__Intref(&libp->para[0]), libp->para[1].ref ? *(void**) libp->para[1].ref : *(void**) (&G__Mlong(libp->para[1])));
   } else {
     p = new((void*) gvp) pair<const int,void*>(*(int*) G__Intref(&libp->para[0]), libp->para[1].ref ? *(void**) libp->para[1].ref : *(void**) (&G__Mlong(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_283_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const int,void*>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const int,void*>(*(pair<const int,void*>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const int,void*> G__TpairlEconstsPintcOvoidmUgR;
static int G__G__Base3_283_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const int,void*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const int,void*>*) (soff+(sizeof(pair<const int,void*>)*i)))->~G__TpairlEconstsPintcOvoidmUgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const int,void*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const int,void*>*) (soff))->~G__TpairlEconstsPintcOvoidmUgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const int,char*> */
static int G__G__Base3_284_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const int,char*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const int,char*>[n];
     } else {
       p = new((void*) gvp) pair<const int,char*>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const int,char*>;
     } else {
       p = new((void*) gvp) pair<const int,char*>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_284_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const int,char*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const int,char*>(*(int*) G__Intref(&libp->para[0]), libp->para[1].ref ? *(char**) libp->para[1].ref : *(char**) (&G__Mlong(libp->para[1])));
   } else {
     p = new((void*) gvp) pair<const int,char*>(*(int*) G__Intref(&libp->para[0]), libp->para[1].ref ? *(char**) libp->para[1].ref : *(char**) (&G__Mlong(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_284_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const int,char*>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const int,char*>(*(pair<const int,char*>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const int,char*> G__TpairlEconstsPintcOcharmUgR;
static int G__G__Base3_284_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const int,char*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const int,char*>*) (soff+(sizeof(pair<const int,char*>)*i)))->~G__TpairlEconstsPintcOcharmUgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const int,char*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const int,char*>*) (soff))->~G__TpairlEconstsPintcOcharmUgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const long,int> */
static int G__G__Base3_285_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const long,int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const long,int>[n];
     } else {
       p = new((void*) gvp) pair<const long,int>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const long,int>;
     } else {
       p = new((void*) gvp) pair<const long,int>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_285_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const long,int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const long,int>(*(long*) G__Longref(&libp->para[0]), *(int*) G__Intref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<const long,int>(*(long*) G__Longref(&libp->para[0]), *(int*) G__Intref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_285_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const long,int>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const long,int>(*(pair<const long,int>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const long,int> G__TpairlEconstsPlongcOintgR;
static int G__G__Base3_285_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const long,int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const long,int>*) (soff+(sizeof(pair<const long,int>)*i)))->~G__TpairlEconstsPlongcOintgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const long,int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const long,int>*) (soff))->~G__TpairlEconstsPlongcOintgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const long,long> */
static int G__G__Base3_286_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const long,long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const long,long>[n];
     } else {
       p = new((void*) gvp) pair<const long,long>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const long,long>;
     } else {
       p = new((void*) gvp) pair<const long,long>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_286_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const long,long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const long,long>(*(long*) G__Longref(&libp->para[0]), *(long*) G__Longref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<const long,long>(*(long*) G__Longref(&libp->para[0]), *(long*) G__Longref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_286_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const long,long>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const long,long>(*(pair<const long,long>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const long,long> G__TpairlEconstsPlongcOlonggR;
static int G__G__Base3_286_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const long,long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const long,long>*) (soff+(sizeof(pair<const long,long>)*i)))->~G__TpairlEconstsPlongcOlonggR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const long,long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const long,long>*) (soff))->~G__TpairlEconstsPlongcOlonggR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const long,float> */
static int G__G__Base3_287_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const long,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const long,float>[n];
     } else {
       p = new((void*) gvp) pair<const long,float>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const long,float>;
     } else {
       p = new((void*) gvp) pair<const long,float>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_287_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const long,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const long,float>(*(long*) G__Longref(&libp->para[0]), *(float*) G__Floatref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<const long,float>(*(long*) G__Longref(&libp->para[0]), *(float*) G__Floatref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_287_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const long,float>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const long,float>(*(pair<const long,float>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const long,float> G__TpairlEconstsPlongcOfloatgR;
static int G__G__Base3_287_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const long,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const long,float>*) (soff+(sizeof(pair<const long,float>)*i)))->~G__TpairlEconstsPlongcOfloatgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const long,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const long,float>*) (soff))->~G__TpairlEconstsPlongcOfloatgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const long,double> */
static int G__G__Base3_288_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const long,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const long,double>[n];
     } else {
       p = new((void*) gvp) pair<const long,double>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const long,double>;
     } else {
       p = new((void*) gvp) pair<const long,double>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_288_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const long,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const long,double>(*(long*) G__Longref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<const long,double>(*(long*) G__Longref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_288_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const long,double>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const long,double>(*(pair<const long,double>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const long,double> G__TpairlEconstsPlongcOdoublegR;
static int G__G__Base3_288_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const long,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const long,double>*) (soff+(sizeof(pair<const long,double>)*i)))->~G__TpairlEconstsPlongcOdoublegR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const long,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const long,double>*) (soff))->~G__TpairlEconstsPlongcOdoublegR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const long,void*> */
static int G__G__Base3_289_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const long,void*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const long,void*>[n];
     } else {
       p = new((void*) gvp) pair<const long,void*>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const long,void*>;
     } else {
       p = new((void*) gvp) pair<const long,void*>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_289_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const long,void*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const long,void*>(*(long*) G__Longref(&libp->para[0]), libp->para[1].ref ? *(void**) libp->para[1].ref : *(void**) (&G__Mlong(libp->para[1])));
   } else {
     p = new((void*) gvp) pair<const long,void*>(*(long*) G__Longref(&libp->para[0]), libp->para[1].ref ? *(void**) libp->para[1].ref : *(void**) (&G__Mlong(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_289_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const long,void*>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const long,void*>(*(pair<const long,void*>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const long,void*> G__TpairlEconstsPlongcOvoidmUgR;
static int G__G__Base3_289_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const long,void*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const long,void*>*) (soff+(sizeof(pair<const long,void*>)*i)))->~G__TpairlEconstsPlongcOvoidmUgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const long,void*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const long,void*>*) (soff))->~G__TpairlEconstsPlongcOvoidmUgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const long,char*> */
static int G__G__Base3_290_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const long,char*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const long,char*>[n];
     } else {
       p = new((void*) gvp) pair<const long,char*>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const long,char*>;
     } else {
       p = new((void*) gvp) pair<const long,char*>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_290_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const long,char*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const long,char*>(*(long*) G__Longref(&libp->para[0]), libp->para[1].ref ? *(char**) libp->para[1].ref : *(char**) (&G__Mlong(libp->para[1])));
   } else {
     p = new((void*) gvp) pair<const long,char*>(*(long*) G__Longref(&libp->para[0]), libp->para[1].ref ? *(char**) libp->para[1].ref : *(char**) (&G__Mlong(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_290_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const long,char*>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const long,char*>(*(pair<const long,char*>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const long,char*> G__TpairlEconstsPlongcOcharmUgR;
static int G__G__Base3_290_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const long,char*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const long,char*>*) (soff+(sizeof(pair<const long,char*>)*i)))->~G__TpairlEconstsPlongcOcharmUgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const long,char*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const long,char*>*) (soff))->~G__TpairlEconstsPlongcOcharmUgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const float,int> */
static int G__G__Base3_291_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const float,int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const float,int>[n];
     } else {
       p = new((void*) gvp) pair<const float,int>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const float,int>;
     } else {
       p = new((void*) gvp) pair<const float,int>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_291_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const float,int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const float,int>(*(float*) G__Floatref(&libp->para[0]), *(int*) G__Intref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<const float,int>(*(float*) G__Floatref(&libp->para[0]), *(int*) G__Intref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_291_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const float,int>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const float,int>(*(pair<const float,int>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const float,int> G__TpairlEconstsPfloatcOintgR;
static int G__G__Base3_291_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const float,int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const float,int>*) (soff+(sizeof(pair<const float,int>)*i)))->~G__TpairlEconstsPfloatcOintgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const float,int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const float,int>*) (soff))->~G__TpairlEconstsPfloatcOintgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const float,long> */
static int G__G__Base3_292_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const float,long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const float,long>[n];
     } else {
       p = new((void*) gvp) pair<const float,long>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const float,long>;
     } else {
       p = new((void*) gvp) pair<const float,long>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_292_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const float,long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const float,long>(*(float*) G__Floatref(&libp->para[0]), *(long*) G__Longref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<const float,long>(*(float*) G__Floatref(&libp->para[0]), *(long*) G__Longref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_292_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const float,long>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const float,long>(*(pair<const float,long>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const float,long> G__TpairlEconstsPfloatcOlonggR;
static int G__G__Base3_292_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const float,long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const float,long>*) (soff+(sizeof(pair<const float,long>)*i)))->~G__TpairlEconstsPfloatcOlonggR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const float,long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const float,long>*) (soff))->~G__TpairlEconstsPfloatcOlonggR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const float,float> */
static int G__G__Base3_293_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const float,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const float,float>[n];
     } else {
       p = new((void*) gvp) pair<const float,float>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const float,float>;
     } else {
       p = new((void*) gvp) pair<const float,float>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_293_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const float,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const float,float>(*(float*) G__Floatref(&libp->para[0]), *(float*) G__Floatref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<const float,float>(*(float*) G__Floatref(&libp->para[0]), *(float*) G__Floatref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_293_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const float,float>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const float,float>(*(pair<const float,float>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const float,float> G__TpairlEconstsPfloatcOfloatgR;
static int G__G__Base3_293_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const float,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const float,float>*) (soff+(sizeof(pair<const float,float>)*i)))->~G__TpairlEconstsPfloatcOfloatgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const float,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const float,float>*) (soff))->~G__TpairlEconstsPfloatcOfloatgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const float,double> */
static int G__G__Base3_294_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const float,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const float,double>[n];
     } else {
       p = new((void*) gvp) pair<const float,double>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const float,double>;
     } else {
       p = new((void*) gvp) pair<const float,double>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_294_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const float,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const float,double>(*(float*) G__Floatref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<const float,double>(*(float*) G__Floatref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_294_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const float,double>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const float,double>(*(pair<const float,double>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const float,double> G__TpairlEconstsPfloatcOdoublegR;
static int G__G__Base3_294_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const float,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const float,double>*) (soff+(sizeof(pair<const float,double>)*i)))->~G__TpairlEconstsPfloatcOdoublegR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const float,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const float,double>*) (soff))->~G__TpairlEconstsPfloatcOdoublegR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const float,void*> */
static int G__G__Base3_295_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const float,void*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const float,void*>[n];
     } else {
       p = new((void*) gvp) pair<const float,void*>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const float,void*>;
     } else {
       p = new((void*) gvp) pair<const float,void*>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_295_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const float,void*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const float,void*>(*(float*) G__Floatref(&libp->para[0]), libp->para[1].ref ? *(void**) libp->para[1].ref : *(void**) (&G__Mlong(libp->para[1])));
   } else {
     p = new((void*) gvp) pair<const float,void*>(*(float*) G__Floatref(&libp->para[0]), libp->para[1].ref ? *(void**) libp->para[1].ref : *(void**) (&G__Mlong(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_295_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const float,void*>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const float,void*>(*(pair<const float,void*>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const float,void*> G__TpairlEconstsPfloatcOvoidmUgR;
static int G__G__Base3_295_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const float,void*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const float,void*>*) (soff+(sizeof(pair<const float,void*>)*i)))->~G__TpairlEconstsPfloatcOvoidmUgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const float,void*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const float,void*>*) (soff))->~G__TpairlEconstsPfloatcOvoidmUgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const float,char*> */
static int G__G__Base3_296_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const float,char*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const float,char*>[n];
     } else {
       p = new((void*) gvp) pair<const float,char*>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const float,char*>;
     } else {
       p = new((void*) gvp) pair<const float,char*>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_296_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const float,char*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const float,char*>(*(float*) G__Floatref(&libp->para[0]), libp->para[1].ref ? *(char**) libp->para[1].ref : *(char**) (&G__Mlong(libp->para[1])));
   } else {
     p = new((void*) gvp) pair<const float,char*>(*(float*) G__Floatref(&libp->para[0]), libp->para[1].ref ? *(char**) libp->para[1].ref : *(char**) (&G__Mlong(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_296_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const float,char*>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const float,char*>(*(pair<const float,char*>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const float,char*> G__TpairlEconstsPfloatcOcharmUgR;
static int G__G__Base3_296_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const float,char*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const float,char*>*) (soff+(sizeof(pair<const float,char*>)*i)))->~G__TpairlEconstsPfloatcOcharmUgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const float,char*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const float,char*>*) (soff))->~G__TpairlEconstsPfloatcOcharmUgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const double,int> */
static int G__G__Base3_297_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const double,int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const double,int>[n];
     } else {
       p = new((void*) gvp) pair<const double,int>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const double,int>;
     } else {
       p = new((void*) gvp) pair<const double,int>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_297_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const double,int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const double,int>(*(double*) G__Doubleref(&libp->para[0]), *(int*) G__Intref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<const double,int>(*(double*) G__Doubleref(&libp->para[0]), *(int*) G__Intref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_297_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const double,int>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const double,int>(*(pair<const double,int>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const double,int> G__TpairlEconstsPdoublecOintgR;
static int G__G__Base3_297_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const double,int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const double,int>*) (soff+(sizeof(pair<const double,int>)*i)))->~G__TpairlEconstsPdoublecOintgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const double,int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const double,int>*) (soff))->~G__TpairlEconstsPdoublecOintgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const double,long> */
static int G__G__Base3_298_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const double,long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const double,long>[n];
     } else {
       p = new((void*) gvp) pair<const double,long>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const double,long>;
     } else {
       p = new((void*) gvp) pair<const double,long>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_298_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const double,long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const double,long>(*(double*) G__Doubleref(&libp->para[0]), *(long*) G__Longref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<const double,long>(*(double*) G__Doubleref(&libp->para[0]), *(long*) G__Longref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_298_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const double,long>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const double,long>(*(pair<const double,long>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const double,long> G__TpairlEconstsPdoublecOlonggR;
static int G__G__Base3_298_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const double,long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const double,long>*) (soff+(sizeof(pair<const double,long>)*i)))->~G__TpairlEconstsPdoublecOlonggR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const double,long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const double,long>*) (soff))->~G__TpairlEconstsPdoublecOlonggR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const double,float> */
static int G__G__Base3_299_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const double,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const double,float>[n];
     } else {
       p = new((void*) gvp) pair<const double,float>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const double,float>;
     } else {
       p = new((void*) gvp) pair<const double,float>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_299_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const double,float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const double,float>(*(double*) G__Doubleref(&libp->para[0]), *(float*) G__Floatref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<const double,float>(*(double*) G__Doubleref(&libp->para[0]), *(float*) G__Floatref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_299_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const double,float>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const double,float>(*(pair<const double,float>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const double,float> G__TpairlEconstsPdoublecOfloatgR;
static int G__G__Base3_299_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const double,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const double,float>*) (soff+(sizeof(pair<const double,float>)*i)))->~G__TpairlEconstsPdoublecOfloatgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const double,float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const double,float>*) (soff))->~G__TpairlEconstsPdoublecOfloatgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const double,double> */
static int G__G__Base3_300_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const double,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const double,double>[n];
     } else {
       p = new((void*) gvp) pair<const double,double>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const double,double>;
     } else {
       p = new((void*) gvp) pair<const double,double>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_300_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const double,double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const double,double>(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
   } else {
     p = new((void*) gvp) pair<const double,double>(*(double*) G__Doubleref(&libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_300_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const double,double>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const double,double>(*(pair<const double,double>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const double,double> G__TpairlEconstsPdoublecOdoublegR;
static int G__G__Base3_300_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const double,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const double,double>*) (soff+(sizeof(pair<const double,double>)*i)))->~G__TpairlEconstsPdoublecOdoublegR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const double,double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const double,double>*) (soff))->~G__TpairlEconstsPdoublecOdoublegR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const double,void*> */
static int G__G__Base3_301_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const double,void*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const double,void*>[n];
     } else {
       p = new((void*) gvp) pair<const double,void*>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const double,void*>;
     } else {
       p = new((void*) gvp) pair<const double,void*>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_301_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const double,void*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const double,void*>(*(double*) G__Doubleref(&libp->para[0]), libp->para[1].ref ? *(void**) libp->para[1].ref : *(void**) (&G__Mlong(libp->para[1])));
   } else {
     p = new((void*) gvp) pair<const double,void*>(*(double*) G__Doubleref(&libp->para[0]), libp->para[1].ref ? *(void**) libp->para[1].ref : *(void**) (&G__Mlong(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_301_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const double,void*>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const double,void*>(*(pair<const double,void*>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOvoidmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const double,void*> G__TpairlEconstsPdoublecOvoidmUgR;
static int G__G__Base3_301_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const double,void*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const double,void*>*) (soff+(sizeof(pair<const double,void*>)*i)))->~G__TpairlEconstsPdoublecOvoidmUgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const double,void*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const double,void*>*) (soff))->~G__TpairlEconstsPdoublecOvoidmUgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<const double,char*> */
static int G__G__Base3_302_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const double,char*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const double,char*>[n];
     } else {
       p = new((void*) gvp) pair<const double,char*>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<const double,char*>;
     } else {
       p = new((void*) gvp) pair<const double,char*>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_302_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<const double,char*>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<const double,char*>(*(double*) G__Doubleref(&libp->para[0]), libp->para[1].ref ? *(char**) libp->para[1].ref : *(char**) (&G__Mlong(libp->para[1])));
   } else {
     p = new((void*) gvp) pair<const double,char*>(*(double*) G__Doubleref(&libp->para[0]), libp->para[1].ref ? *(char**) libp->para[1].ref : *(char**) (&G__Mlong(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_302_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<const double,char*>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<const double,char*>(*(pair<const double,char*>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOcharmUgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<const double,char*> G__TpairlEconstsPdoublecOcharmUgR;
static int G__G__Base3_302_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<const double,char*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<const double,char*>*) (soff+(sizeof(pair<const double,char*>)*i)))->~G__TpairlEconstsPdoublecOcharmUgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<const double,char*>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<const double,char*>*) (soff))->~G__TpairlEconstsPdoublecOcharmUgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TParameter<float> */
static int G__G__Base3_303_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TParameter<float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TParameter<float>[n];
     } else {
       p = new((void*) gvp) TParameter<float>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TParameter<float>;
     } else {
       p = new((void*) gvp) TParameter<float>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TParameterlEfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_303_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TParameter<float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TParameter<float>((const char*) G__int(libp->para[0]), *(float*) G__Floatref(&libp->para[1]));
   } else {
     p = new((void*) gvp) TParameter<float>((const char*) G__int(libp->para[0]), *(float*) G__Floatref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TParameterlEfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_303_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const float& obj = ((const TParameter<float>*) G__getstructoffset())->GetVal();
         result7->ref = (long) (&obj);
         result7->obj.d = (double) (obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_303_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TParameter<float>*) G__getstructoffset())->SetVal(*(float*) G__Floatref(&libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_303_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TParameter<float>::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_303_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TParameter<float>::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_303_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TParameter<float>::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_303_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TParameter<float>::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_303_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TParameter<float>*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_303_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TParameter<float>::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_303_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TParameter<float>::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_303_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TParameter<float>::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_303_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TParameter<float>::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_303_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TParameter<float>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TParameter<float>(*(TParameter<float>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TParameterlEfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TParameter<float> G__TTParameterlEfloatgR;
static int G__G__Base3_303_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TParameter<float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TParameter<float>*) (soff+(sizeof(TParameter<float>)*i)))->~G__TTParameterlEfloatgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TParameter<float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TParameter<float>*) (soff))->~G__TTParameterlEfloatgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Base3_303_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TParameter<float>* dest = (TParameter<float>*) G__getstructoffset();
   *dest = *(TParameter<float>*) libp->para[0].ref;
   const TParameter<float>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TParameter<double> */
static int G__G__Base3_304_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TParameter<double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TParameter<double>[n];
     } else {
       p = new((void*) gvp) TParameter<double>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TParameter<double>;
     } else {
       p = new((void*) gvp) TParameter<double>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TParameterlEdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_304_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TParameter<double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TParameter<double>((const char*) G__int(libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
   } else {
     p = new((void*) gvp) TParameter<double>((const char*) G__int(libp->para[0]), *(double*) G__Doubleref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TParameterlEdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_304_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const double& obj = ((const TParameter<double>*) G__getstructoffset())->GetVal();
         result7->ref = (long) (&obj);
         result7->obj.d = (double) (obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_304_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TParameter<double>*) G__getstructoffset())->SetVal(*(double*) G__Doubleref(&libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_304_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TParameter<double>::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_304_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TParameter<double>::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_304_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TParameter<double>::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_304_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TParameter<double>::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_304_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TParameter<double>*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_304_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TParameter<double>::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_304_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TParameter<double>::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_304_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TParameter<double>::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_304_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TParameter<double>::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_304_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TParameter<double>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TParameter<double>(*(TParameter<double>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TParameterlEdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TParameter<double> G__TTParameterlEdoublegR;
static int G__G__Base3_304_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TParameter<double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TParameter<double>*) (soff+(sizeof(TParameter<double>)*i)))->~G__TTParameterlEdoublegR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TParameter<double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TParameter<double>*) (soff))->~G__TTParameterlEdoublegR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Base3_304_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TParameter<double>* dest = (TParameter<double>*) G__getstructoffset();
   *dest = *(TParameter<double>*) libp->para[0].ref;
   const TParameter<double>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TParameter<int> */
static int G__G__Base3_305_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TParameter<int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TParameter<int>[n];
     } else {
       p = new((void*) gvp) TParameter<int>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TParameter<int>;
     } else {
       p = new((void*) gvp) TParameter<int>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TParameterlEintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_305_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TParameter<int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TParameter<int>((const char*) G__int(libp->para[0]), *(int*) G__Intref(&libp->para[1]));
   } else {
     p = new((void*) gvp) TParameter<int>((const char*) G__int(libp->para[0]), *(int*) G__Intref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TParameterlEintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_305_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const int& obj = ((const TParameter<int>*) G__getstructoffset())->GetVal();
         result7->ref = (long) (&obj);
         G__letint(result7, 'i', (long)obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_305_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TParameter<int>*) G__getstructoffset())->SetVal(*(int*) G__Intref(&libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_305_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TParameter<int>::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_305_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TParameter<int>::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_305_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TParameter<int>::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_305_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TParameter<int>::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_305_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TParameter<int>*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_305_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TParameter<int>::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_305_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TParameter<int>::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_305_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TParameter<int>::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_305_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TParameter<int>::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_305_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TParameter<int>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TParameter<int>(*(TParameter<int>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TParameterlEintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TParameter<int> G__TTParameterlEintgR;
static int G__G__Base3_305_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TParameter<int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TParameter<int>*) (soff+(sizeof(TParameter<int>)*i)))->~G__TTParameterlEintgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TParameter<int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TParameter<int>*) (soff))->~G__TTParameterlEintgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Base3_305_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TParameter<int>* dest = (TParameter<int>*) G__getstructoffset();
   *dest = *(TParameter<int>*) libp->para[0].ref;
   const TParameter<int>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TParameter<long> */
static int G__G__Base3_306_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TParameter<long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TParameter<long>[n];
     } else {
       p = new((void*) gvp) TParameter<long>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TParameter<long>;
     } else {
       p = new((void*) gvp) TParameter<long>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TParameterlElonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_306_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TParameter<long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TParameter<long>((const char*) G__int(libp->para[0]), *(long*) G__Longref(&libp->para[1]));
   } else {
     p = new((void*) gvp) TParameter<long>((const char*) G__int(libp->para[0]), *(long*) G__Longref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TParameterlElonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_306_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const long& obj = ((const TParameter<long>*) G__getstructoffset())->GetVal();
         result7->ref = (long) (&obj);
         G__letint(result7, 'l', (long)obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_306_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TParameter<long>*) G__getstructoffset())->SetVal(*(long*) G__Longref(&libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_306_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TParameter<long>::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_306_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TParameter<long>::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_306_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TParameter<long>::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_306_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TParameter<long>::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_306_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TParameter<long>*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_306_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TParameter<long>::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_306_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TParameter<long>::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_306_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TParameter<long>::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_306_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TParameter<long>::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_306_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TParameter<long>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TParameter<long>(*(TParameter<long>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TParameterlElonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TParameter<long> G__TTParameterlElonggR;
static int G__G__Base3_306_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TParameter<long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TParameter<long>*) (soff+(sizeof(TParameter<long>)*i)))->~G__TTParameterlElonggR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TParameter<long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TParameter<long>*) (soff))->~G__TTParameterlElonggR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Base3_306_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TParameter<long>* dest = (TParameter<long>*) G__getstructoffset();
   *dest = *(TParameter<long>*) libp->para[0].ref;
   const TParameter<long>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TParameter<long long> */
static int G__G__Base3_307_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TParameter<long long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TParameter<long long>[n];
     } else {
       p = new((void*) gvp) TParameter<long long>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TParameter<long long>;
     } else {
       p = new((void*) gvp) TParameter<long long>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TParameterlElongsPlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_307_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TParameter<long long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TParameter<long long>((const char*) G__int(libp->para[0]), *(long long*) G__Longlongref(&libp->para[1]));
   } else {
     p = new((void*) gvp) TParameter<long long>((const char*) G__int(libp->para[0]), *(long long*) G__Longlongref(&libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TParameterlElongsPlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_307_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const long long& obj = ((const TParameter<long long>*) G__getstructoffset())->GetVal();
         result7->ref = (long) (&obj);
         G__letint(result7, 'n', (long)obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_307_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TParameter<long long>*) G__getstructoffset())->SetVal(*(long long*) G__Longlongref(&libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_307_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) TParameter<long long>::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_307_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TParameter<long long>::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_307_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) TParameter<long long>::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_307_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      TParameter<long long>::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_307_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((TParameter<long long>*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_307_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TParameter<long long>::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_307_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TParameter<long long>::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_307_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) TParameter<long long>::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3_307_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) TParameter<long long>::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G__Base3_307_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TParameter<long long>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TParameter<long long>(*(TParameter<long long>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G__Base3LN_TParameterlElongsPlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TParameter<long long> G__TTParameterlElongsPlonggR;
static int G__G__Base3_307_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TParameter<long long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TParameter<long long>*) (soff+(sizeof(TParameter<long long>)*i)))->~G__TTParameterlElongsPlonggR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TParameter<long long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TParameter<long long>*) (soff))->~G__TTParameterlElongsPlonggR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G__Base3_307_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TParameter<long long>* dest = (TParameter<long long>*) G__getstructoffset();
   *dest = *(TParameter<long long>*) libp->para[0].ref;
   const TParameter<long long>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */
static int G__G__Base3__0_215(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ostream& obj = operator<<(*(ostream*) libp->para[0].ref, *(TTimeStamp*) libp->para[1].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3__0_216(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TBuffer& obj = operator<<(*(TBuffer*) libp->para[0].ref, *(TTimeStamp*) libp->para[1].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3__0_217(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TBuffer& obj = operator>>(*(TBuffer*) libp->para[0].ref, *(TTimeStamp*) libp->para[1].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3__0_218(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator==(*(TTimeStamp*) libp->para[0].ref, *(TTimeStamp*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3__0_219(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator!=(*(TTimeStamp*) libp->para[0].ref, *(TTimeStamp*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3__0_220(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator<(*(TTimeStamp*) libp->para[0].ref, *(TTimeStamp*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3__0_221(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator<=(*(TTimeStamp*) libp->para[0].ref, *(TTimeStamp*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3__0_222(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator>(*(TTimeStamp*) libp->para[0].ref, *(TTimeStamp*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3__0_223(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator>=(*(TTimeStamp*) libp->para[0].ref, *(TTimeStamp*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G__Base3__0_444(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator==(*(TUri*) libp->para[0].ref, *(TUri*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}


/*********************************************************
* Member function Stub
*********************************************************/

/* SetWindowAttributes_t */

/* WindowAttributes_t */

/* Event_t */

/* GCValues_t */

/* ColorStruct_t */

/* PictureAttributes_t */

/* Segment_t */

/* Point_t */

/* Rectangle_t */

/* timespec */

/* TVirtualMutex */

/* TTimeStamp */

/* TLockGuard */

/* TVirtualPerfStats */

/* TVirtualAuth */

/* TUrl */

/* TInetAddress */

/* TFileInfoMeta */

/* TFileInfo */

/* TFileCollection */

/* TRedirectOutputGuard */

/* TVirtualMonitoringWriter */

/* TVirtualMonitoringReader */

/* TObjectSpy */

/* TObjectRefSpy */

/* TUri */

/* TVirtualTableInterface */

/* TBase64 */

/* pair<char*,int> */

/* pair<char*,long> */

/* pair<char*,float> */

/* pair<char*,double> */

/* pair<char*,void*> */

/* pair<char*,char*> */

/* pair<string,int> */

/* pair<string,long> */

/* pair<string,float> */

/* pair<string,double> */

/* pair<string,void*> */

/* pair<int,int> */

/* pair<int,long> */

/* pair<int,float> */

/* pair<int,double> */

/* pair<int,void*> */

/* pair<int,char*> */

/* pair<long,int> */

/* pair<long,long> */

/* pair<long,float> */

/* pair<long,double> */

/* pair<long,void*> */

/* pair<long,char*> */

/* pair<float,int> */

/* pair<float,long> */

/* pair<float,float> */

/* pair<float,double> */

/* pair<float,void*> */

/* pair<float,char*> */

/* pair<double,int> */

/* pair<double,long> */

/* pair<double,float> */

/* pair<double,double> */

/* pair<double,void*> */

/* pair<double,char*> */

/* pair<const char*,int> */

/* pair<const char*,long> */

/* pair<const char*,float> */

/* pair<const char*,double> */

/* pair<const char*,void*> */

/* pair<const char*,char*> */

/* pair<const string,int> */

/* pair<const string,long> */

/* pair<const string,float> */

/* pair<const string,double> */

/* pair<const string,void*> */

/* pair<const int,int> */

/* pair<const int,long> */

/* pair<const int,float> */

/* pair<const int,double> */

/* pair<const int,void*> */

/* pair<const int,char*> */

/* pair<const long,int> */

/* pair<const long,long> */

/* pair<const long,float> */

/* pair<const long,double> */

/* pair<const long,void*> */

/* pair<const long,char*> */

/* pair<const float,int> */

/* pair<const float,long> */

/* pair<const float,float> */

/* pair<const float,double> */

/* pair<const float,void*> */

/* pair<const float,char*> */

/* pair<const double,int> */

/* pair<const double,long> */

/* pair<const double,float> */

/* pair<const double,double> */

/* pair<const double,void*> */

/* pair<const double,char*> */

/* TParameter<float> */

/* TParameter<double> */

/* TParameter<int> */

/* TParameter<long> */

/* TParameter<long long> */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfuncG__Base3 {
 public:
  G__Sizep2memfuncG__Base3(): p(&G__Sizep2memfuncG__Base3::sizep2memfunc) {}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfuncG__Base3::*p)();
};

size_t G__get_sizep2memfuncG__Base3()
{
  G__Sizep2memfuncG__Base3 a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */

/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritanceG__Base3() {

   /* Setting up class inheritance */
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__Base3LN_TVirtualMutex))) {
     TVirtualMutex *G__Lderived;
     G__Lderived=(TVirtualMutex*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualMutex),G__get_linked_tagnum(&G__G__Base3LN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__Base3LN_TVirtualPerfStats))) {
     TVirtualPerfStats *G__Lderived;
     G__Lderived=(TVirtualPerfStats*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualPerfStats),G__get_linked_tagnum(&G__G__Base3LN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__Base3LN_TUrl))) {
     TUrl *G__Lderived;
     G__Lderived=(TUrl*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__Base3LN_TUrl),G__get_linked_tagnum(&G__G__Base3LN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__Base3LN_TInetAddress))) {
     TInetAddress *G__Lderived;
     G__Lderived=(TInetAddress*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__Base3LN_TInetAddress),G__get_linked_tagnum(&G__G__Base3LN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__Base3LN_TFileInfoMeta))) {
     TFileInfoMeta *G__Lderived;
     G__Lderived=(TFileInfoMeta*)0x1000;
     {
       TNamed *G__Lpbase=(TNamed*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__Base3LN_TFileInfoMeta),G__get_linked_tagnum(&G__G__Base3LN_TNamed),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__Base3LN_TFileInfoMeta),G__get_linked_tagnum(&G__G__Base3LN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__Base3LN_TFileInfo))) {
     TFileInfo *G__Lderived;
     G__Lderived=(TFileInfo*)0x1000;
     {
       TNamed *G__Lpbase=(TNamed*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__Base3LN_TFileInfo),G__get_linked_tagnum(&G__G__Base3LN_TNamed),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__Base3LN_TFileInfo),G__get_linked_tagnum(&G__G__Base3LN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__Base3LN_TFileCollection))) {
     TFileCollection *G__Lderived;
     G__Lderived=(TFileCollection*)0x1000;
     {
       TNamed *G__Lpbase=(TNamed*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__Base3LN_TFileCollection),G__get_linked_tagnum(&G__G__Base3LN_TNamed),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__Base3LN_TFileCollection),G__get_linked_tagnum(&G__G__Base3LN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringWriter))) {
     TVirtualMonitoringWriter *G__Lderived;
     G__Lderived=(TVirtualMonitoringWriter*)0x1000;
     {
       TNamed *G__Lpbase=(TNamed*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringWriter),G__get_linked_tagnum(&G__G__Base3LN_TNamed),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringWriter),G__get_linked_tagnum(&G__G__Base3LN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringReader))) {
     TVirtualMonitoringReader *G__Lderived;
     G__Lderived=(TVirtualMonitoringReader*)0x1000;
     {
       TNamed *G__Lpbase=(TNamed*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringReader),G__get_linked_tagnum(&G__G__Base3LN_TNamed),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringReader),G__get_linked_tagnum(&G__G__Base3LN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__Base3LN_TObjectSpy))) {
     TObjectSpy *G__Lderived;
     G__Lderived=(TObjectSpy*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__Base3LN_TObjectSpy),G__get_linked_tagnum(&G__G__Base3LN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__Base3LN_TObjectRefSpy))) {
     TObjectRefSpy *G__Lderived;
     G__Lderived=(TObjectRefSpy*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__Base3LN_TObjectRefSpy),G__get_linked_tagnum(&G__G__Base3LN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__Base3LN_TUri))) {
     TUri *G__Lderived;
     G__Lderived=(TUri*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__Base3LN_TUri),G__get_linked_tagnum(&G__G__Base3LN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__Base3LN_TParameterlEfloatgR))) {
     TParameter<float> *G__Lderived;
     G__Lderived=(TParameter<float>*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__Base3LN_TParameterlEfloatgR),G__get_linked_tagnum(&G__G__Base3LN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__Base3LN_TParameterlEdoublegR))) {
     TParameter<double> *G__Lderived;
     G__Lderived=(TParameter<double>*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__Base3LN_TParameterlEdoublegR),G__get_linked_tagnum(&G__G__Base3LN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__Base3LN_TParameterlEintgR))) {
     TParameter<int> *G__Lderived;
     G__Lderived=(TParameter<int>*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__Base3LN_TParameterlEintgR),G__get_linked_tagnum(&G__G__Base3LN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__Base3LN_TParameterlElonggR))) {
     TParameter<long> *G__Lderived;
     G__Lderived=(TParameter<long>*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__Base3LN_TParameterlElonggR),G__get_linked_tagnum(&G__G__Base3LN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G__Base3LN_TParameterlElongsPlonggR))) {
     TParameter<long long> *G__Lderived;
     G__Lderived=(TParameter<long long>*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G__Base3LN_TParameterlElongsPlonggR),G__get_linked_tagnum(&G__G__Base3LN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetableG__Base3() {

   /* Setting up typedef entry */
   G__search_typename2("UChar_t",98,-1,0,-1);
   G__setnewtype(-1,"Unsigned Character 1 byte (unsigned char)",0);
   G__search_typename2("Int_t",105,-1,0,-1);
   G__setnewtype(-1,"Signed integer 4 bytes (int)",0);
   G__search_typename2("UInt_t",104,-1,0,-1);
   G__setnewtype(-1,"Unsigned integer 4 bytes (unsigned int)",0);
   G__search_typename2("Long_t",108,-1,0,-1);
   G__setnewtype(-1,"Signed long integer 4 bytes (long)",0);
   G__search_typename2("Float_t",102,-1,0,-1);
   G__setnewtype(-1,"Float 4 bytes (float)",0);
   G__search_typename2("Double_t",100,-1,0,-1);
   G__setnewtype(-1,"Double 8 bytes",0);
   G__search_typename2("Bool_t",103,-1,0,-1);
   G__setnewtype(-1,"Boolean (0=false, 1=true) (bool)",0);
   G__search_typename2("Version_t",115,-1,0,-1);
   G__setnewtype(-1,"Class version identifier (short)",0);
   G__search_typename2("Option_t",99,-1,256,-1);
   G__setnewtype(-1,"Option string (const char)",0);
   G__search_typename2("Long64_t",110,-1,0,-1);
   G__setnewtype(-1,"Portable signed long integer 8 bytes",0);
   G__search_typename2("vector<TSchemaHelper>",117,G__get_linked_tagnum(&G__G__Base3LN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__Base3LN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__Base3LN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__Base3LN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__Base3LN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__G__Base3LN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Handle_t",107,-1,0,-1);
   G__setnewtype(-1,"Generic resource handle",0);
   G__search_typename2("Display_t",107,-1,0,-1);
   G__setnewtype(-1,"Display handle",0);
   G__search_typename2("Visual_t",107,-1,0,-1);
   G__setnewtype(-1,"Visual handle",0);
   G__search_typename2("Window_t",107,-1,0,-1);
   G__setnewtype(-1,"Window handle",0);
   G__search_typename2("Pixmap_t",107,-1,0,-1);
   G__setnewtype(-1,"Pixmap handle",0);
   G__search_typename2("Drawable_t",107,-1,0,-1);
   G__setnewtype(-1,"Drawable handle",0);
   G__search_typename2("Region_t",107,-1,0,-1);
   G__setnewtype(-1,"Region handle",0);
   G__search_typename2("Colormap_t",107,-1,0,-1);
   G__setnewtype(-1,"Colormap handle",0);
   G__search_typename2("Cursor_t",107,-1,0,-1);
   G__setnewtype(-1,"Cursor handle",0);
   G__search_typename2("FontH_t",107,-1,0,-1);
   G__setnewtype(-1,"Font handle (as opposed to Font_t which is an index)",0);
   G__search_typename2("KeySym_t",107,-1,0,-1);
   G__setnewtype(-1,"Key symbol handle",0);
   G__search_typename2("Atom_t",107,-1,0,-1);
   G__setnewtype(-1,"WM token",0);
   G__search_typename2("GContext_t",107,-1,0,-1);
   G__setnewtype(-1,"Graphics context handle",0);
   G__search_typename2("FontStruct_t",107,-1,0,-1);
   G__setnewtype(-1,"Pointer to font structure",0);
   G__search_typename2("Mask_t",104,-1,0,-1);
   G__setnewtype(-1,"Structure mask type",0);
   G__search_typename2("Time_t",107,-1,0,-1);
   G__setnewtype(-1,"Event time",0);
   G__search_typename2("time_t",108,-1,0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("timespec_t",117,G__get_linked_tagnum(&G__G__Base3LN_timespec),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("tm_t",117,G__get_linked_tagnum(&G__G__Base3LN_tm),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<std::bidirectional_iterator_tag,TObject*,std::ptrdiff_t,const TObject**,const TObject*&>",117,G__get_linked_tagnum(&G__G__Base3LN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*>",117,G__get_linked_tagnum(&G__G__Base3LN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*,long>",117,G__get_linked_tagnum(&G__G__Base3LN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*,long,const TObject**>",117,G__get_linked_tagnum(&G__G__Base3LN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<UInt_t>",117,G__get_linked_tagnum(&G__G__Base3LN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__Base3LN_reverse_iteratorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__Base3LN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__Base3LN_reverse_iteratorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__Base3LN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<unsigned int>",117,G__get_linked_tagnum(&G__G__Base3LN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("AddressList_t",117,G__get_linked_tagnum(&G__G__Base3LN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR),0,G__get_linked_tagnum(&G__G__Base3LN_TInetAddress));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TString>",117,G__get_linked_tagnum(&G__G__Base3LN_vectorlETStringcOallocatorlETStringgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G__Base3LN_reverse_iteratorlEvectorlETStringcOallocatorlETStringgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__Base3LN_vectorlETStringcOallocatorlETStringgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G__Base3LN_reverse_iteratorlEvectorlETStringcOallocatorlETStringgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G__Base3LN_vectorlETStringcOallocatorlETStringgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("AliasList_t",117,G__get_linked_tagnum(&G__G__Base3LN_vectorlETStringcOallocatorlETStringgRsPgR),0,G__get_linked_tagnum(&G__G__Base3LN_TInetAddress));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pair<std::string,int>",117,G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOintgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TParameter<Float_t>",117,G__get_linked_tagnum(&G__G__Base3LN_TParameterlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TParameter<Double_t>",117,G__get_linked_tagnum(&G__G__Base3LN_TParameterlEdoublegR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TParameter<Int_t>",117,G__get_linked_tagnum(&G__G__Base3LN_TParameterlEintgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TParameter<Long_t>",117,G__get_linked_tagnum(&G__G__Base3LN_TParameterlElonggR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TParameter<Long64_t>",117,G__get_linked_tagnum(&G__G__Base3LN_TParameterlElongsPlonggR),0,-1);
   G__setnewtype(-1,NULL,0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* SetWindowAttributes_t */
static void G__setup_memvarSetWindowAttributes_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_SetWindowAttributes_t));
   { SetWindowAttributes_t *p; p=(SetWindowAttributes_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->fBackgroundPixmap)-(long)(p)),107,0,0,-1,G__defined_typename("Pixmap_t"),-1,1,"fBackgroundPixmap=",0,"background or kNone or kParentRelative");
   G__memvar_setup((void*)((long)(&p->fBackgroundPixel)-(long)(p)),107,0,0,-1,G__defined_typename("ULong_t"),-1,1,"fBackgroundPixel=",0,"background pixel");
   G__memvar_setup((void*)((long)(&p->fBorderPixmap)-(long)(p)),107,0,0,-1,G__defined_typename("Pixmap_t"),-1,1,"fBorderPixmap=",0,"border of the window");
   G__memvar_setup((void*)((long)(&p->fBorderPixel)-(long)(p)),107,0,0,-1,G__defined_typename("ULong_t"),-1,1,"fBorderPixel=",0,"border pixel value");
   G__memvar_setup((void*)((long)(&p->fBorderWidth)-(long)(p)),104,0,0,-1,G__defined_typename("UInt_t"),-1,1,"fBorderWidth=",0,"border width in pixels");
   G__memvar_setup((void*)((long)(&p->fBitGravity)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fBitGravity=",0,"one of bit gravity values");
   G__memvar_setup((void*)((long)(&p->fWinGravity)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fWinGravity=",0,"one of the window gravity values");
   G__memvar_setup((void*)((long)(&p->fBackingStore)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fBackingStore=",0,"kNotUseful, kWhenMapped, kAlways");
   G__memvar_setup((void*)((long)(&p->fBackingPlanes)-(long)(p)),107,0,0,-1,G__defined_typename("ULong_t"),-1,1,"fBackingPlanes=",0,"planes to be preseved if possible");
   G__memvar_setup((void*)((long)(&p->fBackingPixel)-(long)(p)),107,0,0,-1,G__defined_typename("ULong_t"),-1,1,"fBackingPixel=",0,"value to use in restoring planes");
   G__memvar_setup((void*)((long)(&p->fSaveUnder)-(long)(p)),103,0,0,-1,G__defined_typename("Bool_t"),-1,1,"fSaveUnder=",0,"should bits under be saved (popups)?");
   G__memvar_setup((void*)((long)(&p->fEventMask)-(long)(p)),108,0,0,-1,G__defined_typename("Long_t"),-1,1,"fEventMask=",0,"set of events that should be saved");
   G__memvar_setup((void*)((long)(&p->fDoNotPropagateMask)-(long)(p)),108,0,0,-1,G__defined_typename("Long_t"),-1,1,"fDoNotPropagateMask=",0,"set of events that should not propagate");
   G__memvar_setup((void*)((long)(&p->fOverrideRedirect)-(long)(p)),103,0,0,-1,G__defined_typename("Bool_t"),-1,1,"fOverrideRedirect=",0,"boolean value for override-redirect");
   G__memvar_setup((void*)((long)(&p->fColormap)-(long)(p)),107,0,0,-1,G__defined_typename("Colormap_t"),-1,1,"fColormap=",0,"color map to be associated with window");
   G__memvar_setup((void*)((long)(&p->fCursor)-(long)(p)),107,0,0,-1,G__defined_typename("Cursor_t"),-1,1,"fCursor=",0,"cursor to be displayed (or kNone)");
   G__memvar_setup((void*)((long)(&p->fMask)-(long)(p)),104,0,0,-1,G__defined_typename("Mask_t"),-1,1,"fMask=",0,"bit mask specifying which fields are valid");
   }
   G__tag_memvar_reset();
}


   /* WindowAttributes_t */
static void G__setup_memvarWindowAttributes_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_WindowAttributes_t));
   { WindowAttributes_t *p; p=(WindowAttributes_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->fX)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fX=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fY)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fY=",0,"location of window");
   G__memvar_setup((void*)((long)(&p->fWidth)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fWidth=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fHeight)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fHeight=",0,"width and height of window");
   G__memvar_setup((void*)((long)(&p->fBorderWidth)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fBorderWidth=",0,"border width of window");
   G__memvar_setup((void*)((long)(&p->fDepth)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fDepth=",0,"depth of window");
   G__memvar_setup((void*)((long)(&p->fVisual)-(long)(p)),89,0,0,-1,-1,-1,1,"fVisual=",0,"the associated visual structure");
   G__memvar_setup((void*)((long)(&p->fRoot)-(long)(p)),107,0,0,-1,G__defined_typename("Window_t"),-1,1,"fRoot=",0,"root of screen containing window");
   G__memvar_setup((void*)((long)(&p->fClass)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fClass=",0,"kInputOutput, kInputOnly");
   G__memvar_setup((void*)((long)(&p->fBitGravity)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fBitGravity=",0,"one of bit gravity values");
   G__memvar_setup((void*)((long)(&p->fWinGravity)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fWinGravity=",0,"one of the window gravity values");
   G__memvar_setup((void*)((long)(&p->fBackingStore)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fBackingStore=",0,"kNotUseful, kWhenMapped, kAlways");
   G__memvar_setup((void*)((long)(&p->fBackingPlanes)-(long)(p)),107,0,0,-1,G__defined_typename("ULong_t"),-1,1,"fBackingPlanes=",0,"planes to be preserved if possible");
   G__memvar_setup((void*)((long)(&p->fBackingPixel)-(long)(p)),107,0,0,-1,G__defined_typename("ULong_t"),-1,1,"fBackingPixel=",0,"value to be used when restoring planes");
   G__memvar_setup((void*)((long)(&p->fSaveUnder)-(long)(p)),103,0,0,-1,G__defined_typename("Bool_t"),-1,1,"fSaveUnder=",0,"boolean, should bits under be saved?");
   G__memvar_setup((void*)((long)(&p->fColormap)-(long)(p)),107,0,0,-1,G__defined_typename("Colormap_t"),-1,1,"fColormap=",0,"color map to be associated with window");
   G__memvar_setup((void*)((long)(&p->fMapInstalled)-(long)(p)),103,0,0,-1,G__defined_typename("Bool_t"),-1,1,"fMapInstalled=",0,"boolean, is color map currently installed");
   G__memvar_setup((void*)((long)(&p->fMapState)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fMapState=",0,"kIsUnmapped, kIsUnviewable, kIsViewable");
   G__memvar_setup((void*)((long)(&p->fAllEventMasks)-(long)(p)),108,0,0,-1,G__defined_typename("Long_t"),-1,1,"fAllEventMasks=",0,"set of events all people have interest in");
   G__memvar_setup((void*)((long)(&p->fYourEventMask)-(long)(p)),108,0,0,-1,G__defined_typename("Long_t"),-1,1,"fYourEventMask=",0,"my event mask");
   G__memvar_setup((void*)((long)(&p->fDoNotPropagateMask)-(long)(p)),108,0,0,-1,G__defined_typename("Long_t"),-1,1,"fDoNotPropagateMask=",0,"set of events that should not propagate");
   G__memvar_setup((void*)((long)(&p->fOverrideRedirect)-(long)(p)),103,0,0,-1,G__defined_typename("Bool_t"),-1,1,"fOverrideRedirect=",0,"boolean value for override-redirect");
   G__memvar_setup((void*)((long)(&p->fScreen)-(long)(p)),89,0,0,-1,-1,-1,1,"fScreen=",0,"back pointer to correct screen");
   }
   G__tag_memvar_reset();
}


   /* Event_t */
static void G__setup_memvarEvent_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_Event_t));
   { Event_t *p; p=(Event_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->fType)-(long)(p)),105,0,0,G__get_linked_tagnum(&G__G__Base3LN_EGEventType),-1,-1,1,"fType=",0,"of event (see EGEventType)");
   G__memvar_setup((void*)((long)(&p->fWindow)-(long)(p)),107,0,0,-1,G__defined_typename("Window_t"),-1,1,"fWindow=",0,"window reported event is relative to");
   G__memvar_setup((void*)((long)(&p->fTime)-(long)(p)),107,0,0,-1,G__defined_typename("Time_t"),-1,1,"fTime=",0,"time event event occured in ms");
   G__memvar_setup((void*)((long)(&p->fX)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fX=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fY)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fY=",0,"pointer x, y coordinates in event window");
   G__memvar_setup((void*)((long)(&p->fXRoot)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fXRoot=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fYRoot)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fYRoot=",0,"coordinates relative to root");
   G__memvar_setup((void*)((long)(&p->fCode)-(long)(p)),104,0,0,-1,G__defined_typename("UInt_t"),-1,1,"fCode=",0,"key or button code");
   G__memvar_setup((void*)((long)(&p->fState)-(long)(p)),104,0,0,-1,G__defined_typename("UInt_t"),-1,1,"fState=",0,"key or button mask");
   G__memvar_setup((void*)((long)(&p->fWidth)-(long)(p)),104,0,0,-1,G__defined_typename("UInt_t"),-1,1,"fWidth=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fHeight)-(long)(p)),104,0,0,-1,G__defined_typename("UInt_t"),-1,1,"fHeight=",0,"width and height of exposed area");
   G__memvar_setup((void*)((long)(&p->fCount)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fCount=",0,"if non-zero, at least this many more exposes");
   G__memvar_setup((void*)((long)(&p->fSendEvent)-(long)(p)),103,0,0,-1,G__defined_typename("Bool_t"),-1,1,"fSendEvent=",0,"true if event came from SendEvent");
   G__memvar_setup((void*)((long)(&p->fHandle)-(long)(p)),107,0,0,-1,G__defined_typename("Handle_t"),-1,1,"fHandle=",0,"general resource handle (used for atoms or windows)");
   G__memvar_setup((void*)((long)(&p->fFormat)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fFormat=",0,"Next fields only used by kClientMessageEvent");
   G__memvar_setup((void*)((long)(&p->fUser)-(long)(p)),108,0,0,-1,G__defined_typename("Long_t"),-1,1,"fUser[5]=",0,"5 longs can be used by client message events");
   }
   G__tag_memvar_reset();
}


   /* GCValues_t */
static void G__setup_memvarGCValues_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_GCValues_t));
   { GCValues_t *p; p=(GCValues_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->fFunction)-(long)(p)),105,0,0,G__get_linked_tagnum(&G__G__Base3LN_EGraphicsFunction),-1,-1,1,"fFunction=",0,"logical operation");
   G__memvar_setup((void*)((long)(&p->fPlaneMask)-(long)(p)),107,0,0,-1,G__defined_typename("ULong_t"),-1,1,"fPlaneMask=",0,"plane mask");
   G__memvar_setup((void*)((long)(&p->fForeground)-(long)(p)),107,0,0,-1,G__defined_typename("ULong_t"),-1,1,"fForeground=",0,"foreground pixel");
   G__memvar_setup((void*)((long)(&p->fBackground)-(long)(p)),107,0,0,-1,G__defined_typename("ULong_t"),-1,1,"fBackground=",0,"background pixel");
   G__memvar_setup((void*)((long)(&p->fLineWidth)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fLineWidth=",0,"line width");
   G__memvar_setup((void*)((long)(&p->fLineStyle)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fLineStyle=",0,"kLineSolid, kLineOnOffDash, kLineDoubleDash");
   G__memvar_setup((void*)((long)(&p->fCapStyle)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fCapStyle=",0,"kCapNotLast, kCapButt,");
   G__memvar_setup((void*)((long)(&p->fJoinStyle)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fJoinStyle=",0,"kJoinMiter, kJoinRound, kJoinBevel");
   G__memvar_setup((void*)((long)(&p->fFillStyle)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fFillStyle=",0,"kFillSolid, kFillTiled,");
   G__memvar_setup((void*)((long)(&p->fFillRule)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fFillRule=",0,"kEvenOddRule, kWindingRule");
   G__memvar_setup((void*)((long)(&p->fArcMode)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fArcMode=",0,"kArcChord, kArcPieSlice");
   G__memvar_setup((void*)((long)(&p->fTile)-(long)(p)),107,0,0,-1,G__defined_typename("Pixmap_t"),-1,1,"fTile=",0,"tile pixmap for tiling operations");
   G__memvar_setup((void*)((long)(&p->fStipple)-(long)(p)),107,0,0,-1,G__defined_typename("Pixmap_t"),-1,1,"fStipple=",0,"stipple 1 plane pixmap for stipping");
   G__memvar_setup((void*)((long)(&p->fTsXOrigin)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fTsXOrigin=",0,"offset for tile or stipple operations");
   G__memvar_setup((void*)((long)(&p->fTsYOrigin)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fTsYOrigin=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fFont)-(long)(p)),107,0,0,-1,G__defined_typename("FontH_t"),-1,1,"fFont=",0,"default text font for text operations");
   G__memvar_setup((void*)((long)(&p->fSubwindowMode)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fSubwindowMode=",0,"kClipByChildren, kIncludeInferiors");
   G__memvar_setup((void*)((long)(&p->fGraphicsExposures)-(long)(p)),103,0,0,-1,G__defined_typename("Bool_t"),-1,1,"fGraphicsExposures=",0,"boolean, should exposures be generated");
   G__memvar_setup((void*)((long)(&p->fClipXOrigin)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fClipXOrigin=",0,"origin for clipping");
   G__memvar_setup((void*)((long)(&p->fClipYOrigin)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fClipYOrigin=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fClipMask)-(long)(p)),107,0,0,-1,G__defined_typename("Pixmap_t"),-1,1,"fClipMask=",0,"bitmap clipping; other calls for rects");
   G__memvar_setup((void*)((long)(&p->fDashOffset)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fDashOffset=",0,"patterned/dashed line information");
   G__memvar_setup((void*)((long)(&p->fDashes)-(long)(p)),99,0,0,-1,G__defined_typename("Char_t"),-1,1,"fDashes[8]=",0,"dash pattern list (dash length per byte)");
   G__memvar_setup((void*)((long)(&p->fDashLen)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fDashLen=",0,"number of dashes in fDashes");
   G__memvar_setup((void*)((long)(&p->fMask)-(long)(p)),104,0,0,-1,G__defined_typename("Mask_t"),-1,1,"fMask=",0,"bit mask specifying which fields are valid");
   }
   G__tag_memvar_reset();
}


   /* ColorStruct_t */
static void G__setup_memvarColorStruct_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_ColorStruct_t));
   { ColorStruct_t *p; p=(ColorStruct_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->fPixel)-(long)(p)),107,0,0,-1,G__defined_typename("ULong_t"),-1,1,"fPixel=",0,"color pixel value (index in color table)");
   G__memvar_setup((void*)((long)(&p->fRed)-(long)(p)),114,0,0,-1,G__defined_typename("UShort_t"),-1,1,"fRed=",0,"red component (0..65535)");
   G__memvar_setup((void*)((long)(&p->fGreen)-(long)(p)),114,0,0,-1,G__defined_typename("UShort_t"),-1,1,"fGreen=",0,"green component (0..65535)");
   G__memvar_setup((void*)((long)(&p->fBlue)-(long)(p)),114,0,0,-1,G__defined_typename("UShort_t"),-1,1,"fBlue=",0,"blue component (0..65535)");
   G__memvar_setup((void*)((long)(&p->fMask)-(long)(p)),114,0,0,-1,G__defined_typename("UShort_t"),-1,1,"fMask=",0,"mask telling which color components are valid");
   }
   G__tag_memvar_reset();
}


   /* PictureAttributes_t */
static void G__setup_memvarPictureAttributes_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_PictureAttributes_t));
   { PictureAttributes_t *p; p=(PictureAttributes_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->fColormap)-(long)(p)),107,0,0,-1,G__defined_typename("Colormap_t"),-1,1,"fColormap=",0,"colormap to use");
   G__memvar_setup((void*)((long)(&p->fDepth)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fDepth=",0,"depth of window");
   G__memvar_setup((void*)((long)(&p->fWidth)-(long)(p)),104,0,0,-1,G__defined_typename("UInt_t"),-1,1,"fWidth=",0,"width of picture");
   G__memvar_setup((void*)((long)(&p->fHeight)-(long)(p)),104,0,0,-1,G__defined_typename("UInt_t"),-1,1,"fHeight=",0,"height of picture");
   G__memvar_setup((void*)((long)(&p->fXHotspot)-(long)(p)),104,0,0,-1,G__defined_typename("UInt_t"),-1,1,"fXHotspot=",0,"picture x hotspot coordinate");
   G__memvar_setup((void*)((long)(&p->fYHotspot)-(long)(p)),104,0,0,-1,G__defined_typename("UInt_t"),-1,1,"fYHotspot=",0,"picture y hotspot coordinate");
   G__memvar_setup((void*)((long)(&p->fPixels)-(long)(p)),75,0,0,-1,G__defined_typename("ULong_t"),-1,1,"fPixels=",0,"list of used color pixels (if set use delete[])");
   G__memvar_setup((void*)((long)(&p->fNpixels)-(long)(p)),104,0,0,-1,G__defined_typename("UInt_t"),-1,1,"fNpixels=",0,"number of used color pixels");
   G__memvar_setup((void*)((long)(&p->fCloseness)-(long)(p)),104,0,0,-1,G__defined_typename("UInt_t"),-1,1,"fCloseness=",0,"allowable RGB deviation");
   G__memvar_setup((void*)((long)(&p->fMask)-(long)(p)),104,0,0,-1,G__defined_typename("Mask_t"),-1,1,"fMask=",0,"mask specifying which attributes are defined");
   }
   G__tag_memvar_reset();
}


   /* Segment_t */
static void G__setup_memvarSegment_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_Segment_t));
   { Segment_t *p; p=(Segment_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->fX1)-(long)(p)),115,0,0,-1,G__defined_typename("Short_t"),-1,1,"fX1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fY1)-(long)(p)),115,0,0,-1,G__defined_typename("Short_t"),-1,1,"fY1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fX2)-(long)(p)),115,0,0,-1,G__defined_typename("Short_t"),-1,1,"fX2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fY2)-(long)(p)),115,0,0,-1,G__defined_typename("Short_t"),-1,1,"fY2=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Point_t */
static void G__setup_memvarPoint_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_Point_t));
   { Point_t *p; p=(Point_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->fX)-(long)(p)),115,0,0,-1,G__defined_typename("Short_t"),-1,1,"fX=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fY)-(long)(p)),115,0,0,-1,G__defined_typename("Short_t"),-1,1,"fY=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Rectangle_t */
static void G__setup_memvarRectangle_t(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_Rectangle_t));
   { Rectangle_t *p; p=(Rectangle_t*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->fX)-(long)(p)),115,0,0,-1,G__defined_typename("Short_t"),-1,1,"fX=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fY)-(long)(p)),115,0,0,-1,G__defined_typename("Short_t"),-1,1,"fY=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fWidth)-(long)(p)),114,0,0,-1,G__defined_typename("UShort_t"),-1,1,"fWidth=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fHeight)-(long)(p)),114,0,0,-1,G__defined_typename("UShort_t"),-1,1,"fHeight=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* timespec */
static void G__setup_memvartimespec(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_timespec));
   { timespec *p; p=(timespec*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->tv_sec)-(long)(p)),108,0,0,-1,G__defined_typename("time_t"),-1,1,"tv_sec=",0,"seconds");
   G__memvar_setup((void*)((long)(&p->tv_nsec)-(long)(p)),108,0,0,-1,-1,-1,1,"tv_nsec=",0,"nanoseconds");
   }
   G__tag_memvar_reset();
}


   /* TVirtualMutex */
static void G__setup_memvarTVirtualMutex(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualMutex));
   { TVirtualMutex *p; p=(TVirtualMutex*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TTimeStamp */
static void G__setup_memvarTTimeStamp(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_TTimeStamp));
   { TTimeStamp *p; p=(TTimeStamp*)0x1000; if (p) { }
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,4,"fSec=",0,"seconds");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,4,"fNanoSec=",0,"nanoseconds");
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TLockGuard */
static void G__setup_memvarTLockGuard(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_TLockGuard));
   { TLockGuard *p; p=(TLockGuard*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TVirtualMutex),-1,-1,4,"fMutex=",0,(char*)NULL);
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TVirtualPerfStats */
static void G__setup_memvarTVirtualPerfStats(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualPerfStats));
   { TVirtualPerfStats *p; p=(TVirtualPerfStats*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_TVirtualPerfStatscLcLEEventType),-1,-2,1,"kUnDefined=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_TVirtualPerfStatscLcLEEventType),-1,-2,1,"kPacket=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_TVirtualPerfStatscLcLEEventType),-1,-2,1,"kStart=2",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_TVirtualPerfStatscLcLEEventType),-1,-2,1,"kStop=3",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_TVirtualPerfStatscLcLEEventType),-1,-2,1,"kFile=4",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_TVirtualPerfStatscLcLEEventType),-1,-2,1,"kFileOpen=5",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_TVirtualPerfStatscLcLEEventType),-1,-2,1,"kFileRead=6",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_TVirtualPerfStatscLcLEEventType),-1,-2,1,"kRate=7",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_TVirtualPerfStatscLcLEEventType),-1,-2,1,"kNumEventType=8",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TVirtualAuth */
static void G__setup_memvarTVirtualAuth(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualAuth));
   { TVirtualAuth *p; p=(TVirtualAuth*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TUrl */
static void G__setup_memvarTUrl(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_TUrl));
   { TUrl *p; p=(TUrl*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_TString),-1,-1,4,"fUrl=",0,"full URL");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_TString),-1,-1,4,"fProtocol=",0,"protocol: http, ftp, news, root, proof, ...");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_TString),-1,-1,4,"fUser=",0,"user name");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_TString),-1,-1,4,"fPasswd=",0,"password");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_TString),-1,-1,4,"fHost=",0,"remote host");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_TString),-1,-1,4,"fFile=",0,"remote object");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_TString),-1,-1,4,"fAnchor=",0,"anchor in object (after #)");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_TString),-1,-1,4,"fOptions=",0,"options/search (after ?)");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_TString),-1,-1,4,"fFileOA=",0,"!file with option and anchor");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_TString),-1,-1,4,"fHostFQ=",0,"!fully qualified host name");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,4,"fPort=",0,"port through which to contact remote server");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TMap),-1,-1,4,"fOptionsMap=",0,"!map containing options key/value pairs");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TObjArray),-1,-2,4,"fgSpecialProtocols=",0,"list of special protocols");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_THashList),-1,-2,4,"fgHostFQDNs=",0,"list of resolved host FQDNs");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TInetAddress */
static void G__setup_memvarTInetAddress(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_TInetAddress));
   { TInetAddress *p; p=(TInetAddress*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_TString),-1,-1,4,"fHostname=",0,"fully qualified hostname");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,4,"fFamily=",0,"address family");
   G__memvar_setup((void*)0,105,0,0,-1,G__defined_typename("Int_t"),-1,4,"fPort=",0,"port through which we are connected");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR),G__defined_typename("AddressList_t"),-1,4,"fAddresses=",0,"list of all IP addresses in host byte order");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_vectorlETStringcOallocatorlETStringgRsPgR),G__defined_typename("AliasList_t"),-1,4,"fAliases=",0,"list of aliases");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TFileInfoMeta */
static void G__setup_memvarTFileInfoMeta(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_TFileInfoMeta));
   { TFileInfoMeta *p; p=(TFileInfoMeta*)0x1000; if (p) { }
   G__memvar_setup((void*)0,110,0,0,-1,G__defined_typename("Long64_t"),-1,4,"fEntries=",0,"number of entries in tree or number of objects");
   G__memvar_setup((void*)0,110,0,0,-1,G__defined_typename("Long64_t"),-1,4,"fFirst=",0,"first valid tree entry");
   G__memvar_setup((void*)0,110,0,0,-1,G__defined_typename("Long64_t"),-1,4,"fLast=",0,"last valid tree entry");
   G__memvar_setup((void*)0,103,0,0,-1,G__defined_typename("Bool_t"),-1,4,"fIsTree=",0,"true if type is a TTree (or TTree derived)");
   G__memvar_setup((void*)0,110,0,0,-1,G__defined_typename("Long64_t"),-1,4,"fTotBytes=",0,"uncompressed size in bytes");
   G__memvar_setup((void*)0,110,0,0,-1,G__defined_typename("Long64_t"),-1,4,"fZipBytes=",0,"compressed size in bytes");
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_TFileInfoMetacLcLEStatusBits),-1,-2,1,"kExternal=32768",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TFileInfo */
static void G__setup_memvarTFileInfo(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_TFileInfo));
   { TFileInfo *p; p=(TFileInfo*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TUrl),-1,-1,4,"fCurrentUrl=",0,"! current URL to access the file, points to URL");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TList),-1,-1,4,"fUrlList=",0,"list of file URLs");
   G__memvar_setup((void*)0,110,0,0,-1,G__defined_typename("Long64_t"),-1,4,"fSize=",0,"file size");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TUUID),-1,-1,4,"fUUID=",0,"-> uuid of the referenced file");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TMD5),-1,-1,4,"fMD5=",0,"-> md5 digest of the file");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TList),-1,-1,4,"fMetaDataList=",0,"generic list of file meta data object(s)");
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_TFileInfocLcLEStatusBits),-1,-2,1,"kStaged=32768",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_TFileInfocLcLEStatusBits),-1,-2,1,"kCorrupted=65536",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TFileCollection */
static void G__setup_memvarTFileCollection(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_TFileCollection));
   { TFileCollection *p; p=(TFileCollection*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_THashList),-1,-1,4,"fList=",0,"-> list of TFileInfos");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TList),-1,-1,4,"fMetaDataList=",0,"-> generic list of file meta data object(s)");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_TString),-1,-1,4,"fDefaultTree=",0,"name of default tree");
   G__memvar_setup((void*)0,110,0,0,-1,G__defined_typename("Long64_t"),-1,4,"fTotalSize=",0,"total size of files in the list");
   G__memvar_setup((void*)0,110,0,0,-1,G__defined_typename("Long64_t"),-1,4,"fNFiles=",0,"number of files ( == fList->GetEntries(), needed");
   G__memvar_setup((void*)0,110,0,0,-1,G__defined_typename("Long64_t"),-1,4,"fNStagedFiles=",0,"number of staged files");
   G__memvar_setup((void*)0,110,0,0,-1,G__defined_typename("Long64_t"),-1,4,"fNCorruptFiles=",0,"number of corrupt files");
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_TFileCollectioncLcLEStatusBits),-1,-2,1,"kRemoteCollection=32768",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TRedirectOutputGuard */
static void G__setup_memvarTRedirectOutputGuard(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_TRedirectOutputGuard));
   { TRedirectOutputGuard *p; p=(TRedirectOutputGuard*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TVirtualMonitoringWriter */
static void G__setup_memvarTVirtualMonitoringWriter(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringWriter));
   { TVirtualMonitoringWriter *p; p=(TVirtualMonitoringWriter*)0x1000; if (p) { }
   G__memvar_setup((void*)0,100,0,0,-1,G__defined_typename("Double_t"),-1,4,"fValue=",0,"double monitor value");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TList),-1,-1,2,"fTmpOpenPhases=",0,"To store open phases when there is not yet an object");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TVirtualMonitoringReader */
static void G__setup_memvarTVirtualMonitoringReader(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringReader));
   { TVirtualMonitoringReader *p; p=(TVirtualMonitoringReader*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TObjectSpy */
static void G__setup_memvarTObjectSpy(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_TObjectSpy));
   { TObjectSpy *p; p=(TObjectSpy*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TObject),-1,-1,2,"fObj=",0,"object being spied");
   G__memvar_setup((void*)0,103,0,0,-1,G__defined_typename("Bool_t"),-1,2,"fResetMustCleanupBit=",0,"flag saying that kMustCleanup needs to be reset in dtor");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TObjectRefSpy */
static void G__setup_memvarTObjectRefSpy(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_TObjectRefSpy));
   { TObjectRefSpy *p; p=(TObjectRefSpy*)0x1000; if (p) { }
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TObject),-1,-1,2,"fObj=",0,"object being spied");
   G__memvar_setup((void*)0,103,0,0,-1,G__defined_typename("Bool_t"),-1,2,"fResetMustCleanupBit=",0,"flag saying that kMustCleanup needs to be reset in dtor");
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TUri */
static void G__setup_memvarTUri(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_TUri));
   { TUri *p; p=(TUri*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_TString),-1,-1,4,"fScheme=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_TString),-1,-1,4,"fUserinfo=",0,"authority/userinfo: user@password, ...");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_TString),-1,-1,4,"fHost=",0,"authority/host: hostname or ip-address");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_TString),-1,-1,4,"fPort=",0,"authority/port: port number, normally 1-65535");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_TString),-1,-1,4,"fPath=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_TString),-1,-1,4,"fQuery=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_TString),-1,-1,4,"fFragment=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,G__defined_typename("Bool_t"),-1,4,"fHasScheme=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,G__defined_typename("Bool_t"),-1,4,"fHasUserinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,G__defined_typename("Bool_t"),-1,4,"fHasHost=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,G__defined_typename("Bool_t"),-1,4,"fHasPort=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,G__defined_typename("Bool_t"),-1,4,"fHasPath=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,G__defined_typename("Bool_t"),-1,4,"fHasQuery=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,G__defined_typename("Bool_t"),-1,4,"fHasFragment=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TVirtualTableInterface */
static void G__setup_memvarTVirtualTableInterface(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualTableInterface));
   { TVirtualTableInterface *p; p=(TVirtualTableInterface*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TBase64 */
static void G__setup_memvarTBase64(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_TBase64));
   { TBase64 *p; p=(TBase64*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<char*,int> */
static void G__setup_memvarpairlEcharmUcOintgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOintgR));
   { pair<char*,int> *p; p=(pair<char*,int>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),67,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),105,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<char*,long> */
static void G__setup_memvarpairlEcharmUcOlonggR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOlonggR));
   { pair<char*,long> *p; p=(pair<char*,long>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),67,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),108,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<char*,float> */
static void G__setup_memvarpairlEcharmUcOfloatgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOfloatgR));
   { pair<char*,float> *p; p=(pair<char*,float>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),67,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),102,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<char*,double> */
static void G__setup_memvarpairlEcharmUcOdoublegR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOdoublegR));
   { pair<char*,double> *p; p=(pair<char*,double>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),67,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),100,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<char*,void*> */
static void G__setup_memvarpairlEcharmUcOvoidmUgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOvoidmUgR));
   { pair<char*,void*> *p; p=(pair<char*,void*>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),67,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),89,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<char*,char*> */
static void G__setup_memvarpairlEcharmUcOcharmUgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOcharmUgR));
   { pair<char*,char*> *p; p=(pair<char*,char*>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),67,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),67,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<string,int> */
static void G__setup_memvarpairlEstringcOintgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOintgR));
   { pair<string,int> *p; p=(pair<string,int>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__G__Base3LN_string),-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),105,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<string,long> */
static void G__setup_memvarpairlEstringcOlonggR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOlonggR));
   { pair<string,long> *p; p=(pair<string,long>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__G__Base3LN_string),-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),108,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<string,float> */
static void G__setup_memvarpairlEstringcOfloatgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOfloatgR));
   { pair<string,float> *p; p=(pair<string,float>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__G__Base3LN_string),-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),102,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<string,double> */
static void G__setup_memvarpairlEstringcOdoublegR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOdoublegR));
   { pair<string,double> *p; p=(pair<string,double>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__G__Base3LN_string),-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),100,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<string,void*> */
static void G__setup_memvarpairlEstringcOvoidmUgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOvoidmUgR));
   { pair<string,void*> *p; p=(pair<string,void*>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__G__Base3LN_string),-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),89,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<int,int> */
static void G__setup_memvarpairlEintcOintgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOintgR));
   { pair<int,int> *p; p=(pair<int,int>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),105,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),105,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<int,long> */
static void G__setup_memvarpairlEintcOlonggR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOlonggR));
   { pair<int,long> *p; p=(pair<int,long>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),105,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),108,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<int,float> */
static void G__setup_memvarpairlEintcOfloatgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOfloatgR));
   { pair<int,float> *p; p=(pair<int,float>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),105,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),102,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<int,double> */
static void G__setup_memvarpairlEintcOdoublegR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOdoublegR));
   { pair<int,double> *p; p=(pair<int,double>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),105,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),100,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<int,void*> */
static void G__setup_memvarpairlEintcOvoidmUgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOvoidmUgR));
   { pair<int,void*> *p; p=(pair<int,void*>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),105,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),89,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<int,char*> */
static void G__setup_memvarpairlEintcOcharmUgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOcharmUgR));
   { pair<int,char*> *p; p=(pair<int,char*>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),105,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),67,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<long,int> */
static void G__setup_memvarpairlElongcOintgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOintgR));
   { pair<long,int> *p; p=(pair<long,int>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),108,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),105,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<long,long> */
static void G__setup_memvarpairlElongcOlonggR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOlonggR));
   { pair<long,long> *p; p=(pair<long,long>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),108,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),108,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<long,float> */
static void G__setup_memvarpairlElongcOfloatgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOfloatgR));
   { pair<long,float> *p; p=(pair<long,float>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),108,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),102,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<long,double> */
static void G__setup_memvarpairlElongcOdoublegR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOdoublegR));
   { pair<long,double> *p; p=(pair<long,double>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),108,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),100,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<long,void*> */
static void G__setup_memvarpairlElongcOvoidmUgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOvoidmUgR));
   { pair<long,void*> *p; p=(pair<long,void*>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),108,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),89,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<long,char*> */
static void G__setup_memvarpairlElongcOcharmUgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOcharmUgR));
   { pair<long,char*> *p; p=(pair<long,char*>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),108,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),67,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<float,int> */
static void G__setup_memvarpairlEfloatcOintgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOintgR));
   { pair<float,int> *p; p=(pair<float,int>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),102,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),105,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<float,long> */
static void G__setup_memvarpairlEfloatcOlonggR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOlonggR));
   { pair<float,long> *p; p=(pair<float,long>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),102,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),108,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<float,float> */
static void G__setup_memvarpairlEfloatcOfloatgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOfloatgR));
   { pair<float,float> *p; p=(pair<float,float>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),102,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),102,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<float,double> */
static void G__setup_memvarpairlEfloatcOdoublegR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOdoublegR));
   { pair<float,double> *p; p=(pair<float,double>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),102,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),100,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<float,void*> */
static void G__setup_memvarpairlEfloatcOvoidmUgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOvoidmUgR));
   { pair<float,void*> *p; p=(pair<float,void*>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),102,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),89,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<float,char*> */
static void G__setup_memvarpairlEfloatcOcharmUgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOcharmUgR));
   { pair<float,char*> *p; p=(pair<float,char*>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),102,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),67,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<double,int> */
static void G__setup_memvarpairlEdoublecOintgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOintgR));
   { pair<double,int> *p; p=(pair<double,int>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),100,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),105,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<double,long> */
static void G__setup_memvarpairlEdoublecOlonggR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOlonggR));
   { pair<double,long> *p; p=(pair<double,long>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),100,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),108,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<double,float> */
static void G__setup_memvarpairlEdoublecOfloatgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOfloatgR));
   { pair<double,float> *p; p=(pair<double,float>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),100,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),102,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<double,double> */
static void G__setup_memvarpairlEdoublecOdoublegR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOdoublegR));
   { pair<double,double> *p; p=(pair<double,double>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),100,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),100,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<double,void*> */
static void G__setup_memvarpairlEdoublecOvoidmUgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOvoidmUgR));
   { pair<double,void*> *p; p=(pair<double,void*>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),100,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),89,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<double,char*> */
static void G__setup_memvarpairlEdoublecOcharmUgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOcharmUgR));
   { pair<double,char*> *p; p=(pair<double,char*>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),100,0,0,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),67,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const char*,int> */
static void G__setup_memvarpairlEconstsPcharmUcOintgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOintgR));
   { pair<const char*,int> *p; p=(pair<const char*,int>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),67,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),105,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const char*,long> */
static void G__setup_memvarpairlEconstsPcharmUcOlonggR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOlonggR));
   { pair<const char*,long> *p; p=(pair<const char*,long>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),67,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),108,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const char*,float> */
static void G__setup_memvarpairlEconstsPcharmUcOfloatgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOfloatgR));
   { pair<const char*,float> *p; p=(pair<const char*,float>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),67,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),102,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const char*,double> */
static void G__setup_memvarpairlEconstsPcharmUcOdoublegR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOdoublegR));
   { pair<const char*,double> *p; p=(pair<const char*,double>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),67,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),100,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const char*,void*> */
static void G__setup_memvarpairlEconstsPcharmUcOvoidmUgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOvoidmUgR));
   { pair<const char*,void*> *p; p=(pair<const char*,void*>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),67,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),89,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const char*,char*> */
static void G__setup_memvarpairlEconstsPcharmUcOcharmUgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOcharmUgR));
   { pair<const char*,char*> *p; p=(pair<const char*,char*>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),67,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),67,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const string,int> */
static void G__setup_memvarpairlEconstsPstringcOintgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOintgR));
   { pair<const string,int> *p; p=(pair<const string,int>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),117,0,1,G__get_linked_tagnum(&G__G__Base3LN_string),-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),105,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const string,long> */
static void G__setup_memvarpairlEconstsPstringcOlonggR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOlonggR));
   { pair<const string,long> *p; p=(pair<const string,long>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),117,0,1,G__get_linked_tagnum(&G__G__Base3LN_string),-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),108,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const string,float> */
static void G__setup_memvarpairlEconstsPstringcOfloatgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOfloatgR));
   { pair<const string,float> *p; p=(pair<const string,float>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),117,0,1,G__get_linked_tagnum(&G__G__Base3LN_string),-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),102,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const string,double> */
static void G__setup_memvarpairlEconstsPstringcOdoublegR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOdoublegR));
   { pair<const string,double> *p; p=(pair<const string,double>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),117,0,1,G__get_linked_tagnum(&G__G__Base3LN_string),-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),100,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const string,void*> */
static void G__setup_memvarpairlEconstsPstringcOvoidmUgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOvoidmUgR));
   { pair<const string,void*> *p; p=(pair<const string,void*>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),117,0,1,G__get_linked_tagnum(&G__G__Base3LN_string),-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),89,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const int,int> */
static void G__setup_memvarpairlEconstsPintcOintgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOintgR));
   { pair<const int,int> *p; p=(pair<const int,int>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),105,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),105,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const int,long> */
static void G__setup_memvarpairlEconstsPintcOlonggR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOlonggR));
   { pair<const int,long> *p; p=(pair<const int,long>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),105,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),108,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const int,float> */
static void G__setup_memvarpairlEconstsPintcOfloatgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOfloatgR));
   { pair<const int,float> *p; p=(pair<const int,float>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),105,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),102,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const int,double> */
static void G__setup_memvarpairlEconstsPintcOdoublegR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOdoublegR));
   { pair<const int,double> *p; p=(pair<const int,double>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),105,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),100,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const int,void*> */
static void G__setup_memvarpairlEconstsPintcOvoidmUgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOvoidmUgR));
   { pair<const int,void*> *p; p=(pair<const int,void*>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),105,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),89,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const int,char*> */
static void G__setup_memvarpairlEconstsPintcOcharmUgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOcharmUgR));
   { pair<const int,char*> *p; p=(pair<const int,char*>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),105,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),67,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const long,int> */
static void G__setup_memvarpairlEconstsPlongcOintgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOintgR));
   { pair<const long,int> *p; p=(pair<const long,int>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),108,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),105,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const long,long> */
static void G__setup_memvarpairlEconstsPlongcOlonggR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOlonggR));
   { pair<const long,long> *p; p=(pair<const long,long>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),108,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),108,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const long,float> */
static void G__setup_memvarpairlEconstsPlongcOfloatgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOfloatgR));
   { pair<const long,float> *p; p=(pair<const long,float>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),108,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),102,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const long,double> */
static void G__setup_memvarpairlEconstsPlongcOdoublegR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOdoublegR));
   { pair<const long,double> *p; p=(pair<const long,double>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),108,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),100,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const long,void*> */
static void G__setup_memvarpairlEconstsPlongcOvoidmUgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOvoidmUgR));
   { pair<const long,void*> *p; p=(pair<const long,void*>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),108,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),89,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const long,char*> */
static void G__setup_memvarpairlEconstsPlongcOcharmUgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOcharmUgR));
   { pair<const long,char*> *p; p=(pair<const long,char*>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),108,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),67,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const float,int> */
static void G__setup_memvarpairlEconstsPfloatcOintgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOintgR));
   { pair<const float,int> *p; p=(pair<const float,int>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),102,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),105,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const float,long> */
static void G__setup_memvarpairlEconstsPfloatcOlonggR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOlonggR));
   { pair<const float,long> *p; p=(pair<const float,long>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),102,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),108,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const float,float> */
static void G__setup_memvarpairlEconstsPfloatcOfloatgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOfloatgR));
   { pair<const float,float> *p; p=(pair<const float,float>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),102,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),102,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const float,double> */
static void G__setup_memvarpairlEconstsPfloatcOdoublegR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOdoublegR));
   { pair<const float,double> *p; p=(pair<const float,double>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),102,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),100,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const float,void*> */
static void G__setup_memvarpairlEconstsPfloatcOvoidmUgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOvoidmUgR));
   { pair<const float,void*> *p; p=(pair<const float,void*>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),102,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),89,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const float,char*> */
static void G__setup_memvarpairlEconstsPfloatcOcharmUgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOcharmUgR));
   { pair<const float,char*> *p; p=(pair<const float,char*>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),102,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),67,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const double,int> */
static void G__setup_memvarpairlEconstsPdoublecOintgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOintgR));
   { pair<const double,int> *p; p=(pair<const double,int>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),100,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),105,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const double,long> */
static void G__setup_memvarpairlEconstsPdoublecOlonggR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOlonggR));
   { pair<const double,long> *p; p=(pair<const double,long>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),100,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),108,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const double,float> */
static void G__setup_memvarpairlEconstsPdoublecOfloatgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOfloatgR));
   { pair<const double,float> *p; p=(pair<const double,float>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),100,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),102,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const double,double> */
static void G__setup_memvarpairlEconstsPdoublecOdoublegR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOdoublegR));
   { pair<const double,double> *p; p=(pair<const double,double>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),100,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),100,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const double,void*> */
static void G__setup_memvarpairlEconstsPdoublecOvoidmUgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOvoidmUgR));
   { pair<const double,void*> *p; p=(pair<const double,void*>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),100,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),89,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<const double,char*> */
static void G__setup_memvarpairlEconstsPdoublecOcharmUgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOcharmUgR));
   { pair<const double,char*> *p; p=(pair<const double,char*>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),100,0,1,-1,-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),67,0,0,-1,-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TParameter<float> */
static void G__setup_memvarTParameterlEfloatgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_TParameterlEfloatgR));
   { TParameter<float> *p; p=(TParameter<float>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_TString),-1,-1,4,"fName=",0,(char*)NULL);
   G__memvar_setup((void*)0,102,0,0,-1,-1,-1,4,"fVal=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TParameter<double> */
static void G__setup_memvarTParameterlEdoublegR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_TParameterlEdoublegR));
   { TParameter<double> *p; p=(TParameter<double>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_TString),-1,-1,4,"fName=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"fVal=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TParameter<int> */
static void G__setup_memvarTParameterlEintgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_TParameterlEintgR));
   { TParameter<int> *p; p=(TParameter<int>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_TString),-1,-1,4,"fName=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"fVal=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TParameter<long> */
static void G__setup_memvarTParameterlElonggR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_TParameterlElonggR));
   { TParameter<long> *p; p=(TParameter<long>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_TString),-1,-1,4,"fName=",0,(char*)NULL);
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"fVal=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TParameter<long long> */
static void G__setup_memvarTParameterlElongsPlonggR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G__Base3LN_TParameterlElongsPlonggR));
   { TParameter<long long> *p; p=(TParameter<long long>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__G__Base3LN_TString),-1,-1,4,"fName=",0,(char*)NULL);
   G__memvar_setup((void*)0,110,0,0,-1,-1,-1,4,"fVal=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvarG__Base3() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncSetWindowAttributes_t(void) {
   /* SetWindowAttributes_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_SetWindowAttributes_t));
   // automatic default constructor
   G__memfunc_setup("SetWindowAttributes_t", 2206, G__G__Base3_99_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_SetWindowAttributes_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("SetWindowAttributes_t", 2206, G__G__Base3_99_0_2, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_SetWindowAttributes_t), -1, 0, 1, 1, 1, 0, "u 'SetWindowAttributes_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~SetWindowAttributes_t", 2332, G__G__Base3_99_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Base3_99_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__Base3LN_SetWindowAttributes_t), -1, 1, 1, 1, 1, 0, "u 'SetWindowAttributes_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncWindowAttributes_t(void) {
   /* WindowAttributes_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_WindowAttributes_t));
   // automatic default constructor
   G__memfunc_setup("WindowAttributes_t", 1906, G__G__Base3_100_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_WindowAttributes_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("WindowAttributes_t", 1906, G__G__Base3_100_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_WindowAttributes_t), -1, 0, 1, 1, 1, 0, "u 'WindowAttributes_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~WindowAttributes_t", 2032, G__G__Base3_100_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Base3_100_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__Base3LN_WindowAttributes_t), -1, 1, 1, 1, 1, 0, "u 'WindowAttributes_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncEvent_t(void) {
   /* Event_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_Event_t));
   // automatic default constructor
   G__memfunc_setup("Event_t", 725, G__G__Base3_101_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_Event_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Event_t", 725, G__G__Base3_101_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_Event_t), -1, 0, 1, 1, 1, 0, "u 'Event_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Event_t", 851, G__G__Base3_101_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Base3_101_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__Base3LN_Event_t), -1, 1, 1, 1, 1, 0, "u 'Event_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncGCValues_t(void) {
   /* GCValues_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_GCValues_t));
   G__memfunc_setup("GCValues_t",973,G__G__Base3_104_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_GCValues_t), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("GCValues_t", 973, G__G__Base3_104_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_GCValues_t), -1, 0, 1, 1, 1, 0, "u 'GCValues_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~GCValues_t", 1099, G__G__Base3_104_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Base3_104_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__Base3LN_GCValues_t), -1, 1, 1, 1, 1, 0, "u 'GCValues_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncColorStruct_t(void) {
   /* ColorStruct_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_ColorStruct_t));
   // automatic default constructor
   G__memfunc_setup("ColorStruct_t", 1367, G__G__Base3_105_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_ColorStruct_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ColorStruct_t", 1367, G__G__Base3_105_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_ColorStruct_t), -1, 0, 1, 1, 1, 0, "u 'ColorStruct_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ColorStruct_t", 1493, G__G__Base3_105_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Base3_105_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__Base3LN_ColorStruct_t), -1, 1, 1, 1, 1, 0, "u 'ColorStruct_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncPictureAttributes_t(void) {
   /* PictureAttributes_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_PictureAttributes_t));
   // automatic default constructor
   G__memfunc_setup("PictureAttributes_t", 2006, G__G__Base3_106_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_PictureAttributes_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("PictureAttributes_t", 2006, G__G__Base3_106_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_PictureAttributes_t), -1, 0, 1, 1, 1, 0, "u 'PictureAttributes_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PictureAttributes_t", 2132, G__G__Base3_106_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Base3_106_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__Base3LN_PictureAttributes_t), -1, 1, 1, 1, 1, 0, "u 'PictureAttributes_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncSegment_t(void) {
   /* Segment_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_Segment_t));
   // automatic default constructor
   G__memfunc_setup("Segment_t", 934, G__G__Base3_108_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_Segment_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Segment_t", 934, G__G__Base3_108_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_Segment_t), -1, 0, 1, 1, 1, 0, "u 'Segment_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Segment_t", 1060, G__G__Base3_108_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Base3_108_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__Base3LN_Segment_t), -1, 1, 1, 1, 1, 0, "u 'Segment_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncPoint_t(void) {
   /* Point_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_Point_t));
   // automatic default constructor
   G__memfunc_setup("Point_t", 733, G__G__Base3_109_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_Point_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Point_t", 733, G__G__Base3_109_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_Point_t), -1, 0, 1, 1, 1, 0, "u 'Point_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Point_t", 859, G__G__Base3_109_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Base3_109_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__Base3LN_Point_t), -1, 1, 1, 1, 1, 0, "u 'Point_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncRectangle_t(void) {
   /* Rectangle_t */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_Rectangle_t));
   // automatic default constructor
   G__memfunc_setup("Rectangle_t", 1128, G__G__Base3_110_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_Rectangle_t), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Rectangle_t", 1128, G__G__Base3_110_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_Rectangle_t), -1, 0, 1, 1, 1, 0, "u 'Rectangle_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Rectangle_t", 1254, G__G__Base3_110_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Base3_110_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__Base3LN_Rectangle_t), -1, 1, 1, 1, 1, 0, "u 'Rectangle_t' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfunctimespec(void) {
   /* timespec */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_timespec));
   // automatic default constructor
   G__memfunc_setup("timespec", 858, G__G__Base3_118_0_1, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_timespec), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("timespec", 858, G__G__Base3_118_0_2, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_timespec), -1, 0, 1, 1, 1, 0, "u 'timespec' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~timespec", 984, G__G__Base3_118_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Base3_118_0_4, (int) ('u'), G__get_linked_tagnum(&G__G__Base3LN_timespec), -1, 1, 1, 1, 1, 0, "u 'timespec' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTVirtualMutex(void) {
   /* TVirtualMutex */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualMutex));
   G__memfunc_setup("Lock",393,G__G__Base3_119_0_2, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("TryLock",712,G__G__Base3_119_0_3, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("UnLock",588,G__G__Base3_119_0_4, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("CleanUp",680,G__G__Base3_119_0_5, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Acquire",714,G__G__Base3_119_0_6, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Release",705,G__G__Base3_119_0_7, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Factory",728,G__G__Base3_119_0_8, 85, G__get_linked_tagnum(&G__G__Base3LN_TVirtualMutex), -1, 0, 1, 1, 1, 0, "g - 'Bool_t' 0 'kFALSE' -", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Class",502,G__G__Base3_119_0_9, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TVirtualMutex::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__Base3_119_0_10, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualMutex::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__Base3_119_0_11, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TVirtualMutex::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__Base3_119_0_12, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TVirtualMutex::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__Base3_119_0_16, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__Base3_119_0_17, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualMutex::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__Base3_119_0_18, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TVirtualMutex::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__Base3_119_0_19, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualMutex::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__Base3_119_0_20, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TVirtualMutex::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~TVirtualMutex", 1484, G__G__Base3_119_0_21, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Base3_119_0_22, (int) ('u'), G__get_linked_tagnum(&G__G__Base3LN_TVirtualMutex), -1, 1, 1, 1, 1, 0, "u 'TVirtualMutex' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTTimeStamp(void) {
   /* TTimeStamp */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_TTimeStamp));
   G__memfunc_setup("NormalizeNanoSec",1624,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 0, 1, 4, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TTimeStamp",1000,G__G__Base3_120_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_TTimeStamp), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TTimeStamp",1000,G__G__Base3_120_0_3, 105, G__get_linked_tagnum(&G__G__Base3LN_TTimeStamp), -1, 0, 1, 1, 1, 0, "u 'timespec' 'timespec_t' 11 - ts", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TTimeStamp",1000,G__G__Base3_120_0_4, 105, G__get_linked_tagnum(&G__G__Base3LN_TTimeStamp), -1, 0, 2, 1, 1, 0, 
"l - 'time_t' 0 - t i - 'Int_t' 0 - nsec", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TTimeStamp",1000,G__G__Base3_120_0_5, 105, G__get_linked_tagnum(&G__G__Base3LN_TTimeStamp), -1, 0, 9, 1, 1, 0, 
"h - 'UInt_t' 0 - year h - 'UInt_t' 0 - month "
"h - 'UInt_t' 0 - day h - 'UInt_t' 0 - hour "
"h - 'UInt_t' 0 - min h - 'UInt_t' 0 - sec "
"h - 'UInt_t' 0 '0' nsec g - 'Bool_t' 0 'kTRUE' isUTC "
"i - 'Int_t' 0 '0' secOffset", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TTimeStamp",1000,G__G__Base3_120_0_6, 105, G__get_linked_tagnum(&G__G__Base3LN_TTimeStamp), -1, 0, 5, 1, 1, 0, 
"h - 'UInt_t' 0 - date h - 'UInt_t' 0 - time "
"h - 'UInt_t' 0 - nsec g - 'Bool_t' 0 'kTRUE' isUTC "
"i - 'Int_t' 0 '0' secOffset", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TTimeStamp",1000,G__G__Base3_120_0_7, 105, G__get_linked_tagnum(&G__G__Base3LN_TTimeStamp), -1, 0, 4, 1, 1, 0, 
"h - 'UInt_t' 0 - tloc g - 'Bool_t' 0 'kTRUE' isUTC "
"i - 'Int_t' 0 '0' secOffset g - 'Bool_t' 0 'kFALSE' dosDate", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Set",300,G__G__Base3_120_0_8, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Set",300,G__G__Base3_120_0_9, 121, -1, -1, 0, 9, 1, 1, 0, 
"i - 'Int_t' 0 - year i - 'Int_t' 0 - month "
"i - 'Int_t' 0 - day i - 'Int_t' 0 - hour "
"i - 'Int_t' 0 - min i - 'Int_t' 0 - sec "
"i - 'Int_t' 0 - nsec g - 'Bool_t' 0 - isUTC "
"i - 'Int_t' 0 - secOffset", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Set",300,G__G__Base3_120_0_10, 121, -1, -1, 0, 5, 1, 1, 0, 
"i - 'Int_t' 0 - date i - 'Int_t' 0 - time "
"i - 'Int_t' 0 - nsec g - 'Bool_t' 0 - isUTC "
"i - 'Int_t' 0 - secOffset", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Set",300,G__G__Base3_120_0_11, 121, -1, -1, 0, 4, 1, 1, 0, 
"h - 'UInt_t' 0 - tloc g - 'Bool_t' 0 - isUTC "
"i - 'Int_t' 0 - secOffset g - 'Bool_t' 0 - dosDate", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetSec",583,G__G__Base3_120_0_12, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - sec", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetNanoSec",979,G__G__Base3_120_0_13, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - nsec", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetTimeSpec",1082,G__G__Base3_120_0_14, 117, G__get_linked_tagnum(&G__G__Base3LN_timespec), G__defined_typename("timespec_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetSec",571,G__G__Base3_120_0_15, 108, -1, G__defined_typename("time_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNanoSec",967,G__G__Base3_120_0_16, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AsDouble",783,G__G__Base3_120_0_17, 100, -1, G__defined_typename("Double_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AsJulianDate",1173,G__G__Base3_120_0_18, 100, -1, G__defined_typename("Double_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AsString",811,G__G__Base3_120_0_19, 67, -1, -1, 0, 1, 1, 1, 9, "C - 'Option_t' 10 '\"\"' option", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Copy",411,G__G__Base3_120_0_20, 121, -1, -1, 0, 1, 1, 1, 8, "u 'TTimeStamp' - 1 - ts", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetDate",670,G__G__Base3_120_0_21, 104, -1, G__defined_typename("UInt_t"), 0, 5, 1, 1, 8, 
"g - 'Bool_t' 0 'kTRUE' inUTC i - 'Int_t' 0 '0' secOffset "
"H - 'UInt_t' 0 '0' year H - 'UInt_t' 0 '0' month "
"H - 'UInt_t' 0 '0' day", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetTime",687,G__G__Base3_120_0_22, 104, -1, G__defined_typename("UInt_t"), 0, 5, 1, 1, 8, 
"g - 'Bool_t' 0 'kTRUE' inUTC i - 'Int_t' 0 '0' secOffset "
"H - 'UInt_t' 0 '0' hour H - 'UInt_t' 0 '0' min "
"H - 'UInt_t' 0 '0' sec", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetDayOfYear",1156,G__G__Base3_120_0_23, 105, -1, G__defined_typename("Int_t"), 0, 2, 1, 1, 8, 
"g - 'Bool_t' 0 'kTRUE' inUTC i - 'Int_t' 0 '0' secOffset", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetDayOfWeek",1151,G__G__Base3_120_0_24, 105, -1, G__defined_typename("Int_t"), 0, 2, 1, 1, 8, 
"g - 'Bool_t' 0 'kTRUE' inUTC i - 'Int_t' 0 '0' secOffset", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetMonth",806,G__G__Base3_120_0_25, 105, -1, G__defined_typename("Int_t"), 0, 2, 1, 1, 8, 
"g - 'Bool_t' 0 'kTRUE' inUTC i - 'Int_t' 0 '0' secOffset", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetWeek",684,G__G__Base3_120_0_26, 105, -1, G__defined_typename("Int_t"), 0, 2, 1, 1, 8, 
"g - 'Bool_t' 0 'kTRUE' inUTC i - 'Int_t' 0 '0' secOffset", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsLeapYear",975,G__G__Base3_120_0_27, 103, -1, G__defined_typename("Bool_t"), 0, 2, 1, 1, 8, 
"g - 'Bool_t' 0 'kTRUE' inUTC i - 'Int_t' 0 '0' secOffset", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Add",265,G__G__Base3_120_0_28, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TTimeStamp' - 11 - offset", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Print",525,G__G__Base3_120_0_29, 121, -1, -1, 0, 1, 1, 1, 8, "C - 'Option_t' 10 '\"\"' option", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator double",1543,G__G__Base3_120_0_30, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetZoneOffset",1315,G__G__Base3_120_0_31, 105, -1, G__defined_typename("Int_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Int_t (*)())(&TTimeStamp::GetZoneOffset) ), 0);
   G__memfunc_setup("MktimeFromUTC",1255,G__G__Base3_120_0_32, 108, -1, G__defined_typename("time_t"), 0, 1, 3, 1, 0, "U 'tm' 'tm_t' 0 - tmstruct", (char*)NULL, (void*) G__func2void( (time_t (*)(tm_t*))(&TTimeStamp::MktimeFromUTC) ), 0);
   G__memfunc_setup("DumpTMStruct",1212,G__G__Base3_120_0_33, 121, -1, -1, 0, 1, 3, 1, 0, "u 'tm' 'tm_t' 11 - tmstruct", (char*)NULL, (void*) G__func2void( (void (*)(const tm_t&))(&TTimeStamp::DumpTMStruct) ), 0);
   G__memfunc_setup("GetDayOfYear",1156,G__G__Base3_120_0_34, 105, -1, G__defined_typename("Int_t"), 0, 3, 3, 1, 0, 
"i - 'Int_t' 0 - day i - 'Int_t' 0 - month "
"i - 'Int_t' 0 - year", (char*)NULL, (void*) G__func2void( (Int_t (*)(Int_t, Int_t, Int_t))(&TTimeStamp::GetDayOfYear) ), 0);
   G__memfunc_setup("GetDayOfWeek",1151,G__G__Base3_120_0_35, 105, -1, G__defined_typename("Int_t"), 0, 3, 3, 1, 0, 
"i - 'Int_t' 0 - day i - 'Int_t' 0 - month "
"i - 'Int_t' 0 - year", (char*)NULL, (void*) G__func2void( (Int_t (*)(Int_t, Int_t, Int_t))(&TTimeStamp::GetDayOfWeek) ), 0);
   G__memfunc_setup("GetWeek",684,G__G__Base3_120_0_36, 105, -1, G__defined_typename("Int_t"), 0, 3, 3, 1, 0, 
"i - 'Int_t' 0 - day i - 'Int_t' 0 - month "
"i - 'Int_t' 0 - year", (char*)NULL, (void*) G__func2void( (Int_t (*)(Int_t, Int_t, Int_t))(&TTimeStamp::GetWeek) ), 0);
   G__memfunc_setup("IsLeapYear",975,G__G__Base3_120_0_37, 103, -1, G__defined_typename("Bool_t"), 0, 1, 3, 1, 0, "i - 'Int_t' 0 - year", (char*)NULL, (void*) G__func2void( (Bool_t (*)(Int_t))(&TTimeStamp::IsLeapYear) ), 0);
   G__memfunc_setup("Class",502,G__G__Base3_120_0_38, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TTimeStamp::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__Base3_120_0_39, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TTimeStamp::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__Base3_120_0_40, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TTimeStamp::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__Base3_120_0_41, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TTimeStamp::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,G__G__Base3_120_0_42, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,G__G__Base3_120_0_43, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,G__G__Base3_120_0_44, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__Base3_120_0_45, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__Base3_120_0_46, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TTimeStamp::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__Base3_120_0_47, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TTimeStamp::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__Base3_120_0_48, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TTimeStamp::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__Base3_120_0_49, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TTimeStamp::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("TTimeStamp", 1000, G__G__Base3_120_0_50, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_TTimeStamp), -1, 0, 1, 1, 1, 0, "u 'TTimeStamp' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TTimeStamp", 1126, G__G__Base3_120_0_51, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Base3_120_0_52, (int) ('u'), G__get_linked_tagnum(&G__G__Base3LN_TTimeStamp), -1, 1, 1, 1, 1, 0, "u 'TTimeStamp' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTLockGuard(void) {
   /* TLockGuard */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_TLockGuard));
   G__memfunc_setup("TLockGuard",976,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__Base3LN_TLockGuard), -1, 0, 1, 1, 4, 0, "u 'TLockGuard' - 11 - -", "not implemented", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_TLockGuard), -1, 1, 1, 1, 4, 0, "u 'TLockGuard' - 11 - -", "not implemented", (void*) NULL, 0);
   G__memfunc_setup("TLockGuard",976,G__G__Base3_121_0_3, 105, G__get_linked_tagnum(&G__G__Base3LN_TLockGuard), -1, 0, 1, 1, 1, 0, "U 'TVirtualMutex' - 0 - mutex", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__G__Base3_121_0_4, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TLockGuard::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__Base3_121_0_5, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TLockGuard::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__Base3_121_0_6, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TLockGuard::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__Base3_121_0_7, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TLockGuard::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,G__G__Base3_121_0_8, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,G__G__Base3_121_0_9, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,G__G__Base3_121_0_10, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__Base3_121_0_11, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__Base3_121_0_12, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TLockGuard::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__Base3_121_0_13, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TLockGuard::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__Base3_121_0_14, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TLockGuard::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__Base3_121_0_15, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TLockGuard::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~TLockGuard", 1102, G__G__Base3_121_0_16, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTVirtualPerfStats(void) {
   /* TVirtualPerfStats */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualPerfStats));
   G__memfunc_setup("SimpleEvent",1132,G__G__Base3_123_0_1, 121, -1, -1, 0, 1, 1, 1, 0, "i 'TVirtualPerfStats::EEventType' - 0 - type", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("PacketEvent",1114,G__G__Base3_123_0_2, 121, -1, -1, 0, 8, 1, 1, 0, 
"C - - 10 - slave C - - 10 - slavename "
"C - - 10 - filename n - 'Long64_t' 0 - eventsprocessed "
"d - 'Double_t' 0 - latency d - 'Double_t' 0 - proctime "
"d - 'Double_t' 0 - cputime n - 'Long64_t' 0 - bytesRead", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("FileEvent",898,G__G__Base3_123_0_3, 121, -1, -1, 0, 5, 1, 1, 0, 
"C - - 10 - slave C - - 10 - slavename "
"C - - 10 - nodename C - - 10 - filename "
"g - 'Bool_t' 0 - isStart", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("FileOpenEvent",1300,G__G__Base3_123_0_4, 121, -1, -1, 0, 3, 1, 1, 0, 
"U 'TFile' - 0 - file C - - 10 - filename "
"d - 'Double_t' 0 - start", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("FileReadEvent",1278,G__G__Base3_123_0_5, 121, -1, -1, 0, 3, 1, 1, 0, 
"U 'TFile' - 0 - file i - 'Int_t' 0 - len "
"d - 'Double_t' 0 - start", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("RateEvent",910,G__G__Base3_123_0_6, 121, -1, -1, 0, 4, 1, 1, 0, 
"d - 'Double_t' 0 - proctime d - 'Double_t' 0 - deltatime "
"n - 'Long64_t' 0 - eventsprocessed n - 'Long64_t' 0 - bytesRead", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("SetBytesRead",1199,G__G__Base3_123_0_7, 121, -1, -1, 0, 1, 1, 1, 0, "n - 'Long64_t' 0 - num", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetBytesRead",1187,G__G__Base3_123_0_8, 110, -1, G__defined_typename("Long64_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("SetNumEvents",1233,G__G__Base3_123_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "n - 'Long64_t' 0 - num", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetNumEvents",1221,G__G__Base3_123_0_10, 110, -1, G__defined_typename("Long64_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("EventType",932,G__G__Base3_123_0_11, 67, -1, -1, 0, 1, 3, 1, 1, "i 'TVirtualPerfStats::EEventType' - 0 - type", (char*)NULL, (void*) G__func2void( (const char* (*)(TVirtualPerfStats::EEventType))(&TVirtualPerfStats::EventType) ), 0);
   G__memfunc_setup("Class",502,G__G__Base3_123_0_12, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TVirtualPerfStats::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__Base3_123_0_13, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualPerfStats::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__Base3_123_0_14, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TVirtualPerfStats::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__Base3_123_0_15, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TVirtualPerfStats::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__Base3_123_0_19, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__Base3_123_0_20, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualPerfStats::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__Base3_123_0_21, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TVirtualPerfStats::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__Base3_123_0_22, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualPerfStats::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__Base3_123_0_23, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TVirtualPerfStats::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~TVirtualPerfStats", 1877, G__G__Base3_123_0_24, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Base3_123_0_25, (int) ('u'), G__get_linked_tagnum(&G__G__Base3LN_TVirtualPerfStats), -1, 1, 1, 1, 1, 0, "u 'TVirtualPerfStats' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTVirtualAuth(void) {
   /* TVirtualAuth */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualAuth));
   G__memfunc_setup("Authenticate",1247,G__G__Base3_152_0_2, 85, G__get_linked_tagnum(&G__G__Base3LN_TSecContext), -1, 0, 4, 1, 1, 0, 
"U 'TSocket' - 0 - - C - - 10 - host "
"C - - 10 - user C - 'Option_t' 10 - options", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("ClientVersion",1349,G__G__Base3_152_0_3, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("ErrorMsg",817,G__G__Base3_152_0_4, 121, -1, -1, 0, 2, 1, 1, 0, 
"C - - 10 - where i - 'Int_t' 0 - ecode", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Name",385,G__G__Base3_152_0_5, 67, -1, -1, 0, 0, 1, 1, 1, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Class",502,G__G__Base3_152_0_6, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TVirtualAuth::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__Base3_152_0_7, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualAuth::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__Base3_152_0_8, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TVirtualAuth::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__Base3_152_0_9, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TVirtualAuth::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,G__G__Base3_152_0_10, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,G__G__Base3_152_0_11, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,G__G__Base3_152_0_12, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__Base3_152_0_13, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__Base3_152_0_14, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualAuth::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__Base3_152_0_15, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TVirtualAuth::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__Base3_152_0_16, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualAuth::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__Base3_152_0_17, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TVirtualAuth::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~TVirtualAuth", 1355, G__G__Base3_152_0_18, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Base3_152_0_19, (int) ('u'), G__get_linked_tagnum(&G__G__Base3LN_TVirtualAuth), -1, 1, 1, 1, 1, 0, "u 'TVirtualAuth' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTUrl(void) {
   /* TUrl */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_TUrl));
   G__memfunc_setup("FindFile",769,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 2, 1, 4, 0, 
"C - - 0 - u g - 'Bool_t' 0 'kTRUE' stripDoubleSlash", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TUrl",391,G__G__Base3_167_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_TUrl), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TUrl",391,G__G__Base3_167_0_3, 105, G__get_linked_tagnum(&G__G__Base3LN_TUrl), -1, 0, 2, 1, 1, 0, 
"C - - 10 - url g - 'Bool_t' 0 'kFALSE' defaultIsFile", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TUrl",391,G__G__Base3_167_0_4, 105, G__get_linked_tagnum(&G__G__Base3LN_TUrl), -1, 0, 1, 1, 1, 0, "u 'TUrl' - 11 - url", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__Base3_167_0_5, 117, G__get_linked_tagnum(&G__G__Base3LN_TUrl), -1, 1, 1, 1, 1, 0, "u 'TUrl' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetUrl",595,G__G__Base3_167_0_6, 67, -1, -1, 0, 1, 1, 1, 1, "g - 'Bool_t' 0 'kFALSE' withDeflt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetProtocol",1138,G__G__Base3_167_0_7, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetUser",703,G__G__Base3_167_0_8, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetPasswd",914,G__G__Base3_167_0_9, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetHost",702,G__G__Base3_167_0_10, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetHostFQDN",999,G__G__Base3_167_0_11, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetFile",672,G__G__Base3_167_0_12, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetAnchor",891,G__G__Base3_167_0_13, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetOptions",1036,G__G__Base3_167_0_14, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetValueFromOptions",1949,G__G__Base3_167_0_15, 67, -1, -1, 0, 1, 1, 1, 9, "C - - 10 - key", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetIntValueFromOptions",2248,G__G__Base3_167_0_16, 105, -1, G__defined_typename("Int_t"), 0, 1, 1, 1, 8, "C - - 10 - key", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ParseOptions",1255,G__G__Base3_167_0_17, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("CleanRelativePath",1708,G__G__Base3_167_0_18, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetFileAndOptions",1695,G__G__Base3_167_0_19, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetPort",709,G__G__Base3_167_0_20, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsValid",684,G__G__Base3_167_0_21, 103, -1, G__defined_typename("Bool_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetProtocol",1150,G__G__Base3_167_0_22, 121, -1, -1, 0, 2, 1, 1, 0, 
"C - - 10 - proto g - 'Bool_t' 0 'kFALSE' setDefaultPort", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetUser",715,G__G__Base3_167_0_23, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - user", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPasswd",926,G__G__Base3_167_0_24, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - pw", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetHost",714,G__G__Base3_167_0_25, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - host", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFile",684,G__G__Base3_167_0_26, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - file", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetAnchor",903,G__G__Base3_167_0_27, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - anchor", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetOptions",1048,G__G__Base3_167_0_28, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - opt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPort",721,G__G__Base3_167_0_29, 121, -1, -1, 0, 1, 1, 1, 0, "i - 'Int_t' 0 - port", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetUrl",607,G__G__Base3_167_0_30, 121, -1, -1, 0, 2, 1, 1, 0, 
"C - - 10 - url g - 'Bool_t' 0 'kFALSE' defaultIsFile", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsSortable",1016,(G__InterfaceMethod) NULL,103, -1, G__defined_typename("Bool_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Compare",711,(G__InterfaceMethod) NULL,105, -1, G__defined_typename("Int_t"), 0, 1, 1, 1, 8, "U 'TObject' - 10 - obj", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Print",525,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 8, "C - 'Option_t' 10 '\"\"' option", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetSpecialProtocols",1958,G__G__Base3_167_0_34, 85, G__get_linked_tagnum(&G__G__Base3LN_TObjArray), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TObjArray* (*)())(&TUrl::GetSpecialProtocols) ), 0);
   G__memfunc_setup("Class",502,G__G__Base3_167_0_35, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TUrl::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__Base3_167_0_36, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TUrl::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__Base3_167_0_37, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TUrl::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__Base3_167_0_38, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TUrl::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__Base3_167_0_42, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__Base3_167_0_43, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TUrl::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__Base3_167_0_44, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TUrl::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__Base3_167_0_45, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TUrl::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__Base3_167_0_46, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TUrl::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~TUrl", 517, G__G__Base3_167_0_47, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTInetAddress(void) {
   /* TInetAddress */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_TInetAddress));
   G__memfunc_setup("TInetAddress",1194,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__Base3LN_TInetAddress), -1, 0, 4, 1, 4, 0, 
"C - - 10 - host h - 'UInt_t' 0 - addr "
"i - 'Int_t' 0 - family i - 'Int_t' 0 '-1' port", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddAddress",975,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 1, 1, 4, 0, "h - 'UInt_t' 0 - addr", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddAlias",755,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 1, 1, 4, 0, "C - - 10 - alias", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TInetAddress",1194,G__G__Base3_168_0_4, 105, G__get_linked_tagnum(&G__G__Base3LN_TInetAddress), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TInetAddress",1194,G__G__Base3_168_0_5, 105, G__get_linked_tagnum(&G__G__Base3LN_TInetAddress), -1, 0, 1, 1, 1, 0, "u 'TInetAddress' - 11 - adr", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__Base3_168_0_6, 117, G__get_linked_tagnum(&G__G__Base3LN_TInetAddress), -1, 1, 1, 1, 1, 0, "u 'TInetAddress' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetAddress",998,G__G__Base3_168_0_7, 104, -1, G__defined_typename("UInt_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetAddressBytes",1517,G__G__Base3_168_0_8, 66, -1, G__defined_typename("UChar_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetHostAddress",1412,G__G__Base3_168_0_9, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetHostName",1087,G__G__Base3_168_0_10, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetFamily",898,G__G__Base3_168_0_11, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetPort",709,G__G__Base3_168_0_12, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetAddresses",1214,G__G__Base3_168_0_13, 117, G__get_linked_tagnum(&G__G__Base3LN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR), G__defined_typename("TInetAddress::AddressList_t"), 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetAliases",994,G__G__Base3_168_0_14, 117, G__get_linked_tagnum(&G__G__Base3LN_vectorlETStringcOallocatorlETStringgRsPgR), G__defined_typename("TInetAddress::AliasList_t"), 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsValid",684,G__G__Base3_168_0_15, 103, -1, G__defined_typename("Bool_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Print",525,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 8, "C - 'Option_t' 10 '\"\"' option", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetHostAddress",1412,G__G__Base3_168_0_17, 67, -1, -1, 0, 1, 3, 1, 1, "h - 'UInt_t' 0 - addr", (char*)NULL, (void*) G__func2void( (const char* (*)(UInt_t))(&TInetAddress::GetHostAddress) ), 0);
   G__memfunc_setup("Class",502,G__G__Base3_168_0_18, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TInetAddress::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__Base3_168_0_19, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TInetAddress::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__Base3_168_0_20, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TInetAddress::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__Base3_168_0_21, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TInetAddress::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__Base3_168_0_25, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__Base3_168_0_26, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TInetAddress::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__Base3_168_0_27, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TInetAddress::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__Base3_168_0_28, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TInetAddress::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__Base3_168_0_29, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TInetAddress::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~TInetAddress", 1320, G__G__Base3_168_0_30, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTFileInfoMeta(void) {
   /* TFileInfoMeta */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_TFileInfoMeta));
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_TFileInfoMeta), -1, 1, 1, 1, 4, 0, "u 'TFileInfoMeta' - 11 - -", "not implemented", (void*) NULL, 0);
   G__memfunc_setup("TFileInfoMeta",1255,G__G__Base3_177_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_TFileInfoMeta), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TFileInfoMeta",1255,G__G__Base3_177_0_3, 105, G__get_linked_tagnum(&G__G__Base3LN_TFileInfoMeta), -1, 0, 7, 1, 1, 0, 
"C - - 10 - objPath C - - 10 '\"TTree\"' objClass "
"n - 'Long64_t' 0 '-1' entries n - 'Long64_t' 0 '0' first "
"n - 'Long64_t' 0 '-1' last n - 'Long64_t' 0 '-1' totbytes "
"n - 'Long64_t' 0 '-1' zipbytes", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TFileInfoMeta",1255,G__G__Base3_177_0_4, 105, G__get_linked_tagnum(&G__G__Base3LN_TFileInfoMeta), -1, 0, 8, 1, 1, 0, 
"C - - 10 - objPath C - - 10 - objDir "
"C - - 10 - objClass n - 'Long64_t' 0 '-1' entries "
"n - 'Long64_t' 0 '0' first n - 'Long64_t' 0 '-1' last "
"n - 'Long64_t' 0 '-1' totbytes n - 'Long64_t' 0 '-1' zipbytes", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TFileInfoMeta",1255,G__G__Base3_177_0_5, 105, G__get_linked_tagnum(&G__G__Base3LN_TFileInfoMeta), -1, 0, 1, 1, 1, 0, "u 'TFileInfoMeta' - 11 - m", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetObject",887,G__G__Base3_177_0_6, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetClass",790,G__G__Base3_177_0_7, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetDirectory",1237,G__G__Base3_177_0_8, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetEntries",1018,G__G__Base3_177_0_9, 110, -1, G__defined_typename("Long64_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetFirst",808,G__G__Base3_177_0_10, 110, -1, G__defined_typename("Long64_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetLast",692,G__G__Base3_177_0_11, 110, -1, G__defined_typename("Long64_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsTree",588,G__G__Base3_177_0_12, 103, -1, G__defined_typename("Bool_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetTotBytes",1118,G__G__Base3_177_0_13, 110, -1, G__defined_typename("Long64_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetZipBytes",1114,G__G__Base3_177_0_14, 110, -1, G__defined_typename("Long64_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetEntries",1030,G__G__Base3_177_0_15, 121, -1, -1, 0, 1, 1, 1, 0, "n - 'Long64_t' 0 - entries", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFirst",820,G__G__Base3_177_0_16, 121, -1, -1, 0, 1, 1, 1, 0, "n - 'Long64_t' 0 - first", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetLast",704,G__G__Base3_177_0_17, 121, -1, -1, 0, 1, 1, 1, 0, "n - 'Long64_t' 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetTotBytes",1130,G__G__Base3_177_0_18, 121, -1, -1, 0, 1, 1, 1, 0, "n - 'Long64_t' 0 - tot", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetZipBytes",1126,G__G__Base3_177_0_19, 121, -1, -1, 0, 1, 1, 1, 0, "n - 'Long64_t' 0 - zip", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Print",525,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 8, "C - 'Option_t' 10 '\"\"' options", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Class",502,G__G__Base3_177_0_21, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TFileInfoMeta::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__Base3_177_0_22, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TFileInfoMeta::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__Base3_177_0_23, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TFileInfoMeta::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__Base3_177_0_24, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TFileInfoMeta::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__Base3_177_0_28, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__Base3_177_0_29, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TFileInfoMeta::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__Base3_177_0_30, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TFileInfoMeta::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__Base3_177_0_31, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TFileInfoMeta::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__Base3_177_0_32, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TFileInfoMeta::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~TFileInfoMeta", 1381, G__G__Base3_177_0_33, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTFileInfo(void) {
   /* TFileInfo */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_TFileInfo));
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_TFileInfo), -1, 1, 1, 1, 4, 0, "u 'TFileInfo' - 11 - -", "not implemented", (void*) NULL, 0);
   G__memfunc_setup("TFileInfo",864,G__G__Base3_178_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_TFileInfo), -1, 0, 5, 1, 1, 0, 
"C - - 10 '0' url n - 'Long64_t' 0 '-1' size "
"C - - 10 '0' uuid C - - 10 '0' md5 "
"U 'TObject' - 0 '0' meta", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TFileInfo",864,G__G__Base3_178_0_3, 105, G__get_linked_tagnum(&G__G__Base3LN_TFileInfo), -1, 0, 1, 1, 1, 0, "u 'TFileInfo' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ResetUrl",822,G__G__Base3_178_0_4, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NextUrl",722,G__G__Base3_178_0_5, 85, G__get_linked_tagnum(&G__G__Base3LN_TUrl), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetCurrentUrl",1334,G__G__Base3_178_0_6, 85, G__get_linked_tagnum(&G__G__Base3LN_TUrl), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetFirstUrl",1115,G__G__Base3_178_0_7, 85, G__get_linked_tagnum(&G__G__Base3LN_TUrl), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNUrls",788,G__G__Base3_178_0_8, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetCurrentUrl",1346,G__G__Base3_178_0_9, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 0, "C - - 10 - url", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetCurrentUrl",1346,G__G__Base3_178_0_10, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 0, "U 'TUrl' - 0 - url", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetSize",699,G__G__Base3_178_0_11, 110, -1, G__defined_typename("Long64_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetUUID",599,G__G__Base3_178_0_12, 85, G__get_linked_tagnum(&G__G__Base3LN_TUUID), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetMD5",486,G__G__Base3_178_0_13, 85, G__get_linked_tagnum(&G__G__Base3LN_TMD5), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetMetaDataList",1469,G__G__Base3_178_0_14, 85, G__get_linked_tagnum(&G__G__Base3LN_TList), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetMetaData",1057,G__G__Base3_178_0_15, 85, G__get_linked_tagnum(&G__G__Base3LN_TFileInfoMeta), -1, 0, 1, 1, 1, 8, "C - - 10 '0' meta", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetSize",711,G__G__Base3_178_0_16, 121, -1, -1, 0, 1, 1, 1, 0, "n - 'Long64_t' 0 - size", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetUUID",611,G__G__Base3_178_0_17, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - uuid", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FindByUrl",879,G__G__Base3_178_0_18, 85, G__get_linked_tagnum(&G__G__Base3LN_TUrl), -1, 0, 2, 1, 1, 0, 
"C - - 10 - url g - 'Bool_t' 0 'kFALSE' withDeflt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddUrl",572,G__G__Base3_178_0_19, 103, -1, G__defined_typename("Bool_t"), 0, 2, 1, 1, 0, 
"C - - 10 - url g - 'Bool_t' 0 'kFALSE' infront", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RemoveUrl",929,G__G__Base3_178_0_20, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 0, "C - - 10 - url", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddMetaData",1034,G__G__Base3_178_0_21, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 0, "U 'TObject' - 0 - meta", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RemoveMetaData",1391,G__G__Base3_178_0_22, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 0, "C - - 10 '0' meta", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsSortable",1016,(G__InterfaceMethod) NULL,103, -1, G__defined_typename("Bool_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Compare",711,(G__InterfaceMethod) NULL,105, -1, G__defined_typename("Int_t"), 0, 1, 1, 1, 8, "U 'TObject' - 10 - obj", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Print",525,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 8, "C - 'Option_t' 10 '\"\"' options", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Class",502,G__G__Base3_178_0_26, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TFileInfo::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__Base3_178_0_27, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TFileInfo::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__Base3_178_0_28, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TFileInfo::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__Base3_178_0_29, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TFileInfo::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__Base3_178_0_33, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__Base3_178_0_34, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TFileInfo::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__Base3_178_0_35, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TFileInfo::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__Base3_178_0_36, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TFileInfo::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__Base3_178_0_37, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TFileInfo::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~TFileInfo", 990, G__G__Base3_178_0_38, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTFileCollection(void) {
   /* TFileCollection */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_TFileCollection));
   G__memfunc_setup("TFileCollection",1504,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__Base3LN_TFileCollection), -1, 0, 1, 1, 4, 0, "u 'TFileCollection' - 11 - -", "not implemented", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_TFileCollection), -1, 1, 1, 1, 4, 0, "u 'TFileCollection' - 11 - -", "not implemented", (void*) NULL, 0);
   G__memfunc_setup("TFileCollection",1504,G__G__Base3_181_0_3, 105, G__get_linked_tagnum(&G__G__Base3LN_TFileCollection), -1, 0, 5, 1, 1, 0, 
"C - - 10 '0' name C - - 10 '0' title "
"C - - 10 '0' file i - 'Int_t' 0 '-1' nfiles "
"i - 'Int_t' 0 '1' firstfile", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Add",265,G__G__Base3_181_0_4, 105, -1, G__defined_typename("Int_t"), 0, 1, 1, 1, 0, "U 'TFileInfo' - 0 - info", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Add",265,G__G__Base3_181_0_5, 105, -1, G__defined_typename("Int_t"), 0, 1, 1, 1, 0, "U 'TFileCollection' - 0 - coll", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddFromFile",1053,G__G__Base3_181_0_6, 105, -1, G__defined_typename("Int_t"), 0, 3, 1, 1, 0, 
"C - - 10 - file i - 'Int_t' 0 '-1' nfiles "
"i - 'Int_t' 0 '1' firstfile", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Add",265,G__G__Base3_181_0_7, 105, -1, G__defined_typename("Int_t"), 0, 1, 1, 1, 0, "C - - 10 - path", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetList",700,G__G__Base3_181_0_8, 85, G__get_linked_tagnum(&G__G__Base3LN_THashList), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetList",712,G__G__Base3_181_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "U 'THashList' - 0 - list", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ExportInfo",1038,G__G__Base3_181_0_10, 85, G__get_linked_tagnum(&G__G__Base3LN_TObjString), -1, 0, 2, 1, 1, 0, 
"C - - 10 '0' name i - 'Int_t' 0 '0' popt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RemoveDuplicates",1660,G__G__Base3_181_0_11, 105, -1, G__defined_typename("Int_t"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Update",611,G__G__Base3_181_0_12, 105, -1, G__defined_typename("Int_t"), 0, 1, 1, 1, 0, "n - 'Long64_t' 0 '-1' avgsize", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Sort",424,G__G__Base3_181_0_13, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetAnchor",903,G__G__Base3_181_0_14, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - anchor", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Print",525,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 8, "C - 'Option_t' 10 '\"\"' option", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetBitAll",868,G__G__Base3_181_0_16, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'UInt_t' 0 - f", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ResetBitAll",1083,G__G__Base3_181_0_17, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'UInt_t' 0 - f", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetTotalSize",1215,G__G__Base3_181_0_18, 110, -1, G__defined_typename("Long64_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNFiles",865,G__G__Base3_181_0_19, 110, -1, G__defined_typename("Long64_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNStagedFiles",1465,G__G__Base3_181_0_20, 110, -1, G__defined_typename("Long64_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetNCorruptFiles",1616,G__G__Base3_181_0_21, 110, -1, G__defined_typename("Long64_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetStagedPercentage",1910,G__G__Base3_181_0_22, 102, -1, G__defined_typename("Float_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetCorruptedPercentage",2262,G__G__Base3_181_0_23, 102, -1, G__defined_typename("Float_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetDefaultTreeName",1782,G__G__Base3_181_0_24, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetDefaultTreeName",1794,G__G__Base3_181_0_25, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - treeName", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetTotalEntries",1534,G__G__Base3_181_0_26, 110, -1, G__defined_typename("Long64_t"), 0, 1, 1, 1, 8, "C - - 10 - tree", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetMetaData",1057,G__G__Base3_181_0_27, 85, G__get_linked_tagnum(&G__G__Base3LN_TFileInfoMeta), -1, 0, 1, 1, 1, 8, "C - - 10 '0' meta", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetDefaultMetaData",1778,G__G__Base3_181_0_28, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 - meta", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AddMetaData",1034,G__G__Base3_181_0_29, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 0, "U 'TObject' - 0 - meta", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RemoveMetaData",1391,G__G__Base3_181_0_30, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 '0' meta", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetStagedSubset",1518,G__G__Base3_181_0_31, 85, G__get_linked_tagnum(&G__G__Base3LN_TFileCollection), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetFilesOnServer",1607,G__G__Base3_181_0_32, 85, G__get_linked_tagnum(&G__G__Base3LN_TFileCollection), -1, 0, 1, 1, 1, 0, "C - - 10 - server", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetFilesPerServer",1713,G__G__Base3_181_0_33, 85, G__get_linked_tagnum(&G__G__Base3LN_TMap), -1, 0, 1, 1, 1, 0, "C - - 10 '0' exclude", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__G__Base3_181_0_34, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TFileCollection::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__Base3_181_0_35, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TFileCollection::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__Base3_181_0_36, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TFileCollection::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__Base3_181_0_37, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TFileCollection::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__Base3_181_0_41, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__Base3_181_0_42, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TFileCollection::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__Base3_181_0_43, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TFileCollection::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__Base3_181_0_44, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TFileCollection::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__Base3_181_0_45, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TFileCollection::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~TFileCollection", 1630, G__G__Base3_181_0_46, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTRedirectOutputGuard(void) {
   /* TRedirectOutputGuard */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_TRedirectOutputGuard));
   G__memfunc_setup("TRedirectOutputGuard",2058,G__G__Base3_225_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_TRedirectOutputGuard), -1, 0, 2, 1, 1, 0, 
"C - - 10 - fout C - - 10 '\"a\"' mode", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__G__Base3_225_0_2, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TRedirectOutputGuard::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__Base3_225_0_3, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRedirectOutputGuard::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__Base3_225_0_4, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TRedirectOutputGuard::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__Base3_225_0_5, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TRedirectOutputGuard::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,G__G__Base3_225_0_6, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,G__G__Base3_225_0_7, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,G__G__Base3_225_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__Base3_225_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__Base3_225_0_10, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRedirectOutputGuard::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__Base3_225_0_11, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TRedirectOutputGuard::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__Base3_225_0_12, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TRedirectOutputGuard::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__Base3_225_0_13, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TRedirectOutputGuard::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("TRedirectOutputGuard", 2058, G__G__Base3_225_0_14, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_TRedirectOutputGuard), -1, 0, 1, 1, 1, 0, "u 'TRedirectOutputGuard' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TRedirectOutputGuard", 2184, G__G__Base3_225_0_15, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Base3_225_0_16, (int) ('u'), G__get_linked_tagnum(&G__G__Base3LN_TRedirectOutputGuard), -1, 1, 1, 1, 1, 0, "u 'TRedirectOutputGuard' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTVirtualMonitoringWriter(void) {
   /* TVirtualMonitoringWriter */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringWriter));
   G__memfunc_setup("TVirtualMonitoringWriter",2526,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringWriter), -1, 0, 1, 1, 4, 0, "u 'TVirtualMonitoringWriter' - 11 - -", "Not implemented", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringWriter), -1, 1, 1, 1, 4, 0, "u 'TVirtualMonitoringWriter' - 11 - -", "Not implemented", (void*) NULL, 0);
   G__memfunc_setup("TVirtualMonitoringWriter",2526,G__G__Base3_226_0_3, 105, G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringWriter), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TVirtualMonitoringWriter",2526,G__G__Base3_226_0_4, 105, G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringWriter), -1, 0, 2, 1, 1, 0, 
"C - - 10 - name d - 'Double_t' 0 - value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SendFileCloseEvent",1794,G__G__Base3_226_0_5, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 0, "U 'TFile' - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SendFileReadProgress",2011,G__G__Base3_226_0_6, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 0, "U 'TFile' - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SendFileWriteProgress",2154,G__G__Base3_226_0_7, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 0, "U 'TFile' - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SendParameters",1438,G__G__Base3_226_0_8, 103, -1, G__defined_typename("Bool_t"), 0, 2, 1, 1, 0, 
"U 'TList' - 0 - - C - - 10 '0' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SendInfoTime",1189,G__G__Base3_226_0_9, 103, -1, G__defined_typename("Bool_t"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SendInfoUser",1205,G__G__Base3_226_0_10, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 0, "C - - 10 '0' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SendInfoDescription",1946,G__G__Base3_226_0_11, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 0, "C - - 10 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SendInfoStatus",1434,G__G__Base3_226_0_12, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 0, "C - - 10 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SendFileOpenProgress",2033,G__G__Base3_226_0_13, 103, -1, G__defined_typename("Bool_t"), 0, 4, 1, 1, 0, 
"U 'TFile' - 0 - - U 'TList' - 0 - - "
"C - - 10 - - g - 'Bool_t' 0 'kFALSE' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SendProcessingStatus",2091,G__G__Base3_226_0_14, 103, -1, G__defined_typename("Bool_t"), 0, 2, 1, 1, 0, 
"C - - 10 - - g - 'Bool_t' 0 'kFALSE' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SendProcessingProgress",2300,G__G__Base3_226_0_15, 103, -1, G__defined_typename("Bool_t"), 0, 3, 1, 1, 0, 
"d - 'Double_t' 0 - - d - 'Double_t' 0 - - "
"g - 'Bool_t' 0 'kFALSE' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("SetLogLevel",1094,G__G__Base3_226_0_16, 121, -1, -1, 0, 1, 1, 1, 0, "C - - 10 '\"WARNING\"' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Verbose",726,G__G__Base3_226_0_17, 121, -1, -1, 0, 1, 1, 1, 0, "g - 'Bool_t' 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Class",502,G__G__Base3_226_0_18, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TVirtualMonitoringWriter::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__Base3_226_0_19, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualMonitoringWriter::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__Base3_226_0_20, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TVirtualMonitoringWriter::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__Base3_226_0_21, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TVirtualMonitoringWriter::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__Base3_226_0_25, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__Base3_226_0_26, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualMonitoringWriter::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__Base3_226_0_27, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TVirtualMonitoringWriter::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__Base3_226_0_28, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualMonitoringWriter::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__Base3_226_0_29, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TVirtualMonitoringWriter::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~TVirtualMonitoringWriter", 2652, G__G__Base3_226_0_30, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTVirtualMonitoringReader(void) {
   /* TVirtualMonitoringReader */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringReader));
   G__memfunc_setup("TVirtualMonitoringReader",2484,G__G__Base3_227_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringReader), -1, 0, 1, 1, 1, 0, "C - - 10 '\"\"' -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DumpResult",1045,G__G__Base3_227_0_2, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetValues",912,G__G__Base3_227_0_3, 121, -1, -1, 0, 7, 1, 1, 0, 
"C - - 10 - - C - - 10 - - "
"C - - 10 - - C - - 10 - - "
"l - 'Long_t' 0 - - l - 'Long_t' 0 - - "
"g - 'Bool_t' 0 'kFALSE' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetLastValues",1316,G__G__Base3_227_0_4, 121, -1, -1, 0, 5, 1, 1, 0, 
"C - - 10 - - C - - 10 - - "
"C - - 10 - - C - - 10 - - "
"g - 'Bool_t' 0 'kFALSE' -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ProxyValues",1170,G__G__Base3_227_0_5, 121, -1, -1, 0, 7, 1, 1, 0, 
"C - - 10 - - C - - 10 - - "
"C - - 10 - - C - - 10 - - "
"l - 'Long_t' 0 - - l - 'Long_t' 0 - - "
"l - 'Long_t' 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetMap",574,G__G__Base3_227_0_6, 85, G__get_linked_tagnum(&G__G__Base3LN_TMap), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("DeleteMap",881,G__G__Base3_227_0_7, 121, -1, -1, 0, 1, 1, 1, 0, "U 'TMap' - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Class",502,G__G__Base3_227_0_8, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TVirtualMonitoringReader::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__Base3_227_0_9, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualMonitoringReader::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__Base3_227_0_10, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TVirtualMonitoringReader::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__Base3_227_0_11, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TVirtualMonitoringReader::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__Base3_227_0_15, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__Base3_227_0_16, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualMonitoringReader::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__Base3_227_0_17, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TVirtualMonitoringReader::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__Base3_227_0_18, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualMonitoringReader::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__Base3_227_0_19, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TVirtualMonitoringReader::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("TVirtualMonitoringReader", 2484, G__G__Base3_227_0_20, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringReader), -1, 0, 1, 1, 1, 0, "u 'TVirtualMonitoringReader' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TVirtualMonitoringReader", 2610, G__G__Base3_227_0_21, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Base3_227_0_22, (int) ('u'), G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringReader), -1, 1, 1, 1, 1, 0, "u 'TVirtualMonitoringReader' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTObjectSpy(void) {
   /* TObjectSpy */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_TObjectSpy));
   G__memfunc_setup("TObjectSpy",999,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__Base3LN_TObjectSpy), -1, 0, 1, 1, 4, 0, "u 'TObjectSpy' - 11 - s", "Not implemented. : TObject(), fObj(s.fObj), fFixMustCleanupBit(s.fFixMustCleanupBit) { }", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_TObjectSpy), -1, 1, 1, 1, 4, 0, "u 'TObjectSpy' - 11 - s", "Not implemented. { fObj = s.fObj; fFixMustCleanupBit = s.fFixMustCleanupBit; return *this; }", (void*) NULL, 0);
   G__memfunc_setup("TObjectSpy",999,G__G__Base3_228_0_3, 105, G__get_linked_tagnum(&G__G__Base3LN_TObjectSpy), -1, 0, 2, 1, 1, 0, 
"U 'TObject' - 0 '0' obj g - 'Bool_t' 0 'kTRUE' fixMustCleanupBit", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RecursiveRemove",1574,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "U 'TObject' - 0 - obj", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetObject",887,G__G__Base3_228_0_5, 85, G__get_linked_tagnum(&G__G__Base3LN_TObject), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetObject",899,G__G__Base3_228_0_6, 121, -1, -1, 0, 2, 1, 1, 0, 
"U 'TObject' - 0 - obj g - 'Bool_t' 0 'kTRUE' fixMustCleanupBit", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__G__Base3_228_0_7, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TObjectSpy::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__Base3_228_0_8, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TObjectSpy::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__Base3_228_0_9, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TObjectSpy::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__Base3_228_0_10, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TObjectSpy::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__Base3_228_0_14, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__Base3_228_0_15, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TObjectSpy::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__Base3_228_0_16, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TObjectSpy::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__Base3_228_0_17, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TObjectSpy::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__Base3_228_0_18, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TObjectSpy::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~TObjectSpy", 1125, G__G__Base3_228_0_19, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTObjectRefSpy(void) {
   /* TObjectRefSpy */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_TObjectRefSpy));
   G__memfunc_setup("TObjectRefSpy",1284,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G__Base3LN_TObjectRefSpy), -1, 0, 1, 1, 4, 0, "u 'TObjectRefSpy' - 11 - s", "Not implemented.  : TObject(), fObj(s.fObj), fFixMustCleanupBit(s.fFixMustCleanupBit) { }", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_TObjectRefSpy), -1, 1, 1, 1, 4, 0, "u 'TObjectRefSpy' - 11 - s", "Not implemented. { fObj = s.fObj; fFixMustCleanupBit = s.fFixMustCleanupBit; return *this; }", (void*) NULL, 0);
   G__memfunc_setup("TObjectRefSpy",1284,G__G__Base3_229_0_3, 105, G__get_linked_tagnum(&G__G__Base3LN_TObjectRefSpy), -1, 0, 2, 1, 1, 0, 
"U 'TObject' - 1 - obj g - 'Bool_t' 0 'kTRUE' fixMustCleanupBit", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("RecursiveRemove",1574,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "U 'TObject' - 0 - obj", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetObject",887,G__G__Base3_229_0_5, 85, G__get_linked_tagnum(&G__G__Base3LN_TObject), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__G__Base3_229_0_6, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TObjectRefSpy::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__Base3_229_0_7, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TObjectRefSpy::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__Base3_229_0_8, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TObjectRefSpy::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__Base3_229_0_9, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TObjectRefSpy::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__Base3_229_0_13, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__Base3_229_0_14, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TObjectRefSpy::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__Base3_229_0_15, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TObjectRefSpy::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__Base3_229_0_16, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TObjectRefSpy::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__Base3_229_0_17, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TObjectRefSpy::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~TObjectRefSpy", 1410, G__G__Base3_229_0_18, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTUri(void) {
   /* TUri */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_TUri));
   G__memfunc_setup("TUri",388,G__G__Base3_230_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_TUri), -1, 0, 1, 1, 1, 0, "u 'TUri' - 11 - uri", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TUri",388,G__G__Base3_230_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_TUri), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TUri",388,G__G__Base3_230_0_3, 105, G__get_linked_tagnum(&G__G__Base3LN_TUri), -1, 0, 1, 1, 1, 0, "u 'TString' - 11 - uri", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TUri",388,G__G__Base3_230_0_4, 105, G__get_linked_tagnum(&G__G__Base3LN_TUri), -1, 0, 1, 1, 1, 0, "C - - 10 - uri", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G__Base3_230_0_5, 117, G__get_linked_tagnum(&G__G__Base3LN_TUri), -1, 1, 1, 1, 1, 0, "u 'TUri' - 11 - rhs", "copy ctor", (void*) NULL, 0);
   G__memfunc_setup("GetUri",592,G__G__Base3_230_0_6, 117, G__get_linked_tagnum(&G__G__Base3LN_TString), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetScheme",885,G__G__Base3_230_0_7, 117, G__get_linked_tagnum(&G__G__Base3LN_TString), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetHierPart",1087,G__G__Base3_230_0_8, 117, G__get_linked_tagnum(&G__G__Base3LN_TString), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetRelativePart",1523,G__G__Base3_230_0_9, 117, G__get_linked_tagnum(&G__G__Base3LN_TString), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetAuthority",1257,G__G__Base3_230_0_10, 117, G__get_linked_tagnum(&G__G__Base3LN_TString), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetUserInfo",1099,G__G__Base3_230_0_11, 117, G__get_linked_tagnum(&G__G__Base3LN_TString), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetHost",702,G__G__Base3_230_0_12, 117, G__get_linked_tagnum(&G__G__Base3LN_TString), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetPort",709,G__G__Base3_230_0_13, 117, G__get_linked_tagnum(&G__G__Base3LN_TString), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetPath",685,G__G__Base3_230_0_14, 117, G__get_linked_tagnum(&G__G__Base3LN_TString), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetQuery",822,G__G__Base3_230_0_15, 117, G__get_linked_tagnum(&G__G__Base3LN_TString), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetFragment",1108,G__G__Base3_230_0_16, 117, G__get_linked_tagnum(&G__G__Base3LN_TString), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("HasScheme",881,G__G__Base3_230_0_17, 103, -1, G__defined_typename("Bool_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("HasHierPart",1083,G__G__Base3_230_0_18, 103, -1, G__defined_typename("Bool_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("HasAuthority",1253,G__G__Base3_230_0_19, 103, -1, G__defined_typename("Bool_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("HasUserInfo",1095,G__G__Base3_230_0_20, 103, -1, G__defined_typename("Bool_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("HasHost",698,G__G__Base3_230_0_21, 103, -1, G__defined_typename("Bool_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("HasPort",705,G__G__Base3_230_0_22, 103, -1, G__defined_typename("Bool_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("HasPath",681,G__G__Base3_230_0_23, 103, -1, G__defined_typename("Bool_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("HasQuery",818,G__G__Base3_230_0_24, 103, -1, G__defined_typename("Bool_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("HasFragment",1104,G__G__Base3_230_0_25, 103, -1, G__defined_typename("Bool_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("HasRelativePart",1519,G__G__Base3_230_0_26, 103, -1, G__defined_typename("Bool_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetUri",604,G__G__Base3_230_0_27, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 0, "u 'TString' - 11 - uri", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetScheme",897,G__G__Base3_230_0_28, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 0, "u 'TString' - 11 - scheme", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetHierPart",1099,G__G__Base3_230_0_29, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 0, "u 'TString' - 11 - hier", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetAuthority",1269,G__G__Base3_230_0_30, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 0, "u 'TString' - 11 - authority", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetUserInfo",1111,G__G__Base3_230_0_31, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 0, "u 'TString' - 11 - userinfo", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetHost",714,G__G__Base3_230_0_32, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 0, "u 'TString' - 11 - host", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPort",721,G__G__Base3_230_0_33, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 0, "u 'TString' - 11 - port", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPath",697,G__G__Base3_230_0_34, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 0, "u 'TString' - 11 - path", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetQuery",834,G__G__Base3_230_0_35, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 0, "u 'TString' - 11 - path", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetFragment",1120,G__G__Base3_230_0_36, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 0, "u 'TString' - 11 - fragment", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetRelativePart",1535,G__G__Base3_230_0_37, 103, -1, G__defined_typename("Bool_t"), 0, 1, 1, 1, 0, "u 'TString' - 11 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Print",525,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 8, "C - 'Option_t' 10 '\"\"' option", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("IsSortable",1016,(G__InterfaceMethod) NULL,103, -1, G__defined_typename("Bool_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Normalise",938,G__G__Base3_230_0_40, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Reset",515,G__G__Base3_230_0_41, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsAbsolute",1019,G__G__Base3_230_0_42, 103, -1, G__defined_typename("Bool_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsRelative",1016,G__G__Base3_230_0_43, 103, -1, G__defined_typename("Bool_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsUri",492,G__G__Base3_230_0_44, 103, -1, G__defined_typename("Bool_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsReference",1099,G__G__Base3_230_0_45, 103, -1, G__defined_typename("Bool_t"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsUnreserved",1247,G__G__Base3_230_0_46, 103, -1, G__defined_typename("Bool_t"), 0, 1, 3, 1, 0, "u 'TString' - 11 - string", (char*)NULL, (void*) G__func2void( (Bool_t (*)(const TString&))(&TUri::IsUnreserved) ), 0);
   G__memfunc_setup("PctEncode",885,G__G__Base3_230_0_47, 117, G__get_linked_tagnum(&G__G__Base3LN_TString), -1, 0, 1, 3, 1, 1, "u 'TString' - 11 - source", (char*)NULL, (void*) G__func2void( (const TString (*)(const TString&))(&TUri::PctEncode) ), 0);
   G__memfunc_setup("PctDecode",875,G__G__Base3_230_0_48, 117, G__get_linked_tagnum(&G__G__Base3LN_TString), -1, 0, 1, 3, 1, 1, "u 'TString' - 11 - source", (char*)NULL, (void*) G__func2void( (const TString (*)(const TString&))(&TUri::PctDecode) ), 0);
   G__memfunc_setup("PctDecodeUnreserved",1934,G__G__Base3_230_0_49, 117, G__get_linked_tagnum(&G__G__Base3LN_TString), -1, 0, 1, 3, 1, 1, "u 'TString' - 11 - source", (char*)NULL, (void*) G__func2void( (const TString (*)(const TString&))(&TUri::PctDecodeUnreserved) ), 0);
   G__memfunc_setup("PctNormalise",1233,G__G__Base3_230_0_50, 117, G__get_linked_tagnum(&G__G__Base3LN_TString), -1, 0, 1, 3, 1, 1, "u 'TString' - 11 - source", (char*)NULL, (void*) G__func2void( (const TString (*)(const TString&))(&TUri::PctNormalise) ), 0);
   G__memfunc_setup("IsScheme",785,G__G__Base3_230_0_51, 103, -1, G__defined_typename("Bool_t"), 0, 1, 3, 1, 0, "u 'TString' - 11 - -", (char*)NULL, (void*) G__func2void( (Bool_t (*)(const TString&))(&TUri::IsScheme) ), 0);
   G__memfunc_setup("IsHierPart",987,G__G__Base3_230_0_52, 103, -1, G__defined_typename("Bool_t"), 0, 1, 3, 1, 0, "u 'TString' - 11 - -", (char*)NULL, (void*) G__func2void( (Bool_t (*)(const TString&))(&TUri::IsHierPart) ), 0);
   G__memfunc_setup("IsAuthority",1157,G__G__Base3_230_0_53, 103, -1, G__defined_typename("Bool_t"), 0, 1, 3, 1, 0, "u 'TString' - 11 - -", (char*)NULL, (void*) G__func2void( (Bool_t (*)(const TString&))(&TUri::IsAuthority) ), 0);
   G__memfunc_setup("IsUserInfo",999,G__G__Base3_230_0_54, 103, -1, G__defined_typename("Bool_t"), 0, 1, 3, 1, 0, "u 'TString' - 11 - -", (char*)NULL, (void*) G__func2void( (Bool_t (*)(const TString&))(&TUri::IsUserInfo) ), 0);
   G__memfunc_setup("IsHost",602,G__G__Base3_230_0_55, 103, -1, G__defined_typename("Bool_t"), 0, 1, 3, 1, 0, "u 'TString' - 11 - -", (char*)NULL, (void*) G__func2void( (Bool_t (*)(const TString&))(&TUri::IsHost) ), 0);
   G__memfunc_setup("IsIpv4",543,G__G__Base3_230_0_56, 103, -1, G__defined_typename("Bool_t"), 0, 1, 3, 1, 0, "u 'TString' - 11 - -", (char*)NULL, (void*) G__func2void( (Bool_t (*)(const TString&))(&TUri::IsIpv4) ), 0);
   G__memfunc_setup("IsRegName",859,G__G__Base3_230_0_57, 103, -1, G__defined_typename("Bool_t"), 0, 1, 3, 1, 0, "u 'TString' - 11 - -", (char*)NULL, (void*) G__func2void( (Bool_t (*)(const TString&))(&TUri::IsRegName) ), 0);
   G__memfunc_setup("IsPort",609,G__G__Base3_230_0_58, 103, -1, G__defined_typename("Bool_t"), 0, 1, 3, 1, 0, "u 'TString' - 11 - -", (char*)NULL, (void*) G__func2void( (Bool_t (*)(const TString&))(&TUri::IsPort) ), 0);
   G__memfunc_setup("IsPath",585,G__G__Base3_230_0_59, 103, -1, G__defined_typename("Bool_t"), 0, 1, 3, 1, 0, "u 'TString' - 11 - -", (char*)NULL, (void*) G__func2void( (Bool_t (*)(const TString&))(&TUri::IsPath) ), 0);
   G__memfunc_setup("IsPathAbsolute",1416,G__G__Base3_230_0_60, 103, -1, G__defined_typename("Bool_t"), 0, 1, 3, 1, 0, "u 'TString' - 11 - -", (char*)NULL, (void*) G__func2void( (Bool_t (*)(const TString&))(&TUri::IsPathAbsolute) ), 0);
   G__memfunc_setup("IsPathAbempty",1307,G__G__Base3_230_0_61, 103, -1, G__defined_typename("Bool_t"), 0, 1, 3, 1, 0, "u 'TString' - 11 - -", (char*)NULL, (void*) G__func2void( (Bool_t (*)(const TString&))(&TUri::IsPathAbempty) ), 0);
   G__memfunc_setup("IsPathNoscheme",1403,G__G__Base3_230_0_62, 103, -1, G__defined_typename("Bool_t"), 0, 1, 3, 1, 0, "u 'TString' - 11 - -", (char*)NULL, (void*) G__func2void( (Bool_t (*)(const TString&))(&TUri::IsPathNoscheme) ), 0);
   G__memfunc_setup("IsPathRootless",1444,G__G__Base3_230_0_63, 103, -1, G__defined_typename("Bool_t"), 0, 1, 3, 1, 0, "u 'TString' - 11 - -", (char*)NULL, (void*) G__func2void( (Bool_t (*)(const TString&))(&TUri::IsPathRootless) ), 0);
   G__memfunc_setup("IsPathEmpty",1112,G__G__Base3_230_0_64, 103, -1, G__defined_typename("Bool_t"), 0, 1, 3, 1, 0, "u 'TString' - 11 - -", (char*)NULL, (void*) G__func2void( (Bool_t (*)(const TString&))(&TUri::IsPathEmpty) ), 0);
   G__memfunc_setup("IsQuery",722,G__G__Base3_230_0_65, 103, -1, G__defined_typename("Bool_t"), 0, 1, 3, 1, 0, "u 'TString' - 11 - -", (char*)NULL, (void*) G__func2void( (Bool_t (*)(const TString&))(&TUri::IsQuery) ), 0);
   G__memfunc_setup("IsFragment",1008,G__G__Base3_230_0_66, 103, -1, G__defined_typename("Bool_t"), 0, 1, 3, 1, 0, "u 'TString' - 11 - -", (char*)NULL, (void*) G__func2void( (Bool_t (*)(const TString&))(&TUri::IsFragment) ), 0);
   G__memfunc_setup("IsRelativePart",1423,G__G__Base3_230_0_67, 103, -1, G__defined_typename("Bool_t"), 0, 1, 3, 1, 0, "u 'TString' - 11 - -", (char*)NULL, (void*) G__func2void( (Bool_t (*)(const TString&))(&TUri::IsRelativePart) ), 0);
   G__memfunc_setup("RemoveDotSegments",1755,G__G__Base3_230_0_68, 117, G__get_linked_tagnum(&G__G__Base3LN_TString), -1, 0, 1, 3, 1, 1, "u 'TString' - 11 - -", (char*)NULL, (void*) G__func2void( (const TString (*)(const TString&))(&TUri::RemoveDotSegments) ), 0);
   G__memfunc_setup("Transform",956,G__G__Base3_230_0_69, 117, G__get_linked_tagnum(&G__G__Base3LN_TUri), -1, 0, 2, 3, 1, 0, 
"u 'TUri' - 11 - reference u 'TUri' - 11 - base", (char*)NULL, (void*) G__func2void( (TUri (*)(const TUri&, const TUri&))(&TUri::Transform) ), 0);
   G__memfunc_setup("MergePaths",1008,G__G__Base3_230_0_70, 117, G__get_linked_tagnum(&G__G__Base3LN_TString), -1, 0, 2, 3, 1, 1, 
"u 'TUri' - 11 - reference u 'TUri' - 11 - base", (char*)NULL, (void*) G__func2void( (const TString (*)(const TUri&, const TUri&))(&TUri::MergePaths) ), 0);
   G__memfunc_setup("Class",502,G__G__Base3_230_0_71, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TUri::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__Base3_230_0_72, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TUri::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__Base3_230_0_73, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TUri::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__Base3_230_0_74, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TUri::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__Base3_230_0_78, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__Base3_230_0_79, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TUri::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__Base3_230_0_80, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TUri::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__Base3_230_0_81, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TUri::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__Base3_230_0_82, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TUri::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~TUri", 514, G__G__Base3_230_0_83, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTVirtualTableInterface(void) {
   /* TVirtualTableInterface */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualTableInterface));
   G__memfunc_setup("GetValue",797,G__G__Base3_231_0_2, 100, -1, G__defined_typename("Double_t"), 0, 2, 1, 1, 0, 
"h - 'UInt_t' 0 - row h - 'UInt_t' 0 - column", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetValueAsString",1608,G__G__Base3_231_0_3, 67, -1, -1, 0, 2, 1, 1, 1, 
"h - 'UInt_t' 0 - row h - 'UInt_t' 0 - column", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetRowHeader",1185,G__G__Base3_231_0_4, 67, -1, -1, 0, 1, 1, 1, 1, "h - 'UInt_t' 0 - row", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetColumnHeader",1495,G__G__Base3_231_0_5, 67, -1, -1, 0, 1, 1, 1, 1, "h - 'UInt_t' 0 - column", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetNRows",793,G__G__Base3_231_0_6, 104, -1, G__defined_typename("UInt_t"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("GetNColumns",1103,G__G__Base3_231_0_7, 104, -1, G__defined_typename("UInt_t"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("Class",502,G__G__Base3_231_0_8, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TVirtualTableInterface::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__Base3_231_0_9, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualTableInterface::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__Base3_231_0_10, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TVirtualTableInterface::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__Base3_231_0_11, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TVirtualTableInterface::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,G__G__Base3_231_0_12, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,G__G__Base3_231_0_13, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,G__G__Base3_231_0_14, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__Base3_231_0_15, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__Base3_231_0_16, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualTableInterface::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__Base3_231_0_17, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TVirtualTableInterface::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__Base3_231_0_18, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TVirtualTableInterface::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__Base3_231_0_19, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TVirtualTableInterface::DeclFileLine) ), 0);
   // automatic destructor
   G__memfunc_setup("~TVirtualTableInterface", 2354, G__G__Base3_231_0_20, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Base3_231_0_21, (int) ('u'), G__get_linked_tagnum(&G__G__Base3LN_TVirtualTableInterface), -1, 1, 1, 1, 1, 0, "u 'TVirtualTableInterface' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTBase64(void) {
   /* TBase64 */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_TBase64));
   G__memfunc_setup("Encode",590,G__G__Base3_232_0_1, 117, G__get_linked_tagnum(&G__G__Base3LN_TString), -1, 0, 1, 3, 1, 0, "C - - 10 - data", (char*)NULL, (void*) G__func2void( (TString (*)(const char*))(&TBase64::Encode) ), 0);
   G__memfunc_setup("Encode",590,G__G__Base3_232_0_2, 117, G__get_linked_tagnum(&G__G__Base3LN_TString), -1, 0, 2, 3, 1, 0, 
"C - - 10 - data i - 'Int_t' 0 - len", (char*)NULL, (void*) G__func2void( (TString (*)(const char*, Int_t))(&TBase64::Encode) ), 0);
   G__memfunc_setup("Decode",580,G__G__Base3_232_0_3, 117, G__get_linked_tagnum(&G__G__Base3LN_TString), -1, 0, 1, 3, 1, 0, "C - - 10 - data", (char*)NULL, (void*) G__func2void( (TString (*)(const char*))(&TBase64::Decode) ), 0);
   G__memfunc_setup("Class",502,G__G__Base3_232_0_4, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TBase64::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__Base3_232_0_5, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TBase64::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__Base3_232_0_6, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TBase64::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__Base3_232_0_7, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TBase64::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,G__G__Base3_232_0_8, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,G__G__Base3_232_0_9, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,G__G__Base3_232_0_10, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__Base3_232_0_11, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__Base3_232_0_12, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TBase64::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__Base3_232_0_13, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TBase64::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__Base3_232_0_14, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TBase64::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__Base3_232_0_15, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TBase64::DeclFileLine) ), 0);
   // automatic default constructor
   G__memfunc_setup("TBase64", 569, G__G__Base3_232_0_16, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_TBase64), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TBase64", 569, G__G__Base3_232_0_17, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_TBase64), -1, 0, 1, 1, 1, 0, "u 'TBase64' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TBase64", 695, G__G__Base3_232_0_18, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Base3_232_0_19, (int) ('u'), G__get_linked_tagnum(&G__G__Base3LN_TBase64), -1, 1, 1, 1, 1, 0, "u 'TBase64' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEcharmUcOintgR(void) {
   /* pair<char*,int> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOintgR));
   G__memfunc_setup("pair<char*,int>",1381,G__G__Base3_233_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOintgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<char*,int>",1381,G__G__Base3_233_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOintgR), -1, 0, 2, 1, 1, 0, 
"C - - 41 - a i - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOintgR), -1, 1, 1, 1, 4, 0, "u 'pair<char*,int>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<char*,int>", 1381, G__G__Base3_233_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOintgR), -1, 0, 1, 1, 1, 0, "u 'pair<char*,int>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<char*,int>", 1507, G__G__Base3_233_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEcharmUcOlonggR(void) {
   /* pair<char*,long> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOlonggR));
   G__memfunc_setup("pair<char*,long>",1482,G__G__Base3_234_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOlonggR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<char*,long>",1482,G__G__Base3_234_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOlonggR), -1, 0, 2, 1, 1, 0, 
"C - - 41 - a l - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOlonggR), -1, 1, 1, 1, 4, 0, "u 'pair<char*,long>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<char*,long>", 1482, G__G__Base3_234_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOlonggR), -1, 0, 1, 1, 1, 0, "u 'pair<char*,long>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<char*,long>", 1608, G__G__Base3_234_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEcharmUcOfloatgR(void) {
   /* pair<char*,float> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOfloatgR));
   G__memfunc_setup("pair<char*,float>",1584,G__G__Base3_235_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOfloatgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<char*,float>",1584,G__G__Base3_235_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOfloatgR), -1, 0, 2, 1, 1, 0, 
"C - - 41 - a f - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOfloatgR), -1, 1, 1, 1, 4, 0, "u 'pair<char*,float>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<char*,float>", 1584, G__G__Base3_235_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOfloatgR), -1, 0, 1, 1, 1, 0, "u 'pair<char*,float>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<char*,float>", 1710, G__G__Base3_235_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEcharmUcOdoublegR(void) {
   /* pair<char*,double> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOdoublegR));
   G__memfunc_setup("pair<char*,double>",1685,G__G__Base3_236_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOdoublegR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<char*,double>",1685,G__G__Base3_236_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOdoublegR), -1, 0, 2, 1, 1, 0, 
"C - - 41 - a d - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOdoublegR), -1, 1, 1, 1, 4, 0, "u 'pair<char*,double>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<char*,double>", 1685, G__G__Base3_236_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOdoublegR), -1, 0, 1, 1, 1, 0, "u 'pair<char*,double>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<char*,double>", 1811, G__G__Base3_236_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEcharmUcOvoidmUgR(void) {
   /* pair<char*,void*> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOvoidmUgR));
   G__memfunc_setup("pair<char*,void*>",1526,G__G__Base3_237_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOvoidmUgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<char*,void*>",1526,G__G__Base3_237_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOvoidmUgR), -1, 0, 2, 1, 1, 0, 
"C - - 41 - a Y - - 41 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOvoidmUgR), -1, 1, 1, 1, 4, 0, "u 'pair<char*,void*>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<char*,void*>", 1526, G__G__Base3_237_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOvoidmUgR), -1, 0, 1, 1, 1, 0, "u 'pair<char*,void*>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<char*,void*>", 1652, G__G__Base3_237_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEcharmUcOcharmUgR(void) {
   /* pair<char*,char*> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOcharmUgR));
   G__memfunc_setup("pair<char*,char*>",1506,G__G__Base3_238_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOcharmUgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<char*,char*>",1506,G__G__Base3_238_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOcharmUgR), -1, 0, 2, 1, 1, 0, 
"C - - 41 - a C - - 41 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOcharmUgR), -1, 1, 1, 1, 4, 0, "u 'pair<char*,char*>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<char*,char*>", 1506, G__G__Base3_238_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOcharmUgR), -1, 0, 1, 1, 1, 0, "u 'pair<char*,char*>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<char*,char*>", 1632, G__G__Base3_238_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEstringcOintgR(void) {
   /* pair<string,int> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOintgR));
   G__memfunc_setup("pair<string,int>",1588,G__G__Base3_239_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOintgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<string,int>",1588,G__G__Base3_239_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOintgR), -1, 0, 2, 1, 1, 0, 
"u 'string' - 11 - a i - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOintgR), -1, 1, 1, 1, 4, 0, "u 'pair<string,int>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<string,int>", 1588, G__G__Base3_239_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOintgR), -1, 0, 1, 1, 1, 0, "u 'pair<string,int>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<string,int>", 1714, G__G__Base3_239_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEstringcOlonggR(void) {
   /* pair<string,long> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOlonggR));
   G__memfunc_setup("pair<string,long>",1689,G__G__Base3_240_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOlonggR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<string,long>",1689,G__G__Base3_240_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOlonggR), -1, 0, 2, 1, 1, 0, 
"u 'string' - 11 - a l - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOlonggR), -1, 1, 1, 1, 4, 0, "u 'pair<string,long>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<string,long>", 1689, G__G__Base3_240_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOlonggR), -1, 0, 1, 1, 1, 0, "u 'pair<string,long>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<string,long>", 1815, G__G__Base3_240_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEstringcOfloatgR(void) {
   /* pair<string,float> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOfloatgR));
   G__memfunc_setup("pair<string,float>",1791,G__G__Base3_241_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOfloatgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<string,float>",1791,G__G__Base3_241_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOfloatgR), -1, 0, 2, 1, 1, 0, 
"u 'string' - 11 - a f - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOfloatgR), -1, 1, 1, 1, 4, 0, "u 'pair<string,float>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<string,float>", 1791, G__G__Base3_241_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOfloatgR), -1, 0, 1, 1, 1, 0, "u 'pair<string,float>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<string,float>", 1917, G__G__Base3_241_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEstringcOdoublegR(void) {
   /* pair<string,double> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOdoublegR));
   G__memfunc_setup("pair<string,double>",1892,G__G__Base3_242_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOdoublegR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<string,double>",1892,G__G__Base3_242_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOdoublegR), -1, 0, 2, 1, 1, 0, 
"u 'string' - 11 - a d - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOdoublegR), -1, 1, 1, 1, 4, 0, "u 'pair<string,double>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<string,double>", 1892, G__G__Base3_242_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOdoublegR), -1, 0, 1, 1, 1, 0, "u 'pair<string,double>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<string,double>", 2018, G__G__Base3_242_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEstringcOvoidmUgR(void) {
   /* pair<string,void*> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOvoidmUgR));
   G__memfunc_setup("pair<string,void*>",1733,G__G__Base3_243_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOvoidmUgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<string,void*>",1733,G__G__Base3_243_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOvoidmUgR), -1, 0, 2, 1, 1, 0, 
"u 'string' - 11 - a Y - - 41 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOvoidmUgR), -1, 1, 1, 1, 4, 0, "u 'pair<string,void*>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<string,void*>", 1733, G__G__Base3_243_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOvoidmUgR), -1, 0, 1, 1, 1, 0, "u 'pair<string,void*>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<string,void*>", 1859, G__G__Base3_243_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEintcOintgR(void) {
   /* pair<int,int> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOintgR));
   G__memfunc_setup("pair<int,int>",1256,G__G__Base3_244_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOintgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<int,int>",1256,G__G__Base3_244_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOintgR), -1, 0, 2, 1, 1, 0, 
"i - - 11 - a i - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOintgR), -1, 1, 1, 1, 4, 0, "u 'pair<int,int>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<int,int>", 1256, G__G__Base3_244_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOintgR), -1, 0, 1, 1, 1, 0, "u 'pair<int,int>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<int,int>", 1382, G__G__Base3_244_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEintcOlonggR(void) {
   /* pair<int,long> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOlonggR));
   G__memfunc_setup("pair<int,long>",1357,G__G__Base3_245_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOlonggR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<int,long>",1357,G__G__Base3_245_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOlonggR), -1, 0, 2, 1, 1, 0, 
"i - - 11 - a l - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOlonggR), -1, 1, 1, 1, 4, 0, "u 'pair<int,long>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<int,long>", 1357, G__G__Base3_245_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOlonggR), -1, 0, 1, 1, 1, 0, "u 'pair<int,long>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<int,long>", 1483, G__G__Base3_245_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEintcOfloatgR(void) {
   /* pair<int,float> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOfloatgR));
   G__memfunc_setup("pair<int,float>",1459,G__G__Base3_246_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOfloatgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<int,float>",1459,G__G__Base3_246_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOfloatgR), -1, 0, 2, 1, 1, 0, 
"i - - 11 - a f - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOfloatgR), -1, 1, 1, 1, 4, 0, "u 'pair<int,float>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<int,float>", 1459, G__G__Base3_246_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOfloatgR), -1, 0, 1, 1, 1, 0, "u 'pair<int,float>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<int,float>", 1585, G__G__Base3_246_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEintcOdoublegR(void) {
   /* pair<int,double> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOdoublegR));
   G__memfunc_setup("pair<int,double>",1560,G__G__Base3_247_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOdoublegR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<int,double>",1560,G__G__Base3_247_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOdoublegR), -1, 0, 2, 1, 1, 0, 
"i - - 11 - a d - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOdoublegR), -1, 1, 1, 1, 4, 0, "u 'pair<int,double>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<int,double>", 1560, G__G__Base3_247_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOdoublegR), -1, 0, 1, 1, 1, 0, "u 'pair<int,double>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<int,double>", 1686, G__G__Base3_247_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEintcOvoidmUgR(void) {
   /* pair<int,void*> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOvoidmUgR));
   G__memfunc_setup("pair<int,void*>",1401,G__G__Base3_248_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOvoidmUgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<int,void*>",1401,G__G__Base3_248_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOvoidmUgR), -1, 0, 2, 1, 1, 0, 
"i - - 11 - a Y - - 41 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOvoidmUgR), -1, 1, 1, 1, 4, 0, "u 'pair<int,void*>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<int,void*>", 1401, G__G__Base3_248_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOvoidmUgR), -1, 0, 1, 1, 1, 0, "u 'pair<int,void*>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<int,void*>", 1527, G__G__Base3_248_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEintcOcharmUgR(void) {
   /* pair<int,char*> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOcharmUgR));
   G__memfunc_setup("pair<int,char*>",1381,G__G__Base3_249_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOcharmUgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<int,char*>",1381,G__G__Base3_249_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOcharmUgR), -1, 0, 2, 1, 1, 0, 
"i - - 11 - a C - - 41 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOcharmUgR), -1, 1, 1, 1, 4, 0, "u 'pair<int,char*>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<int,char*>", 1381, G__G__Base3_249_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOcharmUgR), -1, 0, 1, 1, 1, 0, "u 'pair<int,char*>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<int,char*>", 1507, G__G__Base3_249_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlElongcOintgR(void) {
   /* pair<long,int> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOintgR));
   G__memfunc_setup("pair<long,int>",1357,G__G__Base3_250_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOintgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<long,int>",1357,G__G__Base3_250_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOintgR), -1, 0, 2, 1, 1, 0, 
"l - - 11 - a i - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOintgR), -1, 1, 1, 1, 4, 0, "u 'pair<long,int>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<long,int>", 1357, G__G__Base3_250_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOintgR), -1, 0, 1, 1, 1, 0, "u 'pair<long,int>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<long,int>", 1483, G__G__Base3_250_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlElongcOlonggR(void) {
   /* pair<long,long> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOlonggR));
   G__memfunc_setup("pair<long,long>",1458,G__G__Base3_251_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOlonggR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<long,long>",1458,G__G__Base3_251_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOlonggR), -1, 0, 2, 1, 1, 0, 
"l - - 11 - a l - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOlonggR), -1, 1, 1, 1, 4, 0, "u 'pair<long,long>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<long,long>", 1458, G__G__Base3_251_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOlonggR), -1, 0, 1, 1, 1, 0, "u 'pair<long,long>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<long,long>", 1584, G__G__Base3_251_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlElongcOfloatgR(void) {
   /* pair<long,float> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOfloatgR));
   G__memfunc_setup("pair<long,float>",1560,G__G__Base3_252_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOfloatgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<long,float>",1560,G__G__Base3_252_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOfloatgR), -1, 0, 2, 1, 1, 0, 
"l - - 11 - a f - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOfloatgR), -1, 1, 1, 1, 4, 0, "u 'pair<long,float>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<long,float>", 1560, G__G__Base3_252_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOfloatgR), -1, 0, 1, 1, 1, 0, "u 'pair<long,float>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<long,float>", 1686, G__G__Base3_252_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlElongcOdoublegR(void) {
   /* pair<long,double> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOdoublegR));
   G__memfunc_setup("pair<long,double>",1661,G__G__Base3_253_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOdoublegR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<long,double>",1661,G__G__Base3_253_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOdoublegR), -1, 0, 2, 1, 1, 0, 
"l - - 11 - a d - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOdoublegR), -1, 1, 1, 1, 4, 0, "u 'pair<long,double>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<long,double>", 1661, G__G__Base3_253_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOdoublegR), -1, 0, 1, 1, 1, 0, "u 'pair<long,double>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<long,double>", 1787, G__G__Base3_253_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlElongcOvoidmUgR(void) {
   /* pair<long,void*> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOvoidmUgR));
   G__memfunc_setup("pair<long,void*>",1502,G__G__Base3_254_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOvoidmUgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<long,void*>",1502,G__G__Base3_254_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOvoidmUgR), -1, 0, 2, 1, 1, 0, 
"l - - 11 - a Y - - 41 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOvoidmUgR), -1, 1, 1, 1, 4, 0, "u 'pair<long,void*>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<long,void*>", 1502, G__G__Base3_254_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOvoidmUgR), -1, 0, 1, 1, 1, 0, "u 'pair<long,void*>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<long,void*>", 1628, G__G__Base3_254_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlElongcOcharmUgR(void) {
   /* pair<long,char*> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOcharmUgR));
   G__memfunc_setup("pair<long,char*>",1482,G__G__Base3_255_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOcharmUgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<long,char*>",1482,G__G__Base3_255_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOcharmUgR), -1, 0, 2, 1, 1, 0, 
"l - - 11 - a C - - 41 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOcharmUgR), -1, 1, 1, 1, 4, 0, "u 'pair<long,char*>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<long,char*>", 1482, G__G__Base3_255_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOcharmUgR), -1, 0, 1, 1, 1, 0, "u 'pair<long,char*>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<long,char*>", 1608, G__G__Base3_255_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEfloatcOintgR(void) {
   /* pair<float,int> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOintgR));
   G__memfunc_setup("pair<float,int>",1459,G__G__Base3_256_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOintgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<float,int>",1459,G__G__Base3_256_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOintgR), -1, 0, 2, 1, 1, 0, 
"f - - 11 - a i - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOintgR), -1, 1, 1, 1, 4, 0, "u 'pair<float,int>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<float,int>", 1459, G__G__Base3_256_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOintgR), -1, 0, 1, 1, 1, 0, "u 'pair<float,int>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<float,int>", 1585, G__G__Base3_256_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEfloatcOlonggR(void) {
   /* pair<float,long> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOlonggR));
   G__memfunc_setup("pair<float,long>",1560,G__G__Base3_257_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOlonggR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<float,long>",1560,G__G__Base3_257_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOlonggR), -1, 0, 2, 1, 1, 0, 
"f - - 11 - a l - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOlonggR), -1, 1, 1, 1, 4, 0, "u 'pair<float,long>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<float,long>", 1560, G__G__Base3_257_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOlonggR), -1, 0, 1, 1, 1, 0, "u 'pair<float,long>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<float,long>", 1686, G__G__Base3_257_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEfloatcOfloatgR(void) {
   /* pair<float,float> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOfloatgR));
   G__memfunc_setup("pair<float,float>",1662,G__G__Base3_258_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOfloatgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<float,float>",1662,G__G__Base3_258_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOfloatgR), -1, 0, 2, 1, 1, 0, 
"f - - 11 - a f - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOfloatgR), -1, 1, 1, 1, 4, 0, "u 'pair<float,float>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<float,float>", 1662, G__G__Base3_258_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOfloatgR), -1, 0, 1, 1, 1, 0, "u 'pair<float,float>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<float,float>", 1788, G__G__Base3_258_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEfloatcOdoublegR(void) {
   /* pair<float,double> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOdoublegR));
   G__memfunc_setup("pair<float,double>",1763,G__G__Base3_259_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOdoublegR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<float,double>",1763,G__G__Base3_259_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOdoublegR), -1, 0, 2, 1, 1, 0, 
"f - - 11 - a d - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOdoublegR), -1, 1, 1, 1, 4, 0, "u 'pair<float,double>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<float,double>", 1763, G__G__Base3_259_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOdoublegR), -1, 0, 1, 1, 1, 0, "u 'pair<float,double>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<float,double>", 1889, G__G__Base3_259_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEfloatcOvoidmUgR(void) {
   /* pair<float,void*> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOvoidmUgR));
   G__memfunc_setup("pair<float,void*>",1604,G__G__Base3_260_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOvoidmUgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<float,void*>",1604,G__G__Base3_260_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOvoidmUgR), -1, 0, 2, 1, 1, 0, 
"f - - 11 - a Y - - 41 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOvoidmUgR), -1, 1, 1, 1, 4, 0, "u 'pair<float,void*>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<float,void*>", 1604, G__G__Base3_260_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOvoidmUgR), -1, 0, 1, 1, 1, 0, "u 'pair<float,void*>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<float,void*>", 1730, G__G__Base3_260_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEfloatcOcharmUgR(void) {
   /* pair<float,char*> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOcharmUgR));
   G__memfunc_setup("pair<float,char*>",1584,G__G__Base3_261_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOcharmUgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<float,char*>",1584,G__G__Base3_261_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOcharmUgR), -1, 0, 2, 1, 1, 0, 
"f - - 11 - a C - - 41 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOcharmUgR), -1, 1, 1, 1, 4, 0, "u 'pair<float,char*>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<float,char*>", 1584, G__G__Base3_261_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOcharmUgR), -1, 0, 1, 1, 1, 0, "u 'pair<float,char*>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<float,char*>", 1710, G__G__Base3_261_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEdoublecOintgR(void) {
   /* pair<double,int> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOintgR));
   G__memfunc_setup("pair<double,int>",1560,G__G__Base3_262_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOintgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<double,int>",1560,G__G__Base3_262_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOintgR), -1, 0, 2, 1, 1, 0, 
"d - - 11 - a i - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOintgR), -1, 1, 1, 1, 4, 0, "u 'pair<double,int>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<double,int>", 1560, G__G__Base3_262_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOintgR), -1, 0, 1, 1, 1, 0, "u 'pair<double,int>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<double,int>", 1686, G__G__Base3_262_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEdoublecOlonggR(void) {
   /* pair<double,long> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOlonggR));
   G__memfunc_setup("pair<double,long>",1661,G__G__Base3_263_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOlonggR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<double,long>",1661,G__G__Base3_263_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOlonggR), -1, 0, 2, 1, 1, 0, 
"d - - 11 - a l - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOlonggR), -1, 1, 1, 1, 4, 0, "u 'pair<double,long>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<double,long>", 1661, G__G__Base3_263_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOlonggR), -1, 0, 1, 1, 1, 0, "u 'pair<double,long>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<double,long>", 1787, G__G__Base3_263_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEdoublecOfloatgR(void) {
   /* pair<double,float> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOfloatgR));
   G__memfunc_setup("pair<double,float>",1763,G__G__Base3_264_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOfloatgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<double,float>",1763,G__G__Base3_264_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOfloatgR), -1, 0, 2, 1, 1, 0, 
"d - - 11 - a f - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOfloatgR), -1, 1, 1, 1, 4, 0, "u 'pair<double,float>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<double,float>", 1763, G__G__Base3_264_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOfloatgR), -1, 0, 1, 1, 1, 0, "u 'pair<double,float>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<double,float>", 1889, G__G__Base3_264_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEdoublecOdoublegR(void) {
   /* pair<double,double> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOdoublegR));
   G__memfunc_setup("pair<double,double>",1864,G__G__Base3_265_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOdoublegR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<double,double>",1864,G__G__Base3_265_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOdoublegR), -1, 0, 2, 1, 1, 0, 
"d - - 11 - a d - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOdoublegR), -1, 1, 1, 1, 4, 0, "u 'pair<double,double>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<double,double>", 1864, G__G__Base3_265_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOdoublegR), -1, 0, 1, 1, 1, 0, "u 'pair<double,double>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<double,double>", 1990, G__G__Base3_265_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEdoublecOvoidmUgR(void) {
   /* pair<double,void*> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOvoidmUgR));
   G__memfunc_setup("pair<double,void*>",1705,G__G__Base3_266_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOvoidmUgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<double,void*>",1705,G__G__Base3_266_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOvoidmUgR), -1, 0, 2, 1, 1, 0, 
"d - - 11 - a Y - - 41 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOvoidmUgR), -1, 1, 1, 1, 4, 0, "u 'pair<double,void*>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<double,void*>", 1705, G__G__Base3_266_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOvoidmUgR), -1, 0, 1, 1, 1, 0, "u 'pair<double,void*>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<double,void*>", 1831, G__G__Base3_266_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEdoublecOcharmUgR(void) {
   /* pair<double,char*> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOcharmUgR));
   G__memfunc_setup("pair<double,char*>",1685,G__G__Base3_267_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOcharmUgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<double,char*>",1685,G__G__Base3_267_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOcharmUgR), -1, 0, 2, 1, 1, 0, 
"d - - 11 - a C - - 41 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOcharmUgR), -1, 1, 1, 1, 4, 0, "u 'pair<double,char*>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<double,char*>", 1685, G__G__Base3_267_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOcharmUgR), -1, 0, 1, 1, 1, 0, "u 'pair<double,char*>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<double,char*>", 1811, G__G__Base3_267_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPcharmUcOintgR(void) {
   /* pair<const char*,int> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOintgR));
   G__memfunc_setup("pair<const char*,int>",1964,G__G__Base3_268_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOintgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const char*,int>",1964,G__G__Base3_268_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOintgR), -1, 0, 2, 1, 1, 0, 
"C - - 51 - a i - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOintgR), -1, 1, 1, 1, 4, 0, "u 'pair<const char*,int>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const char*,int>", 1964, G__G__Base3_268_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOintgR), -1, 0, 1, 1, 1, 0, "u 'pair<const char*,int>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const char*,int>", 2090, G__G__Base3_268_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPcharmUcOlonggR(void) {
   /* pair<const char*,long> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOlonggR));
   G__memfunc_setup("pair<const char*,long>",2065,G__G__Base3_269_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOlonggR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const char*,long>",2065,G__G__Base3_269_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOlonggR), -1, 0, 2, 1, 1, 0, 
"C - - 51 - a l - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOlonggR), -1, 1, 1, 1, 4, 0, "u 'pair<const char*,long>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const char*,long>", 2065, G__G__Base3_269_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOlonggR), -1, 0, 1, 1, 1, 0, "u 'pair<const char*,long>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const char*,long>", 2191, G__G__Base3_269_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPcharmUcOfloatgR(void) {
   /* pair<const char*,float> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOfloatgR));
   G__memfunc_setup("pair<const char*,float>",2167,G__G__Base3_270_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOfloatgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const char*,float>",2167,G__G__Base3_270_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOfloatgR), -1, 0, 2, 1, 1, 0, 
"C - - 51 - a f - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOfloatgR), -1, 1, 1, 1, 4, 0, "u 'pair<const char*,float>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const char*,float>", 2167, G__G__Base3_270_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOfloatgR), -1, 0, 1, 1, 1, 0, "u 'pair<const char*,float>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const char*,float>", 2293, G__G__Base3_270_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPcharmUcOdoublegR(void) {
   /* pair<const char*,double> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOdoublegR));
   G__memfunc_setup("pair<const char*,double>",2268,G__G__Base3_271_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOdoublegR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const char*,double>",2268,G__G__Base3_271_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOdoublegR), -1, 0, 2, 1, 1, 0, 
"C - - 51 - a d - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOdoublegR), -1, 1, 1, 1, 4, 0, "u 'pair<const char*,double>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const char*,double>", 2268, G__G__Base3_271_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOdoublegR), -1, 0, 1, 1, 1, 0, "u 'pair<const char*,double>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const char*,double>", 2394, G__G__Base3_271_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPcharmUcOvoidmUgR(void) {
   /* pair<const char*,void*> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOvoidmUgR));
   G__memfunc_setup("pair<const char*,void*>",2109,G__G__Base3_272_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOvoidmUgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const char*,void*>",2109,G__G__Base3_272_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOvoidmUgR), -1, 0, 2, 1, 1, 0, 
"C - - 51 - a Y - - 41 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOvoidmUgR), -1, 1, 1, 1, 4, 0, "u 'pair<const char*,void*>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const char*,void*>", 2109, G__G__Base3_272_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOvoidmUgR), -1, 0, 1, 1, 1, 0, "u 'pair<const char*,void*>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const char*,void*>", 2235, G__G__Base3_272_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPcharmUcOcharmUgR(void) {
   /* pair<const char*,char*> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOcharmUgR));
   G__memfunc_setup("pair<const char*,char*>",2089,G__G__Base3_273_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOcharmUgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const char*,char*>",2089,G__G__Base3_273_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOcharmUgR), -1, 0, 2, 1, 1, 0, 
"C - - 51 - a C - - 41 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOcharmUgR), -1, 1, 1, 1, 4, 0, "u 'pair<const char*,char*>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const char*,char*>", 2089, G__G__Base3_273_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOcharmUgR), -1, 0, 1, 1, 1, 0, "u 'pair<const char*,char*>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const char*,char*>", 2215, G__G__Base3_273_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPstringcOintgR(void) {
   /* pair<const string,int> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOintgR));
   G__memfunc_setup("pair<const string,int>",2171,G__G__Base3_274_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOintgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const string,int>",2171,G__G__Base3_274_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOintgR), -1, 0, 2, 1, 1, 0, 
"u 'string' - 11 - a i - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOintgR), -1, 1, 1, 1, 4, 0, "u 'pair<const string,int>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const string,int>", 2171, G__G__Base3_274_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOintgR), -1, 0, 1, 1, 1, 0, "u 'pair<const string,int>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const string,int>", 2297, G__G__Base3_274_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPstringcOlonggR(void) {
   /* pair<const string,long> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOlonggR));
   G__memfunc_setup("pair<const string,long>",2272,G__G__Base3_275_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOlonggR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const string,long>",2272,G__G__Base3_275_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOlonggR), -1, 0, 2, 1, 1, 0, 
"u 'string' - 11 - a l - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOlonggR), -1, 1, 1, 1, 4, 0, "u 'pair<const string,long>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const string,long>", 2272, G__G__Base3_275_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOlonggR), -1, 0, 1, 1, 1, 0, "u 'pair<const string,long>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const string,long>", 2398, G__G__Base3_275_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPstringcOfloatgR(void) {
   /* pair<const string,float> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOfloatgR));
   G__memfunc_setup("pair<const string,float>",2374,G__G__Base3_276_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOfloatgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const string,float>",2374,G__G__Base3_276_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOfloatgR), -1, 0, 2, 1, 1, 0, 
"u 'string' - 11 - a f - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOfloatgR), -1, 1, 1, 1, 4, 0, "u 'pair<const string,float>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const string,float>", 2374, G__G__Base3_276_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOfloatgR), -1, 0, 1, 1, 1, 0, "u 'pair<const string,float>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const string,float>", 2500, G__G__Base3_276_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPstringcOdoublegR(void) {
   /* pair<const string,double> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOdoublegR));
   G__memfunc_setup("pair<const string,double>",2475,G__G__Base3_277_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOdoublegR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const string,double>",2475,G__G__Base3_277_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOdoublegR), -1, 0, 2, 1, 1, 0, 
"u 'string' - 11 - a d - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOdoublegR), -1, 1, 1, 1, 4, 0, "u 'pair<const string,double>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const string,double>", 2475, G__G__Base3_277_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOdoublegR), -1, 0, 1, 1, 1, 0, "u 'pair<const string,double>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const string,double>", 2601, G__G__Base3_277_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPstringcOvoidmUgR(void) {
   /* pair<const string,void*> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOvoidmUgR));
   G__memfunc_setup("pair<const string,void*>",2316,G__G__Base3_278_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOvoidmUgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const string,void*>",2316,G__G__Base3_278_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOvoidmUgR), -1, 0, 2, 1, 1, 0, 
"u 'string' - 11 - a Y - - 41 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOvoidmUgR), -1, 1, 1, 1, 4, 0, "u 'pair<const string,void*>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const string,void*>", 2316, G__G__Base3_278_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOvoidmUgR), -1, 0, 1, 1, 1, 0, "u 'pair<const string,void*>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const string,void*>", 2442, G__G__Base3_278_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPintcOintgR(void) {
   /* pair<const int,int> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOintgR));
   G__memfunc_setup("pair<const int,int>",1839,G__G__Base3_279_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOintgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const int,int>",1839,G__G__Base3_279_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOintgR), -1, 0, 2, 1, 1, 0, 
"i - - 11 - a i - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOintgR), -1, 1, 1, 1, 4, 0, "u 'pair<const int,int>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const int,int>", 1839, G__G__Base3_279_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOintgR), -1, 0, 1, 1, 1, 0, "u 'pair<const int,int>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const int,int>", 1965, G__G__Base3_279_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPintcOlonggR(void) {
   /* pair<const int,long> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOlonggR));
   G__memfunc_setup("pair<const int,long>",1940,G__G__Base3_280_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOlonggR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const int,long>",1940,G__G__Base3_280_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOlonggR), -1, 0, 2, 1, 1, 0, 
"i - - 11 - a l - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOlonggR), -1, 1, 1, 1, 4, 0, "u 'pair<const int,long>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const int,long>", 1940, G__G__Base3_280_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOlonggR), -1, 0, 1, 1, 1, 0, "u 'pair<const int,long>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const int,long>", 2066, G__G__Base3_280_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPintcOfloatgR(void) {
   /* pair<const int,float> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOfloatgR));
   G__memfunc_setup("pair<const int,float>",2042,G__G__Base3_281_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOfloatgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const int,float>",2042,G__G__Base3_281_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOfloatgR), -1, 0, 2, 1, 1, 0, 
"i - - 11 - a f - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOfloatgR), -1, 1, 1, 1, 4, 0, "u 'pair<const int,float>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const int,float>", 2042, G__G__Base3_281_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOfloatgR), -1, 0, 1, 1, 1, 0, "u 'pair<const int,float>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const int,float>", 2168, G__G__Base3_281_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPintcOdoublegR(void) {
   /* pair<const int,double> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOdoublegR));
   G__memfunc_setup("pair<const int,double>",2143,G__G__Base3_282_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOdoublegR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const int,double>",2143,G__G__Base3_282_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOdoublegR), -1, 0, 2, 1, 1, 0, 
"i - - 11 - a d - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOdoublegR), -1, 1, 1, 1, 4, 0, "u 'pair<const int,double>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const int,double>", 2143, G__G__Base3_282_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOdoublegR), -1, 0, 1, 1, 1, 0, "u 'pair<const int,double>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const int,double>", 2269, G__G__Base3_282_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPintcOvoidmUgR(void) {
   /* pair<const int,void*> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOvoidmUgR));
   G__memfunc_setup("pair<const int,void*>",1984,G__G__Base3_283_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOvoidmUgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const int,void*>",1984,G__G__Base3_283_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOvoidmUgR), -1, 0, 2, 1, 1, 0, 
"i - - 11 - a Y - - 41 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOvoidmUgR), -1, 1, 1, 1, 4, 0, "u 'pair<const int,void*>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const int,void*>", 1984, G__G__Base3_283_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOvoidmUgR), -1, 0, 1, 1, 1, 0, "u 'pair<const int,void*>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const int,void*>", 2110, G__G__Base3_283_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPintcOcharmUgR(void) {
   /* pair<const int,char*> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOcharmUgR));
   G__memfunc_setup("pair<const int,char*>",1964,G__G__Base3_284_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOcharmUgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const int,char*>",1964,G__G__Base3_284_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOcharmUgR), -1, 0, 2, 1, 1, 0, 
"i - - 11 - a C - - 41 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOcharmUgR), -1, 1, 1, 1, 4, 0, "u 'pair<const int,char*>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const int,char*>", 1964, G__G__Base3_284_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOcharmUgR), -1, 0, 1, 1, 1, 0, "u 'pair<const int,char*>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const int,char*>", 2090, G__G__Base3_284_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPlongcOintgR(void) {
   /* pair<const long,int> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOintgR));
   G__memfunc_setup("pair<const long,int>",1940,G__G__Base3_285_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOintgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const long,int>",1940,G__G__Base3_285_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOintgR), -1, 0, 2, 1, 1, 0, 
"l - - 11 - a i - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOintgR), -1, 1, 1, 1, 4, 0, "u 'pair<const long,int>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const long,int>", 1940, G__G__Base3_285_0_4, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOintgR), -1, 0, 1, 1, 1, 0, "u 'pair<const long,int>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const long,int>", 2066, G__G__Base3_285_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPlongcOlonggR(void) {
   /* pair<const long,long> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOlonggR));
   G__memfunc_setup("pair<const long,long>",2041,G__G__Base3_286_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOlonggR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const long,long>",2041,G__G__Base3_286_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOlonggR), -1, 0, 2, 1, 1, 0, 
"l - - 11 - a l - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOlonggR), -1, 1, 1, 1, 4, 0, "u 'pair<const long,long>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const long,long>", 2041, G__G__Base3_286_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOlonggR), -1, 0, 1, 1, 1, 0, "u 'pair<const long,long>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const long,long>", 2167, G__G__Base3_286_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPlongcOfloatgR(void) {
   /* pair<const long,float> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOfloatgR));
   G__memfunc_setup("pair<const long,float>",2143,G__G__Base3_287_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOfloatgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const long,float>",2143,G__G__Base3_287_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOfloatgR), -1, 0, 2, 1, 1, 0, 
"l - - 11 - a f - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOfloatgR), -1, 1, 1, 1, 4, 0, "u 'pair<const long,float>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const long,float>", 2143, G__G__Base3_287_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOfloatgR), -1, 0, 1, 1, 1, 0, "u 'pair<const long,float>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const long,float>", 2269, G__G__Base3_287_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPlongcOdoublegR(void) {
   /* pair<const long,double> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOdoublegR));
   G__memfunc_setup("pair<const long,double>",2244,G__G__Base3_288_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOdoublegR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const long,double>",2244,G__G__Base3_288_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOdoublegR), -1, 0, 2, 1, 1, 0, 
"l - - 11 - a d - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOdoublegR), -1, 1, 1, 1, 4, 0, "u 'pair<const long,double>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const long,double>", 2244, G__G__Base3_288_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOdoublegR), -1, 0, 1, 1, 1, 0, "u 'pair<const long,double>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const long,double>", 2370, G__G__Base3_288_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPlongcOvoidmUgR(void) {
   /* pair<const long,void*> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOvoidmUgR));
   G__memfunc_setup("pair<const long,void*>",2085,G__G__Base3_289_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOvoidmUgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const long,void*>",2085,G__G__Base3_289_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOvoidmUgR), -1, 0, 2, 1, 1, 0, 
"l - - 11 - a Y - - 41 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOvoidmUgR), -1, 1, 1, 1, 4, 0, "u 'pair<const long,void*>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const long,void*>", 2085, G__G__Base3_289_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOvoidmUgR), -1, 0, 1, 1, 1, 0, "u 'pair<const long,void*>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const long,void*>", 2211, G__G__Base3_289_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPlongcOcharmUgR(void) {
   /* pair<const long,char*> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOcharmUgR));
   G__memfunc_setup("pair<const long,char*>",2065,G__G__Base3_290_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOcharmUgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const long,char*>",2065,G__G__Base3_290_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOcharmUgR), -1, 0, 2, 1, 1, 0, 
"l - - 11 - a C - - 41 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOcharmUgR), -1, 1, 1, 1, 4, 0, "u 'pair<const long,char*>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const long,char*>", 2065, G__G__Base3_290_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOcharmUgR), -1, 0, 1, 1, 1, 0, "u 'pair<const long,char*>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const long,char*>", 2191, G__G__Base3_290_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPfloatcOintgR(void) {
   /* pair<const float,int> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOintgR));
   G__memfunc_setup("pair<const float,int>",2042,G__G__Base3_291_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOintgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const float,int>",2042,G__G__Base3_291_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOintgR), -1, 0, 2, 1, 1, 0, 
"f - - 11 - a i - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOintgR), -1, 1, 1, 1, 4, 0, "u 'pair<const float,int>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const float,int>", 2042, G__G__Base3_291_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOintgR), -1, 0, 1, 1, 1, 0, "u 'pair<const float,int>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const float,int>", 2168, G__G__Base3_291_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPfloatcOlonggR(void) {
   /* pair<const float,long> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOlonggR));
   G__memfunc_setup("pair<const float,long>",2143,G__G__Base3_292_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOlonggR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const float,long>",2143,G__G__Base3_292_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOlonggR), -1, 0, 2, 1, 1, 0, 
"f - - 11 - a l - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOlonggR), -1, 1, 1, 1, 4, 0, "u 'pair<const float,long>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const float,long>", 2143, G__G__Base3_292_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOlonggR), -1, 0, 1, 1, 1, 0, "u 'pair<const float,long>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const float,long>", 2269, G__G__Base3_292_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPfloatcOfloatgR(void) {
   /* pair<const float,float> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOfloatgR));
   G__memfunc_setup("pair<const float,float>",2245,G__G__Base3_293_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOfloatgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const float,float>",2245,G__G__Base3_293_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOfloatgR), -1, 0, 2, 1, 1, 0, 
"f - - 11 - a f - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOfloatgR), -1, 1, 1, 1, 4, 0, "u 'pair<const float,float>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const float,float>", 2245, G__G__Base3_293_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOfloatgR), -1, 0, 1, 1, 1, 0, "u 'pair<const float,float>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const float,float>", 2371, G__G__Base3_293_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPfloatcOdoublegR(void) {
   /* pair<const float,double> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOdoublegR));
   G__memfunc_setup("pair<const float,double>",2346,G__G__Base3_294_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOdoublegR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const float,double>",2346,G__G__Base3_294_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOdoublegR), -1, 0, 2, 1, 1, 0, 
"f - - 11 - a d - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOdoublegR), -1, 1, 1, 1, 4, 0, "u 'pair<const float,double>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const float,double>", 2346, G__G__Base3_294_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOdoublegR), -1, 0, 1, 1, 1, 0, "u 'pair<const float,double>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const float,double>", 2472, G__G__Base3_294_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPfloatcOvoidmUgR(void) {
   /* pair<const float,void*> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOvoidmUgR));
   G__memfunc_setup("pair<const float,void*>",2187,G__G__Base3_295_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOvoidmUgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const float,void*>",2187,G__G__Base3_295_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOvoidmUgR), -1, 0, 2, 1, 1, 0, 
"f - - 11 - a Y - - 41 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOvoidmUgR), -1, 1, 1, 1, 4, 0, "u 'pair<const float,void*>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const float,void*>", 2187, G__G__Base3_295_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOvoidmUgR), -1, 0, 1, 1, 1, 0, "u 'pair<const float,void*>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const float,void*>", 2313, G__G__Base3_295_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPfloatcOcharmUgR(void) {
   /* pair<const float,char*> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOcharmUgR));
   G__memfunc_setup("pair<const float,char*>",2167,G__G__Base3_296_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOcharmUgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const float,char*>",2167,G__G__Base3_296_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOcharmUgR), -1, 0, 2, 1, 1, 0, 
"f - - 11 - a C - - 41 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOcharmUgR), -1, 1, 1, 1, 4, 0, "u 'pair<const float,char*>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const float,char*>", 2167, G__G__Base3_296_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOcharmUgR), -1, 0, 1, 1, 1, 0, "u 'pair<const float,char*>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const float,char*>", 2293, G__G__Base3_296_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPdoublecOintgR(void) {
   /* pair<const double,int> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOintgR));
   G__memfunc_setup("pair<const double,int>",2143,G__G__Base3_297_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOintgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const double,int>",2143,G__G__Base3_297_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOintgR), -1, 0, 2, 1, 1, 0, 
"d - - 11 - a i - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOintgR), -1, 1, 1, 1, 4, 0, "u 'pair<const double,int>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const double,int>", 2143, G__G__Base3_297_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOintgR), -1, 0, 1, 1, 1, 0, "u 'pair<const double,int>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const double,int>", 2269, G__G__Base3_297_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPdoublecOlonggR(void) {
   /* pair<const double,long> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOlonggR));
   G__memfunc_setup("pair<const double,long>",2244,G__G__Base3_298_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOlonggR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const double,long>",2244,G__G__Base3_298_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOlonggR), -1, 0, 2, 1, 1, 0, 
"d - - 11 - a l - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOlonggR), -1, 1, 1, 1, 4, 0, "u 'pair<const double,long>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const double,long>", 2244, G__G__Base3_298_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOlonggR), -1, 0, 1, 1, 1, 0, "u 'pair<const double,long>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const double,long>", 2370, G__G__Base3_298_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPdoublecOfloatgR(void) {
   /* pair<const double,float> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOfloatgR));
   G__memfunc_setup("pair<const double,float>",2346,G__G__Base3_299_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOfloatgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const double,float>",2346,G__G__Base3_299_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOfloatgR), -1, 0, 2, 1, 1, 0, 
"d - - 11 - a f - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOfloatgR), -1, 1, 1, 1, 4, 0, "u 'pair<const double,float>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const double,float>", 2346, G__G__Base3_299_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOfloatgR), -1, 0, 1, 1, 1, 0, "u 'pair<const double,float>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const double,float>", 2472, G__G__Base3_299_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPdoublecOdoublegR(void) {
   /* pair<const double,double> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOdoublegR));
   G__memfunc_setup("pair<const double,double>",2447,G__G__Base3_300_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOdoublegR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const double,double>",2447,G__G__Base3_300_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOdoublegR), -1, 0, 2, 1, 1, 0, 
"d - - 11 - a d - - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOdoublegR), -1, 1, 1, 1, 4, 0, "u 'pair<const double,double>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const double,double>", 2447, G__G__Base3_300_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOdoublegR), -1, 0, 1, 1, 1, 0, "u 'pair<const double,double>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const double,double>", 2573, G__G__Base3_300_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPdoublecOvoidmUgR(void) {
   /* pair<const double,void*> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOvoidmUgR));
   G__memfunc_setup("pair<const double,void*>",2288,G__G__Base3_301_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOvoidmUgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const double,void*>",2288,G__G__Base3_301_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOvoidmUgR), -1, 0, 2, 1, 1, 0, 
"d - - 11 - a Y - - 41 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOvoidmUgR), -1, 1, 1, 1, 4, 0, "u 'pair<const double,void*>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const double,void*>", 2288, G__G__Base3_301_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOvoidmUgR), -1, 0, 1, 1, 1, 0, "u 'pair<const double,void*>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const double,void*>", 2414, G__G__Base3_301_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEconstsPdoublecOcharmUgR(void) {
   /* pair<const double,char*> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOcharmUgR));
   G__memfunc_setup("pair<const double,char*>",2268,G__G__Base3_302_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOcharmUgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<const double,char*>",2268,G__G__Base3_302_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOcharmUgR), -1, 0, 2, 1, 1, 0, 
"d - - 11 - a C - - 41 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOcharmUgR), -1, 1, 1, 1, 4, 0, "u 'pair<const double,char*>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<const double,char*>", 2268, G__G__Base3_302_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOcharmUgR), -1, 0, 1, 1, 1, 0, "u 'pair<const double,char*>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<const double,char*>", 2394, G__G__Base3_302_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTParameterlEfloatgR(void) {
   /* TParameter<float> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_TParameterlEfloatgR));
   G__memfunc_setup("TParameter<float>",1669,G__G__Base3_303_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_TParameterlEfloatgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TParameter<float>",1669,G__G__Base3_303_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_TParameterlEfloatgR), -1, 0, 2, 1, 1, 0, 
"C - - 10 - name f - - 11 - val", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetName",673,(G__InterfaceMethod) NULL,67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetVal",579,G__G__Base3_303_0_4, 102, -1, -1, 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetVal",591,G__G__Base3_303_0_5, 121, -1, -1, 0, 1, 1, 1, 0, "f - - 11 - val", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__G__Base3_303_0_6, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TParameter<float>::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__Base3_303_0_7, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TParameter<float>::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__Base3_303_0_8, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TParameter<float>::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__Base3_303_0_9, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TParameter<float>::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__Base3_303_0_13, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__Base3_303_0_14, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TParameter<float>::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__Base3_303_0_15, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TParameter<float>::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__Base3_303_0_16, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TParameter<float>::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__Base3_303_0_17, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TParameter<float>::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("TParameter<float>", 1669, G__G__Base3_303_0_18, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_TParameterlEfloatgR), -1, 0, 1, 1, 1, 0, "u 'TParameter<float>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TParameter<float>", 1795, G__G__Base3_303_0_19, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Base3_303_0_20, (int) ('u'), G__get_linked_tagnum(&G__G__Base3LN_TParameterlEfloatgR), -1, 1, 1, 1, 1, 0, "u 'TParameter<float>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTParameterlEdoublegR(void) {
   /* TParameter<double> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_TParameterlEdoublegR));
   G__memfunc_setup("TParameter<double>",1770,G__G__Base3_304_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_TParameterlEdoublegR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TParameter<double>",1770,G__G__Base3_304_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_TParameterlEdoublegR), -1, 0, 2, 1, 1, 0, 
"C - - 10 - name d - - 11 - val", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetName",673,(G__InterfaceMethod) NULL,67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetVal",579,G__G__Base3_304_0_4, 100, -1, -1, 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetVal",591,G__G__Base3_304_0_5, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 11 - val", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__G__Base3_304_0_6, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TParameter<double>::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__Base3_304_0_7, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TParameter<double>::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__Base3_304_0_8, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TParameter<double>::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__Base3_304_0_9, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TParameter<double>::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__Base3_304_0_13, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__Base3_304_0_14, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TParameter<double>::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__Base3_304_0_15, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TParameter<double>::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__Base3_304_0_16, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TParameter<double>::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__Base3_304_0_17, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TParameter<double>::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("TParameter<double>", 1770, G__G__Base3_304_0_18, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_TParameterlEdoublegR), -1, 0, 1, 1, 1, 0, "u 'TParameter<double>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TParameter<double>", 1896, G__G__Base3_304_0_19, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Base3_304_0_20, (int) ('u'), G__get_linked_tagnum(&G__G__Base3LN_TParameterlEdoublegR), -1, 1, 1, 1, 1, 0, "u 'TParameter<double>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTParameterlEintgR(void) {
   /* TParameter<int> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_TParameterlEintgR));
   G__memfunc_setup("TParameter<int>",1466,G__G__Base3_305_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_TParameterlEintgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TParameter<int>",1466,G__G__Base3_305_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_TParameterlEintgR), -1, 0, 2, 1, 1, 0, 
"C - - 10 - name i - - 11 - val", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetName",673,(G__InterfaceMethod) NULL,67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetVal",579,G__G__Base3_305_0_4, 105, -1, -1, 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetVal",591,G__G__Base3_305_0_5, 121, -1, -1, 0, 1, 1, 1, 0, "i - - 11 - val", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__G__Base3_305_0_6, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TParameter<int>::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__Base3_305_0_7, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TParameter<int>::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__Base3_305_0_8, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TParameter<int>::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__Base3_305_0_9, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TParameter<int>::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__Base3_305_0_13, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__Base3_305_0_14, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TParameter<int>::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__Base3_305_0_15, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TParameter<int>::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__Base3_305_0_16, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TParameter<int>::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__Base3_305_0_17, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TParameter<int>::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("TParameter<int>", 1466, G__G__Base3_305_0_18, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_TParameterlEintgR), -1, 0, 1, 1, 1, 0, "u 'TParameter<int>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TParameter<int>", 1592, G__G__Base3_305_0_19, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Base3_305_0_20, (int) ('u'), G__get_linked_tagnum(&G__G__Base3LN_TParameterlEintgR), -1, 1, 1, 1, 1, 0, "u 'TParameter<int>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTParameterlElonggR(void) {
   /* TParameter<long> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_TParameterlElonggR));
   G__memfunc_setup("TParameter<long>",1567,G__G__Base3_306_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_TParameterlElonggR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TParameter<long>",1567,G__G__Base3_306_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_TParameterlElonggR), -1, 0, 2, 1, 1, 0, 
"C - - 10 - name l - - 11 - val", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetName",673,(G__InterfaceMethod) NULL,67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetVal",579,G__G__Base3_306_0_4, 108, -1, -1, 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetVal",591,G__G__Base3_306_0_5, 121, -1, -1, 0, 1, 1, 1, 0, "l - - 11 - val", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__G__Base3_306_0_6, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TParameter<long>::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__Base3_306_0_7, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TParameter<long>::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__Base3_306_0_8, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TParameter<long>::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__Base3_306_0_9, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TParameter<long>::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__Base3_306_0_13, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__Base3_306_0_14, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TParameter<long>::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__Base3_306_0_15, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TParameter<long>::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__Base3_306_0_16, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TParameter<long>::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__Base3_306_0_17, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TParameter<long>::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("TParameter<long>", 1567, G__G__Base3_306_0_18, (int) ('i'), G__get_linked_tagnum(&G__G__Base3LN_TParameterlElonggR), -1, 0, 1, 1, 1, 0, "u 'TParameter<long>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TParameter<long>", 1693, G__G__Base3_306_0_19, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Base3_306_0_20, (int) ('u'), G__get_linked_tagnum(&G__G__Base3LN_TParameterlElonggR), -1, 1, 1, 1, 1, 0, "u 'TParameter<long>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTParameterlElongsPlonggR(void) {
   /* TParameter<long long> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G__Base3LN_TParameterlElongsPlonggR));
   G__memfunc_setup("TParameter<long long>",2031,G__G__Base3_307_0_1, 105, G__get_linked_tagnum(&G__G__Base3LN_TParameterlElongsPlonggR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TParameter<long long>",2031,G__G__Base3_307_0_2, 105, G__get_linked_tagnum(&G__G__Base3LN_TParameterlElongsPlonggR), -1, 0, 2, 1, 1, 0, 
"C - - 10 - name n - - 11 - val", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetName",673,(G__InterfaceMethod) NULL,67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetVal",579,G__G__Base3_307_0_4, 110, -1, -1, 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetVal",591,G__G__Base3_307_0_5, 121, -1, -1, 0, 1, 1, 1, 0, "n - - 11 - val", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__G__Base3_307_0_6, 85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (TClass* (*)())(&TParameter<long long>::Class) ), 0);
   G__memfunc_setup("Class_Name",982,G__G__Base3_307_0_7, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TParameter<long long>::Class_Name) ), 0);
   G__memfunc_setup("Class_Version",1339,G__G__Base3_307_0_8, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (Version_t (*)())(&TParameter<long long>::Class_Version) ), 0);
   G__memfunc_setup("Dictionary",1046,G__G__Base3_307_0_9, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (void (*)())(&TParameter<long long>::Dictionary) ), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G__Base3LN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__G__Base3_307_0_13, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__G__Base3_307_0_14, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TParameter<long long>::DeclFileName) ), 0);
   G__memfunc_setup("ImplFileLine",1178,G__G__Base3_307_0_15, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TParameter<long long>::ImplFileLine) ), 0);
   G__memfunc_setup("ImplFileName",1171,G__G__Base3_307_0_16, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&TParameter<long long>::ImplFileName) ), 0);
   G__memfunc_setup("DeclFileLine",1152,G__G__Base3_307_0_17, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (int (*)())(&TParameter<long long>::DeclFileLine) ), 0);
   // automatic copy constructor
   G__memfunc_setup("TParameter<long long>", 2031, G__G__Base3_307_0_18, (int) ('i'), 
G__get_linked_tagnum(&G__G__Base3LN_TParameterlElongsPlonggR), -1, 0, 1, 1, 1, 0, "u 'TParameter<long long>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TParameter<long long>", 2157, G__G__Base3_307_0_19, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G__Base3_307_0_20, (int) ('u'), G__get_linked_tagnum(&G__G__Base3LN_TParameterlElongsPlonggR), -1, 1, 1, 1, 1, 0, "u 'TParameter<long long>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfuncG__Base3() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

}

static void G__cpp_setup_global1() {
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kNotUseful=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kWhenMapped=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kAlways=2",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kIsUnmapped=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kIsUnviewable=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kIsViewable=2",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kInputOutput=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kInputOnly=2",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kLineSolid=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kLineOnOffDash=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kLineDoubleDash=2",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kCapNotLast=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kCapButt=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kCapRound=2",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kCapProjecting=3",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kJoinMiter=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kJoinRound=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kJoinBevel=2",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kFillSolid=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kFillTiled=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kFillStippled=2",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kFillOpaqueStippled=3",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kEvenOddRule=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kWindingRule=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kClipByChildren=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kIncludeInferiors=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kArcChord=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),-1,-1,1,"kArcPieSlice=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGEventType),-1,-1,1,"kGKeyPress=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGEventType),-1,-1,1,"kKeyRelease=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGEventType),-1,-1,1,"kButtonPress=2",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGEventType),-1,-1,1,"kButtonRelease=3",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGEventType),-1,-1,1,"kMotionNotify=4",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGEventType),-1,-1,1,"kEnterNotify=5",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGEventType),-1,-1,1,"kLeaveNotify=6",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGEventType),-1,-1,1,"kFocusIn=7",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGEventType),-1,-1,1,"kFocusOut=8",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGEventType),-1,-1,1,"kExpose=9",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGEventType),-1,-1,1,"kConfigureNotify=10",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGEventType),-1,-1,1,"kMapNotify=11",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGEventType),-1,-1,1,"kUnmapNotify=12",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGEventType),-1,-1,1,"kDestroyNotify=13",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGEventType),-1,-1,1,"kClientMessage=14",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGEventType),-1,-1,1,"kSelectionClear=15",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGEventType),-1,-1,1,"kSelectionRequest=16",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGEventType),-1,-1,1,"kSelectionNotify=17",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGEventType),-1,-1,1,"kColormapNotify=18",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGEventType),-1,-1,1,"kButtonDoubleClick=19",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGEventType),-1,-1,1,"kOtherEvent=20",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGraphicsFunction),-1,-1,1,"kGXclear=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGraphicsFunction),-1,-1,1,"kGXand=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGraphicsFunction),-1,-1,1,"kGXandReverse=2",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGraphicsFunction),-1,-1,1,"kGXcopy=3",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGraphicsFunction),-1,-1,1,"kGXandInverted=4",0,(char*)NULL);
}

static void G__cpp_setup_global2() {
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGraphicsFunction),-1,-1,1,"kGXnoop=5",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGraphicsFunction),-1,-1,1,"kGXxor=6",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGraphicsFunction),-1,-1,1,"kGXor=7",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGraphicsFunction),-1,-1,1,"kGXnor=8",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGraphicsFunction),-1,-1,1,"kGXequiv=9",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGraphicsFunction),-1,-1,1,"kGXinvert=10",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGraphicsFunction),-1,-1,1,"kGXorReverse=11",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGraphicsFunction),-1,-1,1,"kGXcopyInverted=12",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGraphicsFunction),-1,-1,1,"kGXorInverted=13",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGraphicsFunction),-1,-1,1,"kGXnand=14",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EGraphicsFunction),-1,-1,1,"kGXset=15",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_dA),-1,-1,1,"kDefaultScrollBarWidth=16",0,(char*)NULL);
   G__memvar_setup((void*)(&kNone),107,0,1,-1,G__defined_typename("Handle_t"),-1,1,"kNone=",0,(char*)NULL);
   G__memvar_setup((void*)(&kCopyFromParent),107,0,1,-1,G__defined_typename("Handle_t"),-1,1,"kCopyFromParent=",0,(char*)NULL);
   G__memvar_setup((void*)(&kParentRelative),107,0,1,-1,G__defined_typename("Handle_t"),-1,1,"kParentRelative=",0,(char*)NULL);
   G__memvar_setup((void*)(&kWABackPixmap),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kWABackPixmap=",0,(char*)NULL);
   G__memvar_setup((void*)(&kWABackPixel),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kWABackPixel=",0,(char*)NULL);
   G__memvar_setup((void*)(&kWABorderPixmap),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kWABorderPixmap=",0,(char*)NULL);
   G__memvar_setup((void*)(&kWABorderPixel),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kWABorderPixel=",0,(char*)NULL);
   G__memvar_setup((void*)(&kWABorderWidth),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kWABorderWidth=",0,(char*)NULL);
   G__memvar_setup((void*)(&kWABitGravity),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kWABitGravity=",0,(char*)NULL);
   G__memvar_setup((void*)(&kWAWinGravity),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kWAWinGravity=",0,(char*)NULL);
   G__memvar_setup((void*)(&kWABackingStore),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kWABackingStore=",0,(char*)NULL);
   G__memvar_setup((void*)(&kWABackingPlanes),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kWABackingPlanes=",0,(char*)NULL);
   G__memvar_setup((void*)(&kWABackingPixel),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kWABackingPixel=",0,(char*)NULL);
   G__memvar_setup((void*)(&kWAOverrideRedirect),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kWAOverrideRedirect=",0,(char*)NULL);
   G__memvar_setup((void*)(&kWASaveUnder),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kWASaveUnder=",0,(char*)NULL);
   G__memvar_setup((void*)(&kWAEventMask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kWAEventMask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kWADontPropagate),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kWADontPropagate=",0,(char*)NULL);
   G__memvar_setup((void*)(&kWAColormap),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kWAColormap=",0,(char*)NULL);
   G__memvar_setup((void*)(&kWACursor),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kWACursor=",0,(char*)NULL);
   G__memvar_setup((void*)(&kNoEventMask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kNoEventMask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kKeyPressMask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kKeyPressMask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kKeyReleaseMask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kKeyReleaseMask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kButtonPressMask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kButtonPressMask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kButtonReleaseMask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kButtonReleaseMask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kPointerMotionMask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kPointerMotionMask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kButtonMotionMask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kButtonMotionMask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kExposureMask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kExposureMask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kStructureNotifyMask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kStructureNotifyMask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kEnterWindowMask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kEnterWindowMask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kLeaveWindowMask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kLeaveWindowMask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kFocusChangeMask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kFocusChangeMask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kOwnerGrabButtonMask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kOwnerGrabButtonMask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kColormapChangeMask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kColormapChangeMask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kKeyShiftMask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kKeyShiftMask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kKeyLockMask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kKeyLockMask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kKeyControlMask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kKeyControlMask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kKeyMod1Mask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kKeyMod1Mask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kButton1Mask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kButton1Mask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kButton2Mask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kButton2Mask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kButton3Mask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kButton3Mask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kButton4Mask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kButton4Mask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kButton5Mask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kButton5Mask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kAnyModifier),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kAnyModifier=",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EMouseButton),-1,-1,1,"kAnyButton=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EMouseButton),-1,-1,1,"kButton1=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EMouseButton),-1,-1,1,"kButton2=2",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EMouseButton),-1,-1,1,"kButton3=3",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EMouseButton),-1,-1,1,"kButton4=4",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EMouseButton),-1,-1,1,"kButton5=5",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EMouseButton),-1,-1,1,"kButton6=6",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EMouseButton),-1,-1,1,"kButton7=7",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EXMagic),-1,-1,1,"kNotifyNormal=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EXMagic),-1,-1,1,"kNotifyGrab=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EXMagic),-1,-1,1,"kNotifyUngrab=2",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EXMagic),-1,-1,1,"kNotifyPointer=5",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EXMagic),-1,-1,1,"kColormapUninstalled=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EXMagic),-1,-1,1,"kColormapInstalled=1",0,(char*)NULL);
   G__memvar_setup((void*)(&kGCFunction),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kGCFunction=",0,(char*)NULL);
   G__memvar_setup((void*)(&kGCPlaneMask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kGCPlaneMask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kGCForeground),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kGCForeground=",0,(char*)NULL);
   G__memvar_setup((void*)(&kGCBackground),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kGCBackground=",0,(char*)NULL);
   G__memvar_setup((void*)(&kGCLineWidth),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kGCLineWidth=",0,(char*)NULL);
   G__memvar_setup((void*)(&kGCLineStyle),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kGCLineStyle=",0,(char*)NULL);
   G__memvar_setup((void*)(&kGCCapStyle),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kGCCapStyle=",0,(char*)NULL);
   G__memvar_setup((void*)(&kGCJoinStyle),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kGCJoinStyle=",0,(char*)NULL);
   G__memvar_setup((void*)(&kGCFillStyle),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kGCFillStyle=",0,(char*)NULL);
   G__memvar_setup((void*)(&kGCFillRule),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kGCFillRule=",0,(char*)NULL);
   G__memvar_setup((void*)(&kGCTile),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kGCTile=",0,(char*)NULL);
   G__memvar_setup((void*)(&kGCStipple),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kGCStipple=",0,(char*)NULL);
   G__memvar_setup((void*)(&kGCTileStipXOrigin),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kGCTileStipXOrigin=",0,(char*)NULL);
   G__memvar_setup((void*)(&kGCTileStipYOrigin),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kGCTileStipYOrigin=",0,(char*)NULL);
   G__memvar_setup((void*)(&kGCFont),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kGCFont=",0,(char*)NULL);
   G__memvar_setup((void*)(&kGCSubwindowMode),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kGCSubwindowMode=",0,(char*)NULL);
   G__memvar_setup((void*)(&kGCGraphicsExposures),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kGCGraphicsExposures=",0,(char*)NULL);
   G__memvar_setup((void*)(&kGCClipXOrigin),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kGCClipXOrigin=",0,(char*)NULL);
   G__memvar_setup((void*)(&kGCClipYOrigin),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kGCClipYOrigin=",0,(char*)NULL);
   G__memvar_setup((void*)(&kGCClipMask),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kGCClipMask=",0,(char*)NULL);
   G__memvar_setup((void*)(&kGCDashOffset),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kGCDashOffset=",0,(char*)NULL);
   G__memvar_setup((void*)(&kGCDashList),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kGCDashList=",0,(char*)NULL);
   G__memvar_setup((void*)(&kGCArcMode),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kGCArcMode=",0,(char*)NULL);
   G__memvar_setup((void*)(&kDoRed),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kDoRed=",0,(char*)NULL);
   G__memvar_setup((void*)(&kDoGreen),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kDoGreen=",0,(char*)NULL);
   G__memvar_setup((void*)(&kDoBlue),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kDoBlue=",0,(char*)NULL);
   G__memvar_setup((void*)(&kPAColormap),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kPAColormap=",0,(char*)NULL);
   G__memvar_setup((void*)(&kPADepth),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kPADepth=",0,(char*)NULL);
   G__memvar_setup((void*)(&kPASize),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kPASize=",0,(char*)NULL);
   G__memvar_setup((void*)(&kPAHotspot),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kPAHotspot=",0,(char*)NULL);
}

static void G__cpp_setup_global3() {
   G__memvar_setup((void*)(&kPAReturnPixels),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kPAReturnPixels=",0,(char*)NULL);
   G__memvar_setup((void*)(&kPACloseness),104,0,1,-1,G__defined_typename("Mask_t"),-1,1,"kPACloseness=",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EInitialState),-1,-1,1,"kNormalState=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EInitialState),-1,-1,1,"kIconicState=2",0,(char*)NULL);
   G__memvar_setup((void*)(&kPrimarySelection),107,0,1,-1,G__defined_typename("Atom_t"),-1,1,"kPrimarySelection=",0,(char*)NULL);
   G__memvar_setup((void*)(&kCutBuffer),107,0,1,-1,G__defined_typename("Atom_t"),-1,1,"kCutBuffer=",0,(char*)NULL);
   G__memvar_setup((void*)(&kMaxPixel),105,0,1,-1,G__defined_typename("Int_t"),-1,1,"kMaxPixel=",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Escape=4096",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Tab=4097",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Backtab=4098",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Backspace=4099",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Return=4100",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Enter=4101",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Insert=4102",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Delete=4103",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Pause=4104",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Print=4105",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_SysReq=4106",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Home=4112",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_End=4113",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Left=4114",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Up=4115",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Right=4116",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Down=4117",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Prior=4118",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_PageUp=4118",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Next=4119",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_PageDown=4119",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Shift=4128",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Control=4129",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Meta=4130",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Alt=4131",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_CapsLock=4132",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_NumLock=4133",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_ScrollLock=4134",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F1=4144",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F2=4145",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F3=4146",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F4=4147",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F5=4148",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F6=4149",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F7=4150",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F8=4151",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F9=4152",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F10=4153",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F11=4154",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F12=4155",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F13=4156",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F14=4157",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F15=4158",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F16=4159",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F17=4160",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F18=4161",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F19=4162",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F20=4163",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F21=4164",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F22=4165",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F23=4166",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F24=4167",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F25=4168",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F26=4169",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F27=4170",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F28=4171",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F29=4172",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F30=4173",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F31=4174",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F32=4175",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F33=4176",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F34=4177",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F35=4178",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Space=32",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Exclam=33",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_QuoteDbl=34",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_NumberSign=35",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Dollar=36",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Percent=37",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Ampersand=38",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Apostrophe=39",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_ParenLeft=40",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_ParenRight=41",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Asterisk=42",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Plus=43",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Comma=44",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Minus=45",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Period=46",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Slash=47",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_0=48",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_1=49",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_2=50",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_3=51",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_4=52",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_5=53",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_6=54",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_7=55",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_8=56",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_9=57",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Colon=58",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Semicolon=59",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Less=60",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Equal=61",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Greater=62",0,(char*)NULL);
}

static void G__cpp_setup_global4() {
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Question=63",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_At=64",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_A=65",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_B=66",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_C=67",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_D=68",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_E=69",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_F=70",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_G=71",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_H=72",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_I=73",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_J=74",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_K=75",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_L=76",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_M=77",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_N=78",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_O=79",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_P=80",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Q=81",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_R=82",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_S=83",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_T=84",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_U=85",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_V=86",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_W=87",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_X=88",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Y=89",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Z=90",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_BracketLeft=91",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Backslash=92",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_BracketRight=93",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_AsciiCircum=94",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Underscore=95",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_QuoteLeft=96",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_a=97",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_b=98",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_c=99",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_d=100",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_e=101",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_f=102",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_g=103",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_h=104",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_i=105",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_j=106",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_k=107",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_l=108",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_m=109",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_n=110",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_o=111",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_p=112",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_q=113",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_r=114",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_s=115",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_t=116",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_u=117",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_v=118",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_w=119",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_x=120",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_y=121",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_z=122",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_BraceLeft=123",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Bar=124",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_BraceRight=125",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_AsciiTilde=126",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kKey_Unknown=65535",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EKeySym),-1,-1,1,"kAnyKey=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kNoEvent=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kButton1Down=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kButton2Down=2",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kButton3Down=3",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kKeyDown=4",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kWheelUp=5",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kWheelDown=6",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kButton1Shift=7",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kButton1Up=11",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kButton2Up=12",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kButton3Up=13",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kKeyUp=14",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kButton1Motion=21",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kButton2Motion=22",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kButton3Motion=23",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kKeyPress=24",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kButton1Locate=41",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kButton2Locate=42",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kButton3Locate=43",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kESC=27",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kMouseMotion=51",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kMouseEnter=52",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kMouseLeave=53",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kButton1Double=61",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kButton2Double=62",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_EEventType),-1,-1,1,"kButton3Double=63",0,(char*)NULL);
}

static void G__cpp_setup_global5() {
   G__memvar_setup((void*)(&gPerfStats),85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TVirtualPerfStats),-1,-1,1,"gPerfStats=",0,(char*)NULL);
   G__memvar_setup((void*)(&kNumCursors),105,0,1,-1,-1,-1,1,"kNumCursors=",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_ECursor),-1,-1,1,"kBottomLeft=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_ECursor),-1,-1,1,"kBottomRight=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_ECursor),-1,-1,1,"kTopLeft=2",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_ECursor),-1,-1,1,"kTopRight=3",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_ECursor),-1,-1,1,"kBottomSide=4",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_ECursor),-1,-1,1,"kLeftSide=5",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_ECursor),-1,-1,1,"kTopSide=6",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_ECursor),-1,-1,1,"kRightSide=7",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_ECursor),-1,-1,1,"kMove=8",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_ECursor),-1,-1,1,"kCross=9",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_ECursor),-1,-1,1,"kArrowHor=10",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_ECursor),-1,-1,1,"kArrowVer=11",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_ECursor),-1,-1,1,"kHand=12",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_ECursor),-1,-1,1,"kRotate=13",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_ECursor),-1,-1,1,"kPointer=14",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_ECursor),-1,-1,1,"kArrowRight=15",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_ECursor),-1,-1,1,"kCaret=16",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_ECursor),-1,-1,1,"kWatch=17",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G__Base3LN_ECursor),-1,-1,1,"kNoDrop=18",0,(char*)NULL);
}

static void G__cpp_setup_global6() {
   G__memvar_setup((void*)(&gMonitoringWriter),85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringWriter),-1,-1,1,"gMonitoringWriter=",0,(char*)NULL);
   G__memvar_setup((void*)(&gMonitoringReader),85,0,0,G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringReader),-1,-1,1,"gMonitoringReader=",0,(char*)NULL);

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_globalG__Base3() {
  G__cpp_setup_global0();
  G__cpp_setup_global1();
  G__cpp_setup_global2();
  G__cpp_setup_global3();
  G__cpp_setup_global4();
  G__cpp_setup_global5();
  G__cpp_setup_global6();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();

}

static void G__cpp_setup_func1() {
}

static void G__cpp_setup_func2() {
   G__memfunc_setup("operator<<", 996, G__G__Base3__0_215, 117, G__get_linked_tagnum(&G__G__Base3LN_basic_ostreamlEcharcOchar_traitslEchargRsPgR), G__defined_typename("ostream"), 1, 2, 1, 1, 0, 
"u 'basic_ostream<char,char_traits<char> >' 'ostream' 1 - os u 'TTimeStamp' - 11 - ts", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator<<", 996, G__G__Base3__0_216, 117, G__get_linked_tagnum(&G__G__Base3LN_TBuffer), -1, 1, 2, 1, 1, 0, 
"u 'TBuffer' - 1 - buf u 'TTimeStamp' - 11 - ts", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator>>", 1000, G__G__Base3__0_217, 117, G__get_linked_tagnum(&G__G__Base3LN_TBuffer), -1, 1, 2, 1, 1, 0, 
"u 'TBuffer' - 1 - buf u 'TTimeStamp' - 1 - ts", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator==", 998, G__G__Base3__0_218, 103, -1, G__defined_typename("Bool_t"), 0, 2, 1, 1, 0, 
"u 'TTimeStamp' - 11 - lhs u 'TTimeStamp' - 11 - rhs", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator!=", 970, G__G__Base3__0_219, 103, -1, G__defined_typename("Bool_t"), 0, 2, 1, 1, 0, 
"u 'TTimeStamp' - 11 - lhs u 'TTimeStamp' - 11 - rhs", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator<", 936, G__G__Base3__0_220, 103, -1, G__defined_typename("Bool_t"), 0, 2, 1, 1, 0, 
"u 'TTimeStamp' - 11 - lhs u 'TTimeStamp' - 11 - rhs", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator<=", 997, G__G__Base3__0_221, 103, -1, G__defined_typename("Bool_t"), 0, 2, 1, 1, 0, 
"u 'TTimeStamp' - 11 - lhs u 'TTimeStamp' - 11 - rhs", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator>", 938, G__G__Base3__0_222, 103, -1, G__defined_typename("Bool_t"), 0, 2, 1, 1, 0, 
"u 'TTimeStamp' - 11 - lhs u 'TTimeStamp' - 11 - rhs", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator>=", 999, G__G__Base3__0_223, 103, -1, G__defined_typename("Bool_t"), 0, 2, 1, 1, 0, 
"u 'TTimeStamp' - 11 - lhs u 'TTimeStamp' - 11 - rhs", (char*) NULL
, (void*) NULL, 0);
}

static void G__cpp_setup_func3() {
}

static void G__cpp_setup_func4() {
   G__memfunc_setup("operator==", 998, G__G__Base3__0_444, 103, -1, G__defined_typename("Bool_t"), 0, 2, 1, 1, 0, 
"u 'TUri' - 11 - u1 u 'TUri' - 11 - u2", (char*) NULL
, (void*) NULL, 0);

   G__resetifuncposition();
}

extern "C" void G__cpp_setup_funcG__Base3() {
  G__cpp_setup_func0();
  G__cpp_setup_func1();
  G__cpp_setup_func2();
  G__cpp_setup_func3();
  G__cpp_setup_func4();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__G__Base3LN_TClass = { "TClass" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TBuffer = { "TBuffer" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TMemberInspector = { "TMemberInspector" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TObject = { "TObject" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TNamed = { "TNamed" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_basic_ostreamlEcharcOchar_traitslEchargRsPgR = { "basic_ostream<char,char_traits<char> >" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_string = { "string" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR = { "vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TList = { "TList" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TObjArray = { "TObjArray" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TString = { "TString" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_EGuiConstants = { "EGuiConstants" , 101 , -1 };
G__linked_taginfo G__G__Base3LN_EGEventType = { "EGEventType" , 101 , -1 };
G__linked_taginfo G__G__Base3LN_EGraphicsFunction = { "EGraphicsFunction" , 101 , -1 };
G__linked_taginfo G__G__Base3LN_dA = { "$" , 101 , -1 };
G__linked_taginfo G__G__Base3LN_SetWindowAttributes_t = { "SetWindowAttributes_t" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_WindowAttributes_t = { "WindowAttributes_t" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_Event_t = { "Event_t" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_EMouseButton = { "EMouseButton" , 101 , -1 };
G__linked_taginfo G__G__Base3LN_EXMagic = { "EXMagic" , 101 , -1 };
G__linked_taginfo G__G__Base3LN_GCValues_t = { "GCValues_t" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_ColorStruct_t = { "ColorStruct_t" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_PictureAttributes_t = { "PictureAttributes_t" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_EInitialState = { "EInitialState" , 101 , -1 };
G__linked_taginfo G__G__Base3LN_Segment_t = { "Segment_t" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_Point_t = { "Point_t" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_Rectangle_t = { "Rectangle_t" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_EKeySym = { "EKeySym" , 101 , -1 };
G__linked_taginfo G__G__Base3LN_EEventType = { "EEventType" , 101 , -1 };
G__linked_taginfo G__G__Base3LN_tm = { "tm" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_timespec = { "timespec" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_TVirtualMutex = { "TVirtualMutex" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TTimeStamp = { "TTimeStamp" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TLockGuard = { "TLockGuard" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TFile = { "TFile" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TVirtualPerfStats = { "TVirtualPerfStats" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TVirtualPerfStatscLcLEEventType = { "TVirtualPerfStats::EEventType" , 101 , -1 };
G__linked_taginfo G__G__Base3LN_ECursor = { "ECursor" , 101 , -1 };
G__linked_taginfo G__G__Base3LN_TSecContext = { "TSecContext" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TSocket = { "TSocket" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TVirtualAuth = { "TVirtualAuth" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TMap = { "TMap" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR = { "iterator<bidirectional_iterator_tag,TObject*,long,const TObject**,const TObject*&>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_THashList = { "THashList" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TUrl = { "TUrl" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TInetAddress = { "TInetAddress" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TUUID = { "TUUID" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TMD5 = { "TMD5" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TObjString = { "TObjString" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TFileInfoMeta = { "TFileInfoMeta" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TFileInfo = { "TFileInfo" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TFileInfocLcLEStatusBits = { "TFileInfo::EStatusBits" , 101 , -1 };
G__linked_taginfo G__G__Base3LN_TFileInfoMetacLcLEStatusBits = { "TFileInfoMeta::EStatusBits" , 101 , -1 };
G__linked_taginfo G__G__Base3LN_TFileCollection = { "TFileCollection" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TFileCollectioncLcLEStatusBits = { "TFileCollection::EStatusBits" , 101 , -1 };
G__linked_taginfo G__G__Base3LN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR = { "vector<unsigned int,allocator<unsigned int> >" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_reverse_iteratorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<unsigned int,allocator<unsigned int> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_vectorlETStringcOallocatorlETStringgRsPgR = { "vector<TString,allocator<TString> >" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_reverse_iteratorlEvectorlETStringcOallocatorlETStringgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TString,allocator<TString> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TRedirectOutputGuard = { "TRedirectOutputGuard" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TVirtualMonitoringWriter = { "TVirtualMonitoringWriter" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TVirtualMonitoringReader = { "TVirtualMonitoringReader" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TObjectSpy = { "TObjectSpy" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TObjectRefSpy = { "TObjectRefSpy" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TUri = { "TUri" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TVirtualTableInterface = { "TVirtualTableInterface" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TBase64 = { "TBase64" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEcharmUcOintgR = { "pair<char*,int>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEcharmUcOlonggR = { "pair<char*,long>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEcharmUcOfloatgR = { "pair<char*,float>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEcharmUcOdoublegR = { "pair<char*,double>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEcharmUcOvoidmUgR = { "pair<char*,void*>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEcharmUcOcharmUgR = { "pair<char*,char*>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEstringcOintgR = { "pair<string,int>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEstringcOlonggR = { "pair<string,long>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEstringcOfloatgR = { "pair<string,float>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEstringcOdoublegR = { "pair<string,double>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEstringcOvoidmUgR = { "pair<string,void*>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEintcOintgR = { "pair<int,int>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEintcOlonggR = { "pair<int,long>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEintcOfloatgR = { "pair<int,float>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEintcOdoublegR = { "pair<int,double>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEintcOvoidmUgR = { "pair<int,void*>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEintcOcharmUgR = { "pair<int,char*>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlElongcOintgR = { "pair<long,int>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlElongcOlonggR = { "pair<long,long>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlElongcOfloatgR = { "pair<long,float>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlElongcOdoublegR = { "pair<long,double>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlElongcOvoidmUgR = { "pair<long,void*>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlElongcOcharmUgR = { "pair<long,char*>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEfloatcOintgR = { "pair<float,int>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEfloatcOlonggR = { "pair<float,long>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEfloatcOfloatgR = { "pair<float,float>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEfloatcOdoublegR = { "pair<float,double>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEfloatcOvoidmUgR = { "pair<float,void*>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEfloatcOcharmUgR = { "pair<float,char*>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEdoublecOintgR = { "pair<double,int>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEdoublecOlonggR = { "pair<double,long>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEdoublecOfloatgR = { "pair<double,float>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEdoublecOdoublegR = { "pair<double,double>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEdoublecOvoidmUgR = { "pair<double,void*>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEdoublecOcharmUgR = { "pair<double,char*>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPcharmUcOintgR = { "pair<const char*,int>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPcharmUcOlonggR = { "pair<const char*,long>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPcharmUcOfloatgR = { "pair<const char*,float>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPcharmUcOdoublegR = { "pair<const char*,double>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPcharmUcOvoidmUgR = { "pair<const char*,void*>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPcharmUcOcharmUgR = { "pair<const char*,char*>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPstringcOintgR = { "pair<const string,int>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPstringcOlonggR = { "pair<const string,long>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPstringcOfloatgR = { "pair<const string,float>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPstringcOdoublegR = { "pair<const string,double>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPstringcOvoidmUgR = { "pair<const string,void*>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPintcOintgR = { "pair<const int,int>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPintcOlonggR = { "pair<const int,long>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPintcOfloatgR = { "pair<const int,float>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPintcOdoublegR = { "pair<const int,double>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPintcOvoidmUgR = { "pair<const int,void*>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPintcOcharmUgR = { "pair<const int,char*>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPlongcOintgR = { "pair<const long,int>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPlongcOlonggR = { "pair<const long,long>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPlongcOfloatgR = { "pair<const long,float>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPlongcOdoublegR = { "pair<const long,double>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPlongcOvoidmUgR = { "pair<const long,void*>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPlongcOcharmUgR = { "pair<const long,char*>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPfloatcOintgR = { "pair<const float,int>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPfloatcOlonggR = { "pair<const float,long>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPfloatcOfloatgR = { "pair<const float,float>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPfloatcOdoublegR = { "pair<const float,double>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPfloatcOvoidmUgR = { "pair<const float,void*>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPfloatcOcharmUgR = { "pair<const float,char*>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPdoublecOintgR = { "pair<const double,int>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPdoublecOlonggR = { "pair<const double,long>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPdoublecOfloatgR = { "pair<const double,float>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPdoublecOdoublegR = { "pair<const double,double>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPdoublecOvoidmUgR = { "pair<const double,void*>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_pairlEconstsPdoublecOcharmUgR = { "pair<const double,char*>" , 115 , -1 };
G__linked_taginfo G__G__Base3LN_TParameterlEfloatgR = { "TParameter<float>" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TParameterlEdoublegR = { "TParameter<double>" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TParameterlEintgR = { "TParameter<int>" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TParameterlElonggR = { "TParameter<long>" , 99 , -1 };
G__linked_taginfo G__G__Base3LN_TParameterlElongsPlonggR = { "TParameter<long long>" , 99 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtableG__Base3() {
  G__G__Base3LN_TClass.tagnum = -1 ;
  G__G__Base3LN_TBuffer.tagnum = -1 ;
  G__G__Base3LN_TMemberInspector.tagnum = -1 ;
  G__G__Base3LN_TObject.tagnum = -1 ;
  G__G__Base3LN_TNamed.tagnum = -1 ;
  G__G__Base3LN_basic_ostreamlEcharcOchar_traitslEchargRsPgR.tagnum = -1 ;
  G__G__Base3LN_string.tagnum = -1 ;
  G__G__Base3LN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR.tagnum = -1 ;
  G__G__Base3LN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__Base3LN_TList.tagnum = -1 ;
  G__G__Base3LN_TObjArray.tagnum = -1 ;
  G__G__Base3LN_TString.tagnum = -1 ;
  G__G__Base3LN_EGuiConstants.tagnum = -1 ;
  G__G__Base3LN_EGEventType.tagnum = -1 ;
  G__G__Base3LN_EGraphicsFunction.tagnum = -1 ;
  G__G__Base3LN_dA.tagnum = -1 ;
  G__G__Base3LN_SetWindowAttributes_t.tagnum = -1 ;
  G__G__Base3LN_WindowAttributes_t.tagnum = -1 ;
  G__G__Base3LN_Event_t.tagnum = -1 ;
  G__G__Base3LN_EMouseButton.tagnum = -1 ;
  G__G__Base3LN_EXMagic.tagnum = -1 ;
  G__G__Base3LN_GCValues_t.tagnum = -1 ;
  G__G__Base3LN_ColorStruct_t.tagnum = -1 ;
  G__G__Base3LN_PictureAttributes_t.tagnum = -1 ;
  G__G__Base3LN_EInitialState.tagnum = -1 ;
  G__G__Base3LN_Segment_t.tagnum = -1 ;
  G__G__Base3LN_Point_t.tagnum = -1 ;
  G__G__Base3LN_Rectangle_t.tagnum = -1 ;
  G__G__Base3LN_EKeySym.tagnum = -1 ;
  G__G__Base3LN_EEventType.tagnum = -1 ;
  G__G__Base3LN_tm.tagnum = -1 ;
  G__G__Base3LN_timespec.tagnum = -1 ;
  G__G__Base3LN_TVirtualMutex.tagnum = -1 ;
  G__G__Base3LN_TTimeStamp.tagnum = -1 ;
  G__G__Base3LN_TLockGuard.tagnum = -1 ;
  G__G__Base3LN_TFile.tagnum = -1 ;
  G__G__Base3LN_TVirtualPerfStats.tagnum = -1 ;
  G__G__Base3LN_TVirtualPerfStatscLcLEEventType.tagnum = -1 ;
  G__G__Base3LN_ECursor.tagnum = -1 ;
  G__G__Base3LN_TSecContext.tagnum = -1 ;
  G__G__Base3LN_TSocket.tagnum = -1 ;
  G__G__Base3LN_TVirtualAuth.tagnum = -1 ;
  G__G__Base3LN_TMap.tagnum = -1 ;
  G__G__Base3LN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR.tagnum = -1 ;
  G__G__Base3LN_THashList.tagnum = -1 ;
  G__G__Base3LN_TUrl.tagnum = -1 ;
  G__G__Base3LN_TInetAddress.tagnum = -1 ;
  G__G__Base3LN_TUUID.tagnum = -1 ;
  G__G__Base3LN_TMD5.tagnum = -1 ;
  G__G__Base3LN_TObjString.tagnum = -1 ;
  G__G__Base3LN_TFileInfoMeta.tagnum = -1 ;
  G__G__Base3LN_TFileInfo.tagnum = -1 ;
  G__G__Base3LN_TFileInfocLcLEStatusBits.tagnum = -1 ;
  G__G__Base3LN_TFileInfoMetacLcLEStatusBits.tagnum = -1 ;
  G__G__Base3LN_TFileCollection.tagnum = -1 ;
  G__G__Base3LN_TFileCollectioncLcLEStatusBits.tagnum = -1 ;
  G__G__Base3LN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR.tagnum = -1 ;
  G__G__Base3LN_reverse_iteratorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__Base3LN_vectorlETStringcOallocatorlETStringgRsPgR.tagnum = -1 ;
  G__G__Base3LN_reverse_iteratorlEvectorlETStringcOallocatorlETStringgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G__Base3LN_TRedirectOutputGuard.tagnum = -1 ;
  G__G__Base3LN_TVirtualMonitoringWriter.tagnum = -1 ;
  G__G__Base3LN_TVirtualMonitoringReader.tagnum = -1 ;
  G__G__Base3LN_TObjectSpy.tagnum = -1 ;
  G__G__Base3LN_TObjectRefSpy.tagnum = -1 ;
  G__G__Base3LN_TUri.tagnum = -1 ;
  G__G__Base3LN_TVirtualTableInterface.tagnum = -1 ;
  G__G__Base3LN_TBase64.tagnum = -1 ;
  G__G__Base3LN_pairlEcharmUcOintgR.tagnum = -1 ;
  G__G__Base3LN_pairlEcharmUcOlonggR.tagnum = -1 ;
  G__G__Base3LN_pairlEcharmUcOfloatgR.tagnum = -1 ;
  G__G__Base3LN_pairlEcharmUcOdoublegR.tagnum = -1 ;
  G__G__Base3LN_pairlEcharmUcOvoidmUgR.tagnum = -1 ;
  G__G__Base3LN_pairlEcharmUcOcharmUgR.tagnum = -1 ;
  G__G__Base3LN_pairlEstringcOintgR.tagnum = -1 ;
  G__G__Base3LN_pairlEstringcOlonggR.tagnum = -1 ;
  G__G__Base3LN_pairlEstringcOfloatgR.tagnum = -1 ;
  G__G__Base3LN_pairlEstringcOdoublegR.tagnum = -1 ;
  G__G__Base3LN_pairlEstringcOvoidmUgR.tagnum = -1 ;
  G__G__Base3LN_pairlEintcOintgR.tagnum = -1 ;
  G__G__Base3LN_pairlEintcOlonggR.tagnum = -1 ;
  G__G__Base3LN_pairlEintcOfloatgR.tagnum = -1 ;
  G__G__Base3LN_pairlEintcOdoublegR.tagnum = -1 ;
  G__G__Base3LN_pairlEintcOvoidmUgR.tagnum = -1 ;
  G__G__Base3LN_pairlEintcOcharmUgR.tagnum = -1 ;
  G__G__Base3LN_pairlElongcOintgR.tagnum = -1 ;
  G__G__Base3LN_pairlElongcOlonggR.tagnum = -1 ;
  G__G__Base3LN_pairlElongcOfloatgR.tagnum = -1 ;
  G__G__Base3LN_pairlElongcOdoublegR.tagnum = -1 ;
  G__G__Base3LN_pairlElongcOvoidmUgR.tagnum = -1 ;
  G__G__Base3LN_pairlElongcOcharmUgR.tagnum = -1 ;
  G__G__Base3LN_pairlEfloatcOintgR.tagnum = -1 ;
  G__G__Base3LN_pairlEfloatcOlonggR.tagnum = -1 ;
  G__G__Base3LN_pairlEfloatcOfloatgR.tagnum = -1 ;
  G__G__Base3LN_pairlEfloatcOdoublegR.tagnum = -1 ;
  G__G__Base3LN_pairlEfloatcOvoidmUgR.tagnum = -1 ;
  G__G__Base3LN_pairlEfloatcOcharmUgR.tagnum = -1 ;
  G__G__Base3LN_pairlEdoublecOintgR.tagnum = -1 ;
  G__G__Base3LN_pairlEdoublecOlonggR.tagnum = -1 ;
  G__G__Base3LN_pairlEdoublecOfloatgR.tagnum = -1 ;
  G__G__Base3LN_pairlEdoublecOdoublegR.tagnum = -1 ;
  G__G__Base3LN_pairlEdoublecOvoidmUgR.tagnum = -1 ;
  G__G__Base3LN_pairlEdoublecOcharmUgR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPcharmUcOintgR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPcharmUcOlonggR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPcharmUcOfloatgR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPcharmUcOdoublegR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPcharmUcOvoidmUgR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPcharmUcOcharmUgR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPstringcOintgR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPstringcOlonggR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPstringcOfloatgR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPstringcOdoublegR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPstringcOvoidmUgR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPintcOintgR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPintcOlonggR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPintcOfloatgR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPintcOdoublegR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPintcOvoidmUgR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPintcOcharmUgR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPlongcOintgR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPlongcOlonggR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPlongcOfloatgR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPlongcOdoublegR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPlongcOvoidmUgR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPlongcOcharmUgR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPfloatcOintgR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPfloatcOlonggR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPfloatcOfloatgR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPfloatcOdoublegR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPfloatcOvoidmUgR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPfloatcOcharmUgR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPdoublecOintgR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPdoublecOlonggR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPdoublecOfloatgR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPdoublecOdoublegR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPdoublecOvoidmUgR.tagnum = -1 ;
  G__G__Base3LN_pairlEconstsPdoublecOcharmUgR.tagnum = -1 ;
  G__G__Base3LN_TParameterlEfloatgR.tagnum = -1 ;
  G__G__Base3LN_TParameterlEdoublegR.tagnum = -1 ;
  G__G__Base3LN_TParameterlEintgR.tagnum = -1 ;
  G__G__Base3LN_TParameterlElonggR.tagnum = -1 ;
  G__G__Base3LN_TParameterlElongsPlonggR.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtableG__Base3() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum_fwd(&G__G__Base3LN_TClass);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_TBuffer);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_TMemberInspector);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_TObject);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_TNamed);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_basic_ostreamlEcharcOchar_traitslEchargRsPgR);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_string);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_TList);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_TObjArray);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_TString);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_EGuiConstants),sizeof(int),-1,0,(char*)NULL,NULL,NULL);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_EGEventType),sizeof(int),-1,0,(char*)NULL,NULL,NULL);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_EGraphicsFunction),sizeof(int),-1,0,(char*)NULL,NULL,NULL);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_dA);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_SetWindowAttributes_t),sizeof(SetWindowAttributes_t),-1,0,(char*)NULL,G__setup_memvarSetWindowAttributes_t,G__setup_memfuncSetWindowAttributes_t);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_WindowAttributes_t),sizeof(WindowAttributes_t),-1,0,(char*)NULL,G__setup_memvarWindowAttributes_t,G__setup_memfuncWindowAttributes_t);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_Event_t),sizeof(Event_t),-1,0,(char*)NULL,G__setup_memvarEvent_t,G__setup_memfuncEvent_t);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_EMouseButton),sizeof(int),-1,0,(char*)NULL,NULL,NULL);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_EXMagic),sizeof(int),-1,0,(char*)NULL,NULL,NULL);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_GCValues_t),sizeof(GCValues_t),-1,256,(char*)NULL,G__setup_memvarGCValues_t,G__setup_memfuncGCValues_t);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_ColorStruct_t),sizeof(ColorStruct_t),-1,0,(char*)NULL,G__setup_memvarColorStruct_t,G__setup_memfuncColorStruct_t);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_PictureAttributes_t),sizeof(PictureAttributes_t),-1,0,(char*)NULL,G__setup_memvarPictureAttributes_t,G__setup_memfuncPictureAttributes_t);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_EInitialState),sizeof(int),-1,0,(char*)NULL,NULL,NULL);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_Segment_t),sizeof(Segment_t),-1,0,(char*)NULL,G__setup_memvarSegment_t,G__setup_memfuncSegment_t);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_Point_t),sizeof(Point_t),-1,0,(char*)NULL,G__setup_memvarPoint_t,G__setup_memfuncPoint_t);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_Rectangle_t),sizeof(Rectangle_t),-1,0,(char*)NULL,G__setup_memvarRectangle_t,G__setup_memfuncRectangle_t);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_EKeySym),sizeof(int),-1,0,(char*)NULL,NULL,NULL);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_EEventType),sizeof(int),-1,0,(char*)NULL,NULL,NULL);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_tm);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_timespec),sizeof(timespec),-1,0,(char*)NULL,G__setup_memvartimespec,G__setup_memfunctimespec);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualMutex),sizeof(TVirtualMutex),-1,29957,"Virtual mutex lock class",G__setup_memvarTVirtualMutex,G__setup_memfuncTVirtualMutex);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_TTimeStamp),sizeof(TTimeStamp),-1,296192,"Encapsulates seconds and ns since EPOCH",G__setup_memvarTTimeStamp,G__setup_memfuncTTimeStamp);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_TLockGuard),sizeof(TLockGuard),-1,36352,"Exception safe locking/unlocking of mutex",G__setup_memvarTLockGuard,G__setup_memfuncTLockGuard);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_TFile);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualPerfStats),sizeof(TVirtualPerfStats),-1,29706,"ABC for collecting PROOF statistics",G__setup_memvarTVirtualPerfStats,G__setup_memfuncTVirtualPerfStats);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualPerfStatscLcLEEventType),sizeof(int),-1,0,(char*)NULL,NULL,NULL);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_ECursor),sizeof(int),-1,0,(char*)NULL,NULL,NULL);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_TSecContext);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_TSocket);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualAuth),sizeof(TVirtualAuth),-1,1284,"client auth interface",G__setup_memvarTVirtualAuth,G__setup_memfuncTVirtualAuth);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_TMap);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_THashList);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_TUrl),sizeof(TUrl),-1,65280,"Represents an URL",G__setup_memvarTUrl,G__setup_memfuncTUrl);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_TInetAddress),sizeof(TInetAddress),-1,130816,"Represents an Internet Protocol (IP) address",G__setup_memvarTInetAddress,G__setup_memfuncTInetAddress);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_TUUID);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_TMD5);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_TObjString);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_TFileInfoMeta),sizeof(TFileInfoMeta),-1,327424,"Describes TFileInfo meta data",G__setup_memvarTFileInfoMeta,G__setup_memfuncTFileInfoMeta);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_TFileInfo),sizeof(TFileInfo),-1,327424,"Describes generic file info including meta data information",G__setup_memvarTFileInfo,G__setup_memfuncTFileInfo);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_TFileInfocLcLEStatusBits);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_TFileInfoMetacLcLEStatusBits);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_TFileCollection),sizeof(TFileCollection),-1,327424,"Collection of TFileInfo objects",G__setup_memvarTFileCollection,G__setup_memfuncTFileCollection);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_TFileCollectioncLcLEStatusBits);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_reverse_iteratorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_vectorlETStringcOallocatorlETStringgRsPgR);
   G__get_linked_tagnum_fwd(&G__G__Base3LN_reverse_iteratorlEvectorlETStringcOallocatorlETStringgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_TRedirectOutputGuard),sizeof(TRedirectOutputGuard),-1,33792,"Exception safe output redirection",G__setup_memvarTRedirectOutputGuard,G__setup_memfuncTRedirectOutputGuard);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringWriter),sizeof(TVirtualMonitoringWriter),-1,65280,"ABC for Sending Monitoring Information",G__setup_memvarTVirtualMonitoringWriter,G__setup_memfuncTVirtualMonitoringWriter);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualMonitoringReader),sizeof(TVirtualMonitoringReader),-1,62720,"ABC for Reading Monitoring Information",G__setup_memvarTVirtualMonitoringReader,G__setup_memfuncTVirtualMonitoringReader);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_TObjectSpy),sizeof(TObjectSpy),-1,32512,"Spy object pointer for deletion",G__setup_memvarTObjectSpy,G__setup_memfuncTObjectSpy);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_TObjectRefSpy),sizeof(TObjectRefSpy),-1,65024,"Spy object reference for deletion",G__setup_memvarTObjectRefSpy,G__setup_memfuncTObjectRefSpy);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_TUri),sizeof(TUri),-1,65280,"Represents an URI",G__setup_memvarTUri,G__setup_memfuncTUri);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_TVirtualTableInterface),sizeof(TVirtualTableInterface),-1,263430,(char*)NULL,G__setup_memvarTVirtualTableInterface,G__setup_memfuncTVirtualTableInterface);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_TBase64),sizeof(TBase64),-1,1024,"Base64 encoding/decoding",G__setup_memvarTBase64,G__setup_memfuncTBase64);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOintgR),sizeof(pair<char*,int>),-1,297216,(char*)NULL,G__setup_memvarpairlEcharmUcOintgR,G__setup_memfuncpairlEcharmUcOintgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOlonggR),sizeof(pair<char*,long>),-1,297216,(char*)NULL,G__setup_memvarpairlEcharmUcOlonggR,G__setup_memfuncpairlEcharmUcOlonggR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOfloatgR),sizeof(pair<char*,float>),-1,297216,(char*)NULL,G__setup_memvarpairlEcharmUcOfloatgR,G__setup_memfuncpairlEcharmUcOfloatgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOdoublegR),sizeof(pair<char*,double>),-1,297216,(char*)NULL,G__setup_memvarpairlEcharmUcOdoublegR,G__setup_memfuncpairlEcharmUcOdoublegR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOvoidmUgR),sizeof(pair<char*,void*>),-1,297216,(char*)NULL,G__setup_memvarpairlEcharmUcOvoidmUgR,G__setup_memfuncpairlEcharmUcOvoidmUgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEcharmUcOcharmUgR),sizeof(pair<char*,char*>),-1,297216,(char*)NULL,G__setup_memvarpairlEcharmUcOcharmUgR,G__setup_memfuncpairlEcharmUcOcharmUgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOintgR),sizeof(pair<string,int>),-1,297216,(char*)NULL,G__setup_memvarpairlEstringcOintgR,G__setup_memfuncpairlEstringcOintgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOlonggR),sizeof(pair<string,long>),-1,297216,(char*)NULL,G__setup_memvarpairlEstringcOlonggR,G__setup_memfuncpairlEstringcOlonggR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOfloatgR),sizeof(pair<string,float>),-1,297216,(char*)NULL,G__setup_memvarpairlEstringcOfloatgR,G__setup_memfuncpairlEstringcOfloatgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOdoublegR),sizeof(pair<string,double>),-1,297216,(char*)NULL,G__setup_memvarpairlEstringcOdoublegR,G__setup_memfuncpairlEstringcOdoublegR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEstringcOvoidmUgR),sizeof(pair<string,void*>),-1,297216,(char*)NULL,G__setup_memvarpairlEstringcOvoidmUgR,G__setup_memfuncpairlEstringcOvoidmUgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOintgR),sizeof(pair<int,int>),-1,297216,(char*)NULL,G__setup_memvarpairlEintcOintgR,G__setup_memfuncpairlEintcOintgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOlonggR),sizeof(pair<int,long>),-1,297216,(char*)NULL,G__setup_memvarpairlEintcOlonggR,G__setup_memfuncpairlEintcOlonggR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOfloatgR),sizeof(pair<int,float>),-1,297216,(char*)NULL,G__setup_memvarpairlEintcOfloatgR,G__setup_memfuncpairlEintcOfloatgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOdoublegR),sizeof(pair<int,double>),-1,297216,(char*)NULL,G__setup_memvarpairlEintcOdoublegR,G__setup_memfuncpairlEintcOdoublegR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOvoidmUgR),sizeof(pair<int,void*>),-1,297216,(char*)NULL,G__setup_memvarpairlEintcOvoidmUgR,G__setup_memfuncpairlEintcOvoidmUgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEintcOcharmUgR),sizeof(pair<int,char*>),-1,297216,(char*)NULL,G__setup_memvarpairlEintcOcharmUgR,G__setup_memfuncpairlEintcOcharmUgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOintgR),sizeof(pair<long,int>),-1,297216,(char*)NULL,G__setup_memvarpairlElongcOintgR,G__setup_memfuncpairlElongcOintgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOlonggR),sizeof(pair<long,long>),-1,297216,(char*)NULL,G__setup_memvarpairlElongcOlonggR,G__setup_memfuncpairlElongcOlonggR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOfloatgR),sizeof(pair<long,float>),-1,297216,(char*)NULL,G__setup_memvarpairlElongcOfloatgR,G__setup_memfuncpairlElongcOfloatgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOdoublegR),sizeof(pair<long,double>),-1,297216,(char*)NULL,G__setup_memvarpairlElongcOdoublegR,G__setup_memfuncpairlElongcOdoublegR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOvoidmUgR),sizeof(pair<long,void*>),-1,297216,(char*)NULL,G__setup_memvarpairlElongcOvoidmUgR,G__setup_memfuncpairlElongcOvoidmUgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlElongcOcharmUgR),sizeof(pair<long,char*>),-1,297216,(char*)NULL,G__setup_memvarpairlElongcOcharmUgR,G__setup_memfuncpairlElongcOcharmUgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOintgR),sizeof(pair<float,int>),-1,297216,(char*)NULL,G__setup_memvarpairlEfloatcOintgR,G__setup_memfuncpairlEfloatcOintgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOlonggR),sizeof(pair<float,long>),-1,297216,(char*)NULL,G__setup_memvarpairlEfloatcOlonggR,G__setup_memfuncpairlEfloatcOlonggR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOfloatgR),sizeof(pair<float,float>),-1,297216,(char*)NULL,G__setup_memvarpairlEfloatcOfloatgR,G__setup_memfuncpairlEfloatcOfloatgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOdoublegR),sizeof(pair<float,double>),-1,297216,(char*)NULL,G__setup_memvarpairlEfloatcOdoublegR,G__setup_memfuncpairlEfloatcOdoublegR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOvoidmUgR),sizeof(pair<float,void*>),-1,297216,(char*)NULL,G__setup_memvarpairlEfloatcOvoidmUgR,G__setup_memfuncpairlEfloatcOvoidmUgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEfloatcOcharmUgR),sizeof(pair<float,char*>),-1,297216,(char*)NULL,G__setup_memvarpairlEfloatcOcharmUgR,G__setup_memfuncpairlEfloatcOcharmUgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOintgR),sizeof(pair<double,int>),-1,297216,(char*)NULL,G__setup_memvarpairlEdoublecOintgR,G__setup_memfuncpairlEdoublecOintgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOlonggR),sizeof(pair<double,long>),-1,297216,(char*)NULL,G__setup_memvarpairlEdoublecOlonggR,G__setup_memfuncpairlEdoublecOlonggR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOfloatgR),sizeof(pair<double,float>),-1,297216,(char*)NULL,G__setup_memvarpairlEdoublecOfloatgR,G__setup_memfuncpairlEdoublecOfloatgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOdoublegR),sizeof(pair<double,double>),-1,297216,(char*)NULL,G__setup_memvarpairlEdoublecOdoublegR,G__setup_memfuncpairlEdoublecOdoublegR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOvoidmUgR),sizeof(pair<double,void*>),-1,297216,(char*)NULL,G__setup_memvarpairlEdoublecOvoidmUgR,G__setup_memfuncpairlEdoublecOvoidmUgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEdoublecOcharmUgR),sizeof(pair<double,char*>),-1,297216,(char*)NULL,G__setup_memvarpairlEdoublecOcharmUgR,G__setup_memfuncpairlEdoublecOcharmUgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOintgR),sizeof(pair<const char*,int>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPcharmUcOintgR,G__setup_memfuncpairlEconstsPcharmUcOintgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOlonggR),sizeof(pair<const char*,long>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPcharmUcOlonggR,G__setup_memfuncpairlEconstsPcharmUcOlonggR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOfloatgR),sizeof(pair<const char*,float>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPcharmUcOfloatgR,G__setup_memfuncpairlEconstsPcharmUcOfloatgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOdoublegR),sizeof(pair<const char*,double>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPcharmUcOdoublegR,G__setup_memfuncpairlEconstsPcharmUcOdoublegR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOvoidmUgR),sizeof(pair<const char*,void*>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPcharmUcOvoidmUgR,G__setup_memfuncpairlEconstsPcharmUcOvoidmUgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPcharmUcOcharmUgR),sizeof(pair<const char*,char*>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPcharmUcOcharmUgR,G__setup_memfuncpairlEconstsPcharmUcOcharmUgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOintgR),sizeof(pair<const string,int>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPstringcOintgR,G__setup_memfuncpairlEconstsPstringcOintgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOlonggR),sizeof(pair<const string,long>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPstringcOlonggR,G__setup_memfuncpairlEconstsPstringcOlonggR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOfloatgR),sizeof(pair<const string,float>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPstringcOfloatgR,G__setup_memfuncpairlEconstsPstringcOfloatgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOdoublegR),sizeof(pair<const string,double>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPstringcOdoublegR,G__setup_memfuncpairlEconstsPstringcOdoublegR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPstringcOvoidmUgR),sizeof(pair<const string,void*>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPstringcOvoidmUgR,G__setup_memfuncpairlEconstsPstringcOvoidmUgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOintgR),sizeof(pair<const int,int>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPintcOintgR,G__setup_memfuncpairlEconstsPintcOintgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOlonggR),sizeof(pair<const int,long>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPintcOlonggR,G__setup_memfuncpairlEconstsPintcOlonggR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOfloatgR),sizeof(pair<const int,float>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPintcOfloatgR,G__setup_memfuncpairlEconstsPintcOfloatgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOdoublegR),sizeof(pair<const int,double>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPintcOdoublegR,G__setup_memfuncpairlEconstsPintcOdoublegR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOvoidmUgR),sizeof(pair<const int,void*>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPintcOvoidmUgR,G__setup_memfuncpairlEconstsPintcOvoidmUgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPintcOcharmUgR),sizeof(pair<const int,char*>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPintcOcharmUgR,G__setup_memfuncpairlEconstsPintcOcharmUgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOintgR),sizeof(pair<const long,int>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPlongcOintgR,G__setup_memfuncpairlEconstsPlongcOintgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOlonggR),sizeof(pair<const long,long>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPlongcOlonggR,G__setup_memfuncpairlEconstsPlongcOlonggR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOfloatgR),sizeof(pair<const long,float>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPlongcOfloatgR,G__setup_memfuncpairlEconstsPlongcOfloatgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOdoublegR),sizeof(pair<const long,double>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPlongcOdoublegR,G__setup_memfuncpairlEconstsPlongcOdoublegR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOvoidmUgR),sizeof(pair<const long,void*>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPlongcOvoidmUgR,G__setup_memfuncpairlEconstsPlongcOvoidmUgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPlongcOcharmUgR),sizeof(pair<const long,char*>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPlongcOcharmUgR,G__setup_memfuncpairlEconstsPlongcOcharmUgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOintgR),sizeof(pair<const float,int>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPfloatcOintgR,G__setup_memfuncpairlEconstsPfloatcOintgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOlonggR),sizeof(pair<const float,long>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPfloatcOlonggR,G__setup_memfuncpairlEconstsPfloatcOlonggR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOfloatgR),sizeof(pair<const float,float>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPfloatcOfloatgR,G__setup_memfuncpairlEconstsPfloatcOfloatgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOdoublegR),sizeof(pair<const float,double>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPfloatcOdoublegR,G__setup_memfuncpairlEconstsPfloatcOdoublegR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOvoidmUgR),sizeof(pair<const float,void*>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPfloatcOvoidmUgR,G__setup_memfuncpairlEconstsPfloatcOvoidmUgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPfloatcOcharmUgR),sizeof(pair<const float,char*>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPfloatcOcharmUgR,G__setup_memfuncpairlEconstsPfloatcOcharmUgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOintgR),sizeof(pair<const double,int>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPdoublecOintgR,G__setup_memfuncpairlEconstsPdoublecOintgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOlonggR),sizeof(pair<const double,long>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPdoublecOlonggR,G__setup_memfuncpairlEconstsPdoublecOlonggR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOfloatgR),sizeof(pair<const double,float>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPdoublecOfloatgR,G__setup_memfuncpairlEconstsPdoublecOfloatgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOdoublegR),sizeof(pair<const double,double>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPdoublecOdoublegR,G__setup_memfuncpairlEconstsPdoublecOdoublegR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOvoidmUgR),sizeof(pair<const double,void*>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPdoublecOvoidmUgR,G__setup_memfuncpairlEconstsPdoublecOvoidmUgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_pairlEconstsPdoublecOcharmUgR),sizeof(pair<const double,char*>),-1,297216,(char*)NULL,G__setup_memvarpairlEconstsPdoublecOcharmUgR,G__setup_memfuncpairlEconstsPdoublecOcharmUgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_TParameterlEfloatgR),sizeof(TParameter<float>),-1,324864,"Named templated parameter type",G__setup_memvarTParameterlEfloatgR,G__setup_memfuncTParameterlEfloatgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_TParameterlEdoublegR),sizeof(TParameter<double>),-1,324864,"Named templated parameter type",G__setup_memvarTParameterlEdoublegR,G__setup_memfuncTParameterlEdoublegR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_TParameterlEintgR),sizeof(TParameter<int>),-1,324864,"Named templated parameter type",G__setup_memvarTParameterlEintgR,G__setup_memfuncTParameterlEintgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_TParameterlElonggR),sizeof(TParameter<long>),-1,324864,"Named templated parameter type",G__setup_memvarTParameterlElonggR,G__setup_memfuncTParameterlElonggR);
   G__tagtable_setup(G__get_linked_tagnum(&G__G__Base3LN_TParameterlElongsPlonggR),sizeof(TParameter<long long>),-1,324864,"Named templated parameter type",G__setup_memvarTParameterlElongsPlonggR,G__setup_memfuncTParameterlElongsPlonggR);
}
extern "C" void G__cpp_setupG__Base3(void) {
  G__check_setup_version(30051515,"G__cpp_setupG__Base3()");
  G__set_cpp_environmentG__Base3();
  G__cpp_setup_tagtableG__Base3();

  G__cpp_setup_inheritanceG__Base3();

  G__cpp_setup_typetableG__Base3();

  G__cpp_setup_memvarG__Base3();

  G__cpp_setup_memfuncG__Base3();
  G__cpp_setup_globalG__Base3();
  G__cpp_setup_funcG__Base3();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfuncG__Base3();
  return;
}
class G__cpp_setup_initG__Base3 {
  public:
    G__cpp_setup_initG__Base3() { G__add_setup_func("G__Base3",(G__incsetup)(&G__cpp_setupG__Base3)); G__call_setup_funcs(); }
   ~G__cpp_setup_initG__Base3() { G__remove_setup_func("G__Base3"); }
};
G__cpp_setup_initG__Base3 G__cpp_setup_initializerG__Base3;

